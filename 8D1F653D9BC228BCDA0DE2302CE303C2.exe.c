/* This file was generated by the Hex-Rays decompiler version 9.0.0.241217.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall nullsub_1(); // weak
__int64 sub_401010();
__int64 sub_401130();
__int64 __fastcall sub_401180(__int64 a1, __int64 a2);
__int64 start();
__int64 sub_4014F0();
__int64 __fastcall sub_401520(int (__cdecl *a1)());
__int64 sub_401540();
__int64 __fastcall nullsub_2(); // weak
__int64 __fastcall sub_401560(__int64 (**a1)(void));
__int64 __fastcall sub_401640(__int64 (*a1)(void));
char __fastcall sub_401650(__int64 a1, __int64 a2);
char __fastcall sub_401670(unsigned __int16 ***a1, __int64 a2);
void __fastcall __noreturn sub_401690();
__int64 sub_403AA0();
BOOL __fastcall sub_403D80(_QWORD *lpMem, unsigned __int64 a2);
void __fastcall __noreturn sub_403DB0(__int64 a1, __int64 a2);
unsigned __int64 __fastcall sub_403DBA(unsigned __int64 *a1, __int64 a2, __int64 a3);
unsigned int __fastcall sub_403DFD(signed __int64 *a1, _BYTE *a2, __int64 a3);
bool __fastcall sub_403F44(__int64 a1, unsigned __int64 a2);
__int64 __fastcall sub_403F80(signed __int64 *a1, __int64 a2);
LPVOID __fastcall sub_404020(_QWORD *a1, SIZE_T a2, __int64 a3);
void __fastcall __noreturn sub_40408F(__int64 a1, __int64 a2, __int64 a3);
void __fastcall __noreturn sub_4040B0(__int64 a1);
void __fastcall __noreturn sub_4040E9(__int64 a1, __int64 a2);
__int64 __fastcall sub_404110(signed __int64 *a1, __int64 a2, __int64 a3);
unsigned __int64 __fastcall sub_4041B0(_QWORD *a1, __int64 a2, char *a3);
__int64 __fastcall sub_404400(__int64 a1, __int64 *a2);
__int64 __fastcall sub_404590(__int64 a1, __int64 a2);
void __fastcall sub_4045C0(_QWORD *a1);
__int64 __fastcall sub_404600(signed __int64 *a1, const void *a2, size_t a3);
__int64 __fastcall sub_404670(signed __int64 *a1, unsigned int a2);
char __fastcall sub_404790(__int64 a1, _QWORD *a2);
LPVOID __fastcall sub_4047B0(_QWORD *a1, char *a2, __int64 a3);
void __fastcall __noreturn sub_4050A0(__int64 a1, __int64 a2, __int64 a3);
void __fastcall __noreturn sub_4050B0(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_405120(unsigned __int64 *a1, __int64 a2);
void __fastcall __noreturn sub_405240(__int64 a1, __int64 a2);
__int64 __fastcall sub_405270(__int64 a1, char a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_405510(unsigned __int16 *a1, __int64 a2);
char __fastcall sub_405A30(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5);
void __fastcall __noreturn sub_405A90(__int64 a1, __int64 a2, __int64 a3);
void __fastcall __noreturn sub_405B00(__int64 a1, __int64 a2, __int64 a3);
void __fastcall __noreturn sub_405B10(__int64 a1, __int64 a2, __int64 a3);
char __fastcall sub_405B80(__int64 a1, unsigned __int16 *a2, unsigned __int64 a3);
void __fastcall __noreturn sub_405FC0(__int64 a1, __int64 a2, __int64 a3);
void __fastcall __noreturn sub_405FFE(char a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int128 *a6, __int64 a7);
__int64 __fastcall sub_406140(_QWORD *a1);
char __fastcall sub_406160(_QWORD *a1, __int64 a2);
char __fastcall sub_406180(__int64 a1, __int64 a2, _QWORD *a3);
void __fastcall __noreturn sub_406390(__int64 a1);
__int64 __fastcall sub_4063D0(_DWORD *a1, __int64 a2);
__int64 __fastcall sub_406500(unsigned __int64 a1, __int64 a2);
__int64 __fastcall sub_406720(__int64 a1, __int64 a2);
void __fastcall __noreturn sub_406750(__int64 a1);
__int64 __fastcall sub_4067B0(_WORD *a1, __int64 a2);
__int64 __fastcall sub_406850(__int64 a1, __int64 a2, unsigned __int64 a3);
_BYTE *__fastcall sub_406A60(_BYTE *a1, __int64 a2, unsigned __int64 a3, __int64 a4, unsigned __int8 (__fastcall *a5)(__int64, _OWORD *));
char __fastcall sub_406C00(__int64 *a1, __int64 a2, unsigned __int64 a3);
char __fastcall sub_406EB0(_QWORD *a1, int a2);
char __fastcall sub_406F20(__int64 a1, _QWORD *a2);
void __fastcall __noreturn sub_406F40(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
void __fastcall __noreturn sub_406FD0(__int64 a1, __int64 a2, __int64 a3);
void __fastcall __noreturn sub_406FE0(__int64 a1, __int64 a2, __int64 a3);
void __fastcall __noreturn sub_407050(__int64 a1);
void __noreturn sub_407070();
void __fastcall __noreturn sub_4070E0(__int128 *a1, char a2, __int64 a3);
void __noreturn sub_407125();
void __noreturn sub_407140();
void __noreturn sub_407190();
__int64 __fastcall sub_4071E0(unsigned __int64 a1, __int64 a2);
void __noreturn sub_407276();
void __fastcall __noreturn sub_407286(__int64 a1, __int64 a2, __int128 *a3, __int64 a4);
__int64 __fastcall sub_4072D0(unsigned __int64 **a1, __int64 a2);
__int64 __fastcall sub_4072E0(_BYTE *a1, unsigned __int64 a2, __int64 a3, __int64 a4);
char __fastcall sub_407630(__int64 a1, unsigned int a2, int a3);
void __fastcall __noreturn sub_4079A0(_BYTE *a1, unsigned __int64 a2, unsigned __int64 a3, unsigned __int64 a4, __int64 a5);
void __fastcall __noreturn sub_4079C0(_BYTE *a1, unsigned __int64 a2, unsigned __int64 a3, unsigned __int64 a4, __int64 a5);
char __fastcall sub_407DC0(unsigned int *a1, __int64 a2);
char __fastcall sub_407E50(unsigned __int64 *a1, __int64 a2);
char __fastcall sub_407EB0(unsigned int a1);
char __fastcall sub_408030(int a1, _BYTE *a2, __int64 a3, __int64 a4, unsigned __int64 a5, char *a6, __int64 a7);
char __fastcall sub_408160(unsigned int *a1, _QWORD *a2);
__int64 __fastcall sub_408240(unsigned __int8 a1, __int64 a2, unsigned __int64 a3);
void __noreturn sub_408340();
void __noreturn sub_408380();
__int64 __fastcall sub_4083C0(_QWORD *a1, __int64 a2, __int64 a3, _BYTE *a4, unsigned __int64 a5);
void __fastcall sub_4088C0(_QWORD *a1, __int64 *a2);
void __noreturn sub_408A70();
__int64 __fastcall sub_408AB0(int *a1, __int64 a2);
char __fastcall sub_408C00(unsigned int a1);
char __fastcall sub_408D80(unsigned int a1);
LPVOID sub_408ED2();
void __fastcall sub_408F07(_QWORD *a1);
LPVOID sub_408F43();
void *__fastcall sub_408F78(__int64 a1, __int64 a2, __int64 a3, const void *a4, __int64 a5);
__int64 __fastcall sub_4090B9(_QWORD *a1, __int64 *a2);
LPVOID __fastcall sub_40923F(_QWORD *a1, __int64 a2, __int64 a3, _WORD *a4);
__int64 __fastcall sub_4093B6(_QWORD *a1, _QWORD *a2, __int64 a3, const void *a4);
__int64 __fastcall sub_4094AE(_QWORD *a1, __int64 *a2);
LPVOID __fastcall sub_40955B(_QWORD *a1, void *a2, SIZE_T a3, __int64 a4);
unsigned __int64 __fastcall sub_4095D5(unsigned __int64 *a1);
unsigned __int64 __fastcall sub_409621(unsigned __int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
unsigned __int64 __fastcall sub_409700(unsigned __int64 *a1, __int64 a2);
char __fastcall sub_40974D(unsigned __int64 *a1, __int64 *a2);
__int64 __fastcall sub_409E2D(__int64 a1);
_BOOL8 __fastcall sub_409E80(unsigned __int8 a1, unsigned __int64 a2, const __m128i *a3);
_BOOL8 __fastcall sub_40A050(unsigned __int8 a1, unsigned __int64 a2, const __m128i *a3);
void __fastcall sub_40A210(__int64 a1, _BYTE *a2);
void __noreturn sub_40A540();
char __fastcall sub_40A570(__int64 *a1, __int64 a2);
char __fastcall sub_40A860(__int64 a1, __int64 a2);
__int64 __fastcall sub_40A920(unsigned __int8 **a1, __int64 a2);
char __fastcall sub_40A960(__int64 a1, __int64 a2);
char __fastcall sub_40B090(__int64 *a1, unsigned int a2);
char __fastcall sub_40B250(__int64 a1, __int64 *a2);
void __fastcall sub_40B330(__int64 *a1, _QWORD *a2);
__int64 __fastcall sub_40B550(unsigned __int8 **a1, _QWORD *a2);
__int64 __fastcall sub_40BBB0(_QWORD *a1);
char __fastcall sub_40BC10(__int64 a1);
__int64 __fastcall sub_40C140(__int64 *a1);
char __fastcall sub_40C1E0(_QWORD *a1);
char __fastcall sub_40C310(__int64 a1, __int64 a2);
char __fastcall sub_40C980(__int64 a1, unsigned __int64 a2);
char __fastcall sub_40CB60(__int64 a1, char a2);
char __fastcall sub_40CE30(__int64 *a1, unsigned int a2);
__int64 __fastcall sub_40CFF0(__int64 a1, __int64 a2);
__int64 __fastcall sub_40D0A0(__int64 a1, __int64 a2);
__int64 __fastcall sub_40D220(__int64 a1, unsigned int a2);
char __fastcall sub_40D380(__int64 a1);
__int64 __fastcall sub_40D650(__int64 *a1, __int64 a2);
__int64 __fastcall sub_40D6F0(__int64 *a1, __int64 a2);
__int64 __fastcall sub_40D7A0(_QWORD *a1);
__int64 __fastcall sub_40DA20(unsigned __int8 **a1);
char __fastcall sub_40DE00(__int64 a1, unsigned int a2);
char __fastcall sub_40E140(__int64 a1, __int64 a2);
__int64 __fastcall sub_40E160(unsigned __int16 *a1, unsigned __int16 *a2);
char __fastcall sub_40E240(__int64 a1, __int64 a2);
__int64 __fastcall sub_40E460(__int64 a1, __int64 a2);
void __fastcall sub_40E480(_QWORD *a1, __int64 a2);
char __fastcall sub_40E880(__int64 a1);
char __fastcall sub_40EAD0(__int64 *a1);
char __fastcall sub_40EC80(__int64 a1, __int64 *a2);
__int64 __fastcall sub_40ED40(__int64 *a1);
char __fastcall sub_40EDE0(__int64 a1);
char __fastcall sub_40F100(__int64 *a1);
__int64 __fastcall sub_40F320(__int64 *a1);
char __fastcall sub_40F580(_QWORD *a1);
__int64 *__fastcall sub_40FA50(__int64 *a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_410600(char ***a1, __int64 a2);
__int64 __fastcall sub_411300(__int64 a1, __int64 a2);
char __fastcall sub_411330(__int64 a1, __int64 a2, unsigned __int64 a3);
char __fastcall sub_411370(__int64 a1, unsigned int a2);
char __fastcall sub_411450(__int64 a1, _QWORD *a2);
void __fastcall __noreturn sub_411464(__int64 a1, __int64 a2);
void __fastcall __noreturn sub_411474(__int64 a1, __int64 a2);
void __fastcall __noreturn sub_4114A0(__int64 a1);
void __fastcall __noreturn sub_4114B0(__int64 a1);
__int64 __fastcall sub_4114E0(struct _EXCEPTION_RECORD *a1, void *a2, CONTEXT *a3, __int64 a4);
void __fastcall __noreturn sub_411502(__int64 a1, __int64 a2, __int64 a3, char a4, char a5);
char __fastcall sub_4121E0(__int64 *a1, __int64 a2);
__int64 __fastcall sub_412270(__int64 a1, _QWORD *a2);
int __fastcall sub_4123A0(__int64 *a1);
char __fastcall sub_4123C0(__int64 a1, __int64 a2);
void sub_4123E0();
void __noreturn sub_412410();
LPVOID sub_412420();
__int64 __fastcall sub_4124E0(__int64 a1, __int64 a2);
__int64 __fastcall sub_412510(signed __int64 a1);
void __fastcall __noreturn sub_41266B(__int64 a1, __int128 *a2);
void __fastcall __noreturn sub_4126B2(__int64 a1, __int128 *a2);
__int64 __fastcall sub_412700(unsigned int **a1, __int64 a2);
void __fastcall TlsCallback_0(__int64 a1, int a2);
void __fastcall sub_412BC0(__int64 *a1);
void __noreturn sub_412C23();
__int64 __fastcall sub_412C40(unsigned int **a1, __int64 a2);
__int64 (__fastcall *__fastcall sub_412E70(_DWORD *lpMem))();
void __fastcall sub_412EC0(_QWORD *a1);
char **__fastcall sub_412EF0(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int64 a3);
signed __int8 __fastcall sub_413070(signed __int8 *Address);
bool sub_413120();
void __fastcall sub_413170(_BYTE *a1, char a2);
int __fastcall sub_4131C0(__int64 a1);
int __fastcall sub_413270(__int64 a1);
__int64 __fastcall sub_413290(unsigned __int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
LPVOID __fastcall sub_413370(_QWORD *a1, void *a2, SIZE_T a3, __int64 a4);
__int64 __fastcall sub_4133F0(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_413520(__int64 *a1, __int64 a2, __int64 (__fastcall *a3)(__int64, _QWORD *));
__int64 __fastcall sub_4135B0(__int64 a1, char a2);
char __fastcall sub_413610(_BYTE *a1, __int64 a2);
char __fastcall sub_414350(__int64 a1, __int64 a2, __int128 *a3, __int64 a4, unsigned __int8 a5, int a6, char a7, int a8);
__int64 __fastcall sub_414920(unsigned __int64 *a1, __m128i *a2);
char __fastcall sub_414A10(_QWORD *a1, __int64 a2);
_OWORD *__fastcall sub_414CB0(_OWORD *a1, unsigned __int16 *a2, __int64 a3);
int __fastcall sub_4151C0(_QWORD *a1, unsigned __int8 *a2, __int64 a3);
__int64 __fastcall sub_415470(__int64 *a1, __int64 a2);
void __fastcall sub_415540(_QWORD *a1);
void __fastcall sub_4155A0(_QWORD *a1);
void __fastcall sub_415650(_QWORD *a1, __int64 a2, unsigned __int64 a3);
void __fastcall sub_415720(volatile signed __int64 **a1, unsigned __int64 *a2);
void __fastcall sub_419960(_QWORD *a1);
void __fastcall sub_419A30(__int64 a1, unsigned __int64 a2);
__int64 __fastcall sub_419B60(__int64 *a1, __int64 a2);
unsigned __int64 __fastcall sub_419C30(_QWORD *a1, const void *a2, size_t a3);
unsigned __int64 __fastcall sub_419E60(__int64 a1, __int64 a2, unsigned __int64 a3);
char __fastcall sub_419ED0(__int64 a1, unsigned __int64 *a2, __int64 a3);
void __fastcall sub_41A180(__m128i *a1, unsigned __int64 a2);
void __fastcall sub_41A2B0(__int64 a1, unsigned __int64 *a2);
int __fastcall sub_41A8B0(unsigned __int64 a1, unsigned __int64 *a2, unsigned __int64 a3);
int __fastcall sub_41D140(LPVOID lpMem, __int64 a2, unsigned __int64 a3);
void __fastcall sub_41D230(__int64 a1);
char __fastcall sub_41D2E0(__int64 a1, unsigned __int64 *a2, unsigned int a3, __int64 a4);
void __fastcall sub_41E760(_QWORD *a1, unsigned __int8 **a2);
__int64 __fastcall sub_41F5E0(__int64 *a1, __int64 a2);
__int64 __fastcall sub_41F6B0(unsigned __int64 *a1, __int64 a2);
void __fastcall sub_41F780(__int64 a1, __int64 a2, unsigned __int64 a3);
__int64 __fastcall sub_41F880(__int64 a1, __int64 *a2);
int __fastcall sub_41FD50(__int64 *a1, __int64 a2, __int64 a3, _QWORD *a4);
void __fastcall sub_4215A0(__int64 a1);
__int64 __fastcall sub_421680(__int64 a1, __int64 *a2);
void __fastcall sub_421DF0(__int64 a1, __int64 a2, unsigned __int64 a3);
void __fastcall sub_421E50(__int128 *a1, unsigned __int64 a2);
__int64 __fastcall sub_421F80(__int64 a1, __int64 a2);
void __fastcall sub_422030(_QWORD *a1, __int64 a2, unsigned __int64 a3);
void __fastcall sub_422100(_QWORD *a1, __int64 a2, unsigned __int64 a3);
__int64 __fastcall sub_4221F0(unsigned __int64 *a1, __int64 a2);
void __fastcall sub_4222C0(__int64 a1, __int64 a2, unsigned __int64 a3);
int __fastcall sub_422320(__int64 *a1, __int64 a2, unsigned __int64 a3);
void __fastcall sub_4223D0(char *lpMem, __int64 a2, unsigned __int64 a3);
void __fastcall sub_422480(__int64 a1, unsigned int *a2, unsigned __int64 a3);
void __fastcall sub_422E90(__int64 a1, __int64 a2, unsigned __int64 a3);
void *__fastcall sub_422FC0(__int64 a1, __int64 a2);
void __fastcall sub_4230A0(__int64 a1, __int64 a2, unsigned __int64 a3);
int __fastcall sub_423160(_QWORD *a1, __int64 a2, volatile signed __int64 **a3, volatile signed __int64 **a4);
void *__fastcall sub_423680(__int64 a1, __int128 *a2, __int64 a3, char *a4);
int __fastcall sub_423B70(unsigned __int64 a1, __int64 *a2, __int64 a3);
void __fastcall sub_425980(__int64 a1);
unsigned __int64 __fastcall sub_4259C0(_QWORD *a1, unsigned __int64 a2);
void __fastcall sub_425B00(_QWORD *a1, unsigned __int64 a2);
__int64 __fastcall sub_425C30(__int64 a1, __int64 a2);
char __fastcall sub_425CD0(__int64 a1, char **a2, unsigned int a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_426260(unsigned __int64 *a1, __int64 a2);
__int64 __fastcall sub_426330(unsigned __int64 *a1, __int64 a2);
void __fastcall sub_426400(_QWORD *a1);
void __fastcall sub_426470(_QWORD *a1);
void __fastcall sub_426530(char *lpMem, __int64 a2);
void __fastcall sub_4265D0(__int64 a1);
char __fastcall sub_4266A0(_OWORD *a1, unsigned __int64 *a2, signed __int64 a3, unsigned __int8 a4, __int64 a5, _QWORD *a6, __int64 a7, unsigned __int64 *a8, __int64 *a9, __int64 a10);
void __fastcall sub_427BE0(__int128 *a1, unsigned __int64 a2);
__int64 __fastcall sub_427D10(_OWORD *a1, __int64 a2);
__int64 __fastcall sub_427DD0(__int64 *a1, _QWORD *a2, __int64 a3, __int64 a4, _QWORD *a5);
void __fastcall sub_427FC0(__int64 a1, __int64 a2, unsigned __int64 a3, unsigned __int8 a4, __int64 a5, _QWORD *a6, _QWORD *a7, __int64 a8);
char __fastcall sub_428290(__int64 a1, unsigned __int8 a2, __int64 a3, unsigned __int64 a4, __int64 a5, _QWORD *a6, __int64 a7);
void __fastcall sub_428690(__int128 *a1, unsigned __int64 a2, _OWORD *a3, size_t a4, char a5);
void __fastcall sub_428E00(__int128 *a1, unsigned __int64 a2, _OWORD *a3, size_t a4, int a5, __int128 *a6);
__int128 *__fastcall sub_429780(_QWORD *a1, _OWORD *a2);
unsigned __int64 *__fastcall sub_429900(unsigned __int64 *a1, unsigned __int64 *a2, unsigned __int64 *a3, unsigned __int64 a4);
__int64 __fastcall sub_429A10(unsigned __int64 *a1, __int64 a2);
void __fastcall sub_429AE0(_QWORD *a1, unsigned __int64 a2, _OWORD *a3, _QWORD *a4, char a5);
void __fastcall sub_42A1F0(_QWORD *a1, unsigned __int64 a2, _OWORD *a3, _QWORD *a4, int a5, unsigned __int64 *a6);
_QWORD *__fastcall sub_42ABB0(_QWORD *a1, _QWORD *a2, _QWORD *a3, unsigned __int64 a4);
__int64 __fastcall sub_42AC70(__int64 *a1, __int64 a2);
__int64 __fastcall sub_42AD40(__int64 *a1, __int64 a2);
void __fastcall sub_42B0A0(char *lpMem, __int64 a2, unsigned __int64 a3);
unsigned __int64 __fastcall sub_42B180(__int64 *a1, __int64 a2, unsigned __int64 a3);
int __fastcall sub_42B260(unsigned __int64 *a1, __int64 a2, unsigned __int64 a3);
unsigned __int64 __fastcall sub_42B5E0(__int64 a1, __int64 a2, unsigned __int64 a3);
void __fastcall sub_42B660(__int128 *a1, unsigned __int64 a2, _OWORD *a3, size_t a4, char a5);
void __fastcall sub_42BD50(__int128 *a1, unsigned __int64 a2, _OWORD *a3, size_t a4, int a5, __int64 a6);
_QWORD *__fastcall sub_42C7C0(_QWORD *a1, _QWORD *a2, _QWORD *a3, unsigned __int64 a4);
__int64 __fastcall sub_42C880(_QWORD *a1);
void __fastcall sub_42C8E0(_QWORD *a1);
void __fastcall sub_42C980(_QWORD *a1, unsigned __int64 a2);
__int64 __fastcall sub_42CAB0(_QWORD *a1, __int64 a2);
void __fastcall sub_42CB60(_QWORD *a1);
int __fastcall sub_42CBF0(_QWORD *a1, __int64 a2, _QWORD *a3, __int64 a4, _QWORD *a5);
void __fastcall sub_42D590(_QWORD *a1);
void __fastcall sub_42D620(void **lpMem, __int64 a2);
void __fastcall sub_42D690(_QWORD *a1, unsigned __int64 a2, _OWORD *a3, _QWORD *a4, char a5);
void __fastcall sub_42DD80(_QWORD *a1, unsigned __int64 a2, _OWORD *a3, _QWORD *a4, int a5, __int64 a6);
__int64 __fastcall sub_42E840(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4);
bool __fastcall sub_42E900(char a1, __int64 a2, unsigned __int64 a3);
unsigned __int64 __fastcall sub_42E9B0(__int64 a1, unsigned __int64 *a2, unsigned __int8 a3);
unsigned __int64 __fastcall sub_42EAB0(__int64 a1, unsigned __int64 *a2, char a3);
unsigned __int64 __fastcall sub_42EB60(__int64 *a1, __int64 a2, unsigned __int64 a3);
int __fastcall sub_42EC30(unsigned __int64 *a1, __int64 a2, unsigned __int64 a3);
unsigned __int64 __fastcall sub_42EFB0(_QWORD *a1, __int64 a2, unsigned __int64 a3);
unsigned __int64 __fastcall sub_42F040(_QWORD *a1, __int64 a2, unsigned __int64 a3);
BOOL __fastcall sub_42F0D0(__int64 a1, __int64 a2);
__int64 __fastcall sub_42F450(__int64 a1, __int64 *a2);
__int64 *__fastcall sub_42F500(__int64 a1, unsigned __int64 *a2, unsigned int a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_42F5F0(__int64 a1, unsigned __int64 *a2, unsigned int a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_42F890(__int64 a1, __int64 *a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_42FB10(__int64 a1, unsigned __int64 *a2, unsigned int a3, __int16 a4);
__int64 __fastcall sub_430550(__int64 *a1, __int64 a2);
void __fastcall sub_430620(__m128i *a1, unsigned __int64 a2, __m128i *a3, size_t a4, char a5);
void __fastcall sub_430D80(__m128i *a1, unsigned __int64 a2, __m128i *a3, size_t a4, int a5, __int64 *a6);
__int64 __fastcall sub_431840(_QWORD *a1, _OWORD *a2, _OWORD *a3);
_QWORD *__fastcall sub_431BC0(_QWORD *a1, _QWORD *a2, _QWORD *a3, unsigned __int64 a4);
void __fastcall sub_431C80(__int128 *a1, unsigned __int64 a2, __int128 *a3, unsigned int a4);
unsigned __int64 __fastcall sub_432510(__int128 *a1, unsigned __int64 a2);
__int64 __fastcall sub_432610(unsigned __int8 *a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_4328B0(__int64 a1, void *a2);
int __fastcall sub_4329C0(__int64 a1, unsigned __int8 *a2, __int64 a3);
int __fastcall sub_432CE0(_QWORD *a1, __int128 *a2);
__int64 __fastcall sub_4332D0(__int64 *a1, __int64 a2);
_BYTE *__fastcall sub_433390(__int64 a1, __int64 a2);
_BYTE *__fastcall sub_4333A0(__int64 a1, __int64 a2);
void __fastcall sub_433610(__int64 a1, __int64 a2);
__int64 __fastcall sub_4336E0(char *Buf1, size_t Size, char *Buf2, unsigned __int64 a4);
char __fastcall sub_433E60(_QWORD *_RCX, __int64 a2, int _R8D, char a4);
int __fastcall sub_433F60(_QWORD *a1);
__int64 __fastcall sub_433FA0(__int64 a1, __int64 a2, __int128 *a3);
__int64 __fastcall sub_434030(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_434060(__int64 a1, __int64 a2, char a3, __int64 a4);
__int64 __fastcall sub_434CA0(_QWORD, _QWORD); // weak
char __fastcall sub_434DE0(__int64 a1, unsigned __int8 *a2, unsigned __int64 a3);
void __fastcall sub_435280(__int64 a1, __int64 a2);
char __fastcall sub_435670(unsigned __int8 *a1, unsigned __int8 *a2);
char __fastcall sub_435740(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
unsigned __int64 __fastcall sub_435880(__int64 *a1, __int64 a2, __int64 a3, __int64 a4);
char __fastcall sub_4359E0(__int64 *a1, char *a2, size_t a3);
bool __fastcall sub_435AB0(__int64 *a1, unsigned int a2);
char __fastcall sub_435C10(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_435C30(DWORD a1, unsigned __int8 *a2, unsigned __int64 a3, unsigned __int8 *a4);
__int64 __fastcall sub_435FE0(void *a1, CHAR *a2, unsigned __int64 a3);
char __fastcall sub_436250(__int64 a1, __int64 a2);
__int64 __fastcall sub_436340(_QWORD *a1, __int64 a2);
__int64 __fastcall sub_4364C0(unsigned __int8 *a1, __int64 a2);
__int64 __fastcall sub_436640(unsigned __int64 *a1, __int64 a2);
void __fastcall sub_436870(volatile signed __int32 *Address, signed __int32 a2);
bool __fastcall sub_436930(__int64 a1, unsigned __int8 *a2, unsigned __int64 a3);
bool __fastcall sub_436980(__int64 a1, unsigned int a2);
char __fastcall sub_436A70(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_436A90(_QWORD *a1, __int64 a2);
_QWORD *__fastcall sub_436AC0(__int64 *a1);
_QWORD *__fastcall sub_436B30(_QWORD *a1);
__int64 sub_436B50();
unsigned __int64 sub_436B60();
__int64 __fastcall sub_436B80(int a1, int a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_437180(__int64 **a1);
__int64 __fastcall sub_437190(__int64 **a1);
__int64 sub_4371A0();
__int64 sub_4371B0();
void __fastcall sub_4371C0(LPVOID lpMem);
__int64 __fastcall sub_437220(unsigned __int64 *a1, __int64 a2);
__int64 __fastcall Handler(struct _EXCEPTION_POINTERS *ExceptionInfo);
void *sub_437520();
void __fastcall sub_437590(volatile signed __int32 *Address, char a2, __int64 a3, __int64 a4, __int64 a5);
void __fastcall sub_437720(_QWORD *a1);
void __fastcall sub_437750(_BYTE **a1);
void __fastcall sub_437929(__int64 a1);
void __fastcall sub_437990(__int64 a1);
void __fastcall sub_4379C0(__int64 a1);
char **__fastcall sub_437AD0(__int64 a1);
void __fastcall sub_437D10(__int64 a1, unsigned __int64 a2);
__int64 __fastcall sub_437D70(_QWORD **a1);
__int64 __fastcall sub_437DF0(_QWORD **a1);
void __noreturn sub_437E70();
__int64 __fastcall sub_437EB0(__int64 a1, __int64 a2);
__int64 sub_437F10();
char **__fastcall sub_437F30(__int64 a1);
char __fastcall sub_438120(unsigned __int64 *a1, unsigned __int64 a2);
unsigned __int64 __fastcall sub_438770(_QWORD *a1, DWORD a2);
__int64 __fastcall sub_438D90(_QWORD **a1);
void __fastcall sub_438DB0(_QWORD *a1);
__int64 __fastcall sub_438DF0(__int64 a1, __int64 a2);
__int64 __fastcall sub_438E10(unsigned int *a1, __int64 a2);
__int64 __fastcall sub_439040(unsigned __int8 *a1, __int64 a2);
char __fastcall sub_439080(__int64 *a1, __int64 a2);
char __fastcall sub_439230(__int64 a1, __int64 a2);
__int64 __fastcall sub_439250(__int64 a1, __int64 a2);
char __fastcall sub_439490(__int64 a1, __int64 a2, unsigned __int8 *a3, __int64 a4);
void *__fastcall sub_4398F0(__int64 a1, _BYTE *a2, size_t a3);
unsigned int __fastcall sub_439BD0(__int64 a1, unsigned __int8 *a2, void *a3);
void __fastcall sub_43A830(__int64 a1, unsigned __int64 a2, unsigned __int64 a3);
int __fastcall sub_43A920(__int64 a1, unsigned __int8 *a2, __int64 a3, int a4);
char **__fastcall sub_43AB70(__int64 a1, unsigned __int8 *a2, unsigned __int64 a3);
char **__fastcall sub_43AC10(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int64 a3);
void sub_43AD86();
LPVOID __fastcall sub_43ADF0(__int64 **a1);
LPVOID __fastcall sub_43AE90(__int64 **a1);
char **__fastcall sub_43AF30(__int64 a1, unsigned __int8 *a2, size_t a3);
bool __fastcall sub_43B230(__int64 a1, unsigned __int8 *a2, size_t a3);
bool __fastcall sub_43B280(__int64 a1, unsigned int a2);
char __fastcall sub_43B370(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_43B390(__int64 **a1, _QWORD *a2);
bool __fastcall sub_43B5A0(__int64 **a1, unsigned __int8 *a2, unsigned __int64 a3);
bool __fastcall sub_43B640(__int64 **a1, unsigned int a2);
char __fastcall sub_43B780(__int64 a1, _QWORD *a2);
int __fastcall sub_43B7A0(_QWORD *a1);
void __fastcall sub_43B870(_QWORD *a1);
__int64 __fastcall sub_43BB40(unsigned __int8 *a1, unsigned __int64 a2);
unsigned __int64 __fastcall sub_43C0B0(_QWORD *a1, char *a2, char *a3);
LPVOID __fastcall sub_43C4F0(SIZE_T dwBytes);
void __fastcall __noreturn sub_43C530(__int64 *a1);
void __fastcall __noreturn sub_43C540(__int64 *a1);
__int64 __fastcall sub_43C620(_QWORD *a1, __int64 a2);
_QWORD *__fastcall sub_43C640(__int64 *a1);
__int64 __fastcall sub_43C690(__int64 a1);
__int64 __fastcall sub_43C6A0(__int64 a1);
int __fastcall sub_43C6B0(_QWORD *a1);
char __fastcall sub_43C6F0(__int64 a1, __int64 a2);
_QWORD *__fastcall sub_43C760(__int64 *a1);
_QWORD *__fastcall sub_43C880(_QWORD *a1);
unsigned __int64 sub_43C940();
__int64 __fastcall sub_43C960(unsigned __int64 *a1, const void *a2, size_t a3);
__int64 __fastcall sub_43C9D0(unsigned __int64 *a1, unsigned int a2);
char __fastcall sub_43CB00(__int64 a1, _QWORD *a2);
int __fastcall sub_43CB20(__int64 a1, __int64 a2);
void __fastcall __noreturn sub_43CC30(_OWORD *a1);
void __fastcall __noreturn sub_43CC50(__int64 a1, __int64 a2);
void __fastcall __noreturn sub_43CC70(__int64 a1, __int64 a2);
// void __stdcall WakeByAddressSingle(PVOID Address);
// void __stdcall WakeByAddressAll(PVOID Address);
// BOOL __stdcall WaitOnAddress(volatile void *Address, PVOID CompareAddress, SIZE_T AddressSize, DWORD dwMilliseconds);
// BOOL __stdcall WriteConsoleW(HANDLE hConsoleOutput, const void *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved);
// DWORD __stdcall WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds);
// BOOL __stdcall UnmapViewOfFile(LPCVOID lpBaseAddress);
// BOOL __stdcall TlsSetValue(DWORD dwTlsIndex, LPVOID lpTlsValue);
// LPVOID __stdcall TlsGetValue(DWORD dwTlsIndex);
// BOOL __stdcall TlsFree(DWORD dwTlsIndex);
// DWORD __stdcall TlsAlloc();
// BOOL __stdcall TerminateProcess(HANDLE hProcess, UINT uExitCode);
// void __stdcall Sleep(DWORD dwMilliseconds);
// BOOL __stdcall SetWaitableTimer(HANDLE hTimer, const LARGE_INTEGER *lpDueTime, LONG lPeriod, PTIMERAPCROUTINE pfnCompletionRoutine, LPVOID lpArgToCompletionRoutine, BOOL fResume);
// BOOL __stdcall SetThreadStackGuarantee(PULONG StackSizeInBytes);
// void __stdcall SetLastError(DWORD dwErrCode);
// BOOL __stdcall SetFileInformationByHandle(HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize);
// PEXCEPTION_ROUTINE __stdcall RtlVirtualUnwind(ULONG HandlerType, ULONG64 ImageBase, ULONG64 ControlPc, PRUNTIME_FUNCTION FunctionEntry, PCONTEXT ContextRecord, PVOID *HandlerData, PULONG64 EstablisherFrame, PKNONVOLATILE_CONTEXT_POINTERS ContextPointers);
// PRUNTIME_FUNCTION __stdcall RtlLookupFunctionEntry(ULONG64 ControlPc, PULONG64 ImageBase, PUNWIND_HISTORY_TABLE HistoryTable);
// void __stdcall RtlCaptureContext(PCONTEXT ContextRecord);
// BOOL __stdcall Process32Next(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
// BOOL __stdcall Process32First(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
// HANDLE __stdcall OpenProcess(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId);
// int __stdcall MultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCCH lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar);
// BOOL __stdcall Module32NextW(HANDLE hSnapshot, LPMODULEENTRY32W lpme);
// BOOL __stdcall Module32FirstW(HANDLE hSnapshot, LPMODULEENTRY32W lpme);
// LPVOID __stdcall MapViewOfFile(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap);
// BOOL __stdcall InitOnceComplete(LPINIT_ONCE lpInitOnce, DWORD dwFlags, LPVOID lpContext);
// BOOL __stdcall InitOnceBeginInitialize(LPINIT_ONCE lpInitOnce, DWORD dwFlags, PBOOL fPending, LPVOID *lpContext);
// LPVOID __stdcall HeapReAlloc(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, SIZE_T dwBytes);
// BOOL __stdcall HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
// LPVOID __stdcall HeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// HANDLE __stdcall GetStdHandle(DWORD nStdHandle);
// HANDLE __stdcall GetProcessHeap();
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// HMODULE __stdcall GetModuleHandleW(LPCWSTR lpModuleName);
// HMODULE __stdcall GetModuleHandleA(LPCSTR lpModuleName);
// DWORD __stdcall GetLastError();
// DWORD __stdcall GetFullPathNameW(LPCWSTR lpFileName, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart);
// BOOL __stdcall GetFileInformationByHandleEx(HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize);
// BOOL __stdcall GetFileInformationByHandle(HANDLE hFile, LPBY_HANDLE_FILE_INFORMATION lpFileInformation);
// DWORD __stdcall GetEnvironmentVariableW(LPCWSTR lpName, LPWSTR lpBuffer, DWORD nSize);
// HANDLE __stdcall GetCurrentThread();
// HANDLE __stdcall GetCurrentProcess();
// DWORD __stdcall GetCurrentDirectoryW(DWORD nBufferLength, LPWSTR lpBuffer);
// UINT __stdcall GetConsoleOutputCP();
// BOOL __stdcall GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode);
// DWORD __stdcall FormatMessageW(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPWSTR lpBuffer, DWORD nSize, va_list *Arguments);
// BOOL __stdcall FindNextFileW(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData);
// HANDLE __stdcall FindFirstFileExW(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags);
// BOOL __stdcall FindClose(HANDLE hFindFile);
// BOOL __stdcall DuplicateHandle(HANDLE hSourceProcessHandle, HANDLE hSourceHandle, HANDLE hTargetProcessHandle, LPHANDLE lpTargetHandle, DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwOptions);
// BOOL __stdcall DeleteFileW(LPCWSTR lpFileName);
// HANDLE __stdcall CreateWaitableTimerExW(LPSECURITY_ATTRIBUTES lpTimerAttributes, LPCWSTR lpTimerName, DWORD dwFlags, DWORD dwDesiredAccess);
// HANDLE __stdcall CreateToolhelp32Snapshot(DWORD dwFlags, DWORD th32ProcessID);
// HANDLE __stdcall CreateFileW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// HANDLE __stdcall CreateFileMappingA(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCSTR lpName);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// PVOID __stdcall AddVectoredExceptionHandler(ULONG First, PVECTORED_EXCEPTION_HANDLER Handler);
// ULONG __stdcall RtlNtStatusToDosError(NTSTATUS Status);
// NTSTATUS __stdcall NtWriteFile(HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);
__int64 __fastcall sub_43CE80(ULONG_PTR a1);
__int64 __fastcall sub_43CEE0(__int64 a1, unsigned int a2);
void __fastcall sub_43CF00(__int64 a1, unsigned int a2, __int64 a3);
__int64 __fastcall sub_43CF20(__int64 a1);
__int64 __fastcall sub_43CF30(__int64 a1);
__int64 __fastcall sub_43CF40(__int64 a1, _DWORD *a2);
void __fastcall sub_43CF50(__int64 a1, __int64 a2);
__int64 __fastcall sub_43CF60(__int64 a1);
__int64 __fastcall sub_43CF70(__int64 a1);
PRUNTIME_FUNCTION __fastcall sub_43CF80(ULONG64 a1);
__int64 sub_43CFB0();
__int64 __fastcall sub_43CFC0(__int64 a1);
__int64 __fastcall sub_43CFD0(PEXCEPTION_RECORD ExceptionRecord, PVOID TargetFrame, PCONTEXT ContextRecord, __int64 a4, __int64 (__fastcall *a5)(__int64, __int64, __int64, __int64 *, __int64 *));
__int64 __fastcall sub_43D1F0(_QWORD *a1);
void __fastcall __noreturn sub_43D250(ULONG_PTR ReturnValue);
void __fastcall __noreturn sub_43D300(_QWORD *a1);
__int64 __fastcall sub_43D320(ULONG_PTR a1, __int64 a2, __int64 a3);
__int64 (__fastcall *__fastcall sub_43D350(__int64 a1))(__int64, __int64);
__int64 __fastcall sub_43D370(unsigned int (__fastcall *a1)(_QWORD *, __int64), __int64 a2);
// size_t __cdecl strlen(const char *Str);
// void *__cdecl memset(void *, int Val, size_t Size);
// void *__cdecl memmove(void *, const void *Src, size_t Size);
// void *__cdecl memcpy(void *, const void *Src, size_t Size);
// int __cdecl memcmp(const void *Buf1, const void *Buf2, size_t Size);
// void *__cdecl malloc(size_t Size);
// void __cdecl __noreturn exit(int Code);
// void __cdecl __noreturn abort();
// _onexit_t __cdecl onexit(_onexit_t Func);
// void __cdecl initterm(_PVFV *First, _PVFV *Last);
// void __cdecl cexit();
// __int64 __fastcall amsg_exit(_QWORD, _QWORD, _QWORD); weak
// void __cdecl _set_app_type(_crt_app_type Type);
// __int64 __fastcall _getmainargs(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
__int64 sub_43D5A0();
__int64 __fastcall sub_43D5B0(__int64 a1);
char *sub_43D5C0();
__int64 sub_43D5D0();
void (*sub_43D5E0())(void);
__int64 sub_43D620();
__int64 sub_43D690();
__int64 sub_43D6C0();
LONGLONG sub_43D6D0();
void __fastcall __noreturn sub_43D7B0(DWORD64 a1);
__int64 __fastcall TlsCallback_2(__int64 a1, unsigned int a2);
__int64 __fastcall TlsCallback_1(__int64 a1, int a2);
__int64 sub_43D970();
__int64 __fastcall sub_43D980(__int64 a1);
void sub_43DA80();
void __noreturn sub_43DA90(char *Format, ...);
int __fastcall sub_43DB00(_QWORD *a1, char *a2, unsigned int a3);
void sub_43DD10();
__int64 (__fastcall *__fastcall sub_43E000(int a1, __int64 a2, double a3, double a4, __int64 a5))(_QWORD);
void __fastcall sub_43E050(_UserMathErrorFunctionPointer UserMathErrorFunction);
__int64 __fastcall sub_43E060(unsigned int *a1);
__int64 sub_43E220();
LONG __stdcall TopLevelExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo); // idb
void sub_43E4D0();
__int64 __fastcall sub_43E540(int a1, __int64 a2);
__int64 __fastcall sub_43E5C0(int a1);
__int64 __fastcall sub_43E650(__int64 a1, unsigned int a2);
_BOOL8 __fastcall sub_43E730(__int64 a1);
_BOOL8 __fastcall sub_43E750(__int64 a1);
__int64 __fastcall sub_43E770(__int64 a1, unsigned __int64 a2);
const char *__fastcall sub_43E7C0(char *Str2);
__int64 sub_43E860();
__int64 sub_43E8F0();
__int64 sub_43E920();
__int64 sub_43E990();
_BOOL8 sub_43E9C0();
__int64 sub_43EA50();
// int __cdecl vfprintf(FILE *const Stream, const char *const Format, va_list ArgList);
// int __cdecl strncmp(const char *Str1, const char *Str2, size_t MaxCount);
// _crt_signal_t __cdecl signal(int Signal, _crt_signal_t Function);
// size_t __cdecl fwrite(const void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// void __cdecl free(void *Block);
// int fprintf(FILE *const Stream, const char *const Format, ...);
// void *__cdecl calloc(size_t Count, size_t Size);
// void __cdecl _setusermatherr(_UserMathErrorFunctionPointer UserMathErrorFunction);
FILE *__fastcall sub_43EB50(int a1);
// FILE *__cdecl _iob_func();
unsigned __int64 __fastcall sub_43EB78();

//-------------------------------------------------------------------------
// Data declarations

__int64 qword_43EBC0[] = { -1LL }; // weak
int dword_43F000 = 10; // weak
_BOOL8 (__fastcall *off_43F010)(unsigned __int8 a1, unsigned __int64 a2, const __m128i *a3) = &sub_409E80; // weak
char byte_43F018 = '\x01'; // weak
__int64 (__fastcall *off_43F020)(__int64 a1, __int64 a2) = &sub_437EB0; // weak
__int128 xmmword_43F028 = 0x08000000000000000LL; // weak
__m256 ymmword_43F038 = { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } }; // weak
__int64 (__fastcall *off_43F058)(LPVOID lpMem) = &sub_412E70; // weak
int dword_43F070 = 0; // weak
_UNKNOWN unk_43F080; // weak
__int64 (*off_43F090)[4] = &qword_43EBE0; // weak
_UNKNOWN unk_43F0A0; // weak
__int64 qword_43F0B0 = 47936899621426LL; // weak
__int64 qword_43F0C0 = -47936899621427LL; // weak
__int128 xmmword_440020 = 0xBFBFBFBFBFBFBFBFBFBFBFBFBFBFBFBFLL; // weak
__int128 xmmword_440030 = 0x19191919191919191919191919191919LL; // weak
__int128 xmmword_440040 = 0x20202020202020202020202020202020LL; // weak
__int128 xmmword_440050 = 49087LL; // weak
__int128 xmmword_440060 = 0x10000000000000001LL; // weak
__int128 xmmword_440070 = 0x1010101010101010101010101010101LL; // weak
__int128 xmmword_440080 = 49087LL; // weak
__int128 xmmword_440090 = 0x10000000000000001LL; // weak
__int128 xmmword_4400A0 = 0xFFFD0800FFFD1410FFFD3150FFFD48C0LL; // weak
__int128 xmmword_4400B0 = 0x80000000800000008000000080000000LL; // weak
__int128 xmmword_4400C0 = 0x7FFFF65D7FFFFFF07FFFFFF17FFFFFF9LL; // weak
__int128 xmmword_440310 = 0xFFFD0800FFFD1410FFFD3150FFFD48C0LL; // weak
__int128 xmmword_440320 = 0x80000000800000008000000080000000LL; // weak
__int128 xmmword_440330 = 0x7FFFF65D7FFFFFF07FFFFFF17FFFFFF9LL; // weak
__int128 xmmword_4403E0 = 49087LL; // weak
__int128 xmmword_4403F0 = 0x10000000000000001LL; // weak
_UNKNOWN *__ptr32 jpt_41FF21[12] =
{
  (_UNKNOWN *__ptr32)0xFFFDF3BD,
  (_UNKNOWN *__ptr32)0xFFFDF24B,
  (_UNKNOWN *__ptr32)0xFFFDF5A3,
  (_UNKNOWN *__ptr32)0xFFFDF611,
  (_UNKNOWN *__ptr32)0xFFFDF537,
  (_UNKNOWN *__ptr32)0xFFFDF6CD,
  (_UNKNOWN *__ptr32)0xFFFDF6D9,
  (_UNKNOWN *__ptr32)0xFFFDF677,
  (_UNKNOWN *__ptr32)0xFFFDF6F1,
  (_UNKNOWN *__ptr32)0xFFFDF597,
  (_UNKNOWN *__ptr32)0xFFFDF6E5,
  (_UNKNOWN *__ptr32)0xFFFDF4D8
}; // weak
__int128 xmmword_441F10 = 0xFFFD0800FFFD1410FFFD3150FFFD48C0LL; // weak
__int128 xmmword_441F20 = 0x80000000800000008000000080000000LL; // weak
__int128 xmmword_441F30 = 0x7FFFF65D7FFFFFF07FFFFFF17FFFFFF9LL; // weak
__int128 xmmword_441FE0 = 1061109511LL; // weak
__int128 xmmword_441FF0 = 2155905264LL; // weak
char *off_442168 = "Error: "; // weak
char *off_4421D0 = "Starting exe cleaner...\n"; // weak
char *off_4421F8 = "Cleaned "; // weak
char *off_442238 = "Error cleaning "; // weak
char *off_442278 = "src/main.rs"; // weak
char *off_4422B0 = "No running process found for: "; // weak
char *off_442300 = "Failed to delete even after killing process: "; // weak
char *off_442340 = "Killed process and deleted: "; // weak
char *off_442380 = "Error deleting after kill: "; // weak
char *off_4423D0 = "Error killing process for: "; // weak
char *off_442408 = "Successfully deleted: "; // weak
char *off_442438 = "Error deleting: "; // weak
char *off_442498 = "Successfully terminated process: "; // weak
_UNKNOWN unk_4424D0; // weak
__int64 (__fastcall *off_4424F0)() = &sub_4045C0; // weak
char *off_442538 = "capacity overflow"; // weak
char *off_442568 = "library\\alloc\\src\\raw_vec.rs"; // weak
char *off_4425B8 = "library\\alloc\\src\\string.rs"; // weak
char *off_4425E8 = "library\\alloc\\src\\fmt.rs"; // weak
char *off_442600 = "library\\alloc\\src\\str.rs"; // weak
char *off_442618 = "library\\alloc\\src\\str.rs"; // weak
char *off_442630 = "library\\alloc\\src\\str.rs"; // weak
char *off_442648 = "library\\alloc\\src\\string.rs"; // weak
_UNKNOWN unk_442660; // weak
char aBorrowmuterror[14] = "BorrowMutError"; // weak
char *off_442688 = "already borrowed: "; // weak
char *off_4426E0 = "library\\core\\src\\panicking.rs"; // weak
char *off_4426F8 = "library\\core\\src\\panicking.rs"; // weak
char *off_442748 = "index out of bounds: the len is "; // weak
char aPanicInAFuncti[38] = "panic in a function that cannot unwind"; // weak
char aPanicInADestru[36] = "panic in a destructor during cleanup"; // weak
_UNKNOWN unk_4427B8; // weak
char asc_4427D8[2] = "=="; // weak
char asc_4427DA[2] = "!="; // weak
char *off_442810 = "assertion `left "; // weak
char *off_442860 = "assertion `left "; // weak
_UNKNOWN unk_4428A0; // weak
char asc_4428D0[4] = "    "; // weak
char asc_4428D4[3] = " {\n"; // weak
char asc_4428D7[2] = ",\n"; // weak
char asc_4428D9[2] = "(\n"; // weak
_WORD a0001020304[100] =
{
  12336,
  12592,
  12848,
  13104,
  13360,
  13616,
  13872,
  14128,
  14384,
  14640,
  12337,
  12593,
  12849,
  13105,
  13361,
  13617,
  13873,
  14129,
  14385,
  14641,
  12338,
  12594,
  12850,
  13106,
  13362,
  13618,
  13874,
  14130,
  14386,
  14642,
  12339,
  12595,
  12851,
  13107,
  13363,
  13619,
  13875,
  14131,
  14387,
  14643,
  12340,
  12596,
  12852,
  13108,
  13364,
  13620,
  13876,
  14132,
  14388,
  14644,
  12341,
  12597,
  12853,
  13109,
  13365,
  13621,
  13877,
  14133,
  14389,
  14645,
  12342,
  12598,
  12854,
  13110,
  13366,
  13622,
  13878,
  14134,
  14390,
  14646,
  12343,
  12599,
  12855,
  13111,
  13367,
  13623,
  13879,
  14135,
  14391,
  14647,
  12344,
  12600,
  12856,
  13112,
  13368,
  13624,
  13880,
  14136,
  14392,
  14648,
  12345,
  12601,
  12857,
  13113,
  13369,
  13625,
  13881,
  14137,
  14393,
  14649
}; // weak
char *off_4429C0 = "library\\core\\src\\fmt\\mod.rs"; // weak
char *off_4429D8 = "library\\core\\src\\fmt\\mod.rs"; // weak
char *off_442A10 = "library\\core\\src\\slice\\memchr.rs"; // weak
char *off_442A28 = "library\\core\\src\\slice\\memchr.rs"; // weak
char *off_442A90 = "user-provided comparison function does not correctly implement a total order"; // weak
char *off_442AD0 = "library\\core\\src\\slice\\sort\\shared\\smallsort.rs"; // weak
char *off_442B18 = "attempted to index str up to maximum usize"; // weak
char *off_442B68 = "library\\core\\src\\str\\pattern.rs"; // weak
char *off_442B80 = "library\\core\\src\\str\\pattern.rs"; // weak
char *off_442B98 = "library\\core\\src\\str\\pattern.rs"; // weak
char *off_442BB0 = "library\\core\\src\\str\\pattern.rs"; // weak
char *off_442BC8 = "library\\core\\src\\str\\pattern.rs"; // weak
_UNKNOWN unk_442BE0; // weak
char *off_442C08 = "begin <= end ("; // weak
char *off_442C80 = "byte index "; // weak
char *off_442CE8 = "byte index "; // weak
char *off_442D18 = "library\\core\\src\\str\\mod.rs"; // weak
char *off_442D58 = "library\\core\\src\\unicode\\printable.rs"; // weak
char *off_442D70 = "library\\core\\src\\unicode\\printable.rs"; // weak
_BYTE byte_442D88[88] =
{
  0,
  6,
  1,
  1,
  3,
  1,
  4,
  2,
  5,
  7,
  7,
  2,
  8,
  8,
  9,
  2,
  10,
  5,
  11,
  2,
  14,
  4,
  16,
  1,
  17,
  2,
  18,
  5,
  19,
  28,
  20,
  1,
  21,
  2,
  23,
  2,
  25,
  13,
  28,
  5,
  29,
  8,
  31,
  1,
  36,
  1,
  106,
  4,
  107,
  2,
  -81,
  3,
  -79,
  2,
  -68,
  2,
  -49,
  2,
  -47,
  2,
  -44,
  12,
  -43,
  9,
  -42,
  2,
  -41,
  2,
  -38,
  1,
  -32,
  5,
  -31,
  2,
  -25,
  4,
  -24,
  2,
  -18,
  32,
  -16,
  4,
  -8,
  2,
  -6,
  4,
  -5,
  1
}; // weak
_UNKNOWN unk_442DE0; // weak
char asc_442EB0[486] = "^\"{\x05\x03\x04-\x03f\x03\x01/.\x80\x82\x1D\x031\x0F\x1C\x04$\t\x1E\x05+\x05D\x04\x0E*\x80\xAA\x06$\x04$\x04(\b4\vN\x034\f\x817\t\x16\n\b\x18;E9\x03c\b\t0\x16\x05!\x03\x1B\x05\x01@8\x04K\x05/\x04\n\a\t\a@ '\x04\f\t6\x03:\x05\x1A\a\x04\f\aPI73\r3\a.\b\n\x06&\x03\x1D\b\x02\x80\xD0\x52\x10\x037,\b*\x16\x1A&\x1C\x14\x17\tN\x04$\tD\r\x19\a\n\x06H\b'\tu\vB>*\x06;\x05\n\x06Q\x06\x01\x05\x10\x03\x05\vY\b\x02\x1Db\x1EH\b\n\x80\xA6^\"E\v\n\x06\r\x13:\x06\n\x06\x14\x1C,\x04\x17\x80\xB9<dS\fH\t\nFE\x1BH\bS\rI\a\n\x80\xB6\"\x0E\n\x06F\n\x1D\x03GI7\x03\x0E\b\n\x069\a\n\x816\x19\a;\x03\x1DU\x01\x0F2\r\x83\x9Bfu\v\x80ĊLc\r\x840\x10\x16\n\x8F\x9B\x05\x82G\x9A\xB9:\x86Ƃ9\a*\x04\\\x06&\nF\n(\x05\x13\x81\xB0:\x80\xC6\x5BeK\x049\a\x11@\x05\v\x02\x0E\x97\xF8\b\x84\xD6\x29\n\xA2\xE7\x81\x33\x0F\x01\x1D\x06\x0E\x04\b\x81\x8C\x89\x04k\x05\r\x03\t\a\x10\x8F`\x80\xFA\x06\x81\xB4LG\tt<\x80\xF6\x0A\x73\x08p\x15Fz\x14\f\x14\fW\t\x19\x80\x87\x81G\x03\x85B\x0F\x15\x84P\x1F\x06\x06\x80\xD5\x2B\x05>!\x01p-\x03\x1A\x04\x02\x81@\x1F\x11:\x05\x01\x81\xD0\x2A\x80\xD6\x2B\x04\x01\x81\xE0\x80\xF7)L\x04\n\x04\x02\x83\x11DL=\x80\xC2\x3C\x06\x01\x04U\x05\x1B4\x02\x81\x0E,\x04d\fV\n\x80\xAE8\x1D\r,\x04\t\a\x02\x0E\x06\x80\x9A\x83\xD8\x04\x11\x03\r\x03w\x04_\x06\f\x04\x01\x0F\f\x048\b\n\x06(\b,\x04\x02>\x81T\f\x1D\x03\n\x058\a\x1C\x06\t\a\x80\xFA\x84\x06"; // weak
_BYTE byte_443096[80] =
{
  0,
  1,
  3,
  5,
  5,
  6,
  6,
  2,
  7,
  6,
  8,
  7,
  9,
  17,
  10,
  28,
  11,
  25,
  12,
  26,
  13,
  16,
  14,
  12,
  15,
  4,
  16,
  3,
  18,
  18,
  19,
  9,
  22,
  1,
  23,
  4,
  24,
  1,
  25,
  3,
  26,
  7,
  27,
  1,
  28,
  2,
  31,
  22,
  32,
  3,
  43,
  3,
  45,
  11,
  46,
  1,
  48,
  4,
  49,
  2,
  50,
  1,
  -89,
  4,
  -87,
  2,
  -86,
  4,
  -85,
  8,
  -6,
  2,
  -5,
  5,
  -3,
  2,
  -2,
  3,
  -1,
  9
}; // weak
_UNKNOWN unk_4430E6; // weak
char byte_443208[297] =
{
  '\0',
  ' ',
  '_',
  '\"',
  '\x82',
  '\xDF',
  '\x04',
  '\x82',
  'D',
  '\b',
  '\x1B',
  '\x04',
  '\x06',
  '\x11',
  '\x81',
  '\xAC',
  '\x0E',
  '\x80',
  '\xAB',
  '\x05',
  '\x1F',
  '\b',
  '\x81',
  '\x1C',
  '\x03',
  '\x19',
  '\b',
  '\x01',
  '\x04',
  '/',
  '\x04',
  '4',
  '\x04',
  '\a',
  '\x03',
  '\x01',
  '\a',
  '\x06',
  '\a',
  '\x11',
  '\n',
  'P',
  '\x0F',
  '\x12',
  '\a',
  'U',
  '\a',
  '\x03',
  '\x04',
  '\x1C',
  '\n',
  '\t',
  '\x03',
  '\b',
  '\x03',
  '\a',
  '\x03',
  '\x02',
  '\x03',
  '\x03',
  '\x03',
  '\f',
  '\x04',
  '\x05',
  '\x03',
  '\v',
  '\x06',
  '\x01',
  '\x0E',
  '\x15',
  '\x05',
  'N',
  '\a',
  '\x1B',
  '\a',
  'W',
  '\a',
  '\x02',
  '\x06',
  '\x17',
  '\f',
  'P',
  '\x04',
  'C',
  '\x03',
  '-',
  '\x03',
  '\x01',
  '\x04',
  '\x11',
  '\x06',
  '\x0F',
  '\f',
  ':',
  '\x04',
  '\x1D',
  '%',
  '_',
  ' ',
  'm',
  '\x04',
  'j',
  '%',
  '\x80',
  '\xC8',
  '\x05',
  '\x82',
  '\xB0',
  '\x03',
  '\x1A',
  '\x06',
  '\x82',
  '\xFD',
  '\x03',
  'Y',
  '\a',
  '\x16',
  '\t',
  '\x18',
  '\t',
  '\x14',
  '\f',
  '\x14',
  '\f',
  'j',
  '\x06',
  '\n',
  '\x06',
  '\x1A',
  '\x06',
  'Y',
  '\a',
  '+',
  '\x05',
  'F',
  '\n',
  ',',
  '\x04',
  '\f',
  '\x04',
  '\x01',
  '\x03',
  '1',
  '\v',
  ',',
  '\x04',
  '\x1A',
  '\x06',
  '\v',
  '\x03',
  '\x80',
  '\xAC',
  '\x06',
  '\n',
  '\x06',
  '/',
  '1',
  '\x80',
  '\xF4',
  '\b',
  '<',
  '\x03',
  '\x0F',
  '\x03',
  '>',
  '\x05',
  '8',
  '\b',
  '+',
  '\x05',
  '\x82',
  '\xFF',
  '\x11',
  '\x18',
  '\b',
  '/',
  '\x11',
  '-',
  '\x03',
  '!',
  '\x0F',
  '!',
  '\x0F',
  '\x80',
  '\x8C',
  '\x04',
  '\x82',
  '\x9A',
  '\x16',
  '\v',
  '\x15',
  '\x88',
  '\x94',
  '\x05',
  '/',
  '\x05',
  ';',
  '\a',
  '\x02',
  '\x0E',
  '\x18',
  '\t',
  '\x80',
  '\xBE',
  '\"',
  't',
  '\f',
  '\x80',
  '\xD6',
  '\x1A',
  '\x81',
  '\x10',
  '\x05',
  '\x80',
  '\xE1',
  '\t',
  '\xF2',
  '\x9E',
  '\x03',
  '7',
  '\t',
  '\x81',
  '\\',
  '\x14',
  '\x80',
  '\xB8',
  '\b',
  '\x80',
  '\xDD',
  '\x15',
  ';',
  '\x03',
  '\n',
  '\x06',
  '8',
  '\b',
  'F',
  '\b',
  '\f',
  '\x06',
  't',
  '\v',
  '\x1E',
  '\x03',
  'Z',
  '\x04',
  'Y',
  '\t',
  '\x80',
  '\x83',
  '\x18',
  '\x1C',
  '\n',
  '\x16',
  '\t',
  'L',
  '\x04',
  '\x80',
  '\x8A',
  '\x06',
  '\xAB',
  '\xA4',
  '\f',
  '\x17',
  '\x04',
  '1',
  '\xA1',
  '\x04',
  '\x81',
  '\xDA',
  '&',
  '\a',
  '\f',
  '\x05',
  '\x05',
  '\x80',
  '\xA6',
  '\x10',
  '\x81',
  '\xF5',
  '\a',
  '\x01',
  ' ',
  '*',
  '\x06',
  'L',
  '\x04',
  '\x80',
  '\x8D',
  '\x04',
  '\x80',
  '\xBE',
  '\x03',
  '\x1B',
  '\x03',
  '\x0F',
  '\r'
}; // weak
char *off_443360 = "library\\core\\src\\unicode\\unicode_data.rs"; // weak
char *off_443378 = "library\\core\\src\\unicode\\unicode_data.rs"; // weak
char *off_4433B0 = "attempt to divide by zero"; // weak
char *off_443400 = "attempt to calculate the remainder with a divisor of zero"; // weak
char *off_443448 = "range start index "; // weak
char *off_443478 = "range end index "; // weak
char *off_4434C0 = "slice index starts at "; // weak
_DWORD dword_4434E0[37] =
{
  688,
  44045149,
  572528402,
  576724925,
  807414908,
  878718981,
  903913493,
  929080568,
  933275148,
  937491230,
  1138818560,
  1147208189,
  1210124160,
  1222707713,
  1235291428,
  1260457643,
  1277237295,
  1537284411,
  1545673776,
  1604394739,
  1667314736,
  1692492062,
  1700883184,
  1709272384,
  1721855823,
  1730260976,
  1747041437,
  1759629056,
  1768018279,
  1776409088,
  1797382144,
  1822548654,
  1856103659,
  1864493264,
  1872884731,
  1882062849,
  1887371760
}; // weak
unsigned __int8 byte_443574[908] =
{
  39u,
  1u,
  6u,
  1u,
  11u,
  1u,
  35u,
  1u,
  1u,
  1u,
  71u,
  1u,
  4u,
  1u,
  1u,
  1u,
  4u,
  1u,
  2u,
  2u,
  0u,
  192u,
  4u,
  2u,
  4u,
  1u,
  9u,
  2u,
  1u,
  1u,
  251u,
  7u,
  207u,
  1u,
  5u,
  1u,
  49u,
  45u,
  1u,
  1u,
  1u,
  2u,
  1u,
  2u,
  1u,
  1u,
  44u,
  1u,
  11u,
  6u,
  10u,
  11u,
  1u,
  1u,
  35u,
  1u,
  10u,
  21u,
  16u,
  1u,
  101u,
  8u,
  1u,
  10u,
  1u,
  4u,
  33u,
  1u,
  1u,
  1u,
  30u,
  27u,
  91u,
  11u,
  58u,
  11u,
  4u,
  1u,
  2u,
  1u,
  24u,
  24u,
  43u,
  3u,
  44u,
  1u,
  7u,
  2u,
  5u,
  9u,
  41u,
  58u,
  55u,
  1u,
  1u,
  1u,
  4u,
  8u,
  4u,
  1u,
  3u,
  7u,
  10u,
  2u,
  13u,
  1u,
  15u,
  1u,
  58u,
  1u,
  4u,
  4u,
  8u,
  1u,
  20u,
  2u,
  26u,
  1u,
  2u,
  2u,
  57u,
  1u,
  4u,
  2u,
  4u,
  2u,
  2u,
  3u,
  3u,
  1u,
  30u,
  2u,
  3u,
  1u,
  11u,
  2u,
  57u,
  1u,
  4u,
  5u,
  1u,
  2u,
  4u,
  1u,
  20u,
  2u,
  22u,
  6u,
  1u,
  1u,
  58u,
  1u,
  2u,
  1u,
  1u,
  4u,
  8u,
  1u,
  7u,
  2u,
  11u,
  2u,
  30u,
  1u,
  61u,
  1u,
  12u,
  1u,
  50u,
  1u,
  3u,
  1u,
  55u,
  1u,
  1u,
  3u,
  5u,
  3u,
  1u,
  4u,
  7u,
  2u,
  11u,
  2u,
  29u,
  1u,
  58u,
  1u,
  2u,
  1u,
  6u,
  1u,
  5u,
  2u,
  20u,
  2u,
  28u,
  2u,
  57u,
  2u,
  4u,
  4u,
  8u,
  1u,
  20u,
  2u,
  29u,
  1u,
  72u,
  1u,
  7u,
  3u,
  1u,
  1u,
  90u,
  1u,
  2u,
  7u,
  11u,
  9u,
  98u,
  1u,
  2u,
  9u,
  9u,
  1u,
  1u,
  7u,
  73u,
  2u,
  27u,
  1u,
  1u,
  1u,
  1u,
  1u,
  55u,
  14u,
  1u,
  5u,
  1u,
  2u,
  5u,
  11u,
  1u,
  36u,
  9u,
  1u,
  102u,
  4u,
  1u,
  6u,
  1u,
  2u,
  2u,
  2u,
  25u,
  2u,
  4u,
  3u,
  16u,
  4u,
  13u,
  1u,
  2u,
  2u,
  6u,
  1u,
  15u,
  1u,
  94u,
  1u,
  0u,
  3u,
  0u,
  3u,
  29u,
  2u,
  30u,
  2u,
  30u,
  2u,
  64u,
  2u,
  1u,
  7u,
  8u,
  1u,
  2u,
  11u,
  3u,
  1u,
  5u,
  1u,
  45u,
  5u,
  51u,
  1u,
  65u,
  2u,
  34u,
  1u,
  118u,
  3u,
  4u,
  2u,
  9u,
  1u,
  6u,
  3u,
  219u,
  2u,
  2u,
  1u,
  58u,
  1u,
  1u,
  7u,
  1u,
  1u,
  1u,
  1u,
  2u,
  8u,
  6u,
  10u,
  2u,
  1u,
  39u,
  1u,
  8u,
  31u,
  49u,
  4u,
  48u,
  1u,
  1u,
  5u,
  1u,
  1u,
  5u,
  1u,
  40u,
  9u,
  12u,
  2u,
  32u,
  4u,
  2u,
  2u,
  1u,
  3u,
  56u,
  1u,
  1u,
  2u,
  3u,
  1u,
  1u,
  3u,
  58u,
  8u,
  2u,
  2u,
  64u,
  6u,
  82u,
  3u,
  1u,
  13u,
  1u,
  7u,
  4u,
  1u,
  6u,
  1u,
  3u,
  2u,
  50u,
  63u,
  13u,
  1u,
  34u,
  101u,
  0u,
  1u,
  1u,
  3u,
  11u,
  3u,
  13u,
  3u,
  13u,
  3u,
  13u,
  2u,
  12u,
  5u,
  8u,
  2u,
  10u,
  1u,
  2u,
  1u,
  2u,
  5u,
  49u,
  5u,
  1u,
  10u,
  1u,
  1u,
  13u,
  1u,
  16u,
  13u,
  51u,
  33u,
  0u,
  2u,
  113u,
  3u,
  125u,
  1u,
  15u,
  1u,
  96u,
  32u,
  47u,
  1u,
  0u,
  1u,
  36u,
  4u,
  3u,
  5u,
  5u,
  1u,
  93u,
  6u,
  93u,
  3u,
  0u,
  1u,
  0u,
  6u,
  0u,
  1u,
  98u,
  4u,
  1u,
  10u,
  1u,
  1u,
  28u,
  4u,
  80u,
  2u,
  14u,
  34u,
  78u,
  1u,
  23u,
  3u,
  103u,
  3u,
  3u,
  2u,
  8u,
  1u,
  3u,
  1u,
  4u,
  1u,
  25u,
  2u,
  5u,
  1u,
  151u,
  2u,
  26u,
  18u,
  13u,
  1u,
  38u,
  8u,
  25u,
  11u,
  46u,
  3u,
  48u,
  1u,
  2u,
  4u,
  2u,
  2u,
  17u,
  1u,
  21u,
  2u,
  66u,
  6u,
  2u,
  2u,
  2u,
  2u,
  12u,
  1u,
  8u,
  1u,
  35u,
  1u,
  11u,
  1u,
  51u,
  1u,
  1u,
  3u,
  2u,
  2u,
  5u,
  2u,
  1u,
  1u,
  27u,
  1u,
  14u,
  2u,
  5u,
  2u,
  1u,
  1u,
  100u,
  5u,
  9u,
  3u,
  121u,
  1u,
  2u,
  1u,
  4u,
  1u,
  0u,
  1u,
  147u,
  17u,
  0u,
  16u,
  3u,
  1u,
  12u,
  16u,
  34u,
  1u,
  2u,
  1u,
  169u,
  1u,
  7u,
  1u,
  6u,
  1u,
  11u,
  1u,
  35u,
  1u,
  1u,
  1u,
  47u,
  1u,
  45u,
  2u,
  67u,
  1u,
  21u,
  3u,
  0u,
  1u,
  226u,
  1u,
  149u,
  5u,
  0u,
  6u,
  1u,
  42u,
  1u,
  9u,
  0u,
  3u,
  1u,
  2u,
  5u,
  4u,
  40u,
  3u,
  4u,
  1u,
  165u,
  2u,
  0u,
  4u,
  38u,
  1u,
  26u,
  5u,
  1u,
  1u,
  0u,
  2u,
  79u,
  4u,
  70u,
  11u,
  49u,
  4u,
  123u,
  1u,
  54u,
  15u,
  41u,
  1u,
  2u,
  2u,
  10u,
  3u,
  49u,
  4u,
  2u,
  2u,
  2u,
  1u,
  4u,
  1u,
  10u,
  1u,
  50u,
  3u,
  36u,
  5u,
  1u,
  8u,
  62u,
  1u,
  12u,
  2u,
  52u,
  9u,
  10u,
  4u,
  2u,
  1u,
  95u,
  3u,
  2u,
  1u,
  1u,
  2u,
  6u,
  1u,
  2u,
  1u,
  157u,
  1u,
  3u,
  8u,
  21u,
  2u,
  57u,
  2u,
  3u,
  1u,
  37u,
  7u,
  3u,
  5u,
  70u,
  6u,
  13u,
  1u,
  1u,
  1u,
  1u,
  1u,
  14u,
  2u,
  85u,
  8u,
  2u,
  3u,
  1u,
  1u,
  23u,
  1u,
  84u,
  6u,
  1u,
  1u,
  4u,
  2u,
  1u,
  2u,
  238u,
  4u,
  6u,
  2u,
  1u,
  2u,
  27u,
  2u,
  85u,
  8u,
  2u,
  1u,
  1u,
  2u,
  106u,
  1u,
  1u,
  1u,
  2u,
  6u,
  1u,
  1u,
  101u,
  1u,
  1u,
  1u,
  2u,
  4u,
  1u,
  5u,
  0u,
  9u,
  1u,
  2u,
  0u,
  2u,
  1u,
  1u,
  4u,
  1u,
  144u,
  4u,
  2u,
  2u,
  4u,
  1u,
  32u,
  10u,
  40u,
  6u,
  2u,
  4u,
  8u,
  1u,
  9u,
  6u,
  2u,
  3u,
  46u,
  13u,
  1u,
  2u,
  0u,
  7u,
  1u,
  6u,
  1u,
  1u,
  82u,
  22u,
  2u,
  7u,
  1u,
  2u,
  1u,
  2u,
  122u,
  6u,
  3u,
  1u,
  1u,
  2u,
  1u,
  7u,
  1u,
  1u,
  72u,
  2u,
  3u,
  1u,
  1u,
  1u,
  0u,
  2u,
  11u,
  2u,
  52u,
  5u,
  5u,
  1u,
  1u,
  1u,
  23u,
  1u,
  0u,
  17u,
  6u,
  15u,
  0u,
  12u,
  3u,
  3u,
  0u,
  5u,
  59u,
  7u,
  9u,
  4u,
  0u,
  3u,
  40u,
  2u,
  0u,
  1u,
  63u,
  17u,
  64u,
  2u,
  1u,
  2u,
  0u,
  4u,
  1u,
  7u,
  1u,
  2u,
  0u,
  2u,
  1u,
  4u,
  0u,
  46u,
  2u,
  23u,
  0u,
  3u,
  9u,
  16u,
  2u,
  7u,
  30u,
  4u,
  148u,
  3u,
  0u,
  55u,
  4u,
  50u,
  8u,
  1u,
  14u,
  1u,
  22u,
  5u,
  1u,
  15u,
  0u,
  7u,
  1u,
  17u,
  2u,
  7u,
  1u,
  2u,
  1u,
  5u,
  5u,
  62u,
  33u,
  1u,
  160u,
  14u,
  0u,
  1u,
  61u,
  4u,
  0u,
  5u,
  254u,
  2u,
  0u,
  7u,
  109u,
  8u,
  0u,
  5u,
  0u,
  1u,
  30u,
  96u,
  128u,
  240u,
  0u,
  0u,
  0u,
  0u
}; // weak
_DWORD dword_443900[22] =
{
  4256,
  115348384,
  136322176,
  144711446,
  163587254,
  320875520,
  325101120,
  350268208,
  392231680,
  404815649,
  413205504,
  421595008,
  467733632,
  484513952,
  501313088,
  505533440,
  509728422,
  587325184,
  635559984,
  648145152,
  652341552,
  657650058
}; // weak
unsigned __int8 byte_443958[320] =
{
  65u,
  26u,
  6u,
  26u,
  47u,
  1u,
  10u,
  1u,
  4u,
  1u,
  5u,
  23u,
  1u,
  31u,
  1u,
  195u,
  1u,
  4u,
  4u,
  208u,
  1u,
  36u,
  7u,
  2u,
  30u,
  5u,
  96u,
  1u,
  42u,
  4u,
  2u,
  2u,
  2u,
  4u,
  1u,
  1u,
  6u,
  1u,
  1u,
  3u,
  1u,
  1u,
  1u,
  20u,
  1u,
  83u,
  1u,
  139u,
  8u,
  166u,
  1u,
  38u,
  9u,
  41u,
  0u,
  38u,
  1u,
  1u,
  5u,
  1u,
  2u,
  43u,
  1u,
  4u,
  0u,
  86u,
  2u,
  6u,
  0u,
  11u,
  5u,
  43u,
  2u,
  3u,
  64u,
  192u,
  64u,
  0u,
  2u,
  6u,
  2u,
  38u,
  2u,
  6u,
  2u,
  8u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  31u,
  2u,
  53u,
  1u,
  7u,
  1u,
  1u,
  3u,
  3u,
  1u,
  7u,
  3u,
  4u,
  2u,
  6u,
  4u,
  13u,
  5u,
  3u,
  1u,
  7u,
  116u,
  1u,
  13u,
  1u,
  16u,
  13u,
  101u,
  1u,
  4u,
  1u,
  2u,
  10u,
  1u,
  1u,
  3u,
  5u,
  6u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  4u,
  1u,
  6u,
  4u,
  1u,
  2u,
  4u,
  5u,
  5u,
  4u,
  1u,
  17u,
  32u,
  3u,
  2u,
  0u,
  52u,
  0u,
  229u,
  6u,
  4u,
  3u,
  2u,
  12u,
  38u,
  1u,
  1u,
  5u,
  1u,
  0u,
  46u,
  18u,
  30u,
  132u,
  102u,
  3u,
  4u,
  1u,
  62u,
  2u,
  2u,
  1u,
  1u,
  1u,
  8u,
  21u,
  5u,
  1u,
  3u,
  0u,
  43u,
  1u,
  14u,
  6u,
  80u,
  0u,
  7u,
  12u,
  5u,
  0u,
  26u,
  6u,
  26u,
  0u,
  80u,
  96u,
  36u,
  4u,
  36u,
  116u,
  11u,
  1u,
  15u,
  1u,
  7u,
  1u,
  2u,
  1u,
  11u,
  1u,
  15u,
  1u,
  7u,
  1u,
  2u,
  0u,
  1u,
  2u,
  3u,
  1u,
  42u,
  1u,
  9u,
  0u,
  51u,
  13u,
  51u,
  93u,
  22u,
  10u,
  22u,
  0u,
  64u,
  0u,
  64u,
  0u,
  85u,
  1u,
  71u,
  1u,
  2u,
  2u,
  1u,
  2u,
  2u,
  2u,
  4u,
  1u,
  12u,
  1u,
  1u,
  1u,
  7u,
  1u,
  65u,
  1u,
  4u,
  2u,
  8u,
  1u,
  7u,
  1u,
  28u,
  1u,
  4u,
  1u,
  5u,
  1u,
  1u,
  3u,
  7u,
  1u,
  0u,
  2u,
  25u,
  1u,
  25u,
  1u,
  31u,
  1u,
  25u,
  1u,
  31u,
  1u,
  25u,
  1u,
  31u,
  1u,
  25u,
  1u,
  31u,
  1u,
  25u,
  1u,
  8u,
  0u,
  10u,
  1u,
  20u,
  6u,
  6u,
  0u,
  62u,
  0u,
  68u,
  0u,
  26u,
  6u,
  26u,
  6u,
  26u,
  0u,
  0u
}; // weak
_DWORD dword_443A98[34] =
{
  768,
  2098307,
  6292881,
  10490717,
  522196754,
  526393356,
  723528943,
  731918378,
  744531567,
  752920578,
  769719070,
  908131840,
  912326558,
  920715773,
  924912129,
  937495844,
  962662059,
  971053103,
  1256266800,
  1323376371,
  1386296384,
  1407279390,
  1415670512,
  1424060239,
  1432468637,
  1449250560,
  1453445477,
  1461836288,
  1487003648,
  1512170158,
  1541530860,
  1549920464,
  1559101472,
  1568604656
}; // weak
unsigned __int8 byte_443B20[752] =
{
  0u,
  112u,
  0u,
  7u,
  0u,
  45u,
  1u,
  1u,
  1u,
  2u,
  1u,
  2u,
  1u,
  1u,
  72u,
  11u,
  48u,
  21u,
  16u,
  1u,
  101u,
  7u,
  2u,
  6u,
  2u,
  2u,
  1u,
  4u,
  35u,
  1u,
  30u,
  27u,
  91u,
  11u,
  58u,
  9u,
  9u,
  1u,
  24u,
  4u,
  1u,
  9u,
  1u,
  3u,
  1u,
  5u,
  43u,
  3u,
  59u,
  9u,
  42u,
  24u,
  1u,
  32u,
  55u,
  1u,
  1u,
  1u,
  4u,
  8u,
  4u,
  1u,
  3u,
  7u,
  10u,
  2u,
  29u,
  1u,
  58u,
  1u,
  1u,
  1u,
  2u,
  4u,
  8u,
  1u,
  9u,
  1u,
  10u,
  2u,
  26u,
  1u,
  2u,
  2u,
  57u,
  1u,
  4u,
  2u,
  4u,
  2u,
  2u,
  3u,
  3u,
  1u,
  30u,
  2u,
  3u,
  1u,
  11u,
  2u,
  57u,
  1u,
  4u,
  5u,
  1u,
  2u,
  4u,
  1u,
  20u,
  2u,
  22u,
  6u,
  1u,
  1u,
  58u,
  1u,
  1u,
  2u,
  1u,
  4u,
  8u,
  1u,
  7u,
  3u,
  10u,
  2u,
  30u,
  1u,
  59u,
  1u,
  1u,
  1u,
  12u,
  1u,
  9u,
  1u,
  40u,
  1u,
  3u,
  1u,
  55u,
  1u,
  1u,
  3u,
  5u,
  3u,
  1u,
  4u,
  7u,
  2u,
  11u,
  2u,
  29u,
  1u,
  58u,
  1u,
  2u,
  2u,
  1u,
  1u,
  3u,
  3u,
  1u,
  4u,
  7u,
  2u,
  11u,
  2u,
  28u,
  2u,
  57u,
  2u,
  1u,
  1u,
  2u,
  4u,
  8u,
  1u,
  9u,
  1u,
  10u,
  2u,
  29u,
  1u,
  72u,
  1u,
  4u,
  1u,
  2u,
  3u,
  1u,
  1u,
  8u,
  1u,
  81u,
  1u,
  2u,
  7u,
  12u,
  8u,
  98u,
  1u,
  2u,
  9u,
  11u,
  7u,
  73u,
  2u,
  27u,
  1u,
  1u,
  1u,
  1u,
  1u,
  55u,
  14u,
  1u,
  5u,
  1u,
  2u,
  5u,
  11u,
  1u,
  36u,
  9u,
  1u,
  102u,
  4u,
  1u,
  6u,
  1u,
  2u,
  2u,
  2u,
  25u,
  2u,
  4u,
  3u,
  16u,
  4u,
  13u,
  1u,
  2u,
  2u,
  6u,
  1u,
  15u,
  1u,
  0u,
  3u,
  0u,
  4u,
  28u,
  3u,
  29u,
  2u,
  30u,
  2u,
  64u,
  2u,
  1u,
  7u,
  8u,
  1u,
  2u,
  11u,
  9u,
  1u,
  45u,
  3u,
  1u,
  1u,
  117u,
  2u,
  34u,
  1u,
  118u,
  3u,
  4u,
  2u,
  9u,
  1u,
  6u,
  3u,
  219u,
  2u,
  2u,
  1u,
  58u,
  1u,
  1u,
  7u,
  1u,
  1u,
  1u,
  1u,
  2u,
  8u,
  6u,
  10u,
  2u,
  1u,
  48u,
  31u,
  49u,
  4u,
  48u,
  10u,
  4u,
  3u,
  38u,
  9u,
  12u,
  2u,
  32u,
  4u,
  2u,
  6u,
  56u,
  1u,
  1u,
  2u,
  3u,
  1u,
  1u,
  5u,
  56u,
  8u,
  2u,
  2u,
  152u,
  3u,
  1u,
  13u,
  1u,
  7u,
  4u,
  1u,
  6u,
  1u,
  3u,
  2u,
  198u,
  64u,
  0u,
  1u,
  195u,
  33u,
  0u,
  3u,
  141u,
  1u,
  96u,
  32u,
  0u,
  6u,
  105u,
  2u,
  0u,
  4u,
  1u,
  10u,
  32u,
  2u,
  80u,
  2u,
  0u,
  1u,
  3u,
  1u,
  4u,
  1u,
  25u,
  2u,
  5u,
  1u,
  151u,
  2u,
  26u,
  18u,
  13u,
  1u,
  38u,
  8u,
  25u,
  11u,
  1u,
  1u,
  44u,
  3u,
  48u,
  1u,
  2u,
  4u,
  2u,
  2u,
  2u,
  1u,
  36u,
  1u,
  67u,
  6u,
  2u,
  2u,
  2u,
  2u,
  12u,
  1u,
  8u,
  1u,
  47u,
  1u,
  51u,
  1u,
  1u,
  3u,
  2u,
  2u,
  5u,
  2u,
  1u,
  1u,
  42u,
  2u,
  8u,
  1u,
  238u,
  1u,
  2u,
  1u,
  4u,
  1u,
  0u,
  1u,
  0u,
  16u,
  16u,
  16u,
  0u,
  2u,
  0u,
  1u,
  226u,
  1u,
  149u,
  5u,
  0u,
  3u,
  1u,
  2u,
  5u,
  4u,
  40u,
  3u,
  4u,
  1u,
  165u,
  2u,
  0u,
  4u,
  65u,
  5u,
  0u,
  2u,
  79u,
  4u,
  70u,
  11u,
  49u,
  4u,
  123u,
  1u,
  54u,
  15u,
  41u,
  1u,
  2u,
  2u,
  10u,
  3u,
  49u,
  4u,
  2u,
  2u,
  7u,
  1u,
  61u,
  3u,
  36u,
  5u,
  1u,
  8u,
  62u,
  1u,
  12u,
  2u,
  52u,
  9u,
  1u,
  1u,
  8u,
  4u,
  2u,
  1u,
  95u,
  3u,
  2u,
  4u,
  6u,
  1u,
  2u,
  1u,
  157u,
  1u,
  3u,
  8u,
  21u,
  2u,
  57u,
  2u,
  1u,
  1u,
  1u,
  1u,
  12u,
  1u,
  9u,
  1u,
  14u,
  7u,
  3u,
  5u,
  67u,
  1u,
  2u,
  6u,
  1u,
  1u,
  2u,
  1u,
  1u,
  3u,
  4u,
  3u,
  1u,
  1u,
  14u,
  2u,
  85u,
  8u,
  2u,
  3u,
  1u,
  1u,
  23u,
  1u,
  81u,
  1u,
  2u,
  6u,
  1u,
  1u,
  2u,
  1u,
  1u,
  2u,
  1u,
  2u,
  235u,
  1u,
  2u,
  4u,
  6u,
  2u,
  1u,
  2u,
  27u,
  2u,
  85u,
  8u,
  2u,
  1u,
  1u,
  2u,
  106u,
  1u,
  1u,
  1u,
  2u,
  8u,
  101u,
  1u,
  1u,
  1u,
  2u,
  4u,
  1u,
  5u,
  0u,
  9u,
  1u,
  2u,
  245u,
  1u,
  10u,
  4u,
  4u,
  1u,
  144u,
  4u,
  2u,
  2u,
  4u,
  1u,
  32u,
  10u,
  40u,
  6u,
  2u,
  4u,
  8u,
  1u,
  9u,
  6u,
  2u,
  3u,
  46u,
  13u,
  1u,
  2u,
  0u,
  7u,
  1u,
  6u,
  1u,
  1u,
  82u,
  22u,
  2u,
  7u,
  1u,
  2u,
  1u,
  2u,
  122u,
  6u,
  3u,
  1u,
  1u,
  2u,
  1u,
  7u,
  1u,
  1u,
  72u,
  2u,
  3u,
  1u,
  1u,
  1u,
  0u,
  2u,
  11u,
  2u,
  52u,
  5u,
  5u,
  3u,
  23u,
  1u,
  0u,
  1u,
  6u,
  15u,
  0u,
  12u,
  3u,
  3u,
  0u,
  5u,
  59u,
  7u,
  0u,
  1u,
  63u,
  4u,
  81u,
  1u,
  11u,
  2u,
  0u,
  2u,
  0u,
  46u,
  2u,
  23u,
  0u,
  5u,
  3u,
  6u,
  8u,
  8u,
  2u,
  7u,
  30u,
  4u,
  148u,
  3u,
  0u,
  55u,
  4u,
  50u,
  8u,
  1u,
  14u,
  1u,
  22u,
  5u,
  1u,
  15u,
  0u,
  7u,
  1u,
  17u,
  2u,
  7u,
  1u,
  2u,
  1u,
  5u,
  100u,
  1u,
  160u,
  7u,
  0u,
  1u,
  61u,
  4u,
  0u,
  4u,
  254u,
  2u,
  0u,
  7u,
  109u,
  7u,
  0u,
  96u,
  128u,
  240u,
  0u,
  0u
}; // weak
char *off_443E10 = "library\\core\\src\\unicode\\unicode_data.rs"; // weak
_DWORD dword_443E28[2868] =
{
  192,
  224,
  193,
  225,
  194,
  226,
  195,
  227,
  196,
  228,
  197,
  229,
  198,
  230,
  199,
  231,
  200,
  232,
  201,
  233,
  202,
  234,
  203,
  235,
  204,
  236,
  205,
  237,
  206,
  238,
  207,
  239,
  208,
  240,
  209,
  241,
  210,
  242,
  211,
  243,
  212,
  244,
  213,
  245,
  214,
  246,
  216,
  248,
  217,
  249,
  218,
  250,
  219,
  251,
  220,
  252,
  221,
  253,
  222,
  254,
  256,
  257,
  258,
  259,
  260,
  261,
  262,
  263,
  264,
  265,
  266,
  267,
  268,
  269,
  270,
  271,
  272,
  273,
  274,
  275,
  276,
  277,
  278,
  279,
  280,
  281,
  282,
  283,
  284,
  285,
  286,
  287,
  288,
  289,
  290,
  291,
  292,
  293,
  294,
  295,
  296,
  297,
  298,
  299,
  300,
  301,
  302,
  303,
  304,
  4194304,
  306,
  307,
  308,
  309,
  310,
  311,
  313,
  314,
  315,
  316,
  317,
  318,
  319,
  320,
  321,
  322,
  323,
  324,
  325,
  326,
  327,
  328,
  330,
  331,
  332,
  333,
  334,
  335,
  336,
  337,
  338,
  339,
  340,
  341,
  342,
  343,
  344,
  345,
  346,
  347,
  348,
  349,
  350,
  351,
  352,
  353,
  354,
  355,
  356,
  357,
  358,
  359,
  360,
  361,
  362,
  363,
  364,
  365,
  366,
  367,
  368,
  369,
  370,
  371,
  372,
  373,
  374,
  375,
  376,
  255,
  377,
  378,
  379,
  380,
  381,
  382,
  385,
  595,
  386,
  387,
  388,
  389,
  390,
  596,
  391,
  392,
  393,
  598,
  394,
  599,
  395,
  396,
  398,
  477,
  399,
  601,
  400,
  603,
  401,
  402,
  403,
  608,
  404,
  611,
  406,
  617,
  407,
  616,
  408,
  409,
  412,
  623,
  413,
  626,
  415,
  629,
  416,
  417,
  418,
  419,
  420,
  421,
  422,
  640,
  423,
  424,
  425,
  643,
  428,
  429,
  430,
  648,
  431,
  432,
  433,
  650,
  434,
  651,
  435,
  436,
  437,
  438,
  439,
  658,
  440,
  441,
  444,
  445,
  452,
  454,
  453,
  454,
  455,
  457,
  456,
  457,
  458,
  460,
  459,
  460,
  461,
  462,
  463,
  464,
  465,
  466,
  467,
  468,
  469,
  470,
  471,
  472,
  473,
  474,
  475,
  476,
  478,
  479,
  480,
  481,
  482,
  483,
  484,
  485,
  486,
  487,
  488,
  489,
  490,
  491,
  492,
  493,
  494,
  495,
  497,
  499,
  498,
  499,
  500,
  501,
  502,
  405,
  503,
  447,
  504,
  505,
  506,
  507,
  508,
  509,
  510,
  511,
  512,
  513,
  514,
  515,
  516,
  517,
  518,
  519,
  520,
  521,
  522,
  523,
  524,
  525,
  526,
  527,
  528,
  529,
  530,
  531,
  532,
  533,
  534,
  535,
  536,
  537,
  538,
  539,
  540,
  541,
  542,
  543,
  544,
  414,
  546,
  547,
  548,
  549,
  550,
  551,
  552,
  553,
  554,
  555,
  556,
  557,
  558,
  559,
  560,
  561,
  562,
  563,
  570,
  11365,
  571,
  572,
  573,
  410,
  574,
  11366,
  577,
  578,
  579,
  384,
  580,
  649,
  581,
  652,
  582,
  583,
  584,
  585,
  586,
  587,
  588,
  589,
  590,
  591,
  880,
  881,
  882,
  883,
  886,
  887,
  895,
  1011,
  902,
  940,
  904,
  941,
  905,
  942,
  906,
  943,
  908,
  972,
  910,
  973,
  911,
  974,
  913,
  945,
  914,
  946,
  915,
  947,
  916,
  948,
  917,
  949,
  918,
  950,
  919,
  951,
  920,
  952,
  921,
  953,
  922,
  954,
  923,
  955,
  924,
  956,
  925,
  957,
  926,
  958,
  927,
  959,
  928,
  960,
  929,
  961,
  931,
  963,
  932,
  964,
  933,
  965,
  934,
  966,
  935,
  967,
  936,
  968,
  937,
  969,
  938,
  970,
  939,
  971,
  975,
  983,
  984,
  985,
  986,
  987,
  988,
  989,
  990,
  991,
  992,
  993,
  994,
  995,
  996,
  997,
  998,
  999,
  1000,
  1001,
  1002,
  1003,
  1004,
  1005,
  1006,
  1007,
  1012,
  952,
  1015,
  1016,
  1017,
  1010,
  1018,
  1019,
  1021,
  891,
  1022,
  892,
  1023,
  893,
  1024,
  1104,
  1025,
  1105,
  1026,
  1106,
  1027,
  1107,
  1028,
  1108,
  1029,
  1109,
  1030,
  1110,
  1031,
  1111,
  1032,
  1112,
  1033,
  1113,
  1034,
  1114,
  1035,
  1115,
  1036,
  1116,
  1037,
  1117,
  1038,
  1118,
  1039,
  1119,
  1040,
  1072,
  1041,
  1073,
  1042,
  1074,
  1043,
  1075,
  1044,
  1076,
  1045,
  1077,
  1046,
  1078,
  1047,
  1079,
  1048,
  1080,
  1049,
  1081,
  1050,
  1082,
  1051,
  1083,
  1052,
  1084,
  1053,
  1085,
  1054,
  1086,
  1055,
  1087,
  1056,
  1088,
  1057,
  1089,
  1058,
  1090,
  1059,
  1091,
  1060,
  1092,
  1061,
  1093,
  1062,
  1094,
  1063,
  1095,
  1064,
  1096,
  1065,
  1097,
  1066,
  1098,
  1067,
  1099,
  1068,
  1100,
  1069,
  1101,
  1070,
  1102,
  1071,
  1103,
  1120,
  1121,
  1122,
  1123,
  1124,
  1125,
  1126,
  1127,
  1128,
  1129,
  1130,
  1131,
  1132,
  1133,
  1134,
  1135,
  1136,
  1137,
  1138,
  1139,
  1140,
  1141,
  1142,
  1143,
  1144,
  1145,
  1146,
  1147,
  1148,
  1149,
  1150,
  1151,
  1152,
  1153,
  1162,
  1163,
  1164,
  1165,
  1166,
  1167,
  1168,
  1169,
  1170,
  1171,
  1172,
  1173,
  1174,
  1175,
  1176,
  1177,
  1178,
  1179,
  1180,
  1181,
  1182,
  1183,
  1184,
  1185,
  1186,
  1187,
  1188,
  1189,
  1190,
  1191,
  1192,
  1193,
  1194,
  1195,
  1196,
  1197,
  1198,
  1199,
  1200,
  1201,
  1202,
  1203,
  1204,
  1205,
  1206,
  1207,
  1208,
  1209,
  1210,
  1211,
  1212,
  1213,
  1214,
  1215,
  1216,
  1231,
  1217,
  1218,
  1219,
  1220,
  1221,
  1222,
  1223,
  1224,
  1225,
  1226,
  1227,
  1228,
  1229,
  1230,
  1232,
  1233,
  1234,
  1235,
  1236,
  1237,
  1238,
  1239,
  1240,
  1241,
  1242,
  1243,
  1244,
  1245,
  1246,
  1247,
  1248,
  1249,
  1250,
  1251,
  1252,
  1253,
  1254,
  1255,
  1256,
  1257,
  1258,
  1259,
  1260,
  1261,
  1262,
  1263,
  1264,
  1265,
  1266,
  1267,
  1268,
  1269,
  1270,
  1271,
  1272,
  1273,
  1274,
  1275,
  1276,
  1277,
  1278,
  1279,
  1280,
  1281,
  1282,
  1283,
  1284,
  1285,
  1286,
  1287,
  1288,
  1289,
  1290,
  1291,
  1292,
  1293,
  1294,
  1295,
  1296,
  1297,
  1298,
  1299,
  1300,
  1301,
  1302,
  1303,
  1304,
  1305,
  1306,
  1307,
  1308,
  1309,
  1310,
  1311,
  1312,
  1313,
  1314,
  1315,
  1316,
  1317,
  1318,
  1319,
  1320,
  1321,
  1322,
  1323,
  1324,
  1325,
  1326,
  1327,
  1329,
  1377,
  1330,
  1378,
  1331,
  1379,
  1332,
  1380,
  1333,
  1381,
  1334,
  1382,
  1335,
  1383,
  1336,
  1384,
  1337,
  1385,
  1338,
  1386,
  1339,
  1387,
  1340,
  1388,
  1341,
  1389,
  1342,
  1390,
  1343,
  1391,
  1344,
  1392,
  1345,
  1393,
  1346,
  1394,
  1347,
  1395,
  1348,
  1396,
  1349,
  1397,
  1350,
  1398,
  1351,
  1399,
  1352,
  1400,
  1353,
  1401,
  1354,
  1402,
  1355,
  1403,
  1356,
  1404,
  1357,
  1405,
  1358,
  1406,
  1359,
  1407,
  1360,
  1408,
  1361,
  1409,
  1362,
  1410,
  1363,
  1411,
  1364,
  1412,
  1365,
  1413,
  1366,
  1414,
  4256,
  11520,
  4257,
  11521,
  4258,
  11522,
  4259,
  11523,
  4260,
  11524,
  4261,
  11525,
  4262,
  11526,
  4263,
  11527,
  4264,
  11528,
  4265,
  11529,
  4266,
  11530,
  4267,
  11531,
  4268,
  11532,
  4269,
  11533,
  4270,
  11534,
  4271,
  11535,
  4272,
  11536,
  4273,
  11537,
  4274,
  11538,
  4275,
  11539,
  4276,
  11540,
  4277,
  11541,
  4278,
  11542,
  4279,
  11543,
  4280,
  11544,
  4281,
  11545,
  4282,
  11546,
  4283,
  11547,
  4284,
  11548,
  4285,
  11549,
  4286,
  11550,
  4287,
  11551,
  4288,
  11552,
  4289,
  11553,
  4290,
  11554,
  4291,
  11555,
  4292,
  11556,
  4293,
  11557,
  4295,
  11559,
  4301,
  11565,
  5024,
  43888,
  5025,
  43889,
  5026,
  43890,
  5027,
  43891,
  5028,
  43892,
  5029,
  43893,
  5030,
  43894,
  5031,
  43895,
  5032,
  43896,
  5033,
  43897,
  5034,
  43898,
  5035,
  43899,
  5036,
  43900,
  5037,
  43901,
  5038,
  43902,
  5039,
  43903,
  5040,
  43904,
  5041,
  43905,
  5042,
  43906,
  5043,
  43907,
  5044,
  43908,
  5045,
  43909,
  5046,
  43910,
  5047,
  43911,
  5048,
  43912,
  5049,
  43913,
  5050,
  43914,
  5051,
  43915,
  5052,
  43916,
  5053,
  43917,
  5054,
  43918,
  5055,
  43919,
  5056,
  43920,
  5057,
  43921,
  5058,
  43922,
  5059,
  43923,
  5060,
  43924,
  5061,
  43925,
  5062,
  43926,
  5063,
  43927,
  5064,
  43928,
  5065,
  43929,
  5066,
  43930,
  5067,
  43931,
  5068,
  43932,
  5069,
  43933,
  5070,
  43934,
  5071,
  43935,
  5072,
  43936,
  5073,
  43937,
  5074,
  43938,
  5075,
  43939,
  5076,
  43940,
  5077,
  43941,
  5078,
  43942,
  5079,
  43943,
  5080,
  43944,
  5081,
  43945,
  5082,
  43946,
  5083,
  43947,
  5084,
  43948,
  5085,
  43949,
  5086,
  43950,
  5087,
  43951,
  5088,
  43952,
  5089,
  43953,
  5090,
  43954,
  5091,
  43955,
  5092,
  43956,
  5093,
  43957,
  5094,
  43958,
  5095,
  43959,
  5096,
  43960,
  5097,
  43961,
  5098,
  43962,
  5099,
  43963,
  5100,
  43964,
  5101,
  43965,
  5102,
  43966,
  5103,
  43967,
  5104,
  5112,
  5105,
  5113,
  5106,
  5114,
  5107,
  5115,
  5108,
  5116,
  5109,
  5117,
  7305,
  7306,
  7312,
  4304,
  7313,
  4305,
  7314,
  4306,
  7315,
  4307,
  7316,
  4308,
  7317,
  4309,
  7318,
  4310,
  7319,
  4311,
  7320,
  4312,
  7321,
  4313,
  7322,
  4314,
  7323,
  4315,
  7324,
  4316,
  7325,
  4317,
  7326,
  4318,
  7327,
  4319,
  7328,
  4320,
  7329,
  4321,
  7330,
  4322,
  7331,
  4323,
  7332,
  4324,
  7333,
  4325,
  7334,
  4326,
  7335,
  4327,
  7336,
  4328,
  7337,
  4329,
  7338,
  4330,
  7339,
  4331,
  7340,
  4332,
  7341,
  4333,
  7342,
  4334,
  7343,
  4335,
  7344,
  4336,
  7345,
  4337,
  7346,
  4338,
  7347,
  4339,
  7348,
  4340,
  7349,
  4341,
  7350,
  4342,
  7351,
  4343,
  7352,
  4344,
  7353,
  4345,
  7354,
  4346,
  7357,
  4349,
  7358,
  4350,
  7359,
  4351,
  7680,
  7681,
  7682,
  7683,
  7684,
  7685,
  7686,
  7687,
  7688,
  7689,
  7690,
  7691,
  7692,
  7693,
  7694,
  7695,
  7696,
  7697,
  7698,
  7699,
  7700,
  7701,
  7702,
  7703,
  7704,
  7705,
  7706,
  7707,
  7708,
  7709,
  7710,
  7711,
  7712,
  7713,
  7714,
  7715,
  7716,
  7717,
  7718,
  7719,
  7720,
  7721,
  7722,
  7723,
  7724,
  7725,
  7726,
  7727,
  7728,
  7729,
  7730,
  7731,
  7732,
  7733,
  7734,
  7735,
  7736,
  7737,
  7738,
  7739,
  7740,
  7741,
  7742,
  7743,
  7744,
  7745,
  7746,
  7747,
  7748,
  7749,
  7750,
  7751,
  7752,
  7753,
  7754,
  7755,
  7756,
  7757,
  7758,
  7759,
  7760,
  7761,
  7762,
  7763,
  7764,
  7765,
  7766,
  7767,
  7768,
  7769,
  7770,
  7771,
  7772,
  7773,
  7774,
  7775,
  7776,
  7777,
  7778,
  7779,
  7780,
  7781,
  7782,
  7783,
  7784,
  7785,
  7786,
  7787,
  7788,
  7789,
  7790,
  7791,
  7792,
  7793,
  7794,
  7795,
  7796,
  7797,
  7798,
  7799,
  7800,
  7801,
  7802,
  7803,
  7804,
  7805,
  7806,
  7807,
  7808,
  7809,
  7810,
  7811,
  7812,
  7813,
  7814,
  7815,
  7816,
  7817,
  7818,
  7819,
  7820,
  7821,
  7822,
  7823,
  7824,
  7825,
  7826,
  7827,
  7828,
  7829,
  7838,
  223,
  7840,
  7841,
  7842,
  7843,
  7844,
  7845,
  7846,
  7847,
  7848,
  7849,
  7850,
  7851,
  7852,
  7853,
  7854,
  7855,
  7856,
  7857,
  7858,
  7859,
  7860,
  7861,
  7862,
  7863,
  7864,
  7865,
  7866,
  7867,
  7868,
  7869,
  7870,
  7871,
  7872,
  7873,
  7874,
  7875,
  7876,
  7877,
  7878,
  7879,
  7880,
  7881,
  7882,
  7883,
  7884,
  7885,
  7886,
  7887,
  7888,
  7889,
  7890,
  7891,
  7892,
  7893,
  7894,
  7895,
  7896,
  7897,
  7898,
  7899,
  7900,
  7901,
  7902,
  7903,
  7904,
  7905,
  7906,
  7907,
  7908,
  7909,
  7910,
  7911,
  7912,
  7913,
  7914,
  7915,
  7916,
  7917,
  7918,
  7919,
  7920,
  7921,
  7922,
  7923,
  7924,
  7925,
  7926,
  7927,
  7928,
  7929,
  7930,
  7931,
  7932,
  7933,
  7934,
  7935,
  7944,
  7936,
  7945,
  7937,
  7946,
  7938,
  7947,
  7939,
  7948,
  7940,
  7949,
  7941,
  7950,
  7942,
  7951,
  7943,
  7960,
  7952,
  7961,
  7953,
  7962,
  7954,
  7963,
  7955,
  7964,
  7956,
  7965,
  7957,
  7976,
  7968,
  7977,
  7969,
  7978,
  7970,
  7979,
  7971,
  7980,
  7972,
  7981,
  7973,
  7982,
  7974,
  7983,
  7975,
  7992,
  7984,
  7993,
  7985,
  7994,
  7986,
  7995,
  7987,
  7996,
  7988,
  7997,
  7989,
  7998,
  7990,
  7999,
  7991,
  8008,
  8000,
  8009,
  8001,
  8010,
  8002,
  8011,
  8003,
  8012,
  8004,
  8013,
  8005,
  8025,
  8017,
  8027,
  8019,
  8029,
  8021,
  8031,
  8023,
  8040,
  8032,
  8041,
  8033,
  8042,
  8034,
  8043,
  8035,
  8044,
  8036,
  8045,
  8037,
  8046,
  8038,
  8047,
  8039,
  8072,
  8064,
  8073,
  8065,
  8074,
  8066,
  8075,
  8067,
  8076,
  8068,
  8077,
  8069,
  8078,
  8070,
  8079,
  8071,
  8088,
  8080,
  8089,
  8081,
  8090,
  8082,
  8091,
  8083,
  8092,
  8084,
  8093,
  8085,
  8094,
  8086,
  8095,
  8087,
  8104,
  8096,
  8105,
  8097,
  8106,
  8098,
  8107,
  8099,
  8108,
  8100,
  8109,
  8101,
  8110,
  8102,
  8111,
  8103,
  8120,
  8112,
  8121,
  8113,
  8122,
  8048,
  8123,
  8049,
  8124,
  8115,
  8136,
  8050,
  8137,
  8051,
  8138,
  8052,
  8139,
  8053,
  8140,
  8131,
  8152,
  8144,
  8153,
  8145,
  8154,
  8054,
  8155,
  8055,
  8168,
  8160,
  8169,
  8161,
  8170,
  8058,
  8171,
  8059,
  8172,
  8165,
  8184,
  8056,
  8185,
  8057,
  8186,
  8060,
  8187,
  8061,
  8188,
  8179,
  8486,
  969,
  8490,
  107,
  8491,
  229,
  8498,
  8526,
  8544,
  8560,
  8545,
  8561,
  8546,
  8562,
  8547,
  8563,
  8548,
  8564,
  8549,
  8565,
  8550,
  8566,
  8551,
  8567,
  8552,
  8568,
  8553,
  8569,
  8554,
  8570,
  8555,
  8571,
  8556,
  8572,
  8557,
  8573,
  8558,
  8574,
  8559,
  8575,
  8579,
  8580,
  9398,
  9424,
  9399,
  9425,
  9400,
  9426,
  9401,
  9427,
  9402,
  9428,
  9403,
  9429,
  9404,
  9430,
  9405,
  9431,
  9406,
  9432,
  9407,
  9433,
  9408,
  9434,
  9409,
  9435,
  9410,
  9436,
  9411,
  9437,
  9412,
  9438,
  9413,
  9439,
  9414,
  9440,
  9415,
  9441,
  9416,
  9442,
  9417,
  9443,
  9418,
  9444,
  9419,
  9445,
  9420,
  9446,
  9421,
  9447,
  9422,
  9448,
  9423,
  9449,
  11264,
  11312,
  11265,
  11313,
  11266,
  11314,
  11267,
  11315,
  11268,
  11316,
  11269,
  11317,
  11270,
  11318,
  11271,
  11319,
  11272,
  11320,
  11273,
  11321,
  11274,
  11322,
  11275,
  11323,
  11276,
  11324,
  11277,
  11325,
  11278,
  11326,
  11279,
  11327,
  11280,
  11328,
  11281,
  11329,
  11282,
  11330,
  11283,
  11331,
  11284,
  11332,
  11285,
  11333,
  11286,
  11334,
  11287,
  11335,
  11288,
  11336,
  11289,
  11337,
  11290,
  11338,
  11291,
  11339,
  11292,
  11340,
  11293,
  11341,
  11294,
  11342,
  11295,
  11343,
  11296,
  11344,
  11297,
  11345,
  11298,
  11346,
  11299,
  11347,
  11300,
  11348,
  11301,
  11349,
  11302,
  11350,
  11303,
  11351,
  11304,
  11352,
  11305,
  11353,
  11306,
  11354,
  11307,
  11355,
  11308,
  11356,
  11309,
  11357,
  11310,
  11358,
  11311,
  11359,
  11360,
  11361,
  11362,
  619,
  11363,
  7549,
  11364,
  637,
  11367,
  11368,
  11369,
  11370,
  11371,
  11372,
  11373,
  593,
  11374,
  625,
  11375,
  592,
  11376,
  594,
  11378,
  11379,
  11381,
  11382,
  11390,
  575,
  11391,
  576,
  11392,
  11393,
  11394,
  11395,
  11396,
  11397,
  11398,
  11399,
  11400,
  11401,
  11402,
  11403,
  11404,
  11405,
  11406,
  11407,
  11408,
  11409,
  11410,
  11411,
  11412,
  11413,
  11414,
  11415,
  11416,
  11417,
  11418,
  11419,
  11420,
  11421,
  11422,
  11423,
  11424,
  11425,
  11426,
  11427,
  11428,
  11429,
  11430,
  11431,
  11432,
  11433,
  11434,
  11435,
  11436,
  11437,
  11438,
  11439,
  11440,
  11441,
  11442,
  11443,
  11444,
  11445,
  11446,
  11447,
  11448,
  11449,
  11450,
  11451,
  11452,
  11453,
  11454,
  11455,
  11456,
  11457,
  11458,
  11459,
  11460,
  11461,
  11462,
  11463,
  11464,
  11465,
  11466,
  11467,
  11468,
  11469,
  11470,
  11471,
  11472,
  11473,
  11474,
  11475,
  11476,
  11477,
  11478,
  11479,
  11480,
  11481,
  11482,
  11483,
  11484,
  11485,
  11486,
  11487,
  11488,
  11489,
  11490,
  11491,
  11499,
  11500,
  11501,
  11502,
  11506,
  11507,
  42560,
  42561,
  42562,
  42563,
  42564,
  42565,
  42566,
  42567,
  42568,
  42569,
  42570,
  42571,
  42572,
  42573,
  42574,
  42575,
  42576,
  42577,
  42578,
  42579,
  42580,
  42581,
  42582,
  42583,
  42584,
  42585,
  42586,
  42587,
  42588,
  42589,
  42590,
  42591,
  42592,
  42593,
  42594,
  42595,
  42596,
  42597,
  42598,
  42599,
  42600,
  42601,
  42602,
  42603,
  42604,
  42605,
  42624,
  42625,
  42626,
  42627,
  42628,
  42629,
  42630,
  42631,
  42632,
  42633,
  42634,
  42635,
  42636,
  42637,
  42638,
  42639,
  42640,
  42641,
  42642,
  42643,
  42644,
  42645,
  42646,
  42647,
  42648,
  42649,
  42650,
  42651,
  42786,
  42787,
  42788,
  42789,
  42790,
  42791,
  42792,
  42793,
  42794,
  42795,
  42796,
  42797,
  42798,
  42799,
  42802,
  42803,
  42804,
  42805,
  42806,
  42807,
  42808,
  42809,
  42810,
  42811,
  42812,
  42813,
  42814,
  42815,
  42816,
  42817,
  42818,
  42819,
  42820,
  42821,
  42822,
  42823,
  42824,
  42825,
  42826,
  42827,
  42828,
  42829,
  42830,
  42831,
  42832,
  42833,
  42834,
  42835,
  42836,
  42837,
  42838,
  42839,
  42840,
  42841,
  42842,
  42843,
  42844,
  42845,
  42846,
  42847,
  42848,
  42849,
  42850,
  42851,
  42852,
  42853,
  42854,
  42855,
  42856,
  42857,
  42858,
  42859,
  42860,
  42861,
  42862,
  42863,
  42873,
  42874,
  42875,
  42876,
  42877,
  7545,
  42878,
  42879,
  42880,
  42881,
  42882,
  42883,
  42884,
  42885,
  42886,
  42887,
  42891,
  42892,
  42893,
  613,
  42896,
  42897,
  42898,
  42899,
  42902,
  42903,
  42904,
  42905,
  42906,
  42907,
  42908,
  42909,
  42910,
  42911,
  42912,
  42913,
  42914,
  42915,
  42916,
  42917,
  42918,
  42919,
  42920,
  42921,
  42922,
  614,
  42923,
  604,
  42924,
  609,
  42925,
  620,
  42926,
  618,
  42928,
  670,
  42929,
  647,
  42930,
  669,
  42931,
  43859,
  42932,
  42933,
  42934,
  42935,
  42936,
  42937,
  42938,
  42939,
  42940,
  42941,
  42942,
  42943,
  42944,
  42945,
  42946,
  42947,
  42948,
  42900,
  42949,
  642,
  42950,
  7566,
  42951,
  42952,
  42953,
  42954,
  42955,
  612,
  42956,
  42957,
  42960,
  42961,
  42966,
  42967,
  42968,
  42969,
  42970,
  42971,
  42972,
  411,
  42997,
  42998,
  65313,
  65345,
  65314,
  65346,
  65315,
  65347,
  65316,
  65348,
  65317,
  65349,
  65318,
  65350,
  65319,
  65351,
  65320,
  65352,
  65321,
  65353,
  65322,
  65354,
  65323,
  65355,
  65324,
  65356,
  65325,
  65357,
  65326,
  65358,
  65327,
  65359,
  65328,
  65360,
  65329,
  65361,
  65330,
  65362,
  65331,
  65363,
  65332,
  65364,
  65333,
  65365,
  65334,
  65366,
  65335,
  65367,
  65336,
  65368,
  65337,
  65369,
  65338,
  65370,
  66560,
  66600,
  66561,
  66601,
  66562,
  66602,
  66563,
  66603,
  66564,
  66604,
  66565,
  66605,
  66566,
  66606,
  66567,
  66607,
  66568,
  66608,
  66569,
  66609,
  66570,
  66610,
  66571,
  66611,
  66572,
  66612,
  66573,
  66613,
  66574,
  66614,
  66575,
  66615,
  66576,
  66616,
  66577,
  66617,
  66578,
  66618,
  66579,
  66619,
  66580,
  66620,
  66581,
  66621,
  66582,
  66622,
  66583,
  66623,
  66584,
  66624,
  66585,
  66625,
  66586,
  66626,
  66587,
  66627,
  66588,
  66628,
  66589,
  66629,
  66590,
  66630,
  66591,
  66631,
  66592,
  66632,
  66593,
  66633,
  66594,
  66634,
  66595,
  66635,
  66596,
  66636,
  66597,
  66637,
  66598,
  66638,
  66599,
  66639,
  66736,
  66776,
  66737,
  66777,
  66738,
  66778,
  66739,
  66779,
  66740,
  66780,
  66741,
  66781,
  66742,
  66782,
  66743,
  66783,
  66744,
  66784,
  66745,
  66785,
  66746,
  66786,
  66747,
  66787,
  66748,
  66788,
  66749,
  66789,
  66750,
  66790,
  66751,
  66791,
  66752,
  66792,
  66753,
  66793,
  66754,
  66794,
  66755,
  66795,
  66756,
  66796,
  66757,
  66797,
  66758,
  66798,
  66759,
  66799,
  66760,
  66800,
  66761,
  66801,
  66762,
  66802,
  66763,
  66803,
  66764,
  66804,
  66765,
  66805,
  66766,
  66806,
  66767,
  66807,
  66768,
  66808,
  66769,
  66809,
  66770,
  66810,
  66771,
  66811,
  66928,
  66967,
  66929,
  66968,
  66930,
  66969,
  66931,
  66970,
  66932,
  66971,
  66933,
  66972,
  66934,
  66973,
  66935,
  66974,
  66936,
  66975,
  66937,
  66976,
  66938,
  66977,
  66940,
  66979,
  66941,
  66980,
  66942,
  66981,
  66943,
  66982,
  66944,
  66983,
  66945,
  66984,
  66946,
  66985,
  66947,
  66986,
  66948,
  66987,
  66949,
  66988,
  66950,
  66989,
  66951,
  66990,
  66952,
  66991,
  66953,
  66992,
  66954,
  66993,
  66956,
  66995,
  66957,
  66996,
  66958,
  66997,
  66959,
  66998,
  66960,
  66999,
  66961,
  67000,
  66962,
  67001,
  66964,
  67003,
  66965,
  67004,
  68736,
  68800,
  68737,
  68801,
  68738,
  68802,
  68739,
  68803,
  68740,
  68804,
  68741,
  68805,
  68742,
  68806,
  68743,
  68807,
  68744,
  68808,
  68745,
  68809,
  68746,
  68810,
  68747,
  68811,
  68748,
  68812,
  68749,
  68813,
  68750,
  68814,
  68751,
  68815,
  68752,
  68816,
  68753,
  68817,
  68754,
  68818,
  68755,
  68819,
  68756,
  68820,
  68757,
  68821,
  68758,
  68822,
  68759,
  68823,
  68760,
  68824,
  68761,
  68825,
  68762,
  68826,
  68763,
  68827,
  68764,
  68828,
  68765,
  68829,
  68766,
  68830,
  68767,
  68831,
  68768,
  68832,
  68769,
  68833,
  68770,
  68834,
  68771,
  68835,
  68772,
  68836,
  68773,
  68837,
  68774,
  68838,
  68775,
  68839,
  68776,
  68840,
  68777,
  68841,
  68778,
  68842,
  68779,
  68843,
  68780,
  68844,
  68781,
  68845,
  68782,
  68846,
  68783,
  68847,
  68784,
  68848,
  68785,
  68849,
  68786,
  68850,
  68944,
  68976,
  68945,
  68977,
  68946,
  68978,
  68947,
  68979,
  68948,
  68980,
  68949,
  68981,
  68950,
  68982,
  68951,
  68983,
  68952,
  68984,
  68953,
  68985,
  68954,
  68986,
  68955,
  68987,
  68956,
  68988,
  68957,
  68989,
  68958,
  68990,
  68959,
  68991,
  68960,
  68992,
  68961,
  68993,
  68962,
  68994,
  68963,
  68995,
  68964,
  68996,
  68965,
  68997,
  71840,
  71872,
  71841,
  71873,
  71842,
  71874,
  71843,
  71875,
  71844,
  71876,
  71845,
  71877,
  71846,
  71878,
  71847,
  71879,
  71848,
  71880,
  71849,
  71881,
  71850,
  71882,
  71851,
  71883,
  71852,
  71884,
  71853,
  71885,
  71854,
  71886,
  71855,
  71887,
  71856,
  71888,
  71857,
  71889,
  71858,
  71890,
  71859,
  71891,
  71860,
  71892,
  71861,
  71893,
  71862,
  71894,
  71863,
  71895,
  71864,
  71896,
  71865,
  71897,
  71866,
  71898,
  71867,
  71899,
  71868,
  71900,
  71869,
  71901,
  71870,
  71902,
  71871,
  71903,
  93760,
  93792,
  93761,
  93793,
  93762,
  93794,
  93763,
  93795,
  93764,
  93796,
  93765,
  93797,
  93766,
  93798,
  93767,
  93799,
  93768,
  93800,
  93769,
  93801,
  93770,
  93802,
  93771,
  93803,
  93772,
  93804,
  93773,
  93805,
  93774,
  93806,
  93775,
  93807,
  93776,
  93808,
  93777,
  93809,
  93778,
  93810,
  93779,
  93811,
  93780,
  93812,
  93781,
  93813,
  93782,
  93814,
  93783,
  93815,
  93784,
  93816,
  93785,
  93817,
  93786,
  93818,
  93787,
  93819,
  93788,
  93820,
  93789,
  93821,
  93790,
  93822,
  93791,
  93823,
  125184,
  125218,
  125185,
  125219,
  125186,
  125220,
  125187,
  125221,
  125188,
  125222,
  125189,
  125223,
  125190,
  125224,
  125191,
  125225,
  125192,
  125226,
  125193,
  125227,
  125194,
  125228,
  125195,
  125229,
  125196,
  125230,
  125197,
  125231,
  125198,
  125232,
  125199,
  125233,
  125200,
  125234,
  125201,
  125235,
  125202,
  125236,
  125203,
  125237,
  125204,
  125238,
  125205,
  125239,
  125206,
  125240,
  125207,
  125241,
  125208,
  125242,
  125209,
  125243,
  125210,
  125244,
  125211,
  125245,
  125212,
  125246,
  125213,
  125247,
  125214,
  125248,
  125215,
  125249,
  125216,
  125250,
  125217,
  125251
}; // weak
char *off_446B58 = "/rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688\\library\\alloc\\src\\collections\\btree\\map\\entry.rs"; // weak
char aAssertionFaile_0[48] = "assertion failed: edge.height == self.height - 1"; // weak
char *off_446C00 = "/rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688\\library\\alloc\\src\\collections\\btree\\node.rs"; // weak
char *off_446C40 = "/rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688\\library\\alloc\\src\\collections\\btree\\node.rs"; // weak
char *off_446C58 = "/rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688\\library\\alloc\\src\\collections\\btree\\node.rs"; // weak
char *off_446C70 = "/rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688\\library\\alloc\\src\\collections\\btree\\node.rs"; // weak
char aAssertionFaile[53] = "assertion failed: edge.height == self.node.height - 1"; // weak
char *off_446CC0 = "/rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688\\library\\alloc\\src\\collections\\btree\\node.rs"; // weak
char *off_446D08 = "/rust/deps\\gimli-0.29.0\\src\\read\\abbrev.rs"; // weak
char *off_446D20 = "/rust/deps\\gimli-0.29.0\\src\\read\\abbrev.rs"; // weak
char *off_446D38 = "/rust/deps\\gimli-0.29.0\\src\\read\\abbrev.rs"; // weak
char *off_446D50 = "/rust/deps\\gimli-0.29.0\\src\\read\\abbrev.rs"; // weak
char *off_446D68 = "/rust/deps\\gimli-0.29.0\\src\\read\\abbrev.rs"; // weak
char *off_446E08 = "/rust/deps\\object-0.36.7\\src\\read\\coff\\section.rs"; // weak
char *off_446E40 = "library\\panic_abort\\src\\lib.rs"; // weak
char asc_446E58[2] = "()"; // weak
char *off_446EB0 = "/rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688\\library\\core\\src\\ops\\function.rs"; // weak
_UNKNOWN unk_446EC8; // weak
_UNKNOWN unk_446EE8; // weak
_UNKNOWN unk_446F08; // weak
_UNKNOWN unk_446F28; // weak
char aParseinterror[13] = "ParseIntError"; // weak
_UNKNOWN unk_446F80; // weak
char *off_446FB0 = "/rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688\\library\\core\\src\\str\\pattern.rs"; // weak
char *off_447000 = "/rust/deps\\rustc-demangle-0.1.24\\src\\legacy.rs"; // weak
char *off_447018 = "/rust/deps\\rustc-demangle-0.1.24\\src\\legacy.rs"; // weak
char *off_447030 = "/rust/deps\\rustc-demangle-0.1.24\\src\\legacy.rs"; // weak
char *off_447048 = "/rust/deps\\rustc-demangle-0.1.24\\src\\legacy.rs"; // weak
char *off_447060 = "/rust/deps\\rustc-demangle-0.1.24\\src\\legacy.rs"; // weak
char *off_447078 = "/rust/deps\\rustc-demangle-0.1.24\\src\\legacy.rs"; // weak
char *off_447090 = "/rust/deps\\rustc-demangle-0.1.24\\src\\legacy.rs"; // weak
char *off_4470A8 = "/rust/deps\\rustc-demangle-0.1.24\\src\\legacy.rs"; // weak
char *off_4470C0 = "/rust/deps\\rustc-demangle-0.1.24\\src\\legacy.rs"; // weak
char *off_4470E0 = "/rust/deps\\rustc-demangle-0.1.24\\src\\legacy.rs"; // weak
char *off_4470F8 = "/rust/deps\\rustc-demangle-0.1.24\\src\\legacy.rs"; // weak
char *off_447110 = "/rust/deps\\rustc-demangle-0.1.24\\src\\legacy.rs"; // weak
char *off_447128 = "/rust/deps\\rustc-demangle-0.1.24\\src\\legacy.rs"; // weak
char *off_447140 = "/rust/deps\\rustc-demangle-0.1.24\\src\\legacy.rs"; // weak
char *off_447158 = "/rust/deps\\rustc-demangle-0.1.24\\src\\legacy.rs"; // weak
_UNKNOWN unk_44717E; // weak
char *off_447180 = "/rust/deps\\rustc-demangle-0.1.24\\src\\legacy.rs"; // weak
char *off_4471A0 = "/rust/deps\\rustc-demangle-0.1.24\\src\\legacy.rs"; // weak
char *off_4471B8 = "/rust/deps\\rustc-demangle-0.1.24\\src\\legacy.rs"; // weak
char *off_4471D0 = "/rust/deps\\rustc-demangle-0.1.24\\src\\legacy.rs"; // weak
char *off_447218 = "/rust/deps\\rustc-demangle-0.1.24\\src\\v0.rs"; // weak
char *off_447230 = "/rust/deps\\rustc-demangle-0.1.24\\src\\v0.rs"; // weak
char *off_447248 = "/rust/deps\\rustc-demangle-0.1.24\\src\\v0.rs"; // weak
char aFmtErrorSShoul[61] = "`fmt::Error`s should be impossible without a `fmt::Formatter`"; // weak
char *off_4472A0 = "/rust/deps\\rustc-demangle-0.1.24\\src\\v0.rs"; // weak
char *off_4472B8 = "/rust/deps\\rustc-demangle-0.1.24\\src\\v0.rs"; // weak
char *off_4472D0 = "/rust/deps\\rustc-demangle-0.1.24\\src\\v0.rs"; // weak
char *off_4472F8 = "/rust/deps\\rustc-demangle-0.1.24\\src\\v0.rs"; // weak
char *off_447310 = "/rust/deps\\rustc-demangle-0.1.24\\src\\v0.rs"; // weak
char *off_447328 = "/rust/deps\\rustc-demangle-0.1.24\\src\\v0.rs"; // weak
char *off_4473B0 = "internal error: entered unreachable code: str::from_utf8("; // weak
char *off_4473F0 = "/rust/deps\\rustc-demangle-0.1.24\\src\\v0.rs"; // weak
char asc_447442 = '_'; // weak
char *off_447448 = "/rust/deps\\rustc-demangle-0.1.24\\src\\v0.rs"; // weak
char *off_447460 = "/rust/deps\\rustc-demangle-0.1.24\\src\\v0.rs"; // weak
char *off_447478 = "/rust/deps\\rustc-demangle-0.1.24\\src\\v0.rs"; // weak
char *off_447490 = "/rust/deps\\rustc-demangle-0.1.24\\src\\v0.rs"; // weak
char *off_4474A8 = "/rust/deps\\rustc-demangle-0.1.24\\src\\v0.rs"; // weak
char aInvalidSyntax[16] = "{invalid syntax}"; // weak
char aRecursionLimit[25] = "{recursion limit reached}"; // weak
char asc_4474E9 = '?'; // weak
char asc_4474EA = '\''; // weak
char aFor[4] = "for<"; // weak
char asc_4474EF[2] = "> "; // weak
char asc_4474F1[2] = ", "; // weak
char asc_4474F3 = '['; // weak
char asc_4474F4 = ']'; // weak
char asc_4474F5[3] = "::{"; // weak
char aClosure[7] = "closure"; // weak
char aShim[4] = "shim"; // weak
char asc_447503 = '#'; // weak
char aAs[4] = " as "; // weak
char asc_447508 = ' '; // weak
char aMut[4] = "mut "; // weak
char aConst[6] = "const "; // weak
char asc_447513[2] = "; "; // weak
char aDyn[4] = "dyn "; // weak
char asc_447519[3] = " + "; // weak
char aUnsafe[7] = "unsafe "; // weak
char aExtern[8] = "extern \""; // weak
char *off_447530 = "/rust/deps\\rustc-demangle-0.1.24\\src\\v0.rs"; // weak
char asc_447548[2] = "\" "; // weak
char aFn[3] = "fn("; // weak
char asc_44754D[4] = " -> "; // weak
char asc_447551[3] = " = "; // weak
char aFalse[5] = "false"; // weak
char aTrue[4] = "true"; // weak
char asc_44755D = '{'; // weak
char asc_44755E[3] = " { "; // weak
char asc_447561[2] = " }"; // weak
char a0x[2] = "0x"; // weak
char *off_447568 = "/rust/deps\\rustc-demangle-0.1.24\\src\\v0.rs"; // weak
char aLlvm[6] = ".llvm."; // weak
char *off_4475B8 = "/rust/deps\\rustc-demangle-0.1.24\\src\\lib.rs"; // weak
char *off_4475D0 = "/rust/deps\\rustc-demangle-0.1.24\\src\\lib.rs"; // weak
char aSizeLimitReach[20] = "{size limit reached}"; // weak
char aFmtErrorFromSi[55] = "`fmt::Error` from `SizeLimitedFmtAdapter` was discarded"; // weak
char *off_447638 = "/rust/deps\\rustc-demangle-0.1.24\\src\\lib.rs"; // weak
char aSizelimitexhau[18] = "SizeLimitExhausted"; // weak
_QWORD qword_447668[5] = { 5LL, 12LL, 11LL, 11LL, 4LL }; // weak
_UNKNOWN unk_447690; // weak
_QWORD qword_4476A8[26] =
{
  2LL,
  4LL,
  4LL,
  3LL,
  3LL,
  3LL,
  4LL,
  2LL,
  5LL,
  5LL,
  4LL,
  3LL,
  3LL,
  4LL,
  4LL,
  1LL,
  4LL,
  4LL,
  3LL,
  3LL,
  2LL,
  3LL,
  4LL,
  3LL,
  3LL,
  1LL
}; // weak
_UNKNOWN *off_447778 = (_UNKNOWN *)0x447413LL; // weak
char *off_4478D0 = "/rust/deps\\gimli-0.29.0\\src\\read\\line.rs"; // weak
char *off_447908 = "library\\std\\src\\panicking.rs"; // weak
char *off_447970 = "/rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688\\library\\core\\src\\str\\pattern.rs"; // weak
char *off_447988 = "/rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688\\library\\core\\src\\str\\pattern.rs"; // weak
char *off_4479A0 = "/rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688\\library\\core\\src\\str\\pattern.rs"; // weak
char *off_4479B8 = "/rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688\\library\\core\\src\\str\\pattern.rs"; // weak
char *off_4479E0 = "mid > len"; // weak
char *off_447A50 = "/rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688\\library\\core\\src\\slice\\sort\\stable\\quicksort.rs"; // weak
char *off_447A68 = "/rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688\\library\\core\\src\\slice\\sort\\stable\\quicksort.rs"; // weak
char a0123456789abcd[17] = "0123456789abcdef"; // weak
char aCalledResultUn[43] = "called `Result::unwrap()` on an `Err` value"; // weak
_UNKNOWN unk_447AE0; // weak
_BYTE byte_447B00[256] =
{
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  3,
  3,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  2,
  2,
  0,
  0,
  0,
  0,
  0,
  2,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  2,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
_UNKNOWN unk_447C00; // weak
_UNKNOWN unk_447C20; // weak
char *off_447C90 = "/rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688\\library\\alloc\\src\\slice.rs"; // weak
char *off_447CD0 = "/rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688\\library\\alloc\\src\\collections\\btree\\navigate.rs"; // weak
char *off_447CE8 = "/rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688\\library\\alloc\\src\\collections\\btree\\navigate.rs"; // weak
char *off_447D50 = "/rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688\\library\\alloc\\src\\vec\\mod.rs"; // weak
char *off_447D68 = "/rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688\\library\\alloc\\src\\slice.rs"; // weak
char *off_447DD0 = "/rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688\\library\\alloc\\src\\string.rs"; // weak
char *off_447E18 = "/rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688\\library\\alloc\\src\\string.rs"; // weak
char *off_447E80 = "/rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688\\library\\alloc\\src\\raw_vec.rs"; // weak
char *off_447E98 = "/rust/deps\\gimli-0.29.0\\src\\read\\line.rs"; // weak
char *off_447EB0 = "/rust/deps\\gimli-0.29.0\\src\\read\\line.rs"; // weak
char *off_447EC8 = "/rust/deps\\gimli-0.29.0\\src\\read\\line.rs"; // weak
char *off_447EE0 = "/rust/deps\\gimli-0.29.0\\src\\read\\line.rs"; // weak
char *off_447EF8 = "/rust/deps\\gimli-0.29.0\\src\\read\\line.rs"; // weak
char *off_447F10 = "/rust/deps\\gimli-0.29.0\\src\\read\\line.rs"; // weak
char *off_447F28 = "/rust/deps\\gimli-0.29.0\\src\\read\\line.rs"; // weak
char *off_447F40 = "/rust/deps\\gimli-0.29.0\\src\\read\\line.rs"; // weak
char *off_447FA8 = "/rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688\\library\\core\\src\\num\\wrapping.rs"; // weak
char *off_447FC0 = "/rust/deps\\gimli-0.29.0\\src\\read\\line.rs"; // weak
char aDebugAbbrev[13] = ".debug_abbrev"; // weak
char aDebugAddr[11] = ".debug_addr"; // weak
char aDebugAranges[14] = ".debug_aranges"; // weak
char aDebugCuIndex[15] = ".debug_cu_index"; // weak
char aDebugInfo[11] = ".debug_info"; // weak
char aDebugLine[11] = ".debug_line"; // weak
char aDebugLineStr[15] = ".debug_line_str"; // weak
char aDebugLoc[10] = ".debug_loc"; // weak
char aDebugLoclists[15] = ".debug_loclists"; // weak
char aDebugRanges[13] = ".debug_ranges"; // weak
char aDebugRnglists[15] = ".debug_rnglists"; // weak
char aDebugStr[10] = ".debug_str"; // weak
char aDebugStrOffset[18] = ".debug_str_offsets"; // weak
char aDebugTuIndex[15] = ".debug_tu_index"; // weak
char aDebugTypes[12] = ".debug_types"; // weak
char aUtf8error[9] = "Utf8Error"; // weak
char aValidUpTo[11] = "valid_up_to"; // weak
char aErrorLen[9] = "error_len"; // weak
char aNone[4] = "None"; // weak
char aSome[4] = "Some"; // weak
char *off_4480F8 = "/rust/deps\\object-0.36.7\\src\\read\\coff\\symbol.rs"; // weak
unsigned __int16 word_448110[4] = { 58u, 0u, 0u, 0u }; // weak
_UNKNOWN unk_448118; // weak
__int64 (__fastcall *off_448148)() = &sub_413270; // weak
__int64 (__fastcall *off_448178)() = &sub_413270; // weak
__int64 (__fastcall *off_4481A8)() = &sub_413270; // weak
__int64 (__fastcall *off_4481D8)() = &sub_438DB0; // weak
__int64 (__fastcall *off_448208)() = &sub_413270; // weak
char *off_448238 = "/rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688\\library\\core\\src\\str\\pattern.rs"; // weak
char *off_448278 = "/rust/deps\\addr2line-0.22.0\\src\\lib.rs"; // weak
char *off_448290 = "/rust/deps\\addr2line-0.22.0\\src\\lib.rs"; // weak
char *off_4482A8 = "/rust/deps\\addr2line-0.22.0\\src\\lib.rs"; // weak
char *off_4482C0 = "/rust/deps\\addr2line-0.22.0\\src\\lib.rs"; // weak
char *off_4482D8 = "/rust/deps\\addr2line-0.22.0\\src\\lib.rs"; // weak
char *off_4482F0 = "/rust/deps\\addr2line-0.22.0\\src\\lib.rs"; // weak
char *off_448308 = "/rust/deps\\addr2line-0.22.0\\src\\lib.rs"; // weak
char *off_448320 = "/rust/deps\\addr2line-0.22.0\\src\\lib.rs"; // weak
char *off_448338 = "/rust/deps\\addr2line-0.22.0\\src\\lib.rs"; // weak
char *off_448350 = "/rust/deps\\addr2line-0.22.0\\src\\lib.rs"; // weak
char *off_448368 = "/rust/deps\\addr2line-0.22.0\\src\\lib.rs"; // weak
char *off_448380 = "/rust/deps\\addr2line-0.22.0\\src\\lib.rs"; // weak
char *off_448398 = "/rust/deps\\addr2line-0.22.0\\src\\lib.rs"; // weak
char *off_4483B0 = "/rust/deps\\addr2line-0.22.0\\src\\lib.rs"; // weak
char *off_4483F8 = "/rust/deps\\addr2line-0.22.0\\src\\function.rs"; // weak
char *off_448410 = "/rust/deps\\addr2line-0.22.0\\src\\function.rs"; // weak
char *off_448428 = "/rust/deps\\addr2line-0.22.0\\src\\function.rs"; // weak
char *off_448440 = "/rust/deps\\addr2line-0.22.0\\src\\function.rs"; // weak
char *off_448458 = "/rust/deps\\addr2line-0.22.0\\src\\function.rs"; // weak
char *off_448470 = "/rust/deps\\addr2line-0.22.0\\src\\function.rs"; // weak
char *off_448488 = "/rust/deps\\addr2line-0.22.0\\src\\function.rs"; // weak
char *off_4484F0 = "fatal runtime error: code running before main must not use thread::current\n"; // weak
const __int64 off_448518 = 4490496LL; // idb
char *off_448590 = "use of std::thread::current() is not possible after the thread's local data has been destroyed"; // weak
char *off_4485C8 = "library\\std\\src\\thread\\current.rs"; // weak
char *off_4486A0 = "fatal runtime error: \nAttempted to access thread-local data while allocating said data.\nDo not access functions that allocate in the global allocator!\nThis is a bug in the global allocator.\n\n"; // weak
char aCannotAccessAT[70] = "cannot access a Thread Local Storage value during or after destruction"; // weak
char *off_448718 = "library\\std\\src\\thread\\local.rs"; // weak
char aAccesserror[11] = "AccessError"; // weak
char *off_448790 = "failed to generate unique thread ID: bitspace exhausted"; // weak
char *off_4487A0 = "library\\std\\src\\thread\\mod.rs"; // weak
char aMain_0[4] = "main"; // weak
char asc_4487BC = '\"'; // weak
unsigned __int8 byte_4487BD[14] = { 82u, 85u, 83u, 84u, 95u, 66u, 65u, 67u, 75u, 84u, 82u, 65u, 67u, 69u }; // weak
char *off_448810 = "library\\std\\src\\ffi\\os_str.rs"; // weak
char *off_448850 = "failed to write the buffered data"; // weak
_UNKNOWN unk_448868; // weak
char *off_4488A8 = "library\\std\\src\\io\\buffered\\linewritershim.rs"; // weak
char aOs[2] = "Os"; // weak
char aCode[4] = "code"; // weak
char aKind[4] = "kind"; // weak
char aMessage[7] = "message"; // weak
char aKind_0[4] = "Kind"; // weak
char aError_0[5] = "Error"; // weak
char aCustom[6] = "Custom"; // weak
char aError_1[5] = "error"; // weak
char asc_448BDD = ')'; // weak
_UNKNOWN unk_448BE0; // weak
char *off_448C30 = "library\\std\\src\\io\\stdio.rs"; // weak
char *off_448C48 = "library\\std\\src\\io\\stdio.rs"; // weak
char *off_448C60 = "library\\std\\src\\io\\stdio.rs"; // weak
char asc_448C8B[2] = ": "; // weak
char *off_448C90 = "failed printing to "; // weak
char *off_448CB0 = "library\\std\\src\\io\\stdio.rs"; // weak
char aStdout[6] = "stdout"; // weak
char aStderr[6] = "stderr"; // weak
char *off_448D10 = "failed to write whole buffer"; // weak
char *off_448D28 = "library\\std\\src\\io\\mod.rs"; // weak
char aAFormattingTra[86] = "a formatting trait implementation returned an error when the underlying stream did not"; // weak
char *off_448D98 = "a formatting trait implementation returned an error when the underlying stream did not"; // weak
char *off_448DA8 = "library\\std\\src\\io\\mod.rs"; // weak
char *off_448DF0 = "library\\std\\src\\path.rs"; // weak
char *off_448E10 = "library\\std\\src\\path.rs"; // weak
char *off_448E28 = "library\\std\\src\\path.rs"; // weak
char *off_448E40 = "library\\std\\src\\path.rs"; // weak
char *off_448E88 = "library\\std\\src\\path.rs"; // weak
char *off_448EA0 = "library\\std\\src\\path.rs"; // weak
char *off_448EB8 = "library\\std\\src\\path.rs"; // weak
char *off_448ED0 = "library\\std\\src\\path.rs"; // weak
char *off_448EE8 = "library\\std\\src\\path.rs"; // weak
char *off_448F00 = "library\\std\\src\\path.rs"; // weak
char *off_448F18 = "library\\std\\src\\path.rs"; // weak
char *off_448F30 = "library\\std\\src\\path.rs"; // weak
char *off_448F80 = "library\\std\\src\\path.rs"; // weak
char *off_448F98 = "library\\std\\src\\path.rs"; // weak
_UNKNOWN unk_448FB0; // weak
char *off_449000 = "library\\std\\src\\sync\\poison\\once.rs"; // weak
_UNKNOWN unk_449018; // weak
const __int64 off_449040 = 4493272LL; // idb
_UNKNOWN unk_449058; // weak
char *off_449080 = "library\\std\\src\\sync\\poison\\once.rs"; // weak
char aLockCountOverf[38] = "lock count overflow in reentrant mutex"; // weak
char *off_4490E8 = "library\\std\\src\\sync\\reentrant_lock.rs"; // weak
char aStackBacktrace[17] = "stack backtrace:\n"; // weak
__int64 (__fastcall *off_449118)() = &sub_433F60; // weak
char aNoteSomeDetail[88] = "note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.\n"; // weak
char aRustEndShortBa[26] = "__rust_end_short_backtrace"; // weak
char aRustBeginShort[28] = "__rust_begin_short_backtrace"; // weak
char aS = 's'; // weak
char *off_4491F0 = "      [... omitted "; // weak
char aUnknown[9] = "<unknown>"; // weak
char *off_449250 = "library\\std\\src\\sys_common\\wtf8.rs"; // weak
char *off_4492B8 = "library\\std\\src\\sys_common\\wtf8.rs"; // weak
char *off_4492D8 = "\\u{}"; // weak
char *off_4492F8 = "library\\std\\src\\sys_common\\wtf8.rs"; // weak
unsigned __int16 word_449310[4] = { 49135u, 189u, 0u, 0u }; // weak
char *off_449318 = "library\\std\\src\\sys_common\\wtf8.rs"; // weak
char *off_449330 = "library\\std\\src\\sys_common\\wtf8.rs"; // weak
char *off_449348 = "library\\std\\src\\sys_common\\wtf8.rs"; // weak
char *off_449360 = "library\\std\\src\\sys_common\\wtf8.rs"; // weak
char *off_449398 = "byte index "; // weak
char *off_4493E0 = "byte index "; // weak
char *off_449420 = "byte index "; // weak
char *off_449468 = "memory allocation of "; // weak
char *off_4494A0 = "library\\std\\src\\panicking.rs"; // weak
char *off_449508 = "note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"; // weak
char *off_449530 = "\nthread '"; // weak
_UNKNOWN unk_4495B0; // weak
__int64 (__fastcall *off_4495E8)() = &sub_43C6B0; // weak
_UNKNOWN unk_449620; // weak
char aBoxDynAny[12] = "Box<dyn Any>"; // weak
char *off_449680 = "aborting due to panic at "; // weak
char *off_4496E8 = "panicked at "; // weak
char *off_449748 = "thread caused non-unwinding panic. aborting.\n"; // weak
_UNKNOWN unk_449758; // weak
char *off_4497B8 = "library\\std\\src\\..\\..\\backtrace\\src\\symbolize\\mod.rs"; // weak
_UNKNOWN unk_4497D0; // weak
_UNKNOWN unk_4497F8; // weak
char asc_449818[6] = "      "; // weak
char aAt[16] = "             at "; // weak
__int16 (*off_449830)[4] = &word_448110; // weak
__int128 xmmword_449A60 = 259LL; // weak
char asc_449A78 = '*'; // weak
char *off_449AC8 = "fatal runtime error: I/O error: operation failed to complete synchronously\n"; // weak
char *off_449B18 = "OS Error "; // weak
char *off_449B70 = "library\\std\\src\\sys\\pal\\windows\\os.rs"; // weak
char *off_449BB8 = "OS Error "; // weak
_UNKNOWN unk_449BD8; // weak
unsigned __int8 byte_449C04[256] =
{
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  4u,
  4u,
  4u,
  4u,
  4u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // weak
char *off_449D70 = "library\\std\\src\\sys\\pal\\windows\\stdio.rs"; // weak
char *off_449D88 = "library\\std\\src\\sys\\pal\\windows\\stdio.rs"; // weak
char *off_449DE0 = "Unexpected number of bytes for incomplete UTF-8 codepoint."; // weak
char *off_449DF0 = "library\\std\\src\\sys\\pal\\windows\\stdio.rs"; // weak
char *off_449E08 = "library\\std\\src\\sys\\pal\\windows\\stdio.rs"; // weak
char *off_449E20 = "library\\std\\src\\sys\\pal\\windows\\stdio.rs"; // weak
char *off_449E38 = "library\\std\\src\\sys\\pal\\windows\\stdio.rs"; // weak
char *off_449E50 = "library\\std\\src\\sys\\pal\\windows\\stdio.rs"; // weak
char *off_449E90 = "Unexpected error in MultiByteToWideChar"; // weak
char *off_449EA0 = "library\\std\\src\\sys\\pal\\windows\\stdio.rs"; // weak
char *off_449EB8 = "library\\std\\src\\sys\\pal\\windows\\stdio.rs"; // weak
char *off_449ED0 = "library\\std\\src\\sys\\pal\\windows\\stdio.rs"; // weak
char *off_449EE8 = "library\\std\\src\\sys\\pal\\windows\\stdio.rs"; // weak
char *off_449F30 = "library\\std\\src\\sys\\pal\\windows\\mod.rs"; // weak
char *off_449F78 = "strings passed to WinAPI cannot contain NULs"; // weak
char *off_449F90 = "library\\std\\src\\sys\\pal\\windows\\mod.rs"; // weak
char *off_449FA8 = "library\\std\\src\\sys\\pal\\windows\\mod.rs"; // weak
char *off_449FC0 = "library\\std\\src\\sys\\pal\\windows\\mod.rs"; // weak
char *off_449FD8 = "library\\std\\src\\sys\\pal\\windows\\mod.rs"; // weak
char *off_44A030 = "\nthread '"; // weak
_UNKNOWN unk_44A050; // weak
_UNKNOWN unk_44A080; // weak
wchar_t asc_44A0B0[4] = L"\\\\?\\"; // weak
char *off_44A0E0 = "library\\std\\src\\sys\\path\\windows.rs"; // weak
char *off_44A0F8 = "library\\std\\src\\sys\\path\\windows.rs"; // weak
char *off_44A120 = "library\\std\\src\\sys\\path\\windows.rs"; // weak
char *off_44A138 = "library\\std\\src\\sys\\path\\windows.rs"; // weak
char *off_44A180 = "Once instance has previously been poisoned"; // weak
char *off_44A1B8 = "too many active read locks on RwLock"; // weak
char *off_44A1F0 = "library\\std\\src\\sys\\sync\\rwlock\\futex.rs"; // weak
char aAssertionFaile_1[36] = "assertion failed: is_unlocked(state)"; // weak
char *off_44A230 = "library\\std\\src\\sys\\sync\\rwlock\\futex.rs"; // weak
char *off_44A278 = "library\\std\\src\\sys\\thread_local\\key\\windows.rs"; // weak
char *off_44A2A8 = "out of TLS indexes"; // weak
char *off_44A2B8 = "library\\std\\src\\sys\\thread_local\\key\\windows.rs"; // weak
_UNKNOWN unk_44A2D0; // weak
char *off_44A2D8 = "library\\std\\src\\sys\\thread_local\\key\\windows.rs"; // weak
char *off_44A2F0 = "library\\std\\src\\sys\\thread_local\\key\\windows.rs"; // weak
char aDebugAbbrevDwo[17] = ".debug_abbrev.dwo"; // weak
char aDebugInfoDwo[15] = ".debug_info.dwo"; // weak
char aDebugLineDwo[15] = ".debug_line.dwo"; // weak
char aDebugLocDwo[14] = ".debug_loc.dwo"; // weak
char aDebugLoclistsD[19] = ".debug_loclists.dwo"; // weak
char aDebugRnglistsD[19] = ".debug_rnglists.dwo"; // weak
char aDebugStrDwo[14] = ".debug_str.dwo"; // weak
char aDebugStrOffset_0[22] = ".debug_str_offsets.dwo"; // weak
char aDebugTypesDwo[16] = ".debug_types.dwo"; // weak
char *off_44A3D8 = "library\\std\\src\\..\\..\\backtrace\\src\\symbolize\\gimli.rs"; // weak
char *off_44A3F0 = "library\\std\\src\\..\\..\\backtrace\\src\\symbolize\\gimli.rs"; // weak
char *off_44A408 = "library\\std\\src\\..\\..\\backtrace\\src\\symbolize\\gimli.rs"; // weak
char *off_44A460 = "library\\std\\src\\..\\..\\backtrace\\src\\symbolize\\gimli\\coff.rs"; // weak
char *off_44A478 = "library\\std\\src\\..\\..\\backtrace\\src\\symbolize\\gimli\\coff.rs"; // weak
char *off_44A4D8 = "library\\std\\src\\..\\..\\backtrace\\src\\symbolize\\gimli\\libs_windows.rs"; // weak
_QWORD qword_44A4F0[42] =
{
  16LL,
  17LL,
  18LL,
  16LL,
  16LL,
  19LL,
  18LL,
  13LL,
  14LL,
  21LL,
  12LL,
  11LL,
  21LL,
  21LL,
  15LL,
  14LL,
  19LL,
  38LL,
  56LL,
  25LL,
  23LL,
  12LL,
  9LL,
  10LL,
  16LL,
  23LL,
  14LL,
  14LL,
  13LL,
  20LL,
  8LL,
  27LL,
  14LL,
  16LL,
  22LL,
  21LL,
  11LL,
  22LL,
  13LL,
  11LL,
  11LL,
  19LL
}; // weak
char *off_44A640 = "entity not foundpermission deniedconnection refusedconnection resethost unreachablenetwork unreachableconnection abortednot connectedaddress in useaddress not availablenetwork downbroken pipeentity already existsoperation would blocknot a directoryis a directorydirectory not emptyread-only filesystem or storage mediumfilesystem loop or indirection limit (e.g. symlink loop)stale network file handleinvalid input parameterinvalid datatimed outwrite zerono storage spaceseek on unseekable filequota exceededfile too largeresource busyexecutable file busydeadlockcross-device link or renametoo many linksinvalid filenameargument list too longoperation interruptedunsupportedunexpected end of fileout of memoryin progressother erroruncategorized error"; // weak
_QWORD qword_44A790[42] =
{
  8LL,
  16LL,
  17LL,
  15LL,
  15LL,
  18LL,
  17LL,
  12LL,
  9LL,
  16LL,
  11LL,
  10LL,
  13LL,
  10LL,
  13LL,
  12LL,
  17LL,
  18LL,
  14LL,
  22LL,
  12LL,
  11LL,
  8LL,
  9LL,
  11LL,
  11LL,
  13LL,
  12LL,
  12LL,
  18LL,
  8LL,
  14LL,
  12LL,
  15LL,
  19LL,
  11LL,
  11LL,
  13LL,
  11LL,
  10LL,
  5LL,
  13LL
}; // weak
_UNKNOWN unk_44A8E0; // weak
unsigned int dword_44A988[6] = { 8u, 8u, 6u, 6u, 3u, 0u }; // weak
const struct _EXCEPTION_POINTERS ExceptionInfo = { &qword_450660, &ContextRecord }; // idb
_UNKNOWN *off_44AD30 = (_UNKNOWN *)0x400000LL; // weak
int dword_450004; // weak
int dword_450008; // weak
int dword_45000C; // weak
int dword_450010; // weak
__int64 qword_450018; // weak
__int64 qword_450020; // weak
int dword_450028; // weak
int dword_450034; // weak
__int64 qword_450038; // weak
char byte_450040; // weak
__int64 qword_450048; // weak
int dword_450050; // weak
char byte_450054; // weak
__int64 qword_450058; // weak
__int128 xmmword_450060; // weak
__int128 xmmword_450070; // weak
int dword_450080; // weak
_UNKNOWN unk_450088; // weak
char byte_4500A8; // weak
char byte_4500A9; // weak
int dword_4500B0; // weak
__int64 qword_4500C0; // weak
__int64 qword_4500C8; // weak
__int64 qword_4500D0; // weak
__int64 qword_4500D8; // weak
__int64 qword_4500E0; // weak
_UNKNOWN unk_4500E8; // weak
int dword_450100; // weak
_UNKNOWN unk_450108; // weak
int dword_450120; // weak
__int64 qword_450130; // weak
int dword_450140; // weak
_UNKNOWN unk_450150; // weak
_UNKNOWN unk_450160; // weak
CONTEXT ContextRecord; // idb
__int64 qword_450660; // weak
__int64 qword_450670; // weak
_UNKNOWN unk_450700; // weak
_UNKNOWN unk_450710; // weak
_UNKNOWN unk_450714; // weak
_UNKNOWN unk_450718; // weak
_UNKNOWN unk_450720; // weak
int dword_450730; // weak
int dword_450734; // weak
__int64 qword_450738; // weak
__int64 (__fastcall *qword_450740)(_QWORD); // weak
_UNKNOWN unk_450750; // weak
__int64 qword_450760; // weak
int dword_450768; // weak
_UNKNOWN unk_450780; // weak
struct _RUNTIME_FUNCTION FunctionTable; // idb
void *Block; // idb
int dword_450A08; // weak
struct _RTL_CRITICAL_SECTION CriticalSection; // idb
__int64 qword_450A60; // weak
__int64 qword_450A68; // weak
_UNKNOWN unk_450A70; // weak
signed __int64 qword_450A78[177]; // weak
// extern HANDLE (__stdcall *GetCurrentProcess)();
// extern DWORD (__stdcall *GetLastError)();
// extern void (__stdcall *GetStartupInfoA)(LPSTARTUPINFOA lpStartupInfo);
// extern void (__stdcall *RtlCaptureContext)(PCONTEXT ContextRecord);
// extern PRUNTIME_FUNCTION (__stdcall *RtlLookupFunctionEntry)(ULONG64 ControlPc, PULONG64 ImageBase, PUNWIND_HISTORY_TABLE HistoryTable);
// extern PEXCEPTION_ROUTINE (__stdcall *RtlVirtualUnwind)(ULONG HandlerType, ULONG64 ImageBase, ULONG64 ControlPc, PRUNTIME_FUNCTION FunctionEntry, PCONTEXT ContextRecord, PVOID *HandlerData, PULONG64 EstablisherFrame, PKNONVOLATILE_CONTEXT_POINTERS ContextPointers);
// extern LPTOP_LEVEL_EXCEPTION_FILTER (__stdcall *SetUnhandledExceptionFilter)(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// extern void (__stdcall *Sleep)(DWORD dwMilliseconds);
// extern BOOL (__stdcall *TerminateProcess)(HANDLE hProcess, UINT uExitCode);
// extern LPVOID (__stdcall *TlsGetValue)(DWORD dwTlsIndex);
// extern void (__stdcall *DeleteCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern void (__stdcall *EnterCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern DWORD (__stdcall *GetCurrentProcessId)();
// extern DWORD (__stdcall *GetCurrentThreadId)();
// extern void (__stdcall *GetSystemTimeAsFileTime)(LPFILETIME lpSystemTimeAsFileTime);
// extern DWORD (__stdcall *GetTickCount)();
// extern void (__stdcall *InitializeCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern void (__stdcall *LeaveCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern BOOL (__stdcall *QueryPerformanceCounter)(LARGE_INTEGER *lpPerformanceCount);
// extern void (__stdcall *RaiseException)(DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD nNumberOfArguments, const ULONG_PTR *lpArguments);
// extern BOOLEAN (__cdecl *RtlAddFunctionTable)(PRUNTIME_FUNCTION FunctionTable, ULONG EntryCount, ULONG64 BaseAddress);
// extern void (__stdcall *RtlUnwindEx)(PVOID TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD ExceptionRecord, PVOID ReturnValue, PCONTEXT ContextRecord, PUNWIND_HISTORY_TABLE HistoryTable);
// extern LONG (__stdcall *UnhandledExceptionFilter)(struct _EXCEPTION_POINTERS *ExceptionInfo);
// extern BOOL (__stdcall *VirtualProtect)(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);
// extern SIZE_T (__stdcall *VirtualQuery)(LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength);
// extern _UNKNOWN _initenv; weak
// extern char *acmdln;
// extern int fmode;
_PVFV qword_453000 = NULL; // weak
_PVFV qword_453010 = NULL; // weak
_PVFV qword_453018 = NULL; // weak
_PVFV qword_453030[2] = { NULL, NULL }; // weak
__int64 (__fastcall *TlsCallbacks[3])() = { &TlsCallback_0, &TlsCallback_1, &TlsCallback_2 }; // weak


//----- (0000000000401010) ----------------------------------------------------
__int64 sub_401010()
{
  BOOL v0; // ecx
  char *v1; // rax
  __int16 v3; // dx

  v0 = 0;
  unk_450718 = 1;
  unk_450714 = 1;
  unk_450710 = 1;
  unk_450160 = 1;
  if ( *(_WORD *)off_44AD30 == 23117 )
  {
    v1 = (char *)off_44AD30 + *((int *)off_44AD30 + 15);
    if ( *(_DWORD *)v1 == 17744 )
    {
      v3 = *((_WORD *)v1 + 12);
      if ( v3 == 267 )
      {
        if ( *((_DWORD *)v1 + 29) > 0xEu )
          v0 = *((_DWORD *)v1 + 58) != 0;
      }
      else if ( v3 == 523 && *((_DWORD *)v1 + 33) > 0xEu )
      {
        v0 = *((_DWORD *)v1 + 62) != 0;
      }
    }
  }
  dword_45000C = v0;
  if ( unk_450720 )
    _set_app_type(_crt_gui_app);
  else
    _set_app_type(_crt_console_app);
  *(_DWORD *)sub_43D5D0() = unk_450750;
  sub_43D6C0();
  if ( unk_43F080 == 1 )
    sub_43E050((_UserMathErrorFunctionPointer)sub_43D980);
  return 0LL;
}
// 44AD30: using guessed type _UNKNOWN *off_44AD30;
// 45000C: using guessed type int dword_45000C;

//----- (0000000000401130) ----------------------------------------------------
__int64 sub_401130()
{
  dword_450004 = unk_450700;
  return _getmainargs(&dword_450028, &qword_450020, &qword_450018, unk_450150, &dword_450004);
}
// 43D598: using guessed type __int64 __fastcall _getmainargs(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 450004: using guessed type int dword_450004;
// 450018: using guessed type __int64 qword_450018;
// 450020: using guessed type __int64 qword_450020;
// 450028: using guessed type int dword_450028;

//----- (0000000000401180) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_401180(__int64 a1, __int64 a2)
{
  _STARTUPINFOA *p_StartupInfo; // r8
  PVOID StackBase; // rsi
  signed __int64 v4; // rax
  int v5; // ebp
  char *v6; // rax
  char v7; // cl
  char *v8; // rax
  char v9; // dl
  char v10; // dl
  int wShowWindow; // eax
  int v12; // ebx
  size_t v13; // r12
  _QWORD *v14; // rax
  __int64 v15; // r13
  __int64 v16; // rdi
  __int64 v17; // rbp
  __int64 v18; // rbx
  size_t v19; // rsi
  void *v20; // rax
  __int64 v21; // rax
  __int64 result; // rax
  _STARTUPINFOA StartupInfo; // [rsp+20h] [rbp-A8h] BYREF

  p_StartupInfo = &StartupInfo;
  memset(&StartupInfo, 0, sizeof(StartupInfo));
  if ( unk_450720 )
    GetStartupInfoA(&StartupInfo);
  StackBase = NtCurrentTeb()->NtTib.StackBase;
  while ( 1 )
  {
    v4 = _InterlockedCompareExchange64(qword_450A78, (signed __int64)StackBase, 0LL);
    if ( !v4 )
    {
      v5 = 0;
      if ( unk_450A70 == 1 )
        goto LABEL_39;
      goto LABEL_8;
    }
    if ( StackBase == (PVOID)v4 )
      break;
    Sleep(0x3E8u);
  }
  v5 = 1;
  if ( unk_450A70 == 1 )
  {
LABEL_39:
    amsg_exit(31LL, a2, p_StartupInfo);
    if ( unk_450A70 == 1 )
      goto LABEL_40;
LABEL_11:
    if ( v5 )
      goto LABEL_12;
    goto LABEL_41;
  }
LABEL_8:
  if ( unk_450A70 )
  {
    dword_450008 = 1;
  }
  else
  {
    unk_450A70 = 1;
    initterm(&qword_453018, qword_453030);
  }
  if ( unk_450A70 != 1 )
    goto LABEL_11;
LABEL_40:
  initterm(&qword_453000, &qword_453010);
  unk_450A70 = 2;
  if ( v5 )
    goto LABEL_12;
LABEL_41:
  _InterlockedExchange64(qword_450A78, 0LL);
LABEL_12:
  if ( TlsCallback_1 )
    TlsCallback_1(0LL, 2LL, 0LL);
  sub_43DD10();
  qword_450760 = (__int64)SetUnhandledExceptionFilter(TopLevelExceptionFilter);
  sub_43E220();
  sub_43D5B0((__int64)nullsub_1);
  sub_43DA80();
  qword_450A68 = (__int64)off_44AD30;
  v6 = sub_43D5C0();
  v7 = 0;
  v8 = *(char **)v6;
  if ( !v8 )
    goto LABEL_27;
  while ( 1 )
  {
    v9 = *v8;
    if ( *v8 <= 32 )
      break;
    if ( v9 == 34 )
      v7 ^= 1u;
LABEL_19:
    ++v8;
  }
  if ( !v9 )
    goto LABEL_26;
  if ( (v7 & 1) != 0 )
  {
    v7 = 1;
    goto LABEL_19;
  }
  do
    v10 = *++v8;
  while ( v10 && v10 <= 32 );
LABEL_26:
  qword_450A60 = (__int64)v8;
LABEL_27:
  if ( unk_450720 )
  {
    wShowWindow = 10;
    if ( (StartupInfo.dwFlags & 1) != 0 )
      wShowWindow = StartupInfo.wShowWindow;
    dword_43F000 = wShowWindow;
  }
  v12 = dword_450028;
  v13 = 8LL * (dword_450028 + 1);
  v14 = malloc(v13);
  v15 = qword_450020;
  v16 = (__int64)v14;
  if ( v12 > 0 )
  {
    v17 = (unsigned int)(v12 - 1);
    v18 = 0LL;
    do
    {
      v19 = strlen(*(const char **)(v15 + 8 * v18)) + 1;
      v20 = malloc(v19);
      *(_QWORD *)(v16 + 8 * v18) = v20;
      memcpy(v20, *(const void **)(v15 + 8 * v18), v19);
      v21 = v18++;
    }
    while ( v17 != v21 );
    v14 = (_QWORD *)(v16 + v13 - 8);
  }
  *v14 = 0LL;
  qword_450020 = v16;
  sub_43D690();
  _initenv = qword_450018;
  result = sub_403AA0();
  dword_450010 = result;
  if ( !dword_45000C )
    exit(result);
  if ( !dword_450008 )
  {
    cexit();
    return (unsigned int)dword_450010;
  }
  return result;
}
// 4013A5: write access to const memory at 451670 has been detected
// 4012D2: conditional instruction was optimized away because dl.1!=0
// 40141C: variable 'a2' is possibly undefined
// 40141C: variable 'p_StartupInfo' is possibly undefined
// 401000: using guessed type __int64 __fastcall nullsub_1();
// 43D588: using guessed type __int64 __fastcall amsg_exit(_QWORD, _QWORD, _QWORD);
// 43D8E0: using guessed type __int64 __fastcall TlsCallback_1(_QWORD, _QWORD, _QWORD);
// 43F000: using guessed type int dword_43F000;
// 44AD30: using guessed type _UNKNOWN *off_44AD30;
// 450008: using guessed type int dword_450008;
// 45000C: using guessed type int dword_45000C;
// 450010: using guessed type int dword_450010;
// 450018: using guessed type __int64 qword_450018;
// 450020: using guessed type __int64 qword_450020;
// 450028: using guessed type int dword_450028;
// 450760: using guessed type __int64 qword_450760;
// 450A60: using guessed type __int64 qword_450A60;
// 450A68: using guessed type __int64 qword_450A68;
// 450A78: using guessed type signed __int64 qword_450A78[177];
// 453000: using guessed type _PVFV qword_453000;
// 453010: using guessed type _PVFV qword_453010;
// 453018: using guessed type _PVFV qword_453018;
// 453030: using guessed type _PVFV qword_453030[2];

//----- (00000000004014C0) ----------------------------------------------------
__int64 start()
{
  __int64 v0; // rdx
  __int64 v1; // rcx

  unk_450720 = 1;
  sub_43D6D0();
  return sub_401180(v1, v0);
}
// 4014D6: variable 'v1' is possibly undefined
// 4014D6: variable 'v0' is possibly undefined

//----- (00000000004014F0) ----------------------------------------------------
__int64 sub_4014F0()
{
  __int64 v0; // rdx
  __int64 v1; // rcx

  unk_450720 = 0;
  sub_43D6D0();
  return sub_401180(v1, v0);
}
// 401506: variable 'v1' is possibly undefined
// 401506: variable 'v0' is possibly undefined

//----- (0000000000401520) ----------------------------------------------------
__int64 __fastcall sub_401520(int (__cdecl *a1)())
{
  return (unsigned int)-(onexit(a1) == 0LL);
}

//----- (0000000000401540) ----------------------------------------------------
__int64 sub_401540()
{
  return sub_401520((int (__cdecl *)())nullsub_2);
}
// 401550: using guessed type __int64 __fastcall nullsub_2();

//----- (0000000000401560) ----------------------------------------------------
__int64 __fastcall sub_401560(__int64 (**a1)(void))
{
  __int64 v1; // rax
  __int64 v2; // rsi
  _QWORD *v3; // rdi
  __int64 v4; // rbx
  void *v5; // rsi
  HANDLE ProcessHeap; // rax
  HANDLE v7; // rax
  __int64 v9; // [rsp+28h] [rbp-60h] BYREF
  _QWORD v10[2]; // [rsp+30h] [rbp-58h] BYREF
  _QWORD v11[9]; // [rsp+40h] [rbp-48h] BYREF

  v1 = sub_401640(*a1);
  if ( !v1 )
    return 0LL;
  v9 = v1;
  v10[0] = &v9;
  v10[1] = sub_438120;
  v11[0] = &off_442168;
  v11[1] = 2LL;
  v11[4] = 0LL;
  v11[2] = v10;
  v11[3] = 1LL;
  sub_43B7A0(v11);
  v2 = v9;
  if ( (v9 & 3) == 1 )
  {
    v3 = *(_QWORD **)(v9 - 1);
    v4 = *(_QWORD *)(v9 + 7);
    if ( *(_QWORD *)v4 )
      (*(void (__fastcall **)(_QWORD))v4)(*(_QWORD *)(v9 - 1));
    v5 = (void *)(v2 - 1);
    if ( *(_QWORD *)(v4 + 8) )
    {
      if ( *(_QWORD *)(v4 + 16) >= 0x11uLL )
        v3 = (_QWORD *)*(v3 - 1);
      ProcessHeap = GetProcessHeap();
      HeapFree(ProcessHeap, 0, v3);
    }
    v7 = GetProcessHeap();
    HeapFree(v7, 0, v5);
  }
  return 1LL;
}
// 442168: using guessed type char *off_442168;

//----- (0000000000401640) ----------------------------------------------------
__int64 __fastcall sub_401640(__int64 (*a1)(void))
{
  return a1();
}

//----- (0000000000401650) ----------------------------------------------------
char __fastcall sub_401650(__int64 a1, __int64 a2)
{
  return sub_405B80(a2, *(unsigned __int16 **)a1, *(_QWORD *)(a1 + 8));
}

//----- (0000000000401670) ----------------------------------------------------
char __fastcall sub_401670(unsigned __int16 ***a1, __int64 a2)
{
  return sub_405B80(a2, **a1, (unsigned __int64)(*a1)[1]);
}

//----- (0000000000401690) ----------------------------------------------------
void __fastcall __noreturn sub_401690()
{
  __m128i v0; // xmm6
  __m128i v1; // xmm7
  __m128i v2; // xmm8
  _QWORD *v3; // rax
  _QWORD *v4; // rsi
  __int64 v5; // r14
  unsigned __int8 *v6; // rbp
  __int64 v7; // r12
  __int64 v8; // r13
  void *v9; // r15
  _QWORD *v10; // r12
  __int64 v11; // rsi
  HANDLE ProcessHeap; // rax
  HANDLE v13; // rax
  __int16 v14; // ax
  int v15; // ecx
  _QWORD *v16; // r12
  __int64 v17; // rsi
  HANDLE v18; // rax
  HANDLE v19; // rax
  __int64 v20; // rax
  void *v21; // rax
  void *v22; // r15
  void *v23; // rax
  void *v24; // rsi
  __int64 v25; // rbx
  void *v26; // rbp
  void *v27; // rsi
  HANDLE v28; // rax
  int v29; // esi
  char v30; // r12
  HANDLE v31; // rax
  int epi16; // ecx
  HANDLE v33; // rsi
  bool v34; // of
  LPVOID v35; // rsi
  __int64 v36; // rt0
  LPVOID *v37; // rcx
  __int64 v38; // rax
  char *v39; // rbx
  LPVOID v40; // rsi
  const void *v41; // rbp
  __int64 v42; // r12
  unsigned __int64 v43; // rcx
  char *v44; // rax
  __int64 v45; // r8
  __int64 v46; // rax
  unsigned __int64 v47; // rax
  unsigned __int8 *v48; // r15
  void *v49; // rbx
  __int64 v50; // rsi
  HANDLE v51; // rax
  _WORD *v52; // rax
  __int64 v53; // rdx
  __int64 v54; // r8
  __int64 v55; // rcx
  __int64 v56; // rsi
  void *v57; // r15
  void *v58; // r12
  HANDLE v59; // rax
  HANDLE v60; // rax
  HANDLE v61; // rax
  HANDLE v62; // rax
  WCHAR *v63; // r12
  const WCHAR *v64; // rbx
  LPCWSTR v65; // rsi
  unsigned __int64 v66; // r15
  HANDLE v67; // rax
  _QWORD *v68; // rbx
  __int64 v69; // rsi
  HANDLE v70; // rax
  HANDLE v71; // rax
  char *v72; // rax
  char *v73; // rdx
  __int128 v74; // kr20_16
  __int64 v75; // rax
  __int64 v76; // rax
  unsigned __int64 v77; // r15
  _QWORD *v78; // rbx
  __int64 v79; // rsi
  HANDLE v80; // rax
  void *v81; // rsi
  HANDLE v82; // rax
  void *v83; // rbp
  HANDLE v84; // rax
  HANDLE Toolhelp32Snapshot; // rax
  void *v86; // rsi
  __int16 v87; // si
  _WORD *v88; // rax
  __int64 v89; // r15
  __int64 v90; // rsi
  __int64 v91; // r12
  __int16 v92; // bx
  __int64 v93; // r13
  __int64 v94; // rax
  unsigned __int64 v95; // rax
  HANDLE v96; // rax
  __int64 v97; // r12
  void *v98; // r12
  __int64 v99; // rbp
  char *v100; // rcx
  char *v101; // r9
  char *v102; // r9
  char *v103; // rdx
  char v104; // r10
  char *v105; // r9
  unsigned __int64 v106; // r8
  WCHAR *v107; // r12
  void *v108; // rbx
  HANDLE v109; // rax
  HANDLE v110; // rax
  HANDLE v111; // r12
  HANDLE v112; // rax
  HANDLE v113; // rax
  HANDLE v114; // rax
  HANDLE v115; // rax
  HANDLE v116; // rax
  void *v117; // rbx
  BOOL v118; // eax
  int v119; // eax
  HANDLE v120; // rax
  HANDLE v121; // rax
  HANDLE v122; // rax
  HANDLE v123; // rax
  LPCWSTR v124; // r15
  void *v125; // rbx
  DWORD v126; // esi
  HANDLE v127; // rax
  __int64 LastError; // rsi
  __int64 v129; // rax
  __int64 v130; // rax
  char v131; // si
  HANDLE v132; // rax
  _QWORD *v133; // rbx
  __int64 v134; // rsi
  HANDLE v135; // rax
  void *v136; // rsi
  HANDLE v137; // rax
  char **v138; // rax
  WCHAR *v139; // r12
  LPCWSTR v140; // rsi
  unsigned __int64 v141; // r15
  HANDLE v142; // rax
  _QWORD *v143; // rbx
  __int64 v144; // rsi
  HANDLE v145; // rax
  HANDLE v146; // rax
  __int64 v147; // rax
  unsigned __int64 v148; // r15
  _QWORD *v149; // rbx
  __int64 v150; // rsi
  HANDLE v151; // rax
  HANDLE v152; // rax
  HANDLE v153; // rax
  HANDLE WaitableTimer; // rax
  void *v155; // rbx
  DWORD v156; // esi
  bool v157; // zf
  const WCHAR *v158; // rax
  __int64 v159; // r15
  _QWORD *v160; // rbx
  __int64 v161; // rsi
  HANDLE v162; // rax
  HANDLE v163; // rax
  void *v164; // rcx
  HANDLE FirstFile; // rax
  _QWORD *v166; // rax
  HANDLE v167; // rax
  void *v168; // rcx
  void *v169; // rax
  _QWORD *v170; // rax
  HANDLE v171; // rax
  HANDLE v172; // rax
  __int64 v173; // rcx
  LPVOID lpMem[2]; // [rsp+30h] [rbp-AD8h] BYREF
  __int128 v175; // [rsp+40h] [rbp-AC8h]
  __int64 v176; // [rsp+50h] [rbp-AB8h]
  LPVOID v177; // [rsp+68h] [rbp-AA0h]
  unsigned __int16 v178; // [rsp+74h] [rbp-A94h]
  unsigned __int16 v179; // [rsp+76h] [rbp-A92h]
  LPVOID v180; // [rsp+78h] [rbp-A90h]
  LPCWSTR lpFileName[2]; // [rsp+80h] [rbp-A88h] BYREF
  size_t v182[2]; // [rsp+90h] [rbp-A78h]
  int v183; // [rsp+A0h] [rbp-A68h]
  __int64 v184; // [rsp+B0h] [rbp-A58h] BYREF
  unsigned __int16 v185; // [rsp+BEh] [rbp-A4Ah]
  __int64 v186; // [rsp+C0h] [rbp-A48h]
  _QWORD *v187; // [rsp+C8h] [rbp-A40h]
  LPVOID v188; // [rsp+D0h] [rbp-A38h]
  HANDLE hFindFile; // [rsp+D8h] [rbp-A30h]
  __int64 v190; // [rsp+E0h] [rbp-A28h]
  unsigned __int64 v191; // [rsp+E8h] [rbp-A20h] BYREF
  void *v192; // [rsp+F0h] [rbp-A18h] BYREF
  int v193; // [rsp+FCh] [rbp-A0Ch]
  LPVOID v194[2]; // [rsp+100h] [rbp-A08h] BYREF
  __int128 v195; // [rsp+110h] [rbp-9F8h]
  char *v196; // [rsp+120h] [rbp-9E8h] BYREF
  __int64 v197; // [rsp+128h] [rbp-9E0h]
  unsigned __int64 *v198; // [rsp+130h] [rbp-9D8h]
  char (__fastcall *v199)(__int64 *, __int64); // [rsp+138h] [rbp-9D0h]
  LPVOID *v200; // [rsp+140h] [rbp-9C8h] BYREF
  __int64 v201; // [rsp+148h] [rbp-9C0h]
  const WCHAR *v202; // [rsp+150h] [rbp-9B8h]
  HANDLE hSnapshot; // [rsp+158h] [rbp-9B0h]
  __int64 v204; // [rsp+160h] [rbp-9A8h]
  _QWORD *v205; // [rsp+168h] [rbp-9A0h] BYREF
  __int128 v206; // [rsp+170h] [rbp-998h] BYREF
  __int128 v207; // [rsp+180h] [rbp-988h]
  int v208; // [rsp+190h] [rbp-978h]
  LPVOID v209; // [rsp+198h] [rbp-970h]
  void *v210; // [rsp+1A0h] [rbp-968h]
  unsigned __int64 v211; // [rsp+1A8h] [rbp-960h]
  __int128 v212; // [rsp+1B0h] [rbp-958h] BYREF
  __int128 v213; // [rsp+1C0h] [rbp-948h]
  int v214; // [rsp+1D0h] [rbp-938h]
  _BYTE Src[542]; // [rsp+1D8h] [rbp-930h] BYREF
  _BYTE FindFileData[600]; // [rsp+3F8h] [rbp-710h] BYREF
  _OWORD v217[34]; // [rsp+650h] [rbp-4B8h] BYREF
  _QWORD v218[68]; // [rsp+870h] [rbp-298h] BYREF

  v3 = sub_43C4F0(0x30uLL);
  if ( !v3 )
    sub_4040E9(8LL, 48LL);
  v4 = v3;
  *v3 = "C:\\Drivers\\Starting exe cleaner...\n";
  v3[1] = 11LL;
  v3[2] = "C:\\Users\\Public\\Music\\C:\\ProgramData\\C:\\Drivers\\Starting exe cleaner...\n";
  v3[3] = 22LL;
  v3[4] = "C:\\ProgramData\\C:\\Drivers\\Starting exe cleaner...\n";
  v3[5] = 15LL;
  *(_QWORD *)FindFileData = &off_4421D0;
  *(_QWORD *)&FindFileData[8] = 1LL;
  *(_QWORD *)&FindFileData[16] = 8LL;
  *(_OWORD *)&FindFileData[24] = 0LL;
  sub_43B870(FindFileData);
  v211 = 0xFFFFFFFF00000003uLL;
  v5 = 0LL;
  v187 = v4;
  while ( 1 )
  {
    while ( 1 )
    {
      v205 = &v4[v5];
      v6 = (unsigned __int8 *)v4[v5];
      v7 = v4[v5 + 1];
      sub_43A920((__int64)Src, v6, v7, 0);
      v8 = *(_QWORD *)&Src[8];
      if ( *(_QWORD *)Src ^ 2LL | v211 & *(_QWORD *)&Src[8] ^ 0x78000000002LL )
      {
        if ( *(_DWORD *)Src == 2 )
          goto LABEL_19;
        v14 = *(_WORD *)&Src[76];
        v15 = *(_DWORD *)&Src[80];
      }
      else
      {
        sub_43A920((__int64)FindFileData, v6, v7, 0x200000);
        if ( *(_DWORD *)FindFileData == 2 )
        {
          if ( (FindFileData[8] & 3) == 1 )
          {
            v9 = (void *)(*(_QWORD *)&FindFileData[8] - 1LL);
            v10 = *(_QWORD **)(*(_QWORD *)&FindFileData[8] - 1LL);
            v11 = *(_QWORD *)(*(_QWORD *)&FindFileData[8] + 7LL);
            if ( *(_QWORD *)v11 )
              (*(void (__fastcall **)(_QWORD *))v11)(v10);
            if ( *(_QWORD *)(v11 + 8) )
            {
              if ( *(_QWORD *)(v11 + 16) >= 0x11uLL )
                v10 = (_QWORD *)*(v10 - 1);
              ProcessHeap = GetProcessHeap();
              HeapFree(ProcessHeap, 0, v10);
            }
            v13 = GetProcessHeap();
            HeapFree(v13, 0, v9);
            v4 = v187;
          }
LABEL_19:
          if ( (v8 & 3) == 1 )
          {
            v16 = *(_QWORD **)(v8 - 1);
            v17 = *(_QWORD *)(v8 + 7);
            if ( *(_QWORD *)v17 )
              (*(void (__fastcall **)(_QWORD))v17)(*(_QWORD *)(v8 - 1));
            if ( *(_QWORD *)(v17 + 8) )
            {
              if ( *(_QWORD *)(v17 + 16) >= 0x11uLL )
                v16 = (_QWORD *)*(v16 - 1);
              v18 = GetProcessHeap();
              HeapFree(v18, 0, v16);
            }
            v19 = GetProcessHeap();
            HeapFree(v19, 0, (LPVOID)(v8 - 1));
            v20 = 0LL;
            v4 = v187;
          }
          else
          {
            v20 = 0LL;
          }
          goto LABEL_282;
        }
        v14 = *(_WORD *)&FindFileData[76];
        v15 = *(_DWORD *)&FindFileData[80];
        if ( ((unsigned __int8)(*(_DWORD *)&FindFileData[76] >> 10) & (*(_DWORD *)&FindFileData[80] >> 29) & 1) != 0 )
          goto LABEL_19;
      }
      if ( (((unsigned __int8)(v14 & 0x10) >> 4) & ((v14 & 0x400) == 0 || (v15 & 0x20000000) == 0)) != 0 )
        break;
      v20 = 0LL;
LABEL_282:
      *(_QWORD *)&v217[0] = v20;
      *(_QWORD *)Src = v217;
      *(_QWORD *)&Src[8] = sub_405120;
      *(_QWORD *)&Src[16] = &v205;
      *(_QWORD *)&Src[24] = sub_401670;
      *(_QWORD *)FindFileData = &off_4421F8;
      *(_QWORD *)&FindFileData[8] = 3LL;
      *(_QWORD *)&FindFileData[32] = 0LL;
      *(_QWORD *)&FindFileData[16] = Src;
      *(_QWORD *)&FindFileData[24] = 2LL;
      sub_43B870(FindFileData);
      v5 += 2LL;
      if ( v5 == 6 )
        goto LABEL_283;
    }
    if ( !v7 )
    {
      v177 = (LPVOID)0x300000002LL;
      goto LABEL_288;
    }
    if ( v7 < 0 )
      goto LABEL_327;
    v21 = sub_43C4F0(v7);
    if ( !v21 )
      goto LABEL_328;
    v22 = v21;
    memcpy(v21, v6, v7);
    v23 = sub_43C4F0(v7);
    if ( !v23 )
      sub_4040E9(1LL, v7);
    v24 = v23;
    memcpy(v23, v6, v7);
    *(_QWORD *)FindFileData = v7;
    *(_QWORD *)&FindFileData[8] = v24;
    *(_QWORD *)&FindFileData[16] = v7;
    FindFileData[24] = 0;
    sub_439BD0((__int64)FindFileData, asc_449A78, (void *)1);
    v25 = *(_QWORD *)FindFileData;
    v26 = *(void **)&FindFileData[8];
    sub_4329C0((__int64)v218, *(unsigned __int8 **)&FindFileData[8], *(__int64 *)&FindFileData[16]);
    v27 = (void *)v218[1];
    v202 = (const WCHAR *)0x8000000000000000LL;
    if ( v218[0] == 0x8000000000000000uLL
      || (*(_QWORD *)FindFileData = v218[0],
          *(_QWORD *)&FindFileData[8] = v218[1],
          *(_QWORD *)&FindFileData[16] = v218[2],
          sub_432CE0(lpMem, (__int128 *)FindFileData),
          v27 = lpMem[1],
          lpMem[0] == v202) )
    {
      v177 = v27;
      if ( v25 )
        goto LABEL_35;
      goto LABEL_36;
    }
    v188 = lpMem[0];
    memset(FindFileData, 0, 0x250uLL);
    v180 = lpMem[1];
    FirstFile = FindFirstFileExW((LPCWSTR)lpMem[1], FindExInfoBasic, FindFileData, FindExSearchNameMatch, 0LL, 0);
    if ( FirstFile != (HANDLE)-1LL )
    {
      hFindFile = FirstFile;
      v166 = sub_43C4F0(0x30uLL);
      if ( !v166 )
        sub_4040E9(8LL, 48LL);
      *v166 = 1LL;
      v166[1] = 1LL;
      v166[2] = v7;
      v166[3] = v22;
      v166[4] = v7;
      v177 = v166;
      *((_BYTE *)v166 + 40) = 0;
      v210 = *(void **)FindFileData;
      v217[0] = *(_OWORD *)&FindFileData[8];
      v217[1] = *(_OWORD *)&FindFileData[24];
      LODWORD(v217[2]) = *(_DWORD *)&FindFileData[40];
      v1 = _mm_cvtsi32_si128(*(unsigned int *)&FindFileData[44]);
      v178 = *(_WORD *)&FindFileData[48];
      memcpy(Src, &FindFileData[50], sizeof(Src));
      if ( v188 )
      {
        v167 = GetProcessHeap();
        HeapFree(v167, 0, v180);
      }
      v29 = 1;
      if ( !v25 )
        break;
      v30 = 0;
      goto LABEL_37;
    }
    LODWORD(v169) = GetLastError();
    v177 = v169;
    if ( (_DWORD)v169 != 2 )
    {
      if ( v188 )
      {
        v172 = GetProcessHeap();
        HeapFree(v172, 0, v180);
      }
      v177 = (LPVOID)(((_QWORD)v177 << 32) | 2LL);
      if ( !v25 )
        goto LABEL_36;
LABEL_35:
      v28 = GetProcessHeap();
      HeapFree(v28, 0, v26);
LABEL_36:
      v29 = 2;
      v30 = 1;
      v26 = v22;
      goto LABEL_37;
    }
    v170 = sub_43C4F0(0x30uLL);
    if ( !v170 )
      sub_4040E9(8LL, 48LL);
    *v170 = 1LL;
    v170[1] = 1LL;
    v170[2] = v7;
    v170[3] = v22;
    v170[4] = v7;
    v177 = v170;
    *((_BYTE *)v170 + 40) = 0;
    if ( v188 )
    {
      v171 = GetProcessHeap();
      HeapFree(v171, 0, v180);
    }
    v30 = 0;
    hFindFile = (HANDLE)-1LL;
    v29 = 0;
    if ( !v25 )
      break;
LABEL_37:
    v31 = GetProcessHeap();
    HeapFree(v31, 0, v26);
    if ( !v30 )
      break;
LABEL_288:
    v40 = v177;
LABEL_289:
    *(_QWORD *)&v206 = v40;
    v218[0] = &v205;
    v218[1] = sub_401670;
    v218[2] = &v206;
    v218[3] = sub_439080;
    *(_QWORD *)Src = &off_442238;
    *(_QWORD *)&Src[8] = 3LL;
    *(_QWORD *)&Src[32] = 0LL;
    *(_QWORD *)&Src[16] = v218;
    *(_QWORD *)&Src[24] = 2LL;
    lpMem[0] = aStderr;
    lpMem[1] = (LPVOID)6;
    *(_QWORD *)&v212 = &unk_450088;
    *(_QWORD *)FindFileData = &v212;
    v158 = (const WCHAR *)sub_43B390((__int64 **)FindFileData, Src);
    v4 = v187;
    if ( v158 )
    {
      lpFileName[0] = v158;
      *(_QWORD *)&v217[0] = lpMem;
      *((_QWORD *)&v217[0] + 1) = sub_4123C0;
      *(_QWORD *)&v217[1] = lpFileName;
      *((_QWORD *)&v217[1] + 1) = sub_439080;
      *(_QWORD *)FindFileData = &off_448C90;
      *(_QWORD *)&FindFileData[8] = 2LL;
      *(_QWORD *)&FindFileData[32] = 0LL;
      *(_QWORD *)&FindFileData[16] = v217;
      *(_QWORD *)&FindFileData[24] = 2LL;
      sub_405240((__int64)FindFileData, (__int64)&off_448CB0);
    }
    v159 = v206;
    if ( (v206 & 3) == 1 )
    {
      v160 = *(_QWORD **)(v206 - 1);
      v161 = *(_QWORD *)(v206 + 7);
      if ( *(_QWORD *)v161 )
        (*(void (__fastcall **)(_QWORD))v161)(*(_QWORD *)(v206 - 1));
      if ( *(_QWORD *)(v161 + 8) )
      {
        if ( *(_QWORD *)(v161 + 16) >= 0x11uLL )
          v160 = (_QWORD *)*(v160 - 1);
        v162 = GetProcessHeap();
        HeapFree(v162, 0, v160);
      }
      v163 = GetProcessHeap();
      HeapFree(v163, 0, (LPVOID)(v159 - 1));
      v4 = v187;
    }
    v5 += 2LL;
    if ( v5 == 6 )
    {
LABEL_283:
      WaitableTimer = CreateWaitableTimerExW(0LL, 0LL, 2u, 0x1F0003u);
      if ( !WaitableTimer )
        goto LABEL_5;
      v155 = WaitableTimer;
      *(_QWORD *)FindFileData = -150000000LL;
      if ( !SetWaitableTimer(WaitableTimer, (const LARGE_INTEGER *)FindFileData, 0, 0LL, 0LL, 0) )
      {
        CloseHandle(v155);
        goto LABEL_5;
      }
      v156 = WaitForSingleObject(v155, 0xFFFFFFFF);
      CloseHandle(v155);
      v5 = 0LL;
      v157 = v156 == -1;
      v4 = v187;
      if ( v157 )
      {
LABEL_5:
        Sleep(0x3A98u);
        v5 = 0LL;
      }
    }
  }
  v206 = v217[0];
  v207 = v217[1];
  v208 = v217[2];
  memcpy(v218, Src, 0x21EuLL);
  epi16 = _mm_extract_epi16(v1, 1);
  LOBYTE(v188) = (unsigned __int16)_mm_cvtsi128_si32(v1) == 46
              && (epi16 == 0 || (v178 | (unsigned __int16)epi16 ^ 0x2E) == 0);
  v204 = 0LL;
  while ( 1 )
  {
    if ( hFindFile == (HANDLE)-1LL )
    {
LABEL_300:
      FindClose(hFindFile);
      v164 = v177;
      if ( !_InterlockedDecrement64((volatile signed __int64 *)v177) )
        sub_4371C0(v164);
      v4 = v187;
      v20 = v204;
      goto LABEL_282;
    }
    if ( (unsigned __int8)v188 & 1 | (v29 != 1) )
    {
      memset(FindFileData, 0, 0x250uLL);
      v33 = hFindFile;
      while ( FindNextFileW(v33, (LPWIN32_FIND_DATAW)FindFileData) )
      {
        v34 = __OFSUB__(*(_WORD *)&FindFileData[44], 46);
        if ( *(_WORD *)&FindFileData[44] == 46 )
        {
          if ( !*(_WORD *)&FindFileData[46] )
            continue;
          v34 = __OFSUB__(*(_WORD *)&FindFileData[46], 46);
          if ( *(_WORD *)&FindFileData[46] == 46 )
          {
            v34 = 0;
            if ( !*(_WORD *)&FindFileData[48] )
              continue;
          }
        }
        v35 = v177;
        v36 = _InterlockedIncrement64((volatile signed __int64 *)v177);
        if ( !((v36 < 0) ^ v34 | (v36 == 0)) )
        {
          v194[0] = *(LPVOID *)FindFileData;
          *(_OWORD *)lpFileName = *(_OWORD *)&FindFileData[8];
          *(_OWORD *)v182 = *(_OWORD *)&FindFileData[24];
          v183 = *(_DWORD *)&FindFileData[40];
          v2 = _mm_cvtsi32_si128(*(unsigned int *)&FindFileData[44]);
          v179 = *(_WORD *)&FindFileData[48];
          memcpy(Src, &FindFileData[50], sizeof(Src));
          v37 = (LPVOID *)&v196;
          v38 = (__int64)v35;
          goto LABEL_71;
        }
LABEL_337:
        BUG();
      }
      LODWORD(v46) = GetLastError();
      if ( (_DWORD)v46 == 18 )
        goto LABEL_300;
      v38 = (v46 << 32) | 2;
      v196 = 0LL;
      v37 = v194;
LABEL_71:
      *v37 = (LPVOID)v38;
      v39 = v196;
      v40 = v194[0];
      if ( v196 )
      {
LABEL_52:
        LODWORD(v176) = v183;
        v175 = *(_OWORD *)v182;
        *(_OWORD *)lpMem = *(_OWORD *)lpFileName;
        memcpy(FindFileData, Src, 0x21EuLL);
        v185 = v179;
        v0 = v2;
      }
    }
    else
    {
      v39 = (char *)v177;
      if ( _InterlockedIncrement64((volatile signed __int64 *)v177) <= 0 )
        goto LABEL_337;
      v194[0] = v210;
      *(_OWORD *)lpFileName = v206;
      *(_OWORD *)v182 = v207;
      v183 = v208;
      memcpy(Src, v218, sizeof(Src));
      v196 = v39;
      v2 = v1;
      v179 = v178;
      v40 = v210;
      if ( v39 )
        goto LABEL_52;
    }
    v214 = v176;
    v213 = v175;
    v212 = *(_OWORD *)lpMem;
    memcpy(v217, FindFileData, 0x21EuLL);
    if ( !v39 )
    {
      FindClose(hFindFile);
      v168 = v177;
      if ( !_InterlockedDecrement64((volatile signed __int64 *)v177) )
        sub_4371C0(v168);
      goto LABEL_289;
    }
    *(_DWORD *)&FindFileData[48] = v214;
    *(_OWORD *)&FindFileData[32] = v213;
    *(_OWORD *)&FindFileData[16] = v212;
    *(_DWORD *)&FindFileData[52] = _mm_cvtsi128_si32(v0);
    *(_WORD *)&FindFileData[56] = v185;
    memcpy(&FindFileData[58], v217, 0x21EuLL);
    *(_QWORD *)FindFileData = v39;
    *(_QWORD *)&FindFileData[8] = v40;
    v41 = (const void *)*((_QWORD *)v39 + 3);
    v42 = *((_QWORD *)v39 + 4);
    v43 = 260LL;
    v44 = &FindFileData[52];
    do
    {
      if ( !*(_WORD *)v44 )
        goto LABEL_80;
      if ( !*((_WORD *)v44 + 1) )
      {
        v44 += 2;
        goto LABEL_80;
      }
      if ( !*((_WORD *)v44 + 2) )
      {
        v44 += 4;
        goto LABEL_80;
      }
      if ( !*((_WORD *)v44 + 3) )
      {
        v44 += 6;
        goto LABEL_80;
      }
      if ( !*((_WORD *)v44 + 4) )
      {
        v44 += 8;
        goto LABEL_80;
      }
      if ( !*((_WORD *)v44 + 5) )
      {
        v44 += 10;
        goto LABEL_80;
      }
      if ( !*((_WORD *)v44 + 6) )
      {
        v44 += 12;
        goto LABEL_80;
      }
      if ( !*((_WORD *)v44 + 7) )
      {
        v44 += 14;
LABEL_80:
        v47 = v44 - &FindFileData[52];
        v45 = v47 >> 1;
        if ( v47 >= 0x20A )
          sub_405B00(v45, 260LL, (__int64)&off_449FD8);
        goto LABEL_81;
      }
      v43 -= 8LL;
      v44 += 16;
    }
    while ( v43 > 7 );
    v44 = &FindFileData[564];
    if ( !*(_WORD *)&FindFileData[564] )
      goto LABEL_80;
    v44 = &FindFileData[566];
    if ( !*(_WORD *)&FindFileData[566] )
      goto LABEL_80;
    v44 = &FindFileData[568];
    if ( !*(_WORD *)&FindFileData[568] )
      goto LABEL_80;
    v45 = 260LL;
    v44 = &FindFileData[570];
    if ( !*(_WORD *)&FindFileData[570] )
      goto LABEL_80;
LABEL_81:
    sub_414CB0(lpMem, (unsigned __int16 *)&FindFileData[52], v45);
    v48 = (unsigned __int8 *)lpMem[1];
    if ( v42 < 0 )
    {
      v173 = 0LL;
LABEL_323:
      sub_40408F(v173, v42, (__int64)&off_447C90);
    }
    v49 = (void *)v175;
    if ( v42 )
    {
      v50 = (__int64)sub_43C4F0(v42);
      if ( !v50 )
      {
        v173 = 1LL;
        goto LABEL_323;
      }
    }
    else
    {
      v50 = 1LL;
    }
    memcpy((void *)v50, v41, v42);
    *(_QWORD *)Src = v42;
    *(_QWORD *)&Src[8] = v50;
    *(_QWORD *)&Src[16] = v42;
    Src[24] = 0;
    sub_439BD0((__int64)Src, v48, v49);
    v195 = *(_OWORD *)&Src[16];
    *(_OWORD *)v194 = *(_OWORD *)Src;
    if ( lpMem[0] )
    {
      v51 = GetProcessHeap();
      HeapFree(v51, 0, v48);
    }
    v52 = (_WORD *)sub_43BB40((unsigned __int8 *)v194[1], v195);
    if ( !v52 )
      goto LABEL_142;
    v54 = v53;
    if ( v53 == 2 && *v52 == 11822 )
      goto LABEL_142;
    do
    {
      if ( !v53 )
        goto LABEL_142;
      v55 = v53--;
    }
    while ( *((_BYTE *)v52 + v55 - 1) != 46 );
    if ( !v53 )
      goto LABEL_142;
    sub_43C0B0(Src, (char *)v52 + v55, (char *)(v54 - v55));
    v57 = *(void **)&Src[8];
    v56 = *(_QWORD *)Src;
    sub_4047B0(lpMem, *(char **)&Src[8], *(__int64 *)&Src[16]);
    v58 = lpMem[1];
    if ( (_QWORD)v175 != 3LL || *(_WORD *)lpMem[1] ^ 0x7865 | *((unsigned __int8 *)lpMem[1] + 2) ^ 0x65 )
    {
      if ( lpMem[0] )
      {
        v59 = GetProcessHeap();
        HeapFree(v59, 0, v58);
      }
      if ( 2 * v56 )
        goto LABEL_99;
      goto LABEL_142;
    }
    if ( lpMem[0] )
    {
      v61 = GetProcessHeap();
      HeapFree(v61, 0, v58);
    }
    if ( 2 * v56 )
    {
      v62 = GetProcessHeap();
      HeapFree(v62, 0, v57);
    }
    sub_4329C0((__int64)lpMem, (unsigned __int8 *)v194[1], v195);
    v63 = (WCHAR *)lpMem[1];
    v64 = v202;
    if ( lpMem[0] == v202
      || (*(_OWORD *)Src = *(_OWORD *)lpMem,
          *(_QWORD *)&Src[16] = v175,
          sub_432CE0(lpFileName, (__int128 *)Src),
          v65 = lpFileName[0],
          v63 = (WCHAR *)lpFileName[1],
          lpFileName[0] == v64) )
    {
      v66 = (unsigned __int64)v63;
      goto LABEL_107;
    }
    if ( DeleteFileW(lpFileName[1]) )
    {
      if ( v65 )
      {
        v67 = GetProcessHeap();
        HeapFree(v67, 0, v63);
      }
      goto LABEL_114;
    }
    v66 = ((unsigned __int64)GetLastError() << 32) | 2;
    if ( v65 )
    {
      v127 = GetProcessHeap();
      HeapFree(v127, 0, v63);
    }
LABEL_107:
    if ( !v66 )
    {
LABEL_114:
      lpMem[0] = v194;
      lpMem[1] = sub_439250;
      *(_QWORD *)Src = &off_442408;
      *(_QWORD *)&Src[8] = 2LL;
      *(_QWORD *)&Src[32] = 0LL;
      *(_QWORD *)&Src[16] = lpMem;
      *(_QWORD *)&Src[24] = 1LL;
      sub_43B870(Src);
      ++v204;
      goto LABEL_142;
    }
    switch ( v66 & 3 )
    {
      case 0uLL:
        if ( *(_BYTE *)(v66 + 16) != 1 )
          goto LABEL_133;
        goto LABEL_128;
      case 1uLL:
        if ( *(_BYTE *)(v66 + 15) != 1 )
          goto LABEL_133;
        v68 = *(_QWORD **)(v66 - 1);
        v69 = *(_QWORD *)(v66 + 7);
        if ( *(_QWORD *)v69 )
          (*(void (__fastcall **)(_QWORD))v69)(*(_QWORD *)(v66 - 1));
        if ( *(_QWORD *)(v69 + 8) )
        {
          if ( *(_QWORD *)(v69 + 16) >= 0x11uLL )
            v68 = (_QWORD *)*(v68 - 1);
          v70 = GetProcessHeap();
          HeapFree(v70, 0, v68);
        }
        v71 = GetProcessHeap();
        HeapFree(v71, 0, (LPVOID)(v66 - 1));
        goto LABEL_128;
      case 2uLL:
        if ( HIDWORD(v66) != 5 && HIDWORD(v66) != 10013 )
          goto LABEL_133;
        goto LABEL_128;
      case 3uLL:
        if ( (v66 & 0xFFFFFFFF00000000uLL) == 0x100000000LL )
        {
LABEL_128:
          v72 = (char *)sub_43BB40((unsigned __int8 *)v194[1], v195);
          if ( !v72 )
            sub_407050((__int64)&off_442278);
          sub_43C0B0(Src, v72, v73);
          v7 = *(_QWORD *)&Src[16];
          if ( *(__int64 *)&Src[16] < 0 )
LABEL_327:
            sub_4040B0((__int64)&off_447C90);
          v74 = *(_OWORD *)Src;
          if ( *(_QWORD *)&Src[16] )
          {
            v75 = (__int64)sub_43C4F0(*(SIZE_T *)&Src[16]);
            if ( !v75 )
LABEL_328:
              sub_4040E9(1LL, v7);
          }
          else
          {
            v75 = 1LL;
          }
          v83 = (void *)v75;
          memcpy((void *)v75, *((const void **)&v74 + 1), v7);
          if ( 2LL * (_QWORD)v74 )
          {
            v84 = GetProcessHeap();
            HeapFree(v84, 0, *((LPVOID *)&v74 + 1));
          }
          v209 = v83;
          v196 = (char *)v83;
          v190 = v7;
          v197 = v7;
          Toolhelp32Snapshot = CreateToolhelp32Snapshot(2u, 0);
          if ( Toolhelp32Snapshot )
          {
            v86 = Toolhelp32Snapshot;
            memset(Src, 0, 0x130uLL);
            *(_DWORD *)Src = 304;
            if ( Process32First(v86, (LPPROCESSENTRY32)Src) )
            {
              v193 = 0;
              hSnapshot = v86;
              while ( 1 )
              {
                v87 = Src[44];
                if ( Src[44] )
                {
                  v88 = sub_43C4F0(8uLL);
                  if ( !v88 )
                    sub_4040E9(2LL, 8LL);
                  v89 = (__int64)v88;
                  *v88 = v87;
                  v90 = 4LL;
                  v91 = 0LL;
                  do
                  {
                    v92 = (char)Src[v91 + 45];
                    if ( !Src[v91 + 45] )
                    {
                      v97 = v91 + 1;
                      goto LABEL_171;
                    }
                    v93 = v91 + 1;
                    if ( v91 + 1 == v90 )
                    {
                      v94 = v90++;
                      v95 = 2 * v94;
                      if ( v95 > v90 )
                        v90 = v95;
                      if ( (unsigned __int64)v90 < 5 )
                        v90 = 4LL;
                      if ( v90 < 0 || (unsigned __int64)(2 * v90) > 0x7FFFFFFFFFFFFFFELL )
                        sub_4040B0((__int64)&off_447E80);
                      if ( v95 )
                      {
                        v96 = GetProcessHeap();
                        v89 = (__int64)HeapReAlloc(v96, 0, (LPVOID)v89, 2 * v90);
                        if ( !v89 )
LABEL_324:
                          sub_4040E9(2LL, 2 * v90);
                      }
                      else
                      {
                        v89 = (__int64)sub_43C4F0(2 * v90);
                        if ( !v89 )
                          goto LABEL_324;
                      }
                    }
                    *(_WORD *)(v89 + 2 * v91++ + 2) = v92;
                  }
                  while ( v93 != 259 );
                  v97 = 260LL;
                }
                else
                {
                  v89 = 2LL;
                  v97 = 0LL;
                  v90 = 0LL;
                }
LABEL_171:
                sub_414CB0(lpMem, (unsigned __int16 *)v89, v97);
                v98 = lpMem[1];
                v99 = v175;
                if ( (BYTE8(v175) & 1) != 0 || !(_QWORD)v175 )
                {
LABEL_188:
                  v106 = v175;
                  v99 = (__int64)lpMem[1];
                  v180 = lpMem[0];
                  goto LABEL_189;
                }
                v100 = (char *)lpMem[1] + v175;
                v101 = (char *)lpMem[1];
                while ( 1 )
                {
                  v103 = v101 + 1;
                  v104 = *v101;
                  if ( *v101 < 0 )
                    break;
LABEL_176:
                  v101 = v103;
                  if ( v103 == v100 )
                    goto LABEL_188;
                }
                if ( (unsigned __int8)v104 < 0xE0u )
                {
                  v102 = v101 + 2;
                  if ( v103 != v100 )
                    v103 = v102;
                  goto LABEL_176;
                }
                if ( v104 != -19 )
                {
                  v105 = v101 + 2;
                  if ( v103 == v100 )
                    v105 = v103;
                  v103 = &v105[v105 != v100];
                  if ( (unsigned __int8)v104 >= 0xF0u )
                    v103 += v103 != v100;
                  goto LABEL_176;
                }
                if ( v103 == v100 || v101 + 2 == v100 )
                  goto LABEL_188;
                if ( (unsigned __int8)v101[1] <= 0x9Fu )
                {
                  v103 = v101 + 3;
                  goto LABEL_176;
                }
                if ( lpMem[0] == v202 )
                {
                  v106 = BYTE8(v175) | ((((unsigned __int64)((HIBYTE(v175) << 16) | (unsigned int)*(unsigned __int16 *)((char *)&v175 + 13)) << 32) | *(unsigned int *)((char *)&v175 + 9)) << 8);
                  v180 = lpMem[1];
                }
                else
                {
                  v99 = 1LL;
                  if ( lpMem[0] )
                  {
                    v120 = GetProcessHeap();
                    HeapFree(v120, 0, v98);
                  }
                  v106 = 0LL;
                  v180 = 0LL;
                }
LABEL_189:
                sub_4047B0(lpFileName, (char *)v99, v106);
                sub_4047B0(lpMem, v196, v197);
                v107 = (WCHAR *)lpFileName[1];
                v108 = lpMem[1];
                if ( v182[0] != (_QWORD)v175 || memcmp(lpFileName[1], lpMem[1], v182[0]) )
                {
                  if ( lpMem[0] )
                  {
                    v109 = GetProcessHeap();
                    HeapFree(v109, 0, v108);
                  }
                  if ( lpFileName[0] )
                  {
                    v110 = GetProcessHeap();
                    HeapFree(v110, 0, v107);
                  }
                  goto LABEL_195;
                }
                if ( lpMem[0] )
                {
                  v114 = GetProcessHeap();
                  HeapFree(v114, 0, v108);
                }
                if ( lpFileName[0] )
                {
                  v115 = GetProcessHeap();
                  HeapFree(v115, 0, v107);
                }
                LODWORD(v200) = *(_DWORD *)&Src[8];
                v116 = OpenProcess(0x401u, 0, *(DWORD *)&Src[8]);
                if ( v116 )
                {
                  v117 = v116;
                  v118 = TerminateProcess(v116, 1u);
                  v111 = hSnapshot;
                  if ( v118 )
                  {
                    lpFileName[0] = (LPCWSTR)&v196;
                    lpFileName[1] = (LPCWSTR)sub_401650;
                    v182[0] = (size_t)&v200;
                    v182[1] = (size_t)sub_4063D0;
                    lpMem[0] = &off_442498;
                    lpMem[1] = (LPVOID)3;
                    v176 = 0LL;
                    *(_QWORD *)&v175 = lpFileName;
                    *((_QWORD *)&v175 + 1) = 2LL;
                    sub_43B870(lpMem);
                    LOBYTE(v119) = 1;
                    v193 = v119;
                  }
                  CloseHandle(v117);
                }
                else
                {
LABEL_195:
                  v111 = hSnapshot;
                }
                if ( !Process32Next(v111, (LPPROCESSENTRY32)Src) )
                  break;
                if ( v180 )
                {
                  v112 = GetProcessHeap();
                  HeapFree(v112, 0, (LPVOID)v99);
                }
                if ( v90 )
                {
                  v113 = GetProcessHeap();
                  HeapFree(v113, 0, (LPVOID)v89);
                }
              }
              if ( v180 )
              {
                v121 = GetProcessHeap();
                HeapFree(v121, 0, (LPVOID)v99);
              }
              if ( v90 )
              {
                v122 = GetProcessHeap();
                HeapFree(v122, 0, (LPVOID)v89);
              }
              CloseHandle(v111);
              if ( (v193 & 1) != 0 )
              {
                v123 = CreateWaitableTimerExW(0LL, 0LL, 2u, 0x1F0003u);
                v124 = v202;
                if ( !v123 )
                  goto LABEL_240;
                v125 = v123;
                *(_QWORD *)Src = -1000000LL;
                if ( !SetWaitableTimer(v123, (const LARGE_INTEGER *)Src, 0, 0LL, 0LL, 0) )
                {
                  CloseHandle(v125);
                  goto LABEL_240;
                }
                v126 = WaitForSingleObject(v125, 0xFFFFFFFF);
                CloseHandle(v125);
                if ( v126 == -1 )
LABEL_240:
                  Sleep(0x64u);
                sub_4329C0((__int64)lpMem, (unsigned __int8 *)v194[1], v195);
                v139 = (WCHAR *)lpMem[1];
                if ( lpMem[0] == v124
                  || (*(_OWORD *)Src = *(_OWORD *)lpMem,
                      *(_QWORD *)&Src[16] = v175,
                      sub_432CE0(lpFileName, (__int128 *)Src),
                      v140 = lpFileName[0],
                      v139 = (WCHAR *)lpFileName[1],
                      lpFileName[0] == v124) )
                {
                  v141 = (unsigned __int64)v139;
                  goto LABEL_244;
                }
                if ( DeleteFileW(lpFileName[1]) )
                {
                  if ( v140 )
                  {
                    v142 = GetProcessHeap();
                    HeapFree(v142, 0, v139);
                  }
                  goto LABEL_251;
                }
                v141 = ((unsigned __int64)GetLastError() << 32) | 2;
                if ( v140 )
                {
                  v153 = GetProcessHeap();
                  HeapFree(v153, 0, v139);
                }
LABEL_244:
                if ( !v141 )
                {
LABEL_251:
                  lpMem[0] = v194;
                  lpMem[1] = sub_439250;
                  *(_QWORD *)Src = &off_442340;
                  *(_QWORD *)&Src[8] = 2LL;
                  *(_QWORD *)&Src[32] = 0LL;
                  *(_QWORD *)&Src[16] = lpMem;
                  *(_QWORD *)&Src[24] = 1LL;
                  sub_43B870(Src);
                  ++v204;
                  goto LABEL_267;
                }
                switch ( v141 & 3 )
                {
                  case 0uLL:
                    if ( *(_BYTE *)(v141 + 16) != 1 )
                      goto LABEL_269;
                    goto LABEL_265;
                  case 1uLL:
                    if ( *(_BYTE *)(v141 + 15) != 1 )
                      goto LABEL_269;
                    v143 = *(_QWORD **)(v141 - 1);
                    v144 = *(_QWORD *)(v141 + 7);
                    if ( *(_QWORD *)v144 )
                      (*(void (__fastcall **)(_QWORD))v144)(*(_QWORD *)(v141 - 1));
                    if ( *(_QWORD *)(v144 + 8) )
                    {
                      if ( *(_QWORD *)(v144 + 16) >= 0x11uLL )
                        v143 = (_QWORD *)*(v143 - 1);
                      v145 = GetProcessHeap();
                      HeapFree(v145, 0, v143);
                    }
                    v146 = GetProcessHeap();
                    HeapFree(v146, 0, (LPVOID)(v141 - 1));
                    goto LABEL_265;
                  case 2uLL:
                    if ( HIDWORD(v141) != 5 && HIDWORD(v141) != 10013 )
                      goto LABEL_269;
                    goto LABEL_265;
                  case 3uLL:
                    if ( (v141 & 0xFFFFFFFF00000000uLL) != 0x100000000LL )
                    {
LABEL_269:
                      v191 = v141;
                      v196 = (char *)v194;
                      v197 = (__int64)sub_439250;
                      v198 = &v191;
                      v199 = sub_439080;
                      lpMem[0] = &off_442380;
                      lpMem[1] = (LPVOID)3;
                      v176 = 0LL;
                      *(_QWORD *)&v175 = &v196;
                      *((_QWORD *)&v175 + 1) = 2LL;
                      v200 = (LPVOID *)aStderr;
                      v201 = 6LL;
                      v192 = &unk_450088;
                      *(_QWORD *)Src = &v192;
                      v147 = sub_43B390((__int64 **)Src, lpMem);
                      if ( v147 )
                      {
                        v184 = v147;
                        lpFileName[0] = (LPCWSTR)&v200;
                        lpFileName[1] = (LPCWSTR)sub_4123C0;
                        v182[0] = (size_t)&v184;
                        v182[1] = (size_t)sub_439080;
                        *(_QWORD *)Src = &off_448C90;
                        *(_QWORD *)&Src[8] = 2LL;
                        *(_QWORD *)&Src[32] = 0LL;
                        *(_QWORD *)&Src[16] = lpFileName;
                        *(_QWORD *)&Src[24] = 2LL;
                        sub_405240((__int64)Src, (__int64)&off_448CB0);
                      }
                      v148 = v191;
                      if ( (v191 & 3) == 1 )
                      {
                        v149 = *(_QWORD **)(v191 - 1);
                        v150 = *(_QWORD *)(v191 + 7);
                        if ( *(_QWORD *)v150 )
                          (*(void (__fastcall **)(_QWORD))v150)(*(_QWORD *)(v191 - 1));
                        if ( *(_QWORD *)(v150 + 8) )
                        {
                          if ( *(_QWORD *)(v150 + 16) >= 0x11uLL )
                            v149 = (_QWORD *)*(v149 - 1);
                          v151 = GetProcessHeap();
                          HeapFree(v151, 0, v149);
                        }
                        v152 = GetProcessHeap();
                        HeapFree(v152, 0, (LPVOID)(v148 - 1));
                      }
LABEL_267:
                      v131 = 1;
                      v130 = v186;
                      if ( !v190 )
                        goto LABEL_229;
                      goto LABEL_228;
                    }
LABEL_265:
                    lpMem[0] = v194;
                    lpMem[1] = sub_439250;
                    v138 = &off_442300;
                    break;
                }
              }
              else
              {
                lpMem[0] = v194;
                lpMem[1] = sub_439250;
                v138 = &off_4422B0;
              }
              *(_QWORD *)Src = v138;
              *(_QWORD *)&Src[8] = 2LL;
              *(_QWORD *)&Src[32] = 0LL;
              *(_QWORD *)&Src[16] = lpMem;
              *(_QWORD *)&Src[24] = 1LL;
              sub_43B870(Src);
              goto LABEL_267;
            }
            CloseHandle(v86);
          }
          LastError = GetLastError();
          v200 = v194;
          v201 = (__int64)sub_439250;
          lpMem[0] = &off_4423D0;
          lpMem[1] = (LPVOID)2;
          v176 = 0LL;
          *(_QWORD *)&v175 = &v200;
          *((_QWORD *)&v175 + 1) = 1LL;
          v196 = aStderr;
          v197 = 6LL;
          v192 = &unk_450088;
          *(_QWORD *)Src = &v192;
          v129 = sub_43B390((__int64 **)Src, lpMem);
          if ( v129 )
          {
            v184 = v129;
            lpFileName[0] = (LPCWSTR)&v196;
            lpFileName[1] = (LPCWSTR)sub_4123C0;
            v182[0] = (size_t)&v184;
            v182[1] = (size_t)sub_439080;
            *(_QWORD *)Src = &off_448C90;
            *(_QWORD *)&Src[8] = 2LL;
            *(_QWORD *)&Src[32] = 0LL;
            *(_QWORD *)&Src[16] = lpFileName;
            *(_QWORD *)&Src[24] = 2LL;
            sub_405240((__int64)Src, (__int64)&off_448CB0);
          }
          v130 = (LastError << 32) | 2;
          v131 = 0;
          v186 = v130;
          if ( !v190 )
            goto LABEL_229;
LABEL_228:
          v132 = GetProcessHeap();
          HeapFree(v132, 0, v209);
          v130 = v186;
LABEL_229:
          if ( !v131 && (v130 & 3) == 1 )
          {
            v133 = *(_QWORD **)(v130 - 1);
            v134 = *(_QWORD *)(v130 + 7);
            if ( *(_QWORD *)v134 )
              (*(void (__fastcall **)(_QWORD))v134)(*(_QWORD *)(v130 - 1));
            if ( *(_QWORD *)(v134 + 8) )
            {
              if ( *(_QWORD *)(v134 + 16) >= 0x11uLL )
                v133 = (_QWORD *)*(v133 - 1);
              v135 = GetProcessHeap();
              HeapFree(v135, 0, v133);
            }
            v136 = (void *)(v186 - 1);
            v137 = GetProcessHeap();
            HeapFree(v137, 0, v136);
          }
          goto LABEL_142;
        }
LABEL_133:
        v191 = v66;
        v196 = (char *)v194;
        v197 = (__int64)sub_439250;
        v198 = &v191;
        v199 = sub_439080;
        lpMem[0] = &off_442438;
        lpMem[1] = (LPVOID)3;
        v176 = 0LL;
        *(_QWORD *)&v175 = &v196;
        *((_QWORD *)&v175 + 1) = 2LL;
        v200 = (LPVOID *)aStderr;
        v201 = 6LL;
        v192 = &unk_450088;
        *(_QWORD *)Src = &v192;
        v76 = sub_43B390((__int64 **)Src, lpMem);
        if ( v76 )
        {
          v184 = v76;
          lpFileName[0] = (LPCWSTR)&v200;
          lpFileName[1] = (LPCWSTR)sub_4123C0;
          v182[0] = (size_t)&v184;
          v182[1] = (size_t)sub_439080;
          *(_QWORD *)Src = &off_448C90;
          *(_QWORD *)&Src[8] = 2LL;
          *(_QWORD *)&Src[32] = 0LL;
          *(_QWORD *)&Src[16] = lpFileName;
          *(_QWORD *)&Src[24] = 2LL;
          sub_405240((__int64)Src, (__int64)&off_448CB0);
        }
        v77 = v191;
        if ( (v191 & 3) == 1 )
        {
          v78 = *(_QWORD **)(v191 - 1);
          v79 = *(_QWORD *)(v191 + 7);
          if ( *(_QWORD *)v79 )
            (*(void (__fastcall **)(_QWORD))v79)(*(_QWORD *)(v191 - 1));
          if ( *(_QWORD *)(v79 + 8) )
          {
            if ( *(_QWORD *)(v79 + 16) >= 0x11uLL )
              v78 = (_QWORD *)*(v78 - 1);
            v80 = GetProcessHeap();
            HeapFree(v80, 0, v78);
          }
          v57 = (void *)(v77 - 1);
LABEL_99:
          v60 = GetProcessHeap();
          HeapFree(v60, 0, v57);
        }
LABEL_142:
        if ( v194[0] )
        {
          v81 = v194[1];
          v82 = GetProcessHeap();
          HeapFree(v82, 0, v81);
        }
        if ( !_InterlockedDecrement64(*(volatile signed __int64 **)FindFileData) )
          sub_4371C0(*(LPVOID *)FindFileData);
        v29 = 0;
        break;
    }
  }
}
// 401B5F: variable 'v1' is possibly undefined
// 401D5A: variable 'v2' is possibly undefined
// 401DC0: variable 'v0' is possibly undefined
// 401EFE: variable 'v46' is possibly undefined
// 402059: variable 'v53' is possibly undefined
// 402366: variable 'v73' is possibly undefined
// 4029CA: variable 'v119' is possibly undefined
// 4034B1: variable 'v169' is possibly undefined
// 4421D0: using guessed type char *off_4421D0;
// 4421F8: using guessed type char *off_4421F8;
// 442238: using guessed type char *off_442238;
// 442278: using guessed type char *off_442278;
// 4422B0: using guessed type char *off_4422B0;
// 442300: using guessed type char *off_442300;
// 442340: using guessed type char *off_442340;
// 442380: using guessed type char *off_442380;
// 4423D0: using guessed type char *off_4423D0;
// 442408: using guessed type char *off_442408;
// 442438: using guessed type char *off_442438;
// 442498: using guessed type char *off_442498;
// 447C90: using guessed type char *off_447C90;
// 447E80: using guessed type char *off_447E80;
// 448C90: using guessed type char *off_448C90;
// 448CB0: using guessed type char *off_448CB0;
// 449A78: using guessed type char asc_449A78;
// 449FD8: using guessed type char *off_449FD8;

//----- (0000000000403AA0) ----------------------------------------------------
__int64 sub_403AA0()
{
  HANDLE CurrentThread; // rax
  LPVOID Value; // rax
  LPVOID v2; // rax
  __int64 v3; // rbx
  __int64 v4; // rsi
  __int64 v5; // rdi
  int v6; // ecx
  DWORD v7; // ecx
  __int64 result; // rax
  DWORD v9; // eax
  DWORD v10; // eax
  DWORD v11; // eax
  void *v12; // rdi
  DWORD v13; // ecx
  unsigned int v14; // esi
  __int64 v15; // [rsp+28h] [rbp-58h] BYREF
  void (__fastcall __noreturn *v16)(); // [rsp+30h] [rbp-50h] BYREF
  _QWORD v17[2]; // [rsp+38h] [rbp-48h] BYREF
  ULONG StackSizeInBytes[2]; // [rsp+48h] [rbp-38h] BYREF
  __int64 v19; // [rsp+50h] [rbp-30h]
  __int64 *v20; // [rsp+58h] [rbp-28h]
  __int128 v21; // [rsp+60h] [rbp-20h]
  int v22; // [rsp+78h] [rbp-8h] BYREF
  char v23; // [rsp+7Ch] [rbp-4h]
  __int64 v24; // [rsp+80h] [rbp+0h] BYREF

  sub_43D690();
  v16 = sub_401690;
  AddVectoredExceptionHandler(0, (PVECTORED_EXCEPTION_HANDLER)Handler);
  StackSizeInBytes[0] = 20480;
  SetThreadStackGuarantee(StackSizeInBytes);
  CurrentThread = GetCurrentThread();
  off_43F020((__int64)CurrentThread, (__int64)L"main");
  if ( dword_450100 )
  {
    Value = TlsGetValue(dword_450100 - 1);
    if ( Value )
      goto LABEL_4;
    goto LABEL_3;
  }
  v9 = sub_412510((signed __int64)&unk_4500E8);
  Value = TlsGetValue(v9);
  if ( !Value )
LABEL_3:
    Value = sub_437520();
LABEL_4:
  byte_450040 = 0;
  qword_450038 = (__int64)Value;
  *(_QWORD *)StackSizeInBytes = 0LL;
  v19 = (__int64)&qword_450038;
  if ( dword_450120 )
  {
    if ( !TlsGetValue(dword_450120 - 1) )
      goto LABEL_6;
LABEL_16:
    v3 = *(_QWORD *)StackSizeInBytes;
    v4 = v19;
LABEL_17:
    v17[0] = v3;
    v17[1] = v4;
    v22 = 0;
    v23 = 0;
    *(_QWORD *)StackSizeInBytes = &off_4484F0;
    v19 = 1LL;
    v20 = &v24;
    v21 = 0LL;
    v15 = sub_412270((__int64)&v22, StackSizeInBytes);
    sub_4123A0(&v15);
    __fastfail(7u);
  }
  v10 = sub_412510((signed __int64)&unk_450108);
  if ( TlsGetValue(v10) )
    goto LABEL_16;
LABEL_6:
  if ( dword_450100 )
  {
    v2 = TlsGetValue(dword_450100 - 1);
    if ( v2 )
      goto LABEL_8;
LABEL_19:
    v12 = *(void **)(v19 + 16LL * *(_QWORD *)StackSizeInBytes);
    if ( dword_450100 )
      v13 = dword_450100 - 1;
    else
      v13 = sub_412510((signed __int64)&unk_4500E8);
    TlsSetValue(v13, v12);
    v4 = v19;
    v5 = 16 * (StackSizeInBytes[0] & 1);
    v6 = dword_450120;
    if ( dword_450120 )
      goto LABEL_10;
    goto LABEL_22;
  }
  v11 = sub_412510((signed __int64)&unk_4500E8);
  v2 = TlsGetValue(v11);
  if ( !v2 )
    goto LABEL_19;
LABEL_8:
  v3 = *(_QWORD *)StackSizeInBytes;
  v4 = v19;
  v5 = 16LL * *(_QWORD *)StackSizeInBytes;
  if ( *(LPVOID *)(v19 + 16LL * *(_QWORD *)StackSizeInBytes) != v2 )
    goto LABEL_17;
  v6 = dword_450120;
  if ( dword_450120 )
  {
LABEL_10:
    v7 = v6 - 1;
    goto LABEL_11;
  }
LABEL_22:
  v7 = sub_412510((signed __int64)&unk_450108);
LABEL_11:
  TlsSetValue(v7, (LPVOID)(v5 + v4));
  result = sub_401560((__int64 (**)(void))&v16);
  if ( dword_450034 != 3 )
  {
    v14 = result;
    LOBYTE(v17[0]) = 1;
    *(_QWORD *)StackSizeInBytes = v17;
    sub_437590(&dword_450034, 0, (__int64)StackSizeInBytes, (__int64)&unk_448FB0, (__int64)&off_448518);
    return v14;
  }
  return result;
}
// 43F020: using guessed type __int64 (__fastcall *off_43F020)(__int64 a1, __int64 a2);
// 4484F0: using guessed type char *off_4484F0;
// 449F00: using guessed type wchar_t aMain[5];
// 450034: using guessed type int dword_450034;
// 450038: using guessed type __int64 qword_450038;
// 450040: using guessed type char byte_450040;
// 450100: using guessed type int dword_450100;
// 450120: using guessed type int dword_450120;
// 453040: using guessed type __int64 (__fastcall *TlsCallbacks[3])();

//----- (0000000000403D80) ----------------------------------------------------
BOOL __fastcall sub_403D80(_QWORD *lpMem, unsigned __int64 a2)
{
  void *v2; // rsi
  HANDLE ProcessHeap; // rax

  v2 = lpMem;
  if ( a2 >= 0x11 )
    v2 = (void *)*(lpMem - 1);
  ProcessHeap = GetProcessHeap();
  return HeapFree(ProcessHeap, 0, v2);
}

//----- (0000000000403DB0) ----------------------------------------------------
void __fastcall __noreturn sub_403DB0(__int64 a1, __int64 a2)
{
  sub_43CC70(a1, a2);
}

//----- (0000000000403DBA) ----------------------------------------------------
unsigned __int64 __fastcall sub_403DBA(unsigned __int64 *a1, __int64 a2, __int64 a3)
{
  unsigned __int64 result; // rax
  __int64 v4; // rdx

  result = sub_409621(a1, a2, a3, 1LL, 1LL);
  if ( result != 0x8000000000000001uLL )
    sub_40408F(result, v4, (__int64)&off_447E80);
  return result;
}
// 403DF7: variable 'v4' is possibly undefined
// 447E80: using guessed type char *off_447E80;

//----- (0000000000403DFD) ----------------------------------------------------
unsigned int __fastcall sub_403DFD(signed __int64 *a1, _BYTE *a2, __int64 a3)
{
  void *v6; // rax
  signed __int64 v7; // r14
  unsigned int result; // eax
  void *v9; // rbx
  HANDLE ProcessHeap; // rax
  __int64 v11; // r15
  unsigned __int64 v12; // r14
  bool v13; // al
  char v14; // r12
  __int64 v15; // rcx

  if ( a3 && (*a2 == 47 || sub_403F44((__int64)a2, a3)) )
  {
    if ( a3 < 0 )
    {
      v15 = 0LL;
    }
    else
    {
      v6 = sub_43C4F0(a3);
      if ( v6 )
      {
        v7 = (signed __int64)v6;
        result = (unsigned int)memcpy(v6, a2, a3);
        if ( *a1 )
        {
          v9 = (void *)a1[1];
          ProcessHeap = GetProcessHeap();
          result = HeapFree(ProcessHeap, 0, v9);
        }
        *a1 = a3;
        a1[1] = v7;
        a1[2] = a3;
        return result;
      }
      v15 = 1LL;
    }
    sub_40408F(v15, a3, (__int64)&off_447C90);
  }
  v11 = a1[1];
  v12 = a1[2];
  v13 = sub_403F44(v11, v12);
  if ( v12 )
  {
    v14 = 47;
    if ( v13 )
      v14 = 92;
    if ( v14 != *(_BYTE *)(v11 + v12 - 1) )
    {
      if ( v12 == *a1 )
      {
        sub_403F80(a1, (__int64)&off_447DD0);
        v11 = a1[1];
      }
      *(_BYTE *)(v11 + v12++) = v14;
      a1[2] = v12;
    }
  }
  else
  {
    v12 = 0LL;
  }
  if ( *a1 - v12 < a3 )
  {
    sub_403DBA((unsigned __int64 *)a1, v12, a3);
    v11 = a1[1];
    v12 = a1[2];
  }
  result = (unsigned int)memcpy((void *)(v12 + v11), a2, a3);
  a1[2] += a3;
  return result;
}
// 447C90: using guessed type char *off_447C90;
// 447DD0: using guessed type char *off_447DD0;

//----- (0000000000403F44) ----------------------------------------------------
bool __fastcall sub_403F44(__int64 a1, unsigned __int64 a2)
{
  bool result; // al

  if ( a2 )
  {
    result = 1;
    if ( *(_BYTE *)a1 == 92 )
      return result;
    if ( a2 != 1 && *(char *)(a1 + 1) >= -64 )
    {
      if ( a2 > 3 )
      {
        if ( *(char *)(a1 + 3) < -64 )
          return 0;
      }
      else if ( a2 != 3 )
      {
        return 0;
      }
      return *(_WORD *)(a1 + 1) == 23610;
    }
  }
  return 0;
}

//----- (0000000000403F80) ----------------------------------------------------
__int64 __fastcall sub_403F80(signed __int64 *a1, __int64 a2)
{
  __int64 v2; // rsi
  signed __int64 v3; // rax
  unsigned __int64 v5; // rcx
  signed __int64 v6; // rbx
  __int64 v7; // rax
  __int64 result; // rax
  _QWORD v9[3]; // [rsp+28h] [rbp-28h] BYREF
  __int64 v10; // [rsp+40h] [rbp-10h] BYREF
  __int64 v11; // [rsp+48h] [rbp-8h]
  __int64 v12; // [rsp+50h] [rbp+0h]

  v2 = a2;
  v3 = *a1;
  if ( *a1 == -1 )
    goto LABEL_12;
  v5 = v3 + 1;
  a2 = 2 * v3;
  if ( 2 * v3 > (unsigned __int64)(v3 + 1) )
    v5 = 2 * v3;
  v6 = 8LL;
  if ( v5 >= 9 )
    v6 = v5;
  if ( v6 < 0 )
LABEL_12:
    sub_40408F(0LL, a2, v2);
  if ( v3 )
  {
    v9[0] = a1[1];
    v9[2] = v3;
    v7 = 1LL;
  }
  else
  {
    v7 = 0LL;
  }
  v9[1] = v7;
  sub_404020(&v10, v6, (__int64)v9);
  if ( (_DWORD)v10 == 1 )
    sub_40408F(v11, v12, v2);
  result = v11;
  a1[1] = v11;
  *a1 = v6;
  return result;
}

//----- (0000000000404020) ----------------------------------------------------
LPVOID __fastcall sub_404020(_QWORD *a1, SIZE_T a2, __int64 a3)
{
  void *v5; // rbx
  HANDLE ProcessHeap; // rax
  LPVOID result; // rax
  __int64 v8; // rcx
  __int64 v9; // rdx

  if ( *(_QWORD *)(a3 + 8) && *(_QWORD *)(a3 + 16) )
  {
    v5 = *(void **)a3;
    ProcessHeap = GetProcessHeap();
    result = HeapReAlloc(ProcessHeap, 0, v5, a2);
  }
  else
  {
    result = sub_43C4F0(a2);
  }
  v8 = 0LL;
  v9 = 1LL;
  if ( result )
    v9 = (__int64)result;
  LOBYTE(v8) = result == 0LL;
  a1[1] = v9;
  a1[2] = a2;
  *a1 = v8;
  return result;
}

//----- (000000000040408F) ----------------------------------------------------
void __fastcall __noreturn sub_40408F(__int64 a1, __int64 a2, __int64 a3)
{
  if ( !a1 )
    sub_4040B0(a3);
  sub_4040E9(a1, a2);
}

//----- (00000000004040B0) ----------------------------------------------------
void __fastcall __noreturn sub_4040B0(__int64 a1)
{
  _QWORD v1[7]; // [rsp+0h] [rbp-50h] BYREF
  __int128 v2; // [rsp+38h] [rbp-18h]

  v1[4] = &off_442538;
  v1[5] = 1LL;
  v1[6] = 8LL;
  v2 = 0LL;
  sub_405240(&v1[4], a1);
}
// 405240: using guessed type void __fastcall __noreturn sub_405240(_QWORD, _QWORD);
// 442538: using guessed type char *off_442538;

//----- (00000000004040E9) ----------------------------------------------------
void __fastcall __noreturn sub_4040E9(__int64 a1, __int64 a2)
{
  sub_403DB0(a2, a1);
}

//----- (0000000000404110) ----------------------------------------------------
__int64 __fastcall sub_404110(signed __int64 *a1, __int64 a2, __int64 a3)
{
  bool v3; // cf
  unsigned __int64 v4; // rdx
  signed __int64 v6; // rax
  unsigned __int64 v7; // rcx
  signed __int64 v8; // rdi
  __int64 v9; // rax
  __int64 result; // rax
  _QWORD v11[3]; // [rsp+20h] [rbp-30h] BYREF
  __int64 v12; // [rsp+38h] [rbp-18h] BYREF
  __int64 v13; // [rsp+40h] [rbp-10h]
  __int64 v14; // [rsp+48h] [rbp-8h]

  v3 = __CFADD__(a3, a2);
  v4 = a3 + a2;
  if ( v3 )
    goto LABEL_12;
  v6 = *a1;
  v7 = 2 * *a1;
  if ( v7 > v4 )
    v4 = v7;
  v8 = 8LL;
  if ( v4 >= 9 )
    v8 = v4;
  if ( v8 < 0 )
LABEL_12:
    sub_40408F(0LL, v4, (__int64)&off_442568);
  if ( v6 )
  {
    v11[0] = a1[1];
    v11[2] = v6;
    v9 = 1LL;
  }
  else
  {
    v9 = 0LL;
  }
  v11[1] = v9;
  sub_404020(&v12, v8, (__int64)v11);
  if ( (_DWORD)v12 == 1 )
    sub_40408F(v13, v14, (__int64)&off_442568);
  result = v13;
  a1[1] = v13;
  *a1 = v8;
  return result;
}
// 442568: using guessed type char *off_442568;

//----- (00000000004041B0) ----------------------------------------------------
unsigned __int64 __fastcall sub_4041B0(_QWORD *a1, __int64 a2, char *a3)
{
  char *v3; // r12
  __int64 v5; // r15
  size_t v6; // r14
  LPVOID v7; // rax
  __int64 v8; // rdi
  unsigned __int64 result; // rax
  __int64 v10; // rbx
  __int64 v11; // rbx
  __int64 v12; // rbx
  void *v13; // r13
  size_t v14; // r12
  __int64 v15; // rsi
  _OWORD *v16; // rcx
  _BYTE v17[40]; // [rsp+0h] [rbp-80h] BYREF
  __int128 v18; // [rsp+28h] [rbp-58h] BYREF
  void *Src; // [rsp+38h] [rbp-48h] BYREF
  size_t Size; // [rsp+40h] [rbp-40h]
  __int64 v21; // [rsp+50h] [rbp-30h]
  __int128 v22; // [rsp+58h] [rbp-28h]
  _QWORD *v23; // [rsp+68h] [rbp-18h]
  LPVOID lpMem[2]; // [rsp+70h] [rbp-10h] BYREF
  __int64 v25; // [rsp+80h] [rbp+0h]

  v3 = a3;
  *(_QWORD *)&v22 = a2;
  *((_QWORD *)&v22 + 1) = a3;
  sub_4088C0(&v17[56], (__int64 *)&v17[88]);
  v5 = (__int64)Src;
  if ( !Src )
  {
    v5 = 1LL;
    v6 = 0LL;
    goto LABEL_8;
  }
  v6 = Size;
  if ( !v21 )
  {
LABEL_8:
    a1[1] = v5;
    a1[2] = v6;
    result = 0x8000000000000000uLL;
    *a1 = 0x8000000000000000uLL;
    return result;
  }
  if ( (__int64)v3 < 0 )
    sub_4040B0((__int64)&off_4425B8);
  if ( v3 )
  {
    v7 = sub_43C4F0((SIZE_T)v3);
    if ( !v7 )
      sub_4040E9(1LL, (__int64)v3);
    v8 = (__int64)v7;
  }
  else
  {
    v8 = 1LL;
  }
  lpMem[0] = v3;
  lpMem[1] = (LPVOID)v8;
  v25 = 0LL;
  if ( v6 > (unsigned __int64)v3 )
  {
    sub_404110((signed __int64 *)lpMem, 0LL, v6);
    v10 = v25;
    v3 = (char *)lpMem[0];
    v8 = (__int64)lpMem[1];
  }
  else
  {
    v10 = 0LL;
  }
  memcpy((void *)(v8 + v10), (const void *)v5, v6);
  v11 = v6 + v10;
  v25 = v11;
  v23 = a1;
  if ( (unsigned __int64)&v3[-v11] <= 2 )
  {
    sub_404110((signed __int64 *)lpMem, v11, 3LL);
    v8 = (__int64)lpMem[1];
    v11 = v25;
  }
  *(_BYTE *)(v8 + v11 + 2) = -67;
  *(_WORD *)(v8 + v11) = -16401;
  v12 = v11 + 3;
  v25 = v12;
  v18 = v22;
  while ( 1 )
  {
    sub_4088C0(&Src, (__int64 *)&v18);
    v13 = Src;
    if ( !Src )
      break;
    v14 = Size;
    v15 = v21;
    if ( (char *)lpMem[0] - v12 < (LPVOID)Size )
    {
      sub_404110((signed __int64 *)lpMem, v12, Size);
      v8 = (__int64)lpMem[1];
      v12 = v25;
    }
    memcpy((void *)(v8 + v12), v13, v14);
    v12 += v14;
    v25 = v12;
    if ( v15 )
    {
      if ( (unsigned __int64)lpMem[0] - v12 <= 2 )
      {
        sub_404110((signed __int64 *)lpMem, v12, 3LL);
        v8 = (__int64)lpMem[1];
        v12 = v25;
      }
      *(_BYTE *)(v8 + v12 + 2) = -67;
      *(_WORD *)(v8 + v12) = -16401;
      v12 += 3LL;
      v25 = v12;
    }
  }
  result = v25;
  v16 = v23;
  v23[2] = v25;
  *v16 = *(_OWORD *)lpMem;
  return result;
}
// 4425B8: using guessed type char *off_4425B8;

//----- (0000000000404400) ----------------------------------------------------
__int64 __fastcall sub_404400(__int64 a1, __int64 *a2)
{
  unsigned __int64 v4; // rdx
  __int64 v5; // rax
  unsigned __int64 v6; // rcx
  __int64 v7; // rbx
  __int64 v8; // r8
  unsigned __int64 v9; // rdx
  _QWORD *v10; // r9
  __int64 v11; // rdx
  __int64 v12; // rcx
  __int64 v13; // r8
  bool v14; // al
  __int64 v15; // rax
  __int64 result; // rax
  LPVOID lpMem[2]; // [rsp+28h] [rbp-18h] BYREF
  __int64 v18; // [rsp+38h] [rbp-8h]
  _BYTE v19[25]; // [rsp+47h] [rbp+7h] BYREF

  v4 = a2[1];
  if ( !v4 )
    goto LABEL_17;
  v5 = *a2;
  v6 = v4 & 3;
  if ( v4 >= 4 )
  {
    v9 = v4 & 0xFFFFFFFFFFFFFFFCuLL;
    v10 = (_QWORD *)(v5 + 56);
    v7 = 0LL;
    v8 = 0LL;
    do
    {
      v7 += *v10 + *(v10 - 2) + *(v10 - 4) + *(v10 - 6);
      v8 += 4LL;
      v10 += 8;
    }
    while ( v9 != v8 );
  }
  else
  {
    v7 = 0LL;
    v8 = 0LL;
  }
  if ( v6 )
  {
    v11 = 16 * v8 + v5 + 8;
    v12 = (unsigned int)(16 * v6);
    v13 = 0LL;
    do
    {
      v7 += *(_QWORD *)(v11 + v13);
      v13 += 16LL;
    }
    while ( v12 != v13 );
  }
  if ( a2[3] )
  {
    v14 = *(_QWORD *)(v5 + 8) == 0LL;
    if ( v7 >= 0 && (!v14 || (unsigned __int64)v7 >= 0x10) )
    {
      v7 *= 2LL;
      goto LABEL_13;
    }
LABEL_17:
    v15 = 1LL;
    v7 = 0LL;
    goto LABEL_18;
  }
LABEL_13:
  if ( v7 < 0 )
    sub_4040B0((__int64)&off_4425B8);
  if ( !v7 )
    goto LABEL_17;
  v15 = (__int64)sub_43C4F0(v7);
  if ( !v15 )
    sub_4040E9(1LL, v7);
LABEL_18:
  lpMem[0] = (LPVOID)v7;
  lpMem[1] = (LPVOID)v15;
  v18 = 0LL;
  if ( sub_406180((__int64)lpMem, (__int64)&off_4424F0, a2) )
    sub_406F40((__int64)aAFormattingTra, 86LL, (__int64)v19, (__int64)&unk_4424D0, (__int64)&off_4425E8);
  result = v18;
  *(_QWORD *)(a1 + 16) = v18;
  *(_OWORD *)a1 = *(_OWORD *)lpMem;
  return result;
}
// 4424F0: using guessed type __int64 (__fastcall *off_4424F0)();
// 4425B8: using guessed type char *off_4425B8;
// 4425E8: using guessed type char *off_4425E8;

//----- (0000000000404590) ----------------------------------------------------
__int64 __fastcall sub_404590(__int64 a1, __int64 a2)
{
  return (*(__int64 (__fastcall **)(_QWORD, const char *, __int64))(*(_QWORD *)(a2 + 56) + 24LL))(
           *(_QWORD *)(a2 + 48),
           aError_0,
           5LL);
}

//----- (00000000004045C0) ----------------------------------------------------
void __fastcall sub_4045C0(_QWORD *a1)
{
  void *v1; // rsi
  HANDLE ProcessHeap; // rax

  if ( *a1 )
  {
    v1 = (void *)a1[1];
    ProcessHeap = GetProcessHeap();
    HeapFree(ProcessHeap, 0, v1);
  }
}

//----- (0000000000404600) ----------------------------------------------------
__int64 __fastcall sub_404600(signed __int64 *a1, const void *a2, size_t a3)
{
  signed __int64 v5; // rbx
  const void *v7; // r14

  v5 = a1[2];
  if ( *a1 - v5 < a3 )
  {
    v7 = a2;
    sub_404110(a1, a1[2], a3);
    a2 = v7;
    v5 = a1[2];
  }
  memcpy((void *)(v5 + a1[1]), a2, a3);
  a1[2] = a3 + v5;
  return 0LL;
}

//----- (0000000000404670) ----------------------------------------------------
__int64 __fastcall sub_404670(signed __int64 *a1, unsigned int a2)
{
  signed __int64 v3; // rdi
  char v4; // bl
  _BYTE *v5; // rax
  size_t v6; // rdi
  signed __int64 v7; // rbx
  _DWORD Src[7]; // [rsp+24h] [rbp+4h] BYREF

  if ( a2 >= 0x80 )
  {
    Src[0] = 0;
    if ( a2 >= 0x800 )
    {
      if ( a2 >= 0x10000 )
      {
        v5 = (char *)Src + 3;
        LOBYTE(Src[0]) = (a2 >> 18) | 0xF0;
        BYTE1(Src[0]) = (a2 >> 12) & 0x3F | 0x80;
        BYTE2(Src[0]) = (a2 >> 6) & 0x3F | 0x80;
        v6 = 4LL;
      }
      else
      {
        v5 = (char *)Src + 2;
        LOBYTE(Src[0]) = (a2 >> 12) | 0xE0;
        BYTE1(Src[0]) = (a2 >> 6) & 0x3F | 0x80;
        v6 = 3LL;
      }
    }
    else
    {
      v5 = (char *)Src + 1;
      LOBYTE(Src[0]) = (a2 >> 6) | 0xC0;
      v6 = 2LL;
    }
    *v5 = a2 & 0x3F | 0x80;
    v7 = a1[2];
    if ( *a1 - v7 < v6 )
    {
      sub_404110(a1, a1[2], v6);
      v7 = a1[2];
    }
    memcpy((void *)(v7 + a1[1]), Src, v6);
    a1[2] = v6 + v7;
  }
  else
  {
    v3 = a1[2];
    if ( v3 == *a1 )
    {
      v4 = a2;
      sub_403F80(a1, (__int64)&off_442648);
      LOBYTE(a2) = v4;
    }
    *(_BYTE *)(a1[1] + v3) = a2;
    a1[2] = v3 + 1;
  }
  return 0LL;
}
// 442648: using guessed type char *off_442648;

//----- (0000000000404790) ----------------------------------------------------
char __fastcall sub_404790(__int64 a1, _QWORD *a2)
{
  return sub_406180(a1, (__int64)&off_4424F0, a2);
}
// 4424F0: using guessed type __int64 (__fastcall *off_4424F0)();

//----- (00000000004047B0) ----------------------------------------------------
LPVOID __fastcall sub_4047B0(_QWORD *a1, char *a2, __int64 a3)
{
  __int64 v4; // rax
  __int64 v5; // rdx
  __m128i si128; // xmm0
  __m128i v7; // xmm1
  __m128i v8; // xmm2
  unsigned __int64 i; // r14
  __int64 v10; // r9
  __m128i v11; // xmm3
  __m128i v12; // xmm4
  _BYTE *v13; // r8
  char *v14; // rcx
  __int64 v15; // r13
  LPVOID result; // rax
  unsigned __int8 *v17; // r14
  __int64 v18; // rbx
  unsigned __int8 *v19; // rsi
  unsigned int v20; // r15d
  int v21; // eax
  int v22; // r8d
  int v23; // edx
  unsigned __int8 *v24; // r9
  unsigned __int64 v25; // rsi
  __int64 v26; // rax
  __int64 v27; // rcx
  __int64 v28; // rax
  __int64 v29; // rcx
  __int64 v30; // rax
  __int64 v31; // rcx
  __int64 v32; // rax
  __int64 v33; // rcx
  __int64 v34; // rax
  __int64 v35; // rcx
  __int64 v36; // rax
  unsigned int v37; // ecx
  unsigned __int64 v38; // rax
  unsigned __int64 v39; // rsi
  _BYTE *v40; // rax
  char *v41; // rdi
  char v42; // r15
  signed int v43; // r12d
  char v44; // cl
  char v45; // dl
  char v46; // r8
  int v47; // edx
  int v48; // ecx
  unsigned __int64 v49; // rsi
  char *v50; // rdi
  unsigned __int8 *v51; // rsi
  char v52; // al
  unsigned int v53; // r12d
  int v54; // ecx
  int v55; // r8d
  int v56; // edx
  _BYTE *v57; // rax
  unsigned __int8 *v59; // [rsp+30h] [rbp-50h]
  unsigned __int8 *v60; // [rsp+38h] [rbp-48h]
  unsigned __int8 *v61; // [rsp+40h] [rbp-40h]
  unsigned __int64 v62; // [rsp+48h] [rbp-38h]
  char **v63; // [rsp+50h] [rbp-30h]
  unsigned __int64 v64; // [rsp+58h] [rbp-28h]
  signed __int64 v66; // [rsp+68h] [rbp-18h] BYREF
  LPVOID lpMem; // [rsp+70h] [rbp-10h]
  __int64 v68; // [rsp+78h] [rbp-8h]
  _DWORD Src[15]; // [rsp+84h] [rbp+4h] BYREF

  if ( a3 < 0 )
    sub_4040B0((__int64)&off_442630);
  if ( a3 )
  {
    v4 = (__int64)sub_43C4F0(a3);
    if ( !v4 )
      sub_4040E9(1LL, a3);
    v5 = 0LL;
    if ( (unsigned __int64)a3 < 0x10 )
    {
      v14 = a2;
      i = a3;
      v13 = (_BYTE *)v4;
LABEL_13:
      v15 = v5;
      v5 += i;
      while ( *v14 >= 0 )
      {
        *v13 = *v14 | (32 * ((unsigned __int8)(*v14 - 65) < 0x1Au));
        ++v15;
        ++v14;
        ++v13;
        if ( !--i )
          goto LABEL_16;
      }
      v66 = a3;
      lpMem = (LPVOID)v4;
      v68 = v15;
      v17 = (unsigned __int8 *)&v14[i];
      v64 = a3;
      v59 = (unsigned __int8 *)&a2[a3];
      v62 = 0LL;
      v63 = &off_442600;
      v18 = v15;
      v19 = 0LL;
      while ( 1 )
      {
        v20 = (unsigned __int8)*v14;
        if ( (v20 & 0x80u) == 0 )
          break;
        v21 = v20 & 0x1F;
        v22 = v14[1] & 0x3F;
        if ( (unsigned __int8)v20 <= 0xDFu )
        {
          v24 = (unsigned __int8 *)(v14 + 2);
          v20 = v22 | (v21 << 6);
        }
        else
        {
          v23 = (v22 << 6) | v14[2] & 0x3F;
          if ( (unsigned __int8)v20 < 0xF0u )
          {
            v24 = (unsigned __int8 *)(v14 + 3);
            v20 = (v21 << 12) | v23;
          }
          else
          {
            v24 = (unsigned __int8 *)(v14 + 4);
            v20 = ((v20 & 7) << 18) | (v23 << 6) | v14[3] & 0x3F;
          }
        }
        v60 = v24;
        v61 = &v24[v19 - (unsigned __int8 *)v14];
        if ( v20 == 931 )
        {
          v25 = (unsigned __int64)&v19[v15];
          if ( v25 )
          {
            if ( v25 >= v64 )
            {
              if ( v25 != v64 )
                goto LABEL_123;
            }
            else if ( a2[v25] <= -65 )
            {
              goto LABEL_123;
            }
          }
          v41 = &a2[v25];
          do
          {
            v42 = -61;
            if ( v41 == a2 )
              goto LABEL_112;
            v43 = *(v41 - 1);
            if ( v43 < 0 )
            {
              v44 = *(v41 - 2);
              if ( v44 >= -64 )
              {
                v41 -= 2;
                v48 = v44 & 0x1F;
              }
              else
              {
                v45 = *(v41 - 3);
                if ( v45 > -65 )
                {
                  v41 -= 3;
                  v47 = v45 & 0xF;
                }
                else
                {
                  v46 = *(v41 - 4);
                  v41 -= 4;
                  v47 = ((v46 & 7) << 6) | v45 & 0x3F;
                }
                v48 = (v47 << 6) | v44 & 0x3F;
              }
              v43 = (v48 << 6) | v43 & 0x3F;
              if ( v43 == 1114112 )
                goto LABEL_112;
            }
            else
            {
              --v41;
            }
          }
          while ( sub_408C00(v43) );
          if ( sub_408D80(v43) )
          {
            v49 = v25 + 2;
            if ( v49 )
            {
              if ( v49 >= v64 )
              {
                if ( v49 != v64 )
                {
LABEL_122:
                  v62 = v49;
                  v25 = v64;
                  v63 = &off_442618;
LABEL_123:
                  sub_4079A0(a2, v64, v62, v25, (__int64)v63);
                }
              }
              else if ( a2[v49] < -64 )
              {
                goto LABEL_122;
              }
            }
            v51 = (unsigned __int8 *)&a2[v49];
            v52 = 0;
            while ( 2 )
            {
              while ( 2 )
              {
                v42 = -62;
                if ( v51 == v59 )
                  goto LABEL_112;
                v53 = *v51;
                if ( (v53 & 0x80u) != 0 )
                {
                  v54 = v53 & 0x1F;
                  v55 = v51[1] & 0x3F;
                  if ( (unsigned __int8)v53 <= 0xDFu )
                  {
                    v51 += 2;
                    v53 = v55 | (v54 << 6);
                    if ( (v52 & 1) == 0 )
                      goto LABEL_109;
                  }
                  else
                  {
                    v56 = (v55 << 6) | v51[2] & 0x3F;
                    if ( (unsigned __int8)v53 < 0xF0u )
                    {
                      v51 += 3;
                      v53 = (v54 << 12) | v56;
                      if ( (v52 & 1) == 0 )
                      {
LABEL_109:
                        if ( sub_408C00(v53) )
                        {
                          v52 = 0;
                          continue;
                        }
                      }
                    }
                    else
                    {
                      v53 = ((v53 & 7) << 18) | (v56 << 6) | v51[3] & 0x3F;
                      if ( v53 == 1114112 )
                        goto LABEL_112;
                      v51 += 4;
                      if ( (v52 & 1) == 0 )
                        goto LABEL_109;
                    }
                  }
                }
                else
                {
                  ++v51;
                  if ( (v52 & 1) == 0 )
                    goto LABEL_109;
                }
                break;
              }
              v52 = 1;
              if ( v53 != 1114112 )
              {
                v42 = sub_408D80(v53) | 0xC2;
                break;
              }
              continue;
            }
          }
LABEL_112:
          if ( (unsigned __int64)(v66 - v18) <= 1 )
          {
            sub_404110(&v66, v18, 2LL);
            v18 = v68;
          }
          v57 = lpMem;
          *((_BYTE *)lpMem + v18) = -49;
          v57[v18 + 1] = v42 & 0x83;
        }
        else
        {
          if ( v20 < 0x80 )
            goto LABEL_23;
          v26 = 717LL;
          if ( v20 < 0x1ED2 )
            v26 = 0LL;
          v27 = v26 + 358;
          if ( dword_443E28[2 * v26 + 716] > v20 )
            v27 = v26;
          v28 = v27 + 179;
          if ( dword_443E28[2 * v27 + 358] > v20 )
            v28 = v27;
          v29 = v28 + 90;
          if ( dword_443E28[2 * v28 + 180] > v20 )
            v29 = v28;
          v30 = v29 + 45;
          if ( dword_443E28[2 * v29 + 90] > v20 )
            v30 = v29;
          v31 = v30 + 22;
          if ( dword_443E28[2 * v30 + 44] > v20 )
            v31 = v30;
          v32 = v31 + 11;
          if ( dword_443E28[2 * v31 + 22] > v20 )
            v32 = v31;
          v33 = v32 + 6;
          if ( dword_443E28[2 * v32 + 12] > v20 )
            v33 = v32;
          v34 = v33 + 3;
          if ( dword_443E28[2 * v33 + 6] > v20 )
            v34 = v33;
          v35 = v34 + 1;
          if ( dword_443E28[2 * v34 + 2] > v20 )
            v35 = v34;
          v36 = v35 + 1;
          if ( dword_443E28[2 * v35 + 2] > v20 )
            v36 = v35;
          v37 = dword_443E28[2 * v36];
          v38 = (v37 < v20) + v36;
          if ( v37 != v20 )
          {
LABEL_63:
            Src[0] = 0;
            if ( v20 >= 0x800 )
            {
              if ( v20 >= 0x10000 )
              {
                LOBYTE(Src[0]) = (v20 >> 18) | 0xF0;
                BYTE1(Src[0]) = (v20 >> 12) & 0x3F | 0x80;
                BYTE2(Src[0]) = (v20 >> 6) & 0x3F | 0x80;
                v39 = 4LL;
                v40 = (char *)Src + 3;
              }
              else
              {
                LOBYTE(Src[0]) = (v20 >> 12) | 0xE0;
                BYTE1(Src[0]) = (v20 >> 6) & 0x3F | 0x80;
                v39 = 3LL;
                v40 = (char *)Src + 2;
              }
            }
            else
            {
              LOBYTE(Src[0]) = (v20 >> 6) | 0xC0;
              v39 = 2LL;
              v40 = (char *)Src + 1;
            }
            *v40 = v20 & 0x3F | 0x80;
            if ( v66 - v18 < v39 )
            {
              sub_404110(&v66, v18, v39);
              v18 = v68;
            }
            memcpy((char *)lpMem + v18, Src, v39);
            v18 += v39;
            goto LABEL_20;
          }
          if ( v38 >= 0x59A )
            sub_4050B0(1434LL, 1434LL, (__int64)&off_443E10);
          v20 = dword_443E28[2 * v38 + 1];
          if ( (v20 ^ 0xD800) - 2048 < 0x10F800 )
          {
            if ( v20 >= 0x80 )
              goto LABEL_63;
            goto LABEL_24;
          }
          if ( v18 == v66 )
            sub_403F80(&v66, (__int64)&off_442648);
          v50 = (char *)lpMem;
          *((_BYTE *)lpMem + v18++) = 105;
          v68 = v18;
          Src[0] = 34764;
          if ( (unsigned __int64)(v66 - v18) <= 1 )
          {
            sub_404110(&v66, v18, 2LL);
            v50 = (char *)lpMem;
            v18 = v68;
          }
          *(_WORD *)&v50[v18] = Src[0];
        }
        v18 += 2LL;
LABEL_20:
        v68 = v18;
        v19 = v61;
        v14 = (char *)v60;
        if ( v60 == v17 )
          goto LABEL_17;
      }
      v60 = (unsigned __int8 *)(v14 + 1);
      v61 = v19 + 1;
LABEL_23:
      LOBYTE(v20) = v20 | (32 * (v20 - 65 < 0x1A));
LABEL_24:
      if ( v18 == v66 )
        sub_403F80(&v66, (__int64)&off_442648);
      *((_BYTE *)lpMem + v18++) = v20;
      goto LABEL_20;
    }
    si128 = _mm_load_si128((const __m128i *)&xmmword_440020);
    v7 = _mm_load_si128((const __m128i *)&xmmword_440030);
    v8 = _mm_load_si128((const __m128i *)&xmmword_440040);
    for ( i = a3; i > 0xF; i -= 16LL )
    {
      v10 = v5;
      v11 = _mm_loadu_si128((const __m128i *)&a2[v5]);
      if ( _mm_movemask_epi8(v11) )
      {
        v14 = &a2[v5];
        v13 = (_BYTE *)(v5 + v4);
        goto LABEL_13;
      }
      v12 = _mm_add_epi8(v11, si128);
      *(__m128i *)(v4 + v5) = _mm_or_si128(_mm_and_si128(_mm_cmpeq_epi8(_mm_min_epu8(v12, v7), v12), v8), v11);
      v5 += 16LL;
    }
    if ( i )
    {
      v13 = (_BYTE *)(v4 + v10 + 16);
      v14 = &a2[v10 + 16];
      goto LABEL_13;
    }
  }
  else
  {
    v4 = 1LL;
    v5 = 0LL;
  }
LABEL_16:
  v66 = a3;
  lpMem = (LPVOID)v4;
  v68 = v5;
LABEL_17:
  a1[2] = v68;
  *a1 = v66;
  result = lpMem;
  a1[1] = lpMem;
  return result;
}
// 404BE9: conditional instruction was optimized away because r12d.4!=110000
// 404C6C: conditional instruction was optimized away because al.1==0
// 440020: using guessed type __int128 xmmword_440020;
// 440030: using guessed type __int128 xmmword_440030;
// 440040: using guessed type __int128 xmmword_440040;
// 442600: using guessed type char *off_442600;
// 442618: using guessed type char *off_442618;
// 442630: using guessed type char *off_442630;
// 442648: using guessed type char *off_442648;
// 443E10: using guessed type char *off_443E10;
// 443E28: using guessed type _DWORD dword_443E28[2868];

//----- (00000000004050A0) ----------------------------------------------------
void __fastcall __noreturn sub_4050A0(__int64 a1, __int64 a2, __int64 a3)
{
  sub_405A90(a1, a2, a3);
}

//----- (00000000004050B0) ----------------------------------------------------
void __fastcall __noreturn sub_4050B0(__int64 a1, __int64 a2, __int64 a3)
{
  _QWORD *v3; // rcx
  _QWORD *v4; // rdx
  _QWORD *v5; // rcx
  _BYTE v6[32]; // [rsp+0h] [rbp-80h] BYREF
  __int64 v7; // [rsp+78h] [rbp-8h] BYREF

  v7 = a1;
  v3 = &v6[112];
  *v3 = a2;
  v4 = &v6[80];
  *v4 = v3;
  *(_QWORD *)&v6[88] = sub_405120;
  v5 = &v6[32];
  *v5 = &off_442748;
  *(_QWORD *)&v6[40] = 2LL;
  *(_QWORD *)&v6[64] = 0LL;
  *(_QWORD *)&v6[96] = &v7;
  *(_QWORD *)&v6[104] = sub_405120;
  *(_QWORD *)&v6[48] = v4;
  *(_QWORD *)&v6[56] = 2LL;
  sub_405240((__int64)v5, a3);
}
// 442748: using guessed type char *off_442748;

//----- (0000000000405120) ----------------------------------------------------
__int64 __fastcall sub_405120(unsigned __int64 *a1, __int64 a2)
{
  unsigned __int64 v3; // rcx
  __int64 v4; // rax
  __int64 v5; // r11
  unsigned __int64 v6; // rdx
  int v7; // esi
  bool v8; // cc
  __int64 v9; // rax
  _WORD v11[20]; // [rsp+38h] [rbp-18h] BYREF

  v3 = *a1;
  v4 = 20LL;
  if ( v3 >= 0x2710 )
  {
    v5 = 10LL;
    do
    {
      v6 = v3 / 0x2710;
      v7 = v3 % 0x2710;
      v4 = v5 * 2 - 4;
      v11[v5] = a0001020304[(unsigned int)(5243 * v7) >> 19];
      v11[v5 + 1] = a0001020304[(unsigned __int16)(v7 - 100 * ((unsigned __int16)((unsigned int)(5243 * v7) >> 16) >> 3))];
      v5 -= 2LL;
      v8 = v3 <= 0x5F5E0FF;
      v3 /= 0x2710uLL;
    }
    while ( !v8 );
    if ( v6 <= 0x63 )
      goto LABEL_6;
    goto LABEL_5;
  }
  v6 = v3;
  if ( v3 > 0x63 )
  {
LABEL_5:
    *(_WORD *)((char *)&v11[1] + v4) = a0001020304[(unsigned __int16)v6 % 0x64u];
    v4 -= 2LL;
    v6 = (unsigned int)(5243 * ((unsigned __int16)v6 >> 2)) >> 17;
  }
LABEL_6:
  if ( v6 >= 0xA )
  {
    *(_WORD *)((char *)&v11[1] + v4) = a0001020304[v6];
    v9 = v4 - 2;
  }
  else
  {
    *((_BYTE *)&v11[1] + v4 + 1) = v6 | 0x30;
    v9 = v4 - 1;
  }
  return sub_405270(a2, 1, 1LL, 0LL, (__int64)&v11[2] + v9, 20 - v9);
}
// 4428DB: using guessed type _WORD a0001020304[100];

//----- (0000000000405240) ----------------------------------------------------
void __fastcall __noreturn sub_405240(__int64 a1, __int64 a2)
{
  _QWORD v2[7]; // [rsp+0h] [rbp-40h] BYREF
  __int16 v3; // [rsp+38h] [rbp-8h]

  v2[5] = a1;
  v2[6] = a2;
  v3 = 1;
  sub_43CC30(&v2[5]);
}

//----- (0000000000405270) ----------------------------------------------------
__int64 __fastcall sub_405270(__int64 a1, char a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  int v8; // eax
  unsigned int v9; // r8d
  unsigned __int64 v10; // rdx
  __int64 v11; // r11
  __int64 v12; // r9
  __int64 v13; // r13
  unsigned __int64 v14; // r15
  bool v15; // cc
  unsigned __int64 v16; // r15
  unsigned __int8 v17; // dl
  unsigned __int64 v18; // rsi
  __int64 v19; // r14
  __int64 v20; // r12
  char v21; // al
  __int64 v23; // r12
  __int64 v24; // r14
  char v25; // al
  unsigned __int64 v26; // r15
  __int64 v27; // r12
  __int64 v28; // r13
  unsigned int v29; // r14d
  unsigned __int64 v30; // rsi
  char v31; // al
  unsigned __int64 v32; // rsi
  __int64 v33; // [rsp+28h] [rbp-18h]
  int v34; // [rsp+34h] [rbp-Ch]
  unsigned int v36; // [rsp+40h] [rbp+0h]
  char v37; // [rsp+47h] [rbp+7h]

  if ( a2 )
  {
    v8 = *(_DWORD *)(a1 + 36);
    v9 = 43;
    if ( (v8 & 1) == 0 )
      v9 = 1114112;
    v10 = a6 + (*(_DWORD *)(a1 + 36) & 1);
    if ( (v8 & 4) != 0 )
    {
LABEL_5:
      v11 = 0LL;
      if ( a4 )
      {
        v12 = 0LL;
        do
          v11 += *(_BYTE *)(a3 + v12++) >= 0xC0;
        while ( a4 != v12 );
      }
      v10 += v11;
      v13 = a5;
      if ( (*(_BYTE *)a1 & 1) == 0 )
        goto LABEL_19;
      goto LABEL_12;
    }
  }
  else
  {
    v10 = a6 + 1;
    v8 = *(_DWORD *)(a1 + 36);
    v9 = 45;
    if ( (v8 & 4) != 0 )
      goto LABEL_5;
  }
  a3 = 0LL;
  v13 = a5;
  if ( (*(_BYTE *)a1 & 1) == 0 )
    goto LABEL_19;
LABEL_12:
  v36 = v9;
  v14 = *(_QWORD *)(a1 + 8);
  v15 = v14 <= v10;
  v16 = v14 - v10;
  if ( !v15 )
  {
    if ( (v8 & 8) != 0 )
    {
      v34 = *(_DWORD *)(a1 + 32);
      *(_DWORD *)(a1 + 32) = 48;
      v37 = *(_BYTE *)(a1 + 40);
      *(_BYTE *)(a1 + 40) = 1;
      v23 = *(_QWORD *)(a1 + 48);
      v24 = *(_QWORD *)(a1 + 56);
      v25 = sub_405A30(v23, v24, v9, a3, a4);
      LOBYTE(a3) = 1;
      if ( !v25 )
      {
        v26 = v16 + 1;
        while ( --v26 )
        {
          if ( (*(unsigned __int8 (__fastcall **)(__int64, __int64))(v24 + 32))(v23, 48LL) )
            return (unsigned int)a3;
        }
        if ( !(*(unsigned __int8 (__fastcall **)(__int64, __int64, __int64))(v24 + 24))(v23, v13, a6) )
        {
          *(_DWORD *)(a1 + 32) = v34;
          *(_BYTE *)(a1 + 40) = v37;
          LODWORD(a3) = 0;
        }
      }
    }
    else
    {
      v17 = 1;
      if ( (unsigned __int8)*(_DWORD *)(a1 + 40) != 3 )
        v17 = *(_DWORD *)(a1 + 40);
      v18 = v17;
      v33 = v13;
      if ( v17 )
      {
        if ( v17 == 1 )
        {
          v18 = v16;
          v16 = 0LL;
        }
        else
        {
          v18 = v16 >> 1;
          v16 = (v16 + 1) >> 1;
        }
      }
      v27 = *(_QWORD *)(a1 + 48);
      v28 = *(_QWORD *)(a1 + 56);
      v29 = *(_DWORD *)(a1 + 32);
      v30 = v18 + 1;
      while ( --v30 )
      {
        if ( (*(unsigned __int8 (__fastcall **)(__int64, _QWORD))(v28 + 32))(v27, v29) )
        {
          LOBYTE(a3) = 1;
          return (unsigned int)a3;
        }
      }
      v31 = sub_405A30(v27, v28, v36, a3, a4);
      LOBYTE(a3) = 1;
      if ( !v31 && !(*(unsigned __int8 (__fastcall **)(__int64, __int64, __int64))(v28 + 24))(v27, v33, a6) )
      {
        a3 = -(__int64)v16;
        v32 = -1LL;
        while ( v32 - v16 != -1LL )
        {
          ++v32;
          if ( (*(unsigned __int8 (__fastcall **)(__int64, _QWORD))(v28 + 32))(v27, v29) )
            goto LABEL_41;
        }
        v32 = v16;
LABEL_41:
        LOBYTE(a3) = v32 < v16;
      }
    }
    return (unsigned int)a3;
  }
LABEL_19:
  v19 = *(_QWORD *)(a1 + 48);
  v20 = *(_QWORD *)(a1 + 56);
  v21 = sub_405A30(v19, v20, v9, a3, a4);
  LOBYTE(a3) = 1;
  if ( v21 )
    return (unsigned int)a3;
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64))(v20 + 24))(v19, v13, a6);
}

//----- (0000000000405510) ----------------------------------------------------
__int64 __fastcall sub_405510(unsigned __int16 *a1, __int64 a2)
{
  unsigned __int64 v2; // rdi
  unsigned __int64 v3; // rdx
  int v4; // eax
  unsigned __int64 v5; // r9
  unsigned __int64 v6; // r8
  __int64 v7; // r10
  __m128i si128; // xmm1
  __m128i v9; // xmm0
  __m128i v10; // xmm2
  __m128i v11; // xmm3
  __m128i v12; // xmm1
  unsigned __int64 v13; // rcx
  __int64 v14; // rsi
  __int64 v15; // rsi
  unsigned __int64 v16; // rdx
  __m128i v17; // xmm1
  unsigned __int64 v18; // rsi
  int v19; // ebx
  __int64 result; // rax
  const __m128i *v21; // r9
  __int64 v22; // r10
  __int64 v23; // rdi
  unsigned __int64 v24; // r14
  const __m128i *v25; // rbx
  unsigned __int64 v26; // r14
  const __m128i *v27; // rsi
  __m128i v28; // xmm4
  unsigned __int64 v29; // r12
  __m128i v30; // xmm5
  __m128i v31; // xmm2
  __m128i v32; // xmm6
  __m128i v33; // xmm3
  __m128i v34; // xmm3
  __m128i v35; // xmm4
  __m128i v36; // xmm10
  __m128i v37; // xmm11
  __m128i v38; // xmm7
  __m128i v39; // xmm9
  __m128i v40; // xmm8
  __m128i v41; // xmm8
  __m128i v42; // xmm5
  __m128i v43; // xmm2
  __m128i v44; // xmm9
  __m128i v45; // xmm7
  __m128i v46; // xmm6
  __m128i v47; // xmm4
  __m128i v48; // xmm5
  __m128i v49; // xmm5
  const __m128i *v50; // rdi
  __m128i v51; // xmm2
  __m128i v52; // xmm3
  __m128i v53; // xmm2
  __int64 v54; // r10
  unsigned __int64 v55; // rax

  v2 = ((unsigned __int64)a1 + 7) & 0xFFFFFFFFFFFFFFF8uLL;
  v3 = a2 - (v2 - (_QWORD)a1);
  v4 = v3 & 7;
  v5 = v2 - (_QWORD)a1;
  if ( v2 != (_QWORD)a1 )
  {
    if ( v5 >= 4 )
    {
      si128 = _mm_load_si128((const __m128i *)&xmmword_440050);
      v9 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(a1[1]), si128);
      v10 = _mm_load_si128((const __m128i *)&xmmword_440060);
      v11 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(*a1), si128);
      v12 = _mm_add_epi64(
              _mm_and_si128(_mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v11, v11), 212), 212), v10),
              _mm_and_si128(_mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v9, v9), 212), 212), v10));
      v6 = _mm_add_epi64(_mm_shuffle_epi32(v12, 238), v12).m128i_u64[0];
      v7 = 4LL;
      if ( v5 == 4 )
        goto LABEL_7;
    }
    else
    {
      v6 = 0LL;
      v7 = 0LL;
    }
    do
      v6 += *((_BYTE *)a1 + v7++) >= 0xC0;
    while ( v5 != v7 );
    goto LABEL_7;
  }
  v6 = 0LL;
LABEL_7:
  if ( (v3 & 7) != 0 )
  {
    v13 = v3 & 0xFFFFFFFFFFFFFFF8uLL;
    v14 = *(_BYTE *)(v2 + (v3 & 0xFFFFFFFFFFFFFFF8uLL)) >= 0xC0;
    if ( v4 != 1 )
    {
      v14 += *(_BYTE *)(v2 + v13 + 1) >= 0xC0;
      if ( v4 != 2 )
      {
        v14 += *(_BYTE *)(v2 + v13 + 2) >= 0xC0;
        if ( v4 != 3 )
        {
          v14 += *(_BYTE *)(v2 + v13 + 3) >= 0xC0;
          if ( v4 != 4 )
          {
            v14 += *(_BYTE *)(v2 + v13 + 4) >= 0xC0;
            if ( v4 != 5 )
            {
              v14 += *(_BYTE *)(v2 + v13 + 5) >= 0xC0;
              if ( v4 != 6 )
                v14 += *(_BYTE *)(v2 + v13 + 6) >= 0xC0;
            }
          }
        }
      }
    }
  }
  else
  {
    v14 = 0LL;
  }
  v15 = v6 + v14;
  v16 = v3 >> 3;
  v17 = _mm_load_si128((const __m128i *)&xmmword_440070);
  while ( 1 )
  {
    result = v15;
    if ( !v16 )
      return result;
    v21 = (const __m128i *)v2;
    v22 = 192LL;
    if ( v16 < 0xC0 )
      v22 = v16;
    if ( v16 < 4 )
    {
      v18 = 0LL;
    }
    else
    {
      v23 = (unsigned int)v22 >> 2;
      v24 = (v23 + 0x7FFFFFFFFFFFFFFLL) & 0x7FFFFFFFFFFFFFFLL;
      if ( v24 >= 3 )
      {
        v26 = v24 + 1;
        v27 = v21 + 4;
        v28 = 0LL;
        v29 = v26 & 0xFFFFFFFFFFFFFFFCuLL;
        v30 = 0LL;
        do
        {
          v31 = _mm_loadu_si128(v27 - 4);
          v32 = _mm_loadu_si128(v27 - 2);
          v33 = _mm_unpacklo_epi64(v31, v32);
          v34 = _mm_add_epi64(
                  _mm_and_si128(
                    _mm_or_si128(_mm_srli_epi64(v33, 6u), _mm_srli_epi64(_mm_xor_si128(v33, (__m128i)-1LL), 7u)),
                    v17),
                  v28);
          v35 = _mm_loadu_si128(v27 - 3);
          v36 = _mm_loadu_si128(v27 - 1);
          v37 = _mm_loadu_si128(v27 + 3);
          v38 = _mm_loadu_si128(v27 + 2);
          v39 = _mm_loadu_si128(v27);
          v40 = _mm_unpacklo_epi64(v39, v38);
          v41 = _mm_add_epi64(
                  _mm_and_si128(
                    _mm_or_si128(_mm_srli_epi64(v40, 6u), _mm_srli_epi64(_mm_xor_si128(v40, (__m128i)-1LL), 7u)),
                    v17),
                  v30);
          v42 = _mm_loadu_si128(v27 + 1);
          v43 = _mm_unpackhi_epi64(v31, v32);
          v44 = _mm_unpackhi_epi64(v39, v38);
          v45 = _mm_unpacklo_epi64(v35, v36);
          v46 = _mm_unpacklo_epi64(v42, v37);
          v47 = _mm_unpackhi_epi64(v35, v36);
          v48 = _mm_unpackhi_epi64(v42, v37);
          v28 = _mm_add_epi64(
                  _mm_and_si128(
                    _mm_or_si128(_mm_srli_epi64(v47, 6u), _mm_srli_epi64(_mm_xor_si128(v47, (__m128i)-1LL), 7u)),
                    v17),
                  _mm_add_epi64(
                    _mm_add_epi64(
                      _mm_and_si128(
                        _mm_or_si128(_mm_srli_epi64(v45, 6u), _mm_srli_epi64(_mm_xor_si128(v45, (__m128i)-1LL), 7u)),
                        v17),
                      _mm_and_si128(
                        _mm_or_si128(_mm_srli_epi64(v43, 6u), _mm_srli_epi64(_mm_xor_si128(v43, (__m128i)-1LL), 7u)),
                        v17)),
                    v34));
          v30 = _mm_add_epi64(
                  _mm_and_si128(
                    _mm_or_si128(_mm_srli_epi64(v48, 6u), _mm_srli_epi64(_mm_xor_si128(v48, (__m128i)-1LL), 7u)),
                    v17),
                  _mm_add_epi64(
                    _mm_add_epi64(
                      _mm_and_si128(
                        _mm_or_si128(_mm_srli_epi64(v46, 6u), _mm_srli_epi64(_mm_xor_si128(v46, (__m128i)-1LL), 7u)),
                        v17),
                      _mm_and_si128(
                        _mm_or_si128(_mm_srli_epi64(v44, 6u), _mm_srli_epi64(_mm_xor_si128(v44, (__m128i)-1LL), 7u)),
                        v17)),
                    v41));
          v27 += 8;
          v29 -= 4LL;
        }
        while ( v29 );
        v49 = _mm_add_epi64(v30, v28);
        v18 = _mm_add_epi64(_mm_shuffle_epi32(v49, 238), v49).m128i_u64[0];
        if ( v26 == (v26 & 0xFFFFFFFFFFFFFFFCuLL) )
          goto LABEL_18;
        v25 = &v21[2 * (v26 & 0xFFFFFFFFFFFFFFFCuLL)];
      }
      else
      {
        v18 = 0LL;
        v25 = v21;
      }
      v50 = (const __m128i *)((char *)v21 + (unsigned int)(32 * v23));
      do
      {
        v51 = _mm_loadu_si128(v25);
        v52 = _mm_loadu_si128(v25 + 1);
        v53 = _mm_add_epi64(
                _mm_and_si128(
                  _mm_or_si128(_mm_srli_epi64(v51, 6u), _mm_srli_epi64(_mm_xor_si128(v51, (__m128i)-1LL), 7u)),
                  v17),
                _mm_and_si128(
                  _mm_or_si128(_mm_srli_epi64(v52, 6u), _mm_srli_epi64(_mm_xor_si128(v52, (__m128i)-1LL), 7u)),
                  v17));
        v18 += _mm_add_epi64(_mm_shuffle_epi32(v53, 238), v53).m128i_u64[0];
        v25 += 2;
      }
      while ( v25 != v50 );
    }
LABEL_18:
    v2 = (unsigned __int64)v21 + 8 * (unsigned int)v22;
    v16 -= v22;
    v19 = v22 & 3;
    v15 = result + ((0x1000100010001LL * ((v18 & 0xFF00FF00FF00FFLL) + ((v18 >> 8) & 0xFF00FF00FF00FFLL))) >> 48);
    if ( (v22 & 3) != 0 )
    {
      v54 = (unsigned __int8)v22 & 0xFC;
      v55 = (((unsigned __int64)~v21->m128i_i64[(unsigned int)v54] >> 7) | ((unsigned __int64)v21->m128i_i64[(unsigned int)v54] >> 6)) & 0x101010101010101LL;
      if ( v19 != 1 )
      {
        v55 += (((unsigned __int64)~v21->m128i_i64[v54 + 1] >> 7) | ((unsigned __int64)v21->m128i_i64[v54 + 1] >> 6)) & 0x101010101010101LL;
        if ( v19 != 2 )
          v55 += (((unsigned __int64)~v21[1].m128i_i64[v54] >> 7) | ((unsigned __int64)v21[1].m128i_i64[v54] >> 6)) & 0x101010101010101LL;
      }
      return v15 + ((0x1000100010001LL * ((v55 & 0xFF00FF00FF00FFLL) + ((v55 >> 8) & 0xFF00FF00FF00FFLL))) >> 48);
    }
  }
}
// 440050: using guessed type __int128 xmmword_440050;
// 440060: using guessed type __int128 xmmword_440060;
// 440070: using guessed type __int128 xmmword_440070;

//----- (0000000000405A30) ----------------------------------------------------
char __fastcall sub_405A30(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5)
{
  __int64 v7; // r14
  char v8; // al
  char v9; // dl
  char result; // al

  if ( a3 == 1114112
    || (v7 = a1, v8 = (*(__int64 (__fastcall **)(__int64, _QWORD))(a2 + 32))(a1, a3), a1 = v7, v9 = v8, result = 1, !v9) )
  {
    if ( a4 )
      return (*(__int64 (__fastcall **)(__int64, __int64, __int64))(a2 + 24))(a1, a4, a5);
    else
      return 0;
  }
  return result;
}

//----- (0000000000405A90) ----------------------------------------------------
void __fastcall __noreturn sub_405A90(__int64 a1, __int64 a2, __int64 a3)
{
  _QWORD v3[16]; // [rsp+0h] [rbp-80h] BYREF

  v3[15] = a1;
  v3[14] = a2;
  v3[10] = &v3[15];
  v3[11] = sub_405120;
  v3[12] = &v3[14];
  v3[13] = sub_405120;
  v3[4] = &off_443448;
  v3[5] = 2LL;
  v3[8] = 0LL;
  v3[6] = &v3[10];
  v3[7] = 2LL;
  sub_405240(&v3[4], a3);
}
// 405240: using guessed type void __fastcall __noreturn sub_405240(_QWORD, _QWORD);
// 443448: using guessed type char *off_443448;

//----- (0000000000405B00) ----------------------------------------------------
void __fastcall __noreturn sub_405B00(__int64 a1, __int64 a2, __int64 a3)
{
  sub_405B10(a1, a2, a3);
}

//----- (0000000000405B10) ----------------------------------------------------
void __fastcall __noreturn sub_405B10(__int64 a1, __int64 a2, __int64 a3)
{
  _QWORD v3[16]; // [rsp+0h] [rbp-80h] BYREF

  v3[15] = a1;
  v3[14] = a2;
  v3[10] = &v3[15];
  v3[11] = sub_405120;
  v3[12] = &v3[14];
  v3[13] = sub_405120;
  v3[4] = &off_443478;
  v3[5] = 2LL;
  v3[8] = 0LL;
  v3[6] = &v3[10];
  v3[7] = 2LL;
  sub_405240(&v3[4], a3);
}
// 405240: using guessed type void __fastcall __noreturn sub_405240(_QWORD, _QWORD);
// 443478: using guessed type char *off_443478;

//----- (0000000000405B80) ----------------------------------------------------
char __fastcall sub_405B80(__int64 a1, unsigned __int16 *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // rsi
  unsigned __int64 v5; // rdx
  __int64 v6; // r9
  unsigned __int16 *v7; // r8
  unsigned __int64 v8; // rdx
  __int64 v9; // r10
  unsigned __int16 *v10; // r11
  unsigned __int16 *v11; // rbx
  char v12; // bl
  unsigned __int16 *v13; // r8
  unsigned __int64 v14; // r15
  unsigned __int64 v15; // rax
  unsigned __int64 v16; // rdx
  __int64 v17; // rbx
  __m128i si128; // xmm2
  __m128i v19; // xmm0
  __m128i v20; // xmm3
  __m128i v21; // xmm0
  __m128i v22; // xmm1
  __m128i v23; // xmm1
  __m128i v24; // xmm4
  __m128i v25; // xmm5
  __m128i v26; // xmm4
  __m128i v27; // xmm5
  __m128i v28; // xmm4
  __m128i v29; // xmm5
  __m128i v30; // xmm4
  __m128i v31; // xmm5
  __m128i v32; // xmm4
  __m128i v33; // xmm5
  __m128i v34; // xmm4
  __m128i v35; // xmm5
  __m128i v36; // xmm0
  bool v37; // cc
  unsigned __int64 v38; // r15
  unsigned __int8 v39; // dl
  unsigned __int64 v40; // r13
  char result; // al
  __int64 v42; // rbx
  __int64 v43; // r12
  unsigned int v44; // r14d
  unsigned __int64 v45; // r13
  char v46; // cl
  unsigned __int64 v47; // rsi

  v3 = a3;
  v5 = *(_QWORD *)(a1 + 16);
  if ( __PAIR128__(v5, *(_QWORD *)a1) == 0 )
    return (*(__int64 (__fastcall **)(_QWORD, unsigned __int16 *, unsigned __int64))(*(_QWORD *)(a1 + 56) + 24LL))(
             *(_QWORD *)(a1 + 48),
             a2,
             v3);
  if ( (v5 & 1) != 0 )
  {
    v6 = *(_QWORD *)(a1 + 24);
    v7 = (unsigned __int16 *)((char *)a2 + a3);
    v8 = 0LL;
    if ( v6 )
    {
      v9 = 0LL;
      v10 = a2;
      while ( v10 != v7 )
      {
        v12 = *(_BYTE *)v10;
        if ( *(char *)v10 >= 0 )
        {
          v11 = (unsigned __int16 *)((char *)v10 + 1);
        }
        else if ( (unsigned __int8)v12 < 0xE0u )
        {
          v11 = v10 + 1;
        }
        else if ( (unsigned __int8)v12 < 0xF0u )
        {
          v11 = (unsigned __int16 *)((char *)v10 + 3);
        }
        else
        {
          v11 = v10 + 2;
        }
        ++v9;
        v8 += (char *)v11 - (char *)v10;
        v10 = v11;
        if ( v6 == v9 )
          goto LABEL_15;
      }
      goto LABEL_24;
    }
    v11 = a2;
LABEL_15:
    if ( v11 != v7 )
    {
      if ( v8 )
      {
        if ( v8 >= v3 )
        {
          if ( v8 != v3 )
            goto LABEL_19;
        }
        else if ( *((char *)a2 + v8) < -64 )
        {
LABEL_19:
          v13 = 0LL;
          goto LABEL_22;
        }
      }
      v13 = a2;
LABEL_22:
      if ( v13 )
      {
        v3 = v8;
        a2 = v13;
      }
    }
  }
LABEL_24:
  if ( !*(_QWORD *)a1 )
    return (*(__int64 (__fastcall **)(_QWORD, unsigned __int16 *, unsigned __int64))(*(_QWORD *)(a1 + 56) + 24LL))(
             *(_QWORD *)(a1 + 48),
             a2,
             v3);
  v14 = *(_QWORD *)(a1 + 8);
  if ( v3 >= 0x20 )
  {
    v17 = a1;
    v15 = sub_405510(a2, v3);
    a1 = v17;
  }
  else if ( v3 )
  {
    if ( v3 >= 4 )
    {
      v16 = v3 & 0x1C;
      si128 = _mm_load_si128((const __m128i *)&xmmword_440080);
      v19 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(*a2), si128);
      v20 = _mm_load_si128((const __m128i *)&xmmword_440090);
      v21 = _mm_and_si128(_mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v19, v19), 212), 212), v20);
      v22 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(a2[1]), si128);
      v23 = _mm_and_si128(_mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v22, v22), 212), 212), v20);
      if ( v16 != 4 )
      {
        v24 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(a2[2]), si128);
        v25 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(a2[3]), si128);
        v21 = _mm_add_epi64(
                v21,
                _mm_and_si128(_mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v24, v24), 212), 212), v20));
        v23 = _mm_add_epi64(
                v23,
                _mm_and_si128(_mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v25, v25), 212), 212), v20));
        if ( (_DWORD)v16 != 8 )
        {
          v26 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(a2[4]), si128);
          v27 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(a2[5]), si128);
          v21 = _mm_add_epi64(
                  v21,
                  _mm_and_si128(_mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v26, v26), 212), 212), v20));
          v23 = _mm_add_epi64(
                  v23,
                  _mm_and_si128(_mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v27, v27), 212), 212), v20));
          if ( (_DWORD)v16 != 12 )
          {
            v28 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(a2[6]), si128);
            v29 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(a2[7]), si128);
            v21 = _mm_add_epi64(
                    v21,
                    _mm_and_si128(_mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v28, v28), 212), 212), v20));
            v23 = _mm_add_epi64(
                    v23,
                    _mm_and_si128(_mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v29, v29), 212), 212), v20));
            if ( (_DWORD)v16 != 16 )
            {
              v30 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(a2[8]), si128);
              v31 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(a2[9]), si128);
              v21 = _mm_add_epi64(
                      v21,
                      _mm_and_si128(_mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v30, v30), 212), 212), v20));
              v23 = _mm_add_epi64(
                      v23,
                      _mm_and_si128(_mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v31, v31), 212), 212), v20));
              if ( (_DWORD)v16 != 20 )
              {
                v32 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(a2[10]), si128);
                v33 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(a2[11]), si128);
                v21 = _mm_add_epi64(
                        v21,
                        _mm_and_si128(
                          _mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v32, v32), 212), 212),
                          v20));
                v23 = _mm_add_epi64(
                        v23,
                        _mm_and_si128(
                          _mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v33, v33), 212), 212),
                          v20));
                if ( (_DWORD)v16 != 24 )
                {
                  v34 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(a2[12]), si128);
                  v35 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(a2[13]), si128);
                  v21 = _mm_add_epi64(
                          v21,
                          _mm_and_si128(
                            _mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v34, v34), 212), 212),
                            v20));
                  v23 = _mm_add_epi64(
                          v23,
                          _mm_and_si128(
                            _mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v35, v35), 212), 212),
                            v20));
                }
              }
            }
          }
        }
      }
      v36 = _mm_add_epi64(v21, v23);
      v15 = _mm_add_epi64(_mm_shuffle_epi32(v36, 238), v36).m128i_u64[0];
      goto LABEL_40;
    }
    v15 = 0LL;
    v16 = 0LL;
    do
    {
      v15 += *((_BYTE *)a2 + v16++) >= 0xC0;
LABEL_40:
      ;
    }
    while ( v3 != v16 );
  }
  else
  {
    v15 = 0LL;
  }
  v37 = v14 <= v15;
  v38 = v14 - v15;
  if ( v37 )
    return (*(__int64 (__fastcall **)(_QWORD, unsigned __int16 *, unsigned __int64))(*(_QWORD *)(a1 + 56) + 24LL))(
             *(_QWORD *)(a1 + 48),
             a2,
             v3);
  v39 = 0;
  if ( (unsigned __int8)*(_DWORD *)(a1 + 40) != 3 )
    v39 = *(_DWORD *)(a1 + 40);
  v40 = v39;
  if ( v39 )
  {
    if ( v39 == 1 )
    {
      v40 = v38;
      v38 = 0LL;
    }
    else
    {
      v40 = v38 >> 1;
      v38 = (v38 + 1) >> 1;
    }
  }
  v42 = *(_QWORD *)(a1 + 48);
  v43 = *(_QWORD *)(a1 + 56);
  v44 = *(_DWORD *)(a1 + 32);
  v45 = v40 + 1;
  while ( --v45 )
  {
    if ( (*(unsigned __int8 (__fastcall **)(__int64, _QWORD))(v43 + 32))(v42, v44) )
      return 1;
  }
  v46 = (*(__int64 (__fastcall **)(__int64, unsigned __int16 *, unsigned __int64))(v43 + 24))(v42, a2, v3);
  result = 1;
  if ( !v46 )
  {
    v47 = -1LL;
    while ( v47 - v38 != -1LL )
    {
      ++v47;
      if ( (*(unsigned __int8 (__fastcall **)(__int64, _QWORD))(v43 + 32))(v42, v44) )
        return v47 < v38;
    }
    v47 = v38;
    return v47 < v38;
  }
  return result;
}
// 440080: using guessed type __int128 xmmword_440080;
// 440090: using guessed type __int128 xmmword_440090;

//----- (0000000000405FC0) ----------------------------------------------------
void __fastcall __noreturn sub_405FC0(__int64 a1, __int64 a2, __int64 a3)
{
  _QWORD v3[7]; // [rsp+0h] [rbp-60h] BYREF
  __int128 v4; // [rsp+38h] [rbp-28h]
  __int64 v5; // [rsp+50h] [rbp-10h]
  __int64 v6; // [rsp+58h] [rbp-8h]

  v5 = a1;
  v6 = a2;
  v3[4] = &v3[10];
  v3[5] = 1LL;
  v3[6] = 8LL;
  v4 = 0LL;
  sub_405240(&v3[4], a3);
}
// 405240: using guessed type void __fastcall __noreturn sub_405240(_QWORD, _QWORD);

//----- (0000000000405FFE) ----------------------------------------------------
void __fastcall __noreturn sub_405FFE(
        char a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int128 *a6,
        __int64 a7)
{
  bool v7; // zf
  const char *v8; // rcx
  __int64 v9; // r10
  __int128 v10; // xmm0
  __int128 v11; // xmm1
  _OWORD v12[3]; // [rsp+20h] [rbp-60h] BYREF
  _QWORD *v13; // [rsp+50h] [rbp-30h] BYREF
  char (__fastcall *v14)(__int64, __int64); // [rsp+58h] [rbp-28h]
  _QWORD *v15; // [rsp+60h] [rbp-20h]
  void *v16; // [rsp+68h] [rbp-18h]
  _QWORD *v17; // [rsp+70h] [rbp-10h]
  __int64 (__fastcall *v18)(_QWORD *); // [rsp+78h] [rbp-8h]
  _QWORD *v19; // [rsp+80h] [rbp+0h]
  __int64 (__fastcall *v20)(_QWORD *); // [rsp+88h] [rbp+8h]
  char **v21; // [rsp+90h] [rbp+10h] BYREF
  __int64 v22; // [rsp+98h] [rbp+18h]
  _QWORD *v23; // [rsp+A0h] [rbp+20h]
  __int64 v24; // [rsp+A8h] [rbp+28h]
  __int64 v25; // [rsp+B0h] [rbp+30h]
  _QWORD v26[2]; // [rsp+C0h] [rbp+40h] BYREF
  _QWORD v27[2]; // [rsp+D0h] [rbp+50h] BYREF
  _QWORD v28[2]; // [rsp+E0h] [rbp+60h] BYREF

  v28[0] = a2;
  v28[1] = a3;
  v27[0] = a4;
  v27[1] = a5;
  v7 = a1 == 0;
  v8 = asc_4427DA;
  if ( v7 )
    v8 = asc_4427D8;
  v26[0] = v8;
  v26[1] = 2LL;
  if ( *(_QWORD *)a6 )
  {
    v10 = *a6;
    v11 = a6[1];
    v12[2] = a6[2];
    v12[1] = v11;
    v12[0] = v10;
    v13 = v26;
    v14 = sub_4123C0;
    v15 = v12;
    v16 = sub_406160;
    v17 = v28;
    v18 = sub_406140;
    v21 = &off_442860;
    v9 = 4LL;
    v22 = 4LL;
    v25 = 0LL;
    v19 = v27;
    v20 = sub_406140;
  }
  else
  {
    v13 = v26;
    v14 = sub_4123C0;
    v15 = v28;
    v16 = sub_406140;
    v21 = &off_442810;
    v9 = 3LL;
    v22 = 3LL;
    v25 = 0LL;
    v17 = v27;
    v18 = sub_406140;
  }
  v23 = &v13;
  v24 = v9;
  sub_405240(&v21, a7);
}
// 405240: using guessed type void __fastcall __noreturn sub_405240(_QWORD, _QWORD);
// 442810: using guessed type char *off_442810;
// 442860: using guessed type char *off_442860;

//----- (0000000000406140) ----------------------------------------------------
__int64 __fastcall sub_406140(_QWORD *a1)
{
  return (*(__int64 (__fastcall **)(_QWORD))(a1[1] + 24LL))(*a1);
}

//----- (0000000000406160) ----------------------------------------------------
char __fastcall sub_406160(_QWORD *a1, __int64 a2)
{
  return sub_406180(*(_QWORD *)(a2 + 48), *(_QWORD *)(a2 + 56), a1);
}

//----- (0000000000406180) ----------------------------------------------------
char __fastcall sub_406180(__int64 a1, __int64 a2, _QWORD *a3)
{
  __int64 v3; // r14
  __int64 v4; // rax
  __int64 v5; // r12
  _QWORD *v6; // r15
  __int64 v7; // r13
  __int64 v8; // rdi
  unsigned __int64 v9; // rbx
  __int64 v10; // rcx
  __int64 v11; // rax
  __int64 v12; // rcx
  __int64 v13; // rcx
  __int64 v14; // rcx
  __int64 v15; // r14
  __int64 v16; // r15
  __int64 v17; // r14
  __int64 v18; // r12
  __int64 v19; // r13
  __int64 v20; // rsi
  _QWORD v22[2]; // [rsp+20h] [rbp-40h] BYREF
  __int64 v23; // [rsp+30h] [rbp-30h]
  __int64 v24; // [rsp+38h] [rbp-28h]
  __int64 v25; // [rsp+40h] [rbp-20h]
  char v26; // [rsp+48h] [rbp-18h]
  __int64 v27; // [rsp+50h] [rbp-10h]
  __int64 v28; // [rsp+58h] [rbp-8h]
  _QWORD *v29; // [rsp+60h] [rbp+0h]

  v22[0] = 0LL;
  v23 = 0LL;
  v25 = 32LL;
  v26 = 3;
  v27 = a1;
  v28 = a2;
  v3 = a3[4];
  v29 = a3;
  if ( v3 )
  {
    v4 = a3[5];
    if ( v4 )
    {
      v5 = a3[2];
      v6 = (_QWORD *)(*a3 + 8LL);
      v7 = 56 * v4;
      v8 = 0LL;
      v9 = 0LL;
      while ( 1 )
      {
        if ( *v6 && (*(unsigned __int8 (__fastcall **)(__int64, _QWORD))(v28 + 24))(v27, *(v6 - 1)) )
          return 1;
        LODWORD(v25) = *(_DWORD *)(v3 + v8 + 40);
        v26 = *(_BYTE *)(v3 + v8 + 48);
        HIDWORD(v25) = *(_DWORD *)(v3 + v8 + 44);
        v10 = *(_QWORD *)(v3 + v8 + 16);
        v11 = *(_QWORD *)(v3 + v8 + 24);
        if ( !v10 )
          goto LABEL_11;
        if ( (_DWORD)v10 == 1 )
        {
          v11 *= 16LL;
          if ( !*(_QWORD *)(v5 + v11) )
            break;
        }
        v12 = 0LL;
LABEL_12:
        v22[0] = v12;
        v22[1] = v11;
        v13 = *(_QWORD *)(v3 + v8);
        if ( v13 != 2 )
        {
          v11 = *(_QWORD *)(v3 + v8 + 8);
          if ( (_DWORD)v13 != 1 )
            goto LABEL_17;
          v11 *= 16LL;
          if ( !*(_QWORD *)(v5 + v11) )
          {
            v11 = *(_QWORD *)(v5 + v11 + 8);
LABEL_17:
            v14 = 1LL;
            goto LABEL_18;
          }
        }
        v14 = 0LL;
LABEL_18:
        v23 = v14;
        v24 = v11;
        if ( (*(unsigned __int8 (__fastcall **)(_QWORD, _QWORD *))(v5 + 16LL * *(_QWORD *)(v3 + v8 + 32) + 8))(
               *(_QWORD *)(v5 + 16LL * *(_QWORD *)(v3 + v8 + 32)),
               v22) )
        {
          return 1;
        }
        v6 += 2;
        v8 += 56LL;
        ++v9;
        if ( v7 == v8 )
          goto LABEL_29;
      }
      v11 = *(_QWORD *)(v5 + v11 + 8);
LABEL_11:
      v12 = 1LL;
      goto LABEL_12;
    }
    v9 = 0LL;
LABEL_29:
    if ( v9 >= v29[1] )
      return 0;
    goto LABEL_30;
  }
  v15 = a3[3];
  if ( v15 )
  {
    v16 = a3[2];
    v17 = v16 + 16 * v15;
    v18 = *a3;
    v19 = 0LL;
    v9 = 0LL;
    while ( !*(_QWORD *)(v18 + v19 + 8)
         || !(*(unsigned __int8 (__fastcall **)(__int64, _QWORD))(v28 + 24))(v27, *(_QWORD *)(v18 + v19)) )
    {
      v20 = v16 + v19;
      if ( (*(unsigned __int8 (__fastcall **)(_QWORD, _QWORD *))(v16 + v19 + 8))(*(_QWORD *)(v16 + v19), v22) )
        break;
      v19 += 16LL;
      ++v9;
      if ( v20 + 16 == v17 )
        goto LABEL_29;
    }
    return 1;
  }
  v9 = 0LL;
  if ( v29[1] )
  {
LABEL_30:
    if ( (*(unsigned __int8 (__fastcall **)(__int64, _QWORD, _QWORD))(v28 + 24))(
           v27,
           *(_QWORD *)(*v29 + 16 * v9),
           *(_QWORD *)(*v29 + 16 * v9 + 8)) )
    {
      return 1;
    }
  }
  return 0;
}

//----- (0000000000406390) ----------------------------------------------------
void __fastcall __noreturn sub_406390(__int64 a1)
{
  _QWORD v1[7]; // [rsp+0h] [rbp-50h] BYREF
  __int128 v2; // [rsp+38h] [rbp-18h]

  v1[4] = &off_4433B0;
  v1[5] = 1LL;
  v1[6] = 8LL;
  v2 = 0LL;
  sub_405240(&v1[4], a1);
}
// 405240: using guessed type void __fastcall __noreturn sub_405240(_QWORD, _QWORD);
// 4433B0: using guessed type char *off_4433B0;

//----- (00000000004063D0) ----------------------------------------------------
__int64 __fastcall sub_4063D0(_DWORD *a1, __int64 a2)
{
  __int64 v2; // r8
  __int64 v3; // rcx
  __int64 v4; // r11
  unsigned int v5; // r10d
  bool v6; // cc
  __int64 v7; // rcx
  _WORD v9[15]; // [rsp+32h] [rbp-Eh] BYREF

  LODWORD(v2) = *a1;
  v3 = 10LL;
  if ( (unsigned int)v2 >= 0x2710 )
  {
    v4 = 5LL;
    do
    {
      v5 = (unsigned int)v2 / 0x2710;
      v3 = v4 * 2 - 4;
      v9[v4] = a0001020304[(5243 * ((unsigned int)v2 % 0x2710)) >> 19];
      v9[v4 + 1] = a0001020304[(unsigned __int16)((unsigned int)v2 % 0x2710
                                                - 100
                                                * ((unsigned __int16)((5243 * ((unsigned int)v2 % 0x2710)) >> 16) >> 3))];
      v4 -= 2LL;
      v6 = (unsigned int)v2 <= 0x5F5E0FF;
      LODWORD(v2) = (unsigned int)v2 / 0x2710;
    }
    while ( !v6 );
    v2 = v5;
    if ( v5 <= 0x63 )
      goto LABEL_6;
    goto LABEL_5;
  }
  v2 = (unsigned int)v2;
  if ( (unsigned int)v2 > 0x63 )
  {
LABEL_5:
    *(_WORD *)((char *)&v9[1] + v3) = a0001020304[(unsigned __int16)v2 % 0x64u];
    v3 -= 2LL;
    v2 = (unsigned int)(5243 * ((unsigned __int16)v2 >> 2)) >> 17;
  }
LABEL_6:
  if ( (unsigned int)v2 >= 0xA )
  {
    *(_WORD *)((char *)&v9[1] + v3) = a0001020304[v2];
    v7 = v3 - 2;
  }
  else
  {
    *((_BYTE *)&v9[1] + v3 + 1) = v2 | 0x30;
    v7 = v3 - 1;
  }
  return sub_405270(a2, 1, 1LL, 0LL, (__int64)&v9[2] + v7, 10 - v7);
}
// 4428DB: using guessed type _WORD a0001020304[100];

//----- (0000000000406500) ----------------------------------------------------
__int64 __fastcall sub_406500(unsigned __int64 a1, __int64 a2)
{
  int v3; // eax
  __int64 v4; // rax
  __int64 v5; // r11
  unsigned __int64 v6; // rdx
  int v7; // esi
  bool v8; // cc
  __int64 v9; // rax
  __int64 v10; // r8
  unsigned __int64 v11; // rdx
  __int64 v12; // rax
  char v13; // r9
  unsigned __int64 v14; // rdx
  char v15; // r9
  _WORD v17[74]; // [rsp+2Ch] [rbp-54h] BYREF

  v3 = *(_DWORD *)(a2 + 36);
  if ( (v3 & 0x10) != 0 )
  {
    v10 = 129LL;
    v11 = a1;
    do
    {
      v12 = v10;
      v11 >>= 4;
      v13 = (a1 & 0xF) + 87;
      if ( (a1 & 0xF) < 0xA )
        v13 = (a1 & 0xF) + 48;
      *((_BYTE *)&v17[1] + v10--) = v13;
      v8 = a1 <= 0xF;
      a1 = v11;
    }
    while ( !v8 );
    return sub_405270(a2, 1, (__int64)a0x, 2LL, (__int64)&v17[1] + v12, 129 - v10);
  }
  if ( (v3 & 0x20) != 0 )
  {
    v10 = 129LL;
    v14 = a1;
    do
    {
      v12 = v10;
      v14 >>= 4;
      v15 = (a1 & 0xF) + 55;
      if ( (a1 & 0xF) < 0xA )
        v15 = (a1 & 0xF) + 48;
      *((_BYTE *)&v17[1] + v10--) = v15;
      v8 = a1 <= 0xF;
      a1 = v14;
    }
    while ( !v8 );
    return sub_405270(a2, 1, (__int64)a0x, 2LL, (__int64)&v17[1] + v12, 129 - v10);
  }
  v4 = 20LL;
  if ( a1 < 0x2710 )
  {
    v6 = a1;
    if ( a1 <= 0x63 )
      goto LABEL_8;
    goto LABEL_7;
  }
  v5 = 10LL;
  do
  {
    v6 = a1 / 0x2710;
    v7 = a1 % 0x2710;
    v4 = v5 * 2 - 4;
    v17[v5] = a0001020304[(unsigned int)(5243 * v7) >> 19];
    v17[v5 + 1] = a0001020304[(unsigned __int16)(v7 - 100 * ((unsigned __int16)((unsigned int)(5243 * v7) >> 16) >> 3))];
    v5 -= 2LL;
    v8 = a1 <= 0x5F5E0FF;
    a1 /= 0x2710uLL;
  }
  while ( !v8 );
  if ( v6 > 0x63 )
  {
LABEL_7:
    *(_WORD *)((char *)&v17[1] + v4) = a0001020304[(unsigned __int16)v6 % 0x64u];
    v4 -= 2LL;
    v6 = (unsigned int)(5243 * ((unsigned __int16)v6 >> 2)) >> 17;
  }
LABEL_8:
  if ( v6 >= 0xA )
  {
    *(_WORD *)((char *)&v17[1] + v4) = a0001020304[v6];
    v9 = v4 - 2;
  }
  else
  {
    *((_BYTE *)&v17[1] + v4 + 1) = v6 | 0x30;
    v9 = v4 - 1;
  }
  return sub_405270(a2, 1, 1LL, 0LL, (__int64)&v17[2] + v9, 20 - v9);
}
// 4428DB: using guessed type _WORD a0001020304[100];

//----- (0000000000406720) ----------------------------------------------------
__int64 __fastcall sub_406720(__int64 a1, __int64 a2)
{
  return (*(__int64 (__fastcall **)(_QWORD, const char *, __int64))(*(_QWORD *)(a2 + 56) + 24LL))(
           *(_QWORD *)(a2 + 48),
           aBorrowmuterror,
           14LL);
}

//----- (0000000000406750) ----------------------------------------------------
void __fastcall __noreturn sub_406750(__int64 a1)
{
  _QWORD v1[13]; // [rsp+0h] [rbp-70h] BYREF

  v1[11] = (char *)&v1[13] + 7;
  v1[12] = sub_406720;
  v1[5] = &off_442688;
  v1[6] = 1LL;
  v1[9] = 0LL;
  v1[7] = &v1[11];
  v1[8] = 1LL;
  sub_405240((__int64)&v1[5], a1);
}
// 442688: using guessed type char *off_442688;

//----- (00000000004067B0) ----------------------------------------------------
__int64 __fastcall sub_4067B0(_WORD *a1, __int64 a2)
{
  __int64 v2; // rax
  unsigned __int16 v3; // r9
  char v4; // r10
  __int64 v5; // r8
  _BYTE v7[130]; // [rsp+2Eh] [rbp-52h] BYREF

  LOWORD(a1) = *a1;
  v2 = 129LL;
  do
  {
    v3 = (unsigned __int16)a1;
    LODWORD(a1) = (unsigned __int16)a1 >> 4;
    v4 = (v3 & 0xF) + 87;
    if ( (v3 & 0xFu) < 0xA )
      v4 = (v3 & 0xF) + 48;
    v5 = v2;
    v7[v2--] = v4;
  }
  while ( v3 > 0xFu );
  return sub_405270(a2, 1, (__int64)a0x, 2LL, (__int64)&v7[v5], 129 - v2);
}

//----- (0000000000406850) ----------------------------------------------------
__int64 __fastcall sub_406850(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // r9
  unsigned __int64 v4; // rax
  unsigned __int64 v5; // rbx
  int v6; // r14d
  char v7; // r11
  unsigned __int64 v8; // r14
  char v9; // r14
  char v10; // r14
  __int64 result; // rax

  v3 = 0LL;
  if ( a3 >= 0xF )
    v3 = a3 - 15;
  if ( !a3 )
  {
LABEL_50:
    *(_QWORD *)(a1 + 8) = a2;
    *(_QWORD *)(a1 + 16) = a3;
    result = 0LL;
    goto LABEL_55;
  }
  v4 = 0LL;
  while ( 1 )
  {
    v5 = *(unsigned __int8 *)(a2 + v4);
    if ( (v5 & 0x80u) == 0LL )
    {
      if ( (((((_BYTE)a2 + 7) & 0xF8) - (_BYTE)a2 - (_BYTE)v4) & 7) != 0 )
      {
        ++v4;
      }
      else
      {
        while ( v4 < v3 && ((*(_QWORD *)(a2 + v4) | *(_QWORD *)(a2 + v4 + 8)) & 0x8080808080808080uLL) == 0 )
          v4 += 16LL;
        if ( v4 < a3 )
        {
          while ( *(char *)(a2 + v4) >= 0 )
          {
            if ( a3 == ++v4 )
              goto LABEL_50;
          }
        }
      }
      goto LABEL_6;
    }
    v6 = byte_449C04[v5];
    v7 = 1;
    if ( v6 != 4 )
    {
      if ( v6 == 3 )
      {
        if ( v4 + 1 >= a3 )
          goto LABEL_51;
        v9 = *(_BYTE *)(a2 + v4 + 1);
        if ( v5 == 224 )
        {
          if ( (v9 & 0xE0) != 0xA0 )
            goto LABEL_52;
        }
        else if ( (_DWORD)v5 == 237 )
        {
          if ( v9 > -97 )
            goto LABEL_52;
        }
        else if ( (unsigned __int8)(v5 + 31) >= 0xCu && (LOBYTE(v5) = v5 & 0xFE, (_BYTE)v5 != 0xEE) || v9 >= -64 )
        {
LABEL_52:
          LOBYTE(v5) = 1;
          goto LABEL_54;
        }
        v8 = v4 + 2;
        if ( v4 + 2 >= a3 )
          goto LABEL_51;
        if ( *(char *)(a2 + v8) > -65 )
          break;
      }
      else
      {
        if ( v6 != 2 )
          goto LABEL_52;
        v8 = v4 + 1;
        if ( v4 + 1 >= a3 )
        {
LABEL_51:
          v7 = 0;
          goto LABEL_54;
        }
        LOBYTE(v5) = 1;
        if ( *(char *)(a2 + v8) > -65 )
          goto LABEL_54;
      }
      goto LABEL_5;
    }
    if ( v4 + 1 >= a3 )
      goto LABEL_51;
    v10 = *(_BYTE *)(a2 + v4 + 1);
    if ( v5 == 240 )
    {
      if ( (unsigned __int8)(v10 + 112) >= 0x30u )
        goto LABEL_52;
    }
    else if ( (_DWORD)v5 == 244 )
    {
      if ( v10 > -113 )
        goto LABEL_52;
    }
    else if ( (unsigned __int8)(v5 + 15) > 2u || v10 >= -64 )
    {
      goto LABEL_52;
    }
    v5 = v4 + 2;
    if ( v4 + 2 >= a3 )
      goto LABEL_51;
    if ( *(char *)(a2 + v5) > -65 )
      break;
    v8 = v4 + 3;
    if ( v4 + 3 >= a3 )
      goto LABEL_51;
    if ( *(char *)(a2 + v8) > -65 )
    {
      LOBYTE(v5) = 3;
      goto LABEL_54;
    }
LABEL_5:
    v4 = v8 + 1;
LABEL_6:
    if ( v4 >= a3 )
      goto LABEL_50;
  }
  LOBYTE(v5) = 2;
LABEL_54:
  *(_QWORD *)(a1 + 8) = v4;
  *(_BYTE *)(a1 + 16) = v7;
  *(_BYTE *)(a1 + 17) = v5;
  result = 1LL;
LABEL_55:
  *(_QWORD *)a1 = result;
  return result;
}
// 449C04: using guessed type unsigned __int8 byte_449C04[256];

//----- (0000000000406A60) ----------------------------------------------------
_BYTE *__fastcall sub_406A60(
        _BYTE *a1,
        __int64 a2,
        unsigned __int64 a3,
        __int64 a4,
        unsigned __int8 (__fastcall *a5)(__int64, _OWORD *))
{
  char v6; // r14
  __int64 v9; // rbx
  unsigned __int8 v10; // al
  __int64 v11; // r12
  unsigned __int64 v12; // r15
  const char *v13; // rdx
  char v14; // al
  unsigned __int64 v15; // r14
  __int64 v16; // r15
  char v17; // al
  __int128 v18; // xmm1
  __int128 v19; // xmm2
  _OWORD v20[3]; // [rsp+20h] [rbp-60h] BYREF
  __int128 *v21; // [rsp+50h] [rbp-30h]
  __int64 (__fastcall **v22)(_OWORD *, const char *, __int64); // [rsp+58h] [rbp-28h]
  __int128 v23; // [rsp+60h] [rbp-20h] BYREF
  char *v24; // [rsp+70h] [rbp-10h]
  char v25; // [rsp+87h] [rbp+7h] BYREF

  v6 = 1;
  if ( a1[8] )
    goto LABEL_2;
  v9 = *(_QWORD *)a1;
  v10 = a1[9];
  if ( (*(_BYTE *)(*(_QWORD *)a1 + 36LL) & 4) != 0 )
  {
    if ( v10
      || (v15 = a3,
          v16 = a2,
          v17 = (*(__int64 (__fastcall **)(_QWORD, const char *, __int64))(*(_QWORD *)(v9 + 56) + 24LL))(
                  *(_QWORD *)(v9 + 48),
                  asc_4428D4,
                  3LL),
          a2 = v16,
          a3 = v15,
          v6 = 1,
          !v17) )
    {
      v25 = 1;
      v23 = *(_OWORD *)(v9 + 48);
      v24 = &v25;
      v18 = *(_OWORD *)(v9 + 16);
      v19 = *(_OWORD *)(v9 + 32);
      v20[0] = *(_OWORD *)v9;
      v20[1] = v18;
      v20[2] = v19;
      v21 = &v23;
      v22 = (__int64 (__fastcall **)(_OWORD *, const char *, __int64))&unk_4428A0;
      if ( !sub_406C00((__int64 *)&v23, a2, a3)
        && !sub_406C00((__int64 *)&v23, (__int64)asc_448C8B, 2uLL)
        && !a5(a4, v20) )
      {
        v14 = v22[3](v21, asc_4428D7, 2LL);
        goto LABEL_16;
      }
    }
  }
  else
  {
    v11 = a2;
    v12 = a3;
    v13 = asc_44755E;
    if ( v10 )
      v13 = asc_4474F1;
    if ( !(*(unsigned __int8 (__fastcall **)(_QWORD, const char *, __int64))(*(_QWORD *)(v9 + 56) + 24LL))(
            *(_QWORD *)(v9 + 48),
            v13,
            v10 ^ 3LL)
      && !(*(unsigned __int8 (__fastcall **)(_QWORD, __int64, unsigned __int64))(*(_QWORD *)(v9 + 56) + 24LL))(
            *(_QWORD *)(v9 + 48),
            v11,
            v12)
      && !(*(unsigned __int8 (__fastcall **)(_QWORD, const char *, __int64))(*(_QWORD *)(v9 + 56) + 24LL))(
            *(_QWORD *)(v9 + 48),
            asc_448C8B,
            2LL) )
    {
      v14 = a5(a4, (_OWORD *)v9);
LABEL_16:
      v6 = v14;
    }
  }
LABEL_2:
  a1[8] = v6;
  a1[9] = 1;
  return a1;
}

//----- (0000000000406C00) ----------------------------------------------------
char __fastcall sub_406C00(__int64 *a1, __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // r12
  __int64 v4; // rbx
  unsigned __int64 v5; // rdi
  unsigned __int64 v6; // r13
  char v7; // r14
  bool v8; // al
  char v9; // al
  unsigned __int64 v10; // r15
  __int64 v11; // r10
  unsigned __int64 v12; // rcx
  __int64 v13; // rax
  __int64 v14; // r9
  unsigned __int64 v15; // rdx
  unsigned __int64 v16; // r9
  _QWORD *v17; // rsi
  __int64 v18; // r9
  __int64 v19; // rsi
  unsigned __int64 v20; // rbx
  unsigned __int64 v21; // r12
  char v22; // al
  bool *v24; // [rsp+20h] [rbp-20h]
  __int64 v25; // [rsp+28h] [rbp-18h]
  __int64 v26; // [rsp+30h] [rbp-10h]
  unsigned __int64 v27; // [rsp+38h] [rbp-8h]

  v3 = 0x8080808080808080uLL;
  v4 = 0xA0A0A0A0A0A0A0ALL;
  v24 = (bool *)a1[2];
  v25 = *a1;
  v26 = a1[1];
  v5 = 0LL;
  v6 = 0LL;
  v7 = 0;
  v27 = a3;
  do
  {
    if ( (v7 & 1) != 0 )
      return 0;
    if ( v5 <= a3 )
    {
      v11 = a2;
      while ( 1 )
      {
        v12 = a3 - v5;
        v13 = v11 + v5;
        if ( a3 - v5 > 0xF )
        {
          v15 = ((v13 + 7) & 0xFFFFFFFFFFFFFFF8uLL) - v13;
          if ( v15 )
          {
            v14 = 0LL;
            while ( *(_BYTE *)(v13 + v14) != 10 )
            {
              if ( v15 == ++v14 )
              {
                v16 = v12 - 16;
                if ( v15 <= v12 - 16 )
                  goto LABEL_23;
                goto LABEL_26;
              }
            }
          }
          else
          {
            v16 = v12 - 16;
LABEL_23:
            v17 = (_QWORD *)(((v13 + 7) & 0xFFFFFFFFFFFFFFF8uLL) + 8);
            do
            {
              if ( ((v4 ^ *v17 | (0x101010101010100LL - (v4 ^ *v17))) & v3 & (*(v17 - 1) | (0x101010101010100LL
                                                                                          - (v4 ^ *(v17 - 1))))) != v3 )
                break;
              v15 += 16LL;
              v17 += 2;
            }
            while ( v15 <= v16 );
LABEL_26:
            if ( v15 == v12 )
            {
              a3 = v27;
              v10 = v27;
              goto LABEL_7;
            }
            a3 = v27;
            v18 = 0LL;
            v11 = a2;
            while ( *(_BYTE *)(v13 + v15 + v18) != 10 )
            {
              if ( v27 - v15 - v5 == ++v18 )
                goto LABEL_35;
            }
            v14 = v15 + v18;
          }
        }
        else
        {
          if ( a3 == v5 )
          {
LABEL_35:
            v10 = a3;
            goto LABEL_36;
          }
          v14 = 0LL;
          while ( *(_BYTE *)(v13 + v14) != 10 )
          {
            if ( v12 == ++v14 )
              goto LABEL_35;
          }
        }
        v10 = v5 + v14 + 1;
        if ( v14 + v5 < a3 && *(_BYTE *)(v13 + v14) == 10 )
        {
          v19 = v4;
          v20 = v3;
          v7 = 0;
          v5 += v14 + 1;
          v21 = v10;
          goto LABEL_37;
        }
        v5 += v14 + 1;
        if ( v10 > a3 )
          goto LABEL_36;
      }
    }
    v10 = v5;
LABEL_7:
    v11 = a2;
LABEL_36:
    v19 = v4;
    v20 = v3;
    v7 = 1;
    v5 = v10;
    v10 = v6;
    v21 = a3;
    if ( v6 == a3 )
      return 0;
LABEL_37:
    if ( *v24 )
    {
      v22 = (*(__int64 (__fastcall **)(__int64, const char *, __int64))(v26 + 24))(v25, asc_4428D0, 4LL);
      v11 = a2;
      if ( v22 )
        break;
    }
    v8 = v21 != v6 && *(_BYTE *)(v11 + v21 - 1) == 10;
    *v24 = v8;
    v9 = (*(__int64 (__fastcall **)(__int64, unsigned __int64, unsigned __int64))(v26 + 24))(v25, v11 + v6, v21 - v6);
    v6 = v10;
    v3 = v20;
    v4 = v19;
    a3 = v27;
  }
  while ( !v9 );
  return 1;
}

//----- (0000000000406EB0) ----------------------------------------------------
char __fastcall sub_406EB0(_QWORD *a1, int a2)
{
  bool *v2; // rdi
  __int64 v3; // rsi
  __int64 v4; // rbx
  int v5; // r14d
  char v6; // al

  v2 = (bool *)a1[2];
  v3 = *a1;
  v4 = a1[1];
  if ( *v2 )
  {
    v5 = a2;
    v6 = (*(__int64 (__fastcall **)(_QWORD, const char *, __int64))(v4 + 24))(*a1, asc_4428D0, 4LL);
    a2 = v5;
    if ( v6 )
      return 1;
  }
  *v2 = a2 == 10;
  return (*(__int64 (__fastcall **)(__int64))(v4 + 32))(v3);
}

//----- (0000000000406F20) ----------------------------------------------------
char __fastcall sub_406F20(__int64 a1, _QWORD *a2)
{
  return sub_406180(a1, (__int64)&unk_4428A0, a2);
}

//----- (0000000000406F40) ----------------------------------------------------
void __fastcall __noreturn sub_406F40(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  _QWORD v5[16]; // [rsp+0h] [rbp-80h] BYREF
  _QWORD v6[2]; // [rsp+80h] [rbp+0h] BYREF

  v6[0] = a1;
  v6[1] = a2;
  v5[14] = a3;
  v5[15] = a4;
  v5[10] = v6;
  v5[11] = sub_4123C0;
  v5[12] = &v5[14];
  v5[13] = sub_406140;
  v5[4] = &unk_4497D0;
  v5[5] = 2LL;
  v5[8] = 0LL;
  v5[6] = &v5[10];
  v5[7] = 2LL;
  sub_405240(&v5[4], a5);
}
// 405240: using guessed type void __fastcall __noreturn sub_405240(_QWORD, _QWORD);

//----- (0000000000406FD0) ----------------------------------------------------
void __fastcall __noreturn sub_406FD0(__int64 a1, __int64 a2, __int64 a3)
{
  sub_406FE0(a1, a2, a3);
}

//----- (0000000000406FE0) ----------------------------------------------------
void __fastcall __noreturn sub_406FE0(__int64 a1, __int64 a2, __int64 a3)
{
  _QWORD v3[16]; // [rsp+0h] [rbp-80h] BYREF

  v3[15] = a1;
  v3[14] = a2;
  v3[10] = &v3[15];
  v3[11] = sub_405120;
  v3[12] = &v3[14];
  v3[13] = sub_405120;
  v3[4] = &off_4434C0;
  v3[5] = 2LL;
  v3[8] = 0LL;
  v3[6] = &v3[10];
  v3[7] = 2LL;
  sub_405240(&v3[4], a3);
}
// 405240: using guessed type void __fastcall __noreturn sub_405240(_QWORD, _QWORD);
// 4434C0: using guessed type char *off_4434C0;

//----- (0000000000407050) ----------------------------------------------------
void __fastcall __noreturn sub_407050(__int64 a1)
{
  sub_405FC0((__int64)"called `Option::unwrap()` on a `None` valuelibrary\\core\\src\\panicking.rs", 43LL, a1);
}

//----- (0000000000407070) ----------------------------------------------------
void __noreturn sub_407070()
{
  _QWORD v0[14]; // [rsp+0h] [rbp-70h] BYREF

  v0[12] = aLockCountOverf;
  v0[13] = 38LL;
  v0[10] = &v0[12];
  v0[11] = sub_4123C0;
  v0[4] = &unk_448868;
  v0[5] = 1LL;
  v0[8] = 0LL;
  v0[6] = &v0[10];
  v0[7] = 1LL;
  sub_405240((__int64)&v0[4], (__int64)&off_4490E8);
}
// 4490E8: using guessed type char *off_4490E8;

//----- (00000000004070E0) ----------------------------------------------------
void __fastcall __noreturn sub_4070E0(__int128 *a1, char a2, __int64 a3)
{
  __int128 v3; // xmm0
  __int128 v4; // xmm1
  _OWORD v5[5]; // [rsp+0h] [rbp-70h] BYREF
  _OWORD *v6; // [rsp+58h] [rbp-18h]
  __int64 v7; // [rsp+60h] [rbp-10h]
  char v8; // [rsp+68h] [rbp-8h]
  char v9; // [rsp+69h] [rbp-7h]

  v3 = *a1;
  v4 = a1[1];
  v5[4] = a1[2];
  v5[3] = v4;
  v5[2] = v3;
  v6 = &v5[2];
  v7 = a3;
  v8 = 0;
  v9 = a2;
  sub_43CC30((char *)&v5[5] + 8);
}
// 43CC30: using guessed type void __fastcall __noreturn sub_43CC30(_QWORD);

//----- (0000000000407125) ----------------------------------------------------
void __noreturn sub_407125()
{
  sub_407140();
}

//----- (0000000000407140) ----------------------------------------------------
void __noreturn sub_407140()
{
  _QWORD v0[7]; // [rsp+0h] [rbp-60h] BYREF
  __int128 v1; // [rsp+38h] [rbp-28h]
  const char *v2; // [rsp+50h] [rbp-10h]
  __int64 v3; // [rsp+58h] [rbp-8h]

  v2 = aPanicInAFuncti;
  v3 = 38LL;
  v0[4] = &v0[10];
  v0[5] = 1LL;
  v0[6] = 8LL;
  v1 = 0LL;
  sub_4070E0(&v0[4], 0LL, &off_4426E0);
}
// 4070E0: using guessed type void __fastcall __noreturn sub_4070E0(_QWORD, _QWORD, _QWORD);
// 4426E0: using guessed type char *off_4426E0;

//----- (0000000000407190) ----------------------------------------------------
void __noreturn sub_407190()
{
  _QWORD v0[7]; // [rsp+0h] [rbp-60h] BYREF
  __int128 v1; // [rsp+38h] [rbp-28h]
  const char *v2; // [rsp+50h] [rbp-10h]
  __int64 v3; // [rsp+58h] [rbp-8h]

  v2 = aPanicInADestru;
  v3 = 36LL;
  v0[4] = &v0[10];
  v0[5] = 1LL;
  v0[6] = 8LL;
  v1 = 0LL;
  sub_4070E0((__int128 *)&v0[4], 1, (__int64)&off_4426F8);
}
// 4426F8: using guessed type char *off_4426F8;

//----- (00000000004071E0) ----------------------------------------------------
__int64 __fastcall sub_4071E0(unsigned __int64 a1, __int64 a2)
{
  __int64 v2; // r9
  unsigned __int64 v3; // r8
  __int64 v4; // rax
  char v5; // r10
  bool v6; // cc
  _BYTE v8[130]; // [rsp+2Eh] [rbp-52h] BYREF

  v2 = 129LL;
  v3 = a1;
  do
  {
    v4 = v2;
    v3 >>= 4;
    v5 = (a1 & 0xF) + 87;
    if ( (a1 & 0xF) < 0xA )
      v5 = (a1 & 0xF) + 48;
    v8[v2--] = v5;
    v6 = a1 <= 0xF;
    a1 = v3;
  }
  while ( !v6 );
  return sub_405270(a2, 1, (__int64)a0x, 2LL, (__int64)&v8[v4], 129 - v2);
}

//----- (0000000000407276) ----------------------------------------------------
void __noreturn sub_407276()
{
  sub_407190();
}

//----- (0000000000407286) ----------------------------------------------------
void __fastcall __noreturn sub_407286(__int64 a1, __int64 a2, __int128 *a3, __int64 a4)
{
  _BYTE v4[32]; // [rsp+0h] [rbp-50h] BYREF

  *(_QWORD *)&v4[72] = a1;
  *(_QWORD *)&v4[64] = a2;
  sub_405FFE(0, (__int64)&v4[72], (__int64)&unk_4427B8, (__int64)&v4[64], (__int64)&unk_4427B8, a3, a4);
}

//----- (00000000004072D0) ----------------------------------------------------
__int64 __fastcall sub_4072D0(unsigned __int64 **a1, __int64 a2)
{
  return sub_406500(**a1, a2);
}

//----- (00000000004072E0) ----------------------------------------------------
__int64 __fastcall sub_4072E0(_BYTE *a1, unsigned __int64 a2, __int64 a3, __int64 a4)
{
  unsigned int v4; // r14d
  __int64 v5; // r12
  __int64 v6; // rdi
  unsigned __int8 (__fastcall *v9)(__int64, __int64); // rbx
  _BYTE *v10; // rdi
  unsigned __int64 v11; // rax
  unsigned __int64 v12; // r13
  unsigned __int64 v13; // r9
  _BYTE *v14; // rbx
  __int64 v15; // r12
  int v16; // ecx
  _BYTE *v17; // rdi
  int v18; // eax
  int v19; // edx
  int v20; // ecx
  char v21; // r14
  unsigned __int64 v22; // r12
  unsigned __int64 v23; // r8
  _BYTE *v24; // r13
  unsigned __int8 (__fastcall *v25)(__int64, _BYTE *, unsigned __int64); // r15
  unsigned __int8 v26; // al
  __int64 v27; // r13
  __int64 v28; // r9
  unsigned __int64 v29; // rax
  _BYTE *v31; // [rsp+28h] [rbp-28h]
  __int64 v32; // [rsp+30h] [rbp-20h]
  unsigned __int8 (__fastcall *v33)(__int64, __int64); // [rsp+38h] [rbp-18h]
  _BYTE v34[4]; // [rsp+44h] [rbp-Ch] BYREF
  unsigned int v35; // [rsp+48h] [rbp-8h]
  unsigned __int8 v36; // [rsp+4Eh] [rbp-2h]
  unsigned __int8 v37; // [rsp+4Fh] [rbp-1h]
  __int64 v38; // [rsp+50h] [rbp+0h]

  v5 = a4;
  v6 = a3;
  v9 = *(unsigned __int8 (__fastcall **)(__int64, __int64))(a4 + 32);
  LOBYTE(v4) = 1;
  if ( v9(a3, 34LL) )
    return v4;
  if ( !a2 )
  {
    a2 = 0LL;
    v29 = 0LL;
    goto LABEL_58;
  }
  v32 = v5;
  v33 = v9;
  v38 = v6;
  v10 = a1;
  v11 = a2;
  v12 = 0LL;
  v13 = 0LL;
  do
  {
    v14 = &v10[v11];
    v15 = 0LL;
    while ( 1 )
    {
      v16 = (unsigned __int8)v10[v15];
      if ( (unsigned __int8)(v16 - 127) < 0xA1u || v16 == 34 || v16 == 92 )
        break;
      if ( v11 == ++v15 )
      {
        v13 += v11;
        goto LABEL_43;
      }
    }
    v4 = (unsigned __int8)v10[v15];
    if ( (v4 & 0x80u) != 0 )
    {
      v17 = &v10[v15];
      v18 = v4 & 0x1F;
      v19 = v17[1] & 0x3F;
      if ( (unsigned __int8)v4 <= 0xDFu )
      {
        v10 = v17 + 2;
        v4 = v19 | (v18 << 6);
      }
      else
      {
        v20 = (v19 << 6) | v17[2] & 0x3F;
        if ( (unsigned __int8)v4 < 0xF0u )
        {
          v10 = v17 + 3;
          v4 = (v18 << 12) | v20;
        }
        else
        {
          v21 = v17[3];
          v10 = v17 + 4;
          v4 = ((v18 & 7) << 18) | (v20 << 6) | v21 & 0x3F;
        }
      }
    }
    else
    {
      v10 += v15 + 1;
    }
    v22 = v13 + v15;
    sub_407630((__int64)v34, v4, 65537);
    if ( !__OFSUB__(0, v34[0]) && v37 - v36 != 1 )
    {
      v23 = v22 - v12;
      if ( v22 < v12 )
        goto LABEL_63;
      if ( v12 )
      {
        if ( v12 >= a2 )
        {
          if ( v12 != a2 )
            goto LABEL_63;
        }
        else if ( (char)a1[v12] <= -65 )
        {
          goto LABEL_63;
        }
      }
      if ( v22 )
      {
        if ( v22 >= a2 )
        {
          if ( v22 != a2 )
LABEL_63:
            sub_4079A0(a1, a2, v12, v22, (__int64)&off_4429C0);
        }
        else if ( (char)a1[v22] <= -65 )
        {
          goto LABEL_63;
        }
      }
      v31 = a1;
      v24 = &a1[v12];
      v25 = *(unsigned __int8 (__fastcall **)(__int64, _BYTE *, unsigned __int64))(v32 + 24);
      if ( v25(v38, v24, v23)
        || (!__OFSUB__(0, v34[0]) ? (v26 = v25(v38, &v34[v36], v37 - (unsigned __int64)v36)) : (v26 = v33(v38, v35)), v26) )
      {
        LOBYTE(v4) = 1;
        return v4;
      }
      v27 = 1LL;
      if ( v4 >= 0x80 )
      {
        v27 = 2LL;
        if ( v4 >= 0x800 )
          v27 = 4LL - (v4 < 0x10000);
      }
      v12 = v22 + v27;
      a1 = v31;
    }
    v28 = 1LL;
    if ( v4 >= 0x80 )
    {
      v28 = 2LL;
      if ( v4 >= 0x800 )
        v28 = 4LL - (v4 < 0x10000);
    }
    v13 = v22 + v28;
    v11 = v14 - v10;
  }
  while ( v14 != v10 );
LABEL_43:
  if ( v12 > v13 )
    goto LABEL_62;
  LOBYTE(v4) = 1;
  if ( !v12 )
  {
    v29 = 0LL;
    if ( v13 )
      goto LABEL_48;
LABEL_53:
    a2 = 0LL;
    goto LABEL_57;
  }
  if ( v12 >= a2 )
  {
    v29 = a2;
    if ( v12 != a2 )
      goto LABEL_62;
  }
  else
  {
    v29 = v12;
    if ( (char)a1[v12] <= -65 )
      goto LABEL_62;
  }
  if ( !v13 )
    goto LABEL_53;
LABEL_48:
  if ( v13 >= a2 )
  {
    v12 = v29;
    if ( v13 == a2 )
      goto LABEL_57;
LABEL_62:
    sub_4079A0(a1, a2, v12, v13, (__int64)&off_4429D8);
  }
  v12 = v29;
  if ( (char)a1[v13] <= -65 )
    goto LABEL_62;
  a2 = v13;
LABEL_57:
  v6 = v38;
  v9 = v33;
  v5 = v32;
LABEL_58:
  if ( !(*(unsigned __int8 (__fastcall **)(__int64, _BYTE *, unsigned __int64))(v5 + 24))(v6, &a1[v29], a2 - v29) )
    return ((unsigned int (__fastcall *)(__int64, __int64))v9)(v6, 34LL);
  return v4;
}
// 4075DA: variable 'v4' is possibly undefined
// 4429C0: using guessed type char *off_4429C0;
// 4429D8: using guessed type char *off_4429D8;

//----- (0000000000407630) ----------------------------------------------------
char __fastcall sub_407630(__int64 a1, unsigned int a2, int a3)
{
  char result; // al
  __int64 v5; // rdi
  unsigned int v6; // eax
  __int64 v7; // rax
  char v8; // cl
  _BYTE *v9; // rdx
  void *v10; // r9
  __int64 v11; // r8
  __int64 v12; // rdi
  unsigned int v13; // eax
  __int64 v14; // rax
  char v15; // dl
  unsigned __int64 v16; // [rsp+20h] [rbp-30h]
  char *v17; // [rsp+28h] [rbp-28h]
  __int64 v18; // [rsp+30h] [rbp-20h]
  __int64 v19; // [rsp+38h] [rbp-18h]
  __int16 v20; // [rsp+40h] [rbp-10h]
  __int16 v21; // [rsp+42h] [rbp-Eh]
  __int64 v22; // [rsp+44h] [rbp-Ch]
  __int16 v23; // [rsp+4Ch] [rbp-4h]

  result = a2;
  switch ( a2 )
  {
    case 0u:
      *(_WORD *)a1 = 12380;
      goto LABEL_15;
    case 1u:
    case 2u:
    case 3u:
    case 4u:
    case 5u:
    case 6u:
    case 7u:
    case 8u:
    case 0xBu:
    case 0xCu:
    case 0xEu:
    case 0xFu:
    case 0x10u:
    case 0x11u:
    case 0x12u:
    case 0x13u:
    case 0x14u:
    case 0x15u:
    case 0x16u:
    case 0x17u:
    case 0x18u:
    case 0x19u:
    case 0x1Au:
    case 0x1Bu:
    case 0x1Cu:
    case 0x1Du:
    case 0x1Eu:
    case 0x1Fu:
    case 0x20u:
    case 0x21u:
    case 0x23u:
    case 0x24u:
    case 0x25u:
    case 0x26u:
      goto LABEL_5;
    case 9u:
      *(_WORD *)a1 = 29788;
      goto LABEL_15;
    case 0xAu:
      *(_WORD *)a1 = 28252;
      goto LABEL_15;
    case 0xDu:
      *(_WORD *)a1 = 29276;
      goto LABEL_15;
    case 0x22u:
      if ( (a3 & 0x10000) == 0 )
        goto LABEL_30;
      *(_WORD *)a1 = 8796;
      goto LABEL_15;
    case 0x27u:
      if ( (a3 & 0x100) == 0 )
        goto LABEL_30;
      *(_WORD *)a1 = 10076;
      goto LABEL_15;
    default:
      if ( a2 != 92 )
      {
LABEL_5:
        result = a2 >= 0x300;
        if ( ((unsigned __int8)a3 & (a2 >= 0x300)) != 0 )
        {
          v5 = a1;
          if ( sub_407EB0(a2) )
          {
            _BitScanReverse(&v6, a2 | 1);
            v7 = (v6 ^ 0x1C) >> 2;
            v8 = v7 - 2;
            BYTE2(v22) = 0;
            LOWORD(v22) = 0;
            BYTE3(v22) = a0123456789abcd[a2 >> 20];
            BYTE4(v22) = a0123456789abcd[HIWORD(a2) & 0xF];
            BYTE5(v22) = a0123456789abcd[(unsigned __int16)a2 >> 12];
            BYTE6(v22) = a0123456789abcd[(a2 >> 8) & 0xF];
            HIBYTE(v22) = a0123456789abcd[(unsigned __int8)a2 >> 4];
            LOBYTE(v23) = a0123456789abcd[a2 & 0xF];
            HIBYTE(v23) = 125;
            *(__int16 *)((char *)&v21 + v7) = 30044;
            *((_BYTE *)&v22 + v7) = 123;
            *(_WORD *)(v5 + 8) = v23;
            result = v22;
            *(_QWORD *)v5 = v22;
            *(_BYTE *)(v5 + 10) = v8;
            *(_BYTE *)(v5 + 11) = 10;
            return result;
          }
          a1 = v5;
        }
        else
        {
          if ( a2 < 0x20 )
          {
LABEL_25:
            _BitScanReverse(&v13, a2 | 1);
            v14 = (v13 ^ 0x1C) >> 2;
            v15 = v14 - 2;
            BYTE2(v19) = 0;
            LOWORD(v19) = 0;
            BYTE3(v19) = a0123456789abcd[a2 >> 20];
            BYTE4(v19) = a0123456789abcd[HIWORD(a2) & 0xF];
            BYTE5(v19) = a0123456789abcd[(unsigned __int16)a2 >> 12];
            BYTE6(v19) = a0123456789abcd[(a2 >> 8) & 0xF];
            HIBYTE(v19) = a0123456789abcd[(unsigned __int8)a2 >> 4];
            LOBYTE(v20) = a0123456789abcd[a2 & 0xF];
            HIBYTE(v20) = 125;
            *(_WORD *)((char *)&v18 + v14 + 6) = 30044;
            *((_BYTE *)&v19 + v14) = 123;
            *(_WORD *)(a1 + 8) = v20;
            result = v19;
            *(_QWORD *)a1 = v19;
            *(_BYTE *)(a1 + 10) = v15;
            *(_BYTE *)(a1 + 11) = 10;
            return result;
          }
          if ( a2 < 0x7F )
            goto LABEL_30;
        }
        if ( a2 >= 0x10000 )
        {
          if ( a2 >= 0x20000 )
          {
            if ( _mm_movemask_ps((__m128)_mm_cmpgt_epi32(
                                           _mm_xor_si128(
                                             _mm_add_epi32(
                                               _mm_shuffle_epi32(_mm_cvtsi32_si128(a2), 0),
                                               (__m128i)xmmword_4400A0),
                                             (__m128i)xmmword_4400B0),
                                           (__m128i)xmmword_4400C0)) != 0
              || a2 - 917760 >= 0xFFF522B0
              || a2 - 196608 >= 0xFFFFFA1E
              || a2 - 201552 >= 0xFFFFFFFB )
            {
              goto LABEL_25;
            }
            if ( (a2 & 0x1FFFE0) == 0x2A6E0 )
              goto LABEL_25;
            if ( a2 > 0xE01EF )
              goto LABEL_25;
            result = a2 & 0xFE;
            if ( (a2 & 0x1FFFFE) == 0x2B81E )
              goto LABEL_25;
            goto LABEL_30;
          }
          v17 = asc_442EB0;
          v18 = 486LL;
          v16 = 208LL;
          v9 = byte_442D88;
          v10 = &unk_442DE0;
          v11 = 44LL;
        }
        else
        {
          v17 = byte_443208;
          v18 = 297LL;
          v16 = 290LL;
          v9 = byte_443096;
          v10 = &unk_4430E6;
          v11 = 40LL;
        }
        v12 = a1;
        result = sub_408030(a2, v9, v11, (__int64)v10, v16, v17, v18);
        a1 = v12;
        if ( !result )
          goto LABEL_25;
LABEL_30:
        *(_BYTE *)a1 = 0x80;
        *(_DWORD *)(a1 + 4) = a2;
        return result;
      }
      *(_WORD *)a1 = 23644;
LABEL_15:
      *(_QWORD *)(a1 + 2) = 0LL;
      *(_WORD *)(a1 + 10) = 512;
      return result;
  }
}
// 4400A0: using guessed type __int128 xmmword_4400A0;
// 4400B0: using guessed type __int128 xmmword_4400B0;
// 4400C0: using guessed type __int128 xmmword_4400C0;
// 442D88: using guessed type _BYTE byte_442D88[88];
// 443096: using guessed type _BYTE byte_443096[80];

//----- (00000000004079A0) ----------------------------------------------------
void __fastcall __noreturn sub_4079A0(
        _BYTE *a1,
        unsigned __int64 a2,
        unsigned __int64 a3,
        unsigned __int64 a4,
        __int64 a5)
{
  sub_4079C0(a1, a2, a3, a4, a5);
}

//----- (00000000004079C0) ----------------------------------------------------
void __fastcall __noreturn sub_4079C0(
        _BYTE *a1,
        unsigned __int64 a2,
        unsigned __int64 a3,
        unsigned __int64 a4,
        __int64 a5)
{
  __int64 v5; // r11
  __int64 v6; // r10
  __int64 v7; // r11
  unsigned __int64 v8; // r8
  unsigned __int64 v9; // r10
  unsigned __int64 v10; // r11
  unsigned __int64 v11; // r8
  _BYTE *v12; // r11
  _BYTE *v13; // r9
  char v14; // r9
  __int64 v15; // rdx
  int v16; // edx
  int v17; // r11d
  int v18; // r10d
  unsigned int v19; // ecx
  unsigned __int64 v20; // [rsp+28h] [rbp-58h] BYREF
  unsigned __int64 v21; // [rsp+30h] [rbp-50h] BYREF
  unsigned __int64 v22; // [rsp+38h] [rbp-48h] BYREF
  _QWORD v23[2]; // [rsp+40h] [rbp-40h] BYREF
  _QWORD v24[2]; // [rsp+50h] [rbp-30h] BYREF
  unsigned __int64 *v25; // [rsp+60h] [rbp-20h] BYREF
  __int64 (__fastcall *v26)(unsigned __int64 *, __int64); // [rsp+68h] [rbp-18h]
  _QWORD *v27; // [rsp+70h] [rbp-10h]
  void *v28; // [rsp+78h] [rbp-8h]
  _QWORD *v29; // [rsp+80h] [rbp+0h]
  void *v30; // [rsp+88h] [rbp+8h]
  _QWORD *v31; // [rsp+90h] [rbp+10h]
  char (__fastcall *v32)(__int64, __int64); // [rsp+98h] [rbp+18h]
  _QWORD *v33; // [rsp+A0h] [rbp+20h]
  char (__fastcall *v34)(__int64, __int64); // [rsp+A8h] [rbp+28h]
  char **v35; // [rsp+B0h] [rbp+30h] BYREF
  __int64 v36; // [rsp+B8h] [rbp+38h]
  unsigned __int64 **v37; // [rsp+C0h] [rbp+40h]
  __int64 v38; // [rsp+C8h] [rbp+48h]
  __int64 v39; // [rsp+D0h] [rbp+50h]
  _BYTE *v40; // [rsp+E0h] [rbp+60h] BYREF
  unsigned __int64 v41; // [rsp+E8h] [rbp+68h]
  unsigned int v42; // [rsp+F4h] [rbp+74h] BYREF

  v22 = a3;
  v21 = a4;
  if ( a2 < 0x101 )
  {
    v40 = a1;
    v41 = a2;
    v7 = 1LL;
    v6 = 0LL;
  }
  else
  {
    v5 = 3LL;
    if ( (char)a1[256] <= -65 )
    {
      v5 = 2LL;
      if ( (char)a1[255] <= -65 )
        v5 = a1[254] >= 0xC0;
    }
    if ( (char)a1[v5 + 253] <= -65 )
      sub_4079A0((_DWORD)a1, a2, 0, v5 + 253, a5);
    v40 = a1;
    v41 = v5 + 253;
    v6 = 5LL;
    v7 = (__int64)&unk_442BE0;
  }
  v24[0] = v7;
  v24[1] = v6;
  if ( a3 > a2 || a4 > a2 )
  {
    if ( a3 > a2 )
      a4 = a3;
    v23[0] = a4;
    v25 = v23;
    v26 = sub_405120;
    v27 = &v40;
    v28 = sub_4123C0;
    v29 = v24;
    v30 = sub_4123C0;
    v35 = &off_442CE8;
    v36 = 3LL;
    v39 = 0LL;
    v37 = &v25;
    v38 = 3LL;
    sub_405240(&v35, a5);
  }
  if ( a3 > a4 )
  {
    v25 = &v22;
    v26 = sub_405120;
    v27 = &v21;
    v28 = sub_405120;
    v29 = &v40;
    v30 = sub_4123C0;
    v31 = v24;
    v32 = sub_4123C0;
    v35 = &off_442C08;
    v36 = 4LL;
    v39 = 0LL;
    v37 = &v25;
    v38 = 4LL;
    sub_405240(&v35, a5);
  }
  if ( a3 != 0 && a3 < a2 && (char)a1[a3] < -64 )
    a4 = a3;
  v20 = a4;
  v8 = a2;
  if ( a4 < a2 )
  {
    v9 = 0LL;
    if ( a4 >= 3 )
      v9 = a4 - 3;
    v10 = a4 + 1;
    if ( a4 + 1 < v9 )
      sub_406FD0(v9, a4 + 1, (__int64)&off_442D18);
    v11 = v10 - v9;
    if ( v10 != v9 )
    {
      if ( (char)a1[a4] <= -65 )
      {
        if ( v9 != a4 )
        {
          v12 = &a1[v10];
          if ( (char)*(v12 - 2) <= -65 )
          {
            v13 = &a1[v9];
            if ( &a1[v9] != v12 - 2 )
            {
              if ( (char)*(v12 - 3) <= -65 )
              {
                if ( v13 != v12 - 3 )
                {
                  if ( (char)*(v12 - 4) <= -65 )
                  {
                    if ( v13 != v12 - 4 )
                      v11 -= 5LL;
                  }
                  else
                  {
                    v11 -= 4LL;
                  }
                }
              }
              else
              {
                v11 -= 3LL;
              }
            }
          }
          else
          {
            v11 -= 2LL;
          }
        }
      }
      else
      {
        --v11;
      }
    }
    v8 = v9 + v11;
  }
  if ( !v8 )
  {
LABEL_35:
    if ( v8 == a2 )
      goto LABEL_36;
    v14 = a1[v8];
    if ( v14 >= 0 )
    {
      v42 = (unsigned __int8)a1[v8];
      v15 = 1LL;
      goto LABEL_54;
    }
    v16 = v14 & 0x1F;
    v17 = a1[v8 + 1] & 0x3F;
    if ( (unsigned __int8)v14 <= 0xDFu )
    {
      v19 = v17 | (v16 << 6);
    }
    else
    {
      v18 = (v17 << 6) | a1[v8 + 2] & 0x3F;
      if ( (unsigned __int8)v14 < 0xF0u )
      {
        v19 = (v16 << 12) | v18;
        v42 = v19;
        v15 = 1LL;
        if ( v19 < 0x80 )
          goto LABEL_54;
LABEL_52:
        v15 = 2LL;
        if ( v19 >= 0x800 )
          v15 = 4LL - (v19 < 0x10000);
LABEL_54:
        v23[0] = v8;
        v23[1] = v8 + v15;
        v25 = &v20;
        v26 = sub_405120;
        v27 = &v42;
        v28 = sub_407DC0;
        v29 = v23;
        v30 = sub_407E50;
        v31 = &v40;
        v32 = sub_4123C0;
        v33 = v24;
        v34 = sub_4123C0;
        v35 = &off_442C80;
        v36 = 5LL;
        v39 = 0LL;
        v37 = &v25;
        v38 = 5LL;
        sub_405240(&v35, a5);
      }
      v19 = ((v14 & 7) << 18) | (v18 << 6) | a1[v8 + 3] & 0x3F;
      if ( v19 == 1114112 )
LABEL_36:
        sub_407050(a5);
    }
    v42 = v19;
    v15 = 1LL;
    if ( v19 < 0x80 )
      goto LABEL_54;
    goto LABEL_52;
  }
  if ( v8 >= a2 )
  {
    if ( v8 == a2 )
      goto LABEL_35;
  }
  else if ( (char)a1[v8] > -65 )
  {
    goto LABEL_35;
  }
  sub_4079A0((_DWORD)a1, a2, v8, a2, a5);
}
// 405240: using guessed type void __fastcall __noreturn sub_405240(_QWORD, _QWORD);
// 4079A0: using guessed type void __fastcall __noreturn sub_4079A0(_DWORD, _DWORD, _DWORD, _DWORD, __int64);
// 442C08: using guessed type char *off_442C08;
// 442C80: using guessed type char *off_442C80;
// 442CE8: using guessed type char *off_442CE8;
// 442D18: using guessed type char *off_442D18;

//----- (0000000000407DC0) ----------------------------------------------------
char __fastcall sub_407DC0(unsigned int *a1, __int64 a2)
{
  __int64 v3; // rsi
  __int64 v4; // r14
  __int64 (__fastcall *v5)(__int64, __int64); // rbx
  char v6; // cl
  char result; // al
  _BYTE v8[4]; // [rsp+24h] [rbp-Ch] BYREF
  unsigned int v9; // [rsp+28h] [rbp-8h]
  unsigned __int8 v10; // [rsp+2Eh] [rbp-2h]
  unsigned __int8 v11; // [rsp+2Fh] [rbp-1h]

  v3 = *(_QWORD *)(a2 + 48);
  v4 = *(_QWORD *)(a2 + 56);
  v5 = *(__int64 (__fastcall **)(__int64, __int64))(v4 + 32);
  v6 = v5(v3, 39LL);
  result = 1;
  if ( !v6 )
  {
    sub_407630(v8, *a1, 257LL);
    if ( __OFSUB__(0, v8[0]) )
    {
      if ( !(unsigned __int8)v5(v3, v9) )
        return v5(v3, 39LL);
    }
    else if ( !(*(unsigned __int8 (__fastcall **)(__int64, _BYTE *, unsigned __int64))(v4 + 24))(
                 v3,
                 &v8[v10],
                 v11 - (unsigned __int64)v10) )
    {
      return v5(v3, 39LL);
    }
    return 1;
  }
  return result;
}
// 407630: using guessed type __int64 __fastcall sub_407630(_QWORD, _QWORD, _QWORD);

//----- (0000000000407E50) ----------------------------------------------------
char __fastcall sub_407E50(unsigned __int64 *a1, __int64 a2)
{
  if ( (unsigned __int8)sub_406500(*a1, a2)
    || (*(unsigned __int8 (__fastcall **)(_QWORD, const char *, __int64))(*(_QWORD *)(a2 + 56) + 24LL))(
         *(_QWORD *)(a2 + 48),
         "..\\.",
         2LL) )
  {
    return 1;
  }
  else
  {
    return sub_406500(a1[1], a2);
  }
}

//----- (0000000000407EB0) ----------------------------------------------------
char __fastcall sub_407EB0(unsigned int a1)
{
  unsigned int v1; // eax
  __int64 v2; // r8
  __int64 v3; // r9
  __int64 v4; // r8
  __int64 v5; // r9
  __int64 v6; // r8
  __int64 v7; // r10
  unsigned __int64 v8; // r9
  unsigned __int64 v9; // rax
  __int64 v10; // r8
  int v11; // r10d
  unsigned int v12; // ecx
  __int64 v13; // r8
  unsigned int v14; // edx
  unsigned __int64 v15; // r9
  __int64 v17; // rcx

  v1 = a1 << 11;
  v2 = 17LL;
  if ( a1 < 0x1182F )
    v2 = 0LL;
  v3 = v2 + 8;
  if ( dword_443A98[v2 + 8] << 11 > v1 )
    v3 = v2;
  v4 = v3 + 4;
  if ( dword_443A98[v3 + 4] << 11 > v1 )
    v4 = v3;
  v5 = v4 + 2;
  if ( dword_443A98[v4 + 2] << 11 > v1 )
    v5 = v4;
  v6 = v5 + 1;
  if ( dword_443A98[v5 + 1] << 11 > v1 )
    v6 = v5;
  v7 = v6 + 1;
  if ( dword_443A98[v6 + 1] << 11 > v1 )
    v7 = v6;
  v8 = v7 + (dword_443A98[v7] << 11 < v1) + (unsigned __int64)(dword_443A98[v7] << 11 == v1);
  if ( v8 > 0x21 )
    sub_4050B0(v8, 34LL, (__int64)&off_443360);
  v9 = dword_443A98[v8] >> 21;
  v10 = 751LL;
  if ( v8 == 33 || (v10 = dword_443A98[v8 + 1] >> 21, v8) )
  {
    v11 = dword_443A98[v8 - 1] & 0x1FFFFF;
    if ( !(v10 + ~v9) )
      return v9 & 1;
  }
  else
  {
    v11 = 0;
    if ( !(v10 + ~v9) )
      return v9 & 1;
  }
  v12 = a1 - v11;
  v13 = v10 - 1;
  v14 = 0;
  v15 = dword_443A98[v8] >> 21;
  while ( 1 )
  {
    if ( v15 > 0x2EE )
    {
      v17 = 751LL;
      if ( v9 >= 0x2F0 )
        v17 = v9;
      sub_4050B0(v17, 751LL, (__int64)&off_443378);
    }
    v14 += byte_443B20[v15];
    if ( v14 > v12 )
      break;
    if ( v13 == ++v15 )
    {
      LOBYTE(v9) = v13;
      return v9 & 1;
    }
  }
  LOBYTE(v9) = v15;
  return v9 & 1;
}
// 443360: using guessed type char *off_443360;
// 443378: using guessed type char *off_443378;
// 443A98: using guessed type _DWORD dword_443A98[34];
// 443B20: using guessed type unsigned __int8 byte_443B20[752];

//----- (0000000000408030) ----------------------------------------------------
char __fastcall sub_408030(int a1, _BYTE *a2, __int64 a3, __int64 a4, unsigned __int64 a5, char *a6, __int64 a7)
{
  _BYTE *v7; // rax
  char *v8; // rdi
  _BYTE *v9; // r8
  unsigned __int64 v10; // r11
  _BYTE *v11; // r15
  __int64 v12; // r14
  unsigned __int64 v13; // r10
  __int64 v14; // r11
  __int64 v15; // r15
  char *v17; // rsi
  int v18; // edx
  int v19; // r8d
  char v20; // al

  v7 = a2;
  v8 = a6;
  v9 = &a2[2 * a3];
  v10 = 0LL;
  while ( 1 )
  {
    v11 = v7;
    v12 = (unsigned __int8)v7[1];
    v7 += 2;
    v13 = v10 + v12;
    if ( *v11 == BYTE1(a1) )
      break;
    if ( *v11 > BYTE1(a1) )
      goto LABEL_11;
LABEL_10:
    v10 = v13;
    if ( v7 == v9 )
    {
LABEL_11:
      v17 = &a6[a7];
      a1 = (unsigned __int16)a1;
      v20 = 1;
      while ( 1 )
      {
        v18 = *v8;
        if ( v18 < 0 )
        {
          if ( v8 + 1 == v17 )
            sub_407050((__int64)&off_442D58);
          v19 = (unsigned __int8)v8[1];
          v8 += 2;
          a1 -= v19 | ((v18 & 0x7F) << 8);
          if ( a1 < 0 )
            return v20 & 1;
        }
        else
        {
          ++v8;
          a1 -= v18;
          if ( a1 < 0 )
            return v20 & 1;
        }
        v20 ^= 1u;
        if ( v8 == v17 )
          return v20 & 1;
      }
    }
  }
  if ( v13 < v10 )
    sub_406FD0(v10, v10 + v12, (__int64)&off_442D70);
  if ( v13 > a5 )
    sub_405B00(v10 + v12, a5, (__int64)&off_442D70);
  v14 = a4 + v10;
  v15 = 0LL;
  do
  {
    if ( v12 == v15 )
      goto LABEL_10;
  }
  while ( *(_BYTE *)(v14 + v15++) != (unsigned __int8)a1 );
  v20 = 0;
  return v20 & 1;
}
// 442D58: using guessed type char *off_442D58;
// 442D70: using guessed type char *off_442D70;

//----- (0000000000408160) ----------------------------------------------------
char __fastcall sub_408160(unsigned int *a1, _QWORD *a2)
{
  unsigned int v2; // eax
  unsigned __int64 v4; // r8
  int v5; // [rsp+2Ch] [rbp-4h] BYREF

  v2 = *a1;
  if ( !(*a2 | a2[2]) )
    return (*(__int64 (__fastcall **)(_QWORD, _QWORD))(a2[7] + 32LL))(a2[6], v2);
  v5 = 0;
  if ( v2 >= 0x80 )
  {
    if ( v2 >= 0x800 )
    {
      if ( v2 >= 0x10000 )
      {
        LOBYTE(v5) = (v2 >> 18) | 0xF0;
        BYTE1(v5) = (v2 >> 12) & 0x3F | 0x80;
        BYTE2(v5) = (v2 >> 6) & 0x3F | 0x80;
        HIBYTE(v5) = v2 & 0x3F | 0x80;
        v4 = 4LL;
      }
      else
      {
        LOBYTE(v5) = (v2 >> 12) | 0xE0;
        BYTE1(v5) = (v2 >> 6) & 0x3F | 0x80;
        BYTE2(v5) = v2 & 0x3F | 0x80;
        v4 = 3LL;
      }
    }
    else
    {
      LOBYTE(v5) = (v2 >> 6) | 0xC0;
      BYTE1(v5) = v2 & 0x3F | 0x80;
      v4 = 2LL;
    }
  }
  else
  {
    LOBYTE(v5) = v2;
    v4 = 1LL;
  }
  return sub_405B80((__int64)a2, (unsigned __int16 *)&v5, v4);
}

//----- (0000000000408240) ----------------------------------------------------
__int64 __fastcall sub_408240(unsigned __int8 a1, __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // r10
  __int64 v4; // r9
  unsigned __int64 v5; // rax
  unsigned __int64 v6; // r8
  __int64 result; // rax
  __int64 v8; // rdx
  __int64 v9; // r9

  v3 = ((a2 + 7) & 0xFFFFFFFFFFFFFFF8uLL) - a2;
  if ( !v3 )
    goto LABEL_10;
  if ( v3 >= a3 )
    v3 = a3;
  if ( v3 )
  {
    v4 = 0LL;
    while ( *(_BYTE *)(a2 + v4) != a1 )
    {
      if ( v3 == ++v4 )
      {
        v5 = a3 - 16;
        if ( v3 <= a3 - 16 )
          goto LABEL_11;
        goto LABEL_13;
      }
    }
  }
  else
  {
LABEL_10:
    v5 = a3 - 16;
    v3 = 0LL;
    do
    {
LABEL_11:
      if ( (((0x101010101010101LL * a1) ^ *(_QWORD *)(a2 + v3 + 8) | (0x101010101010100LL
                                                                    - ((0x101010101010101LL * a1) ^ *(_QWORD *)(a2 + v3 + 8)))) & ((0x101010101010101LL * a1) ^ *(_QWORD *)(a2 + v3) | (0x101010101010100LL - ((0x101010101010101LL * a1) ^ *(_QWORD *)(a2 + v3)))) & 0x8080808080808080uLL) != 0x8080808080808080uLL )
        break;
      v3 += 16LL;
    }
    while ( v3 <= v5 );
LABEL_13:
    v6 = a3 - v3;
    if ( !v6 )
      return 0LL;
    v8 = v3 + a2;
    result = 0LL;
    v9 = 0LL;
    while ( *(_BYTE *)(v8 + v9) != a1 )
    {
      if ( v6 == ++v9 )
        return result;
    }
  }
  return 1LL;
}

//----- (0000000000408340) ----------------------------------------------------
void __noreturn sub_408340()
{
  _QWORD v0[7]; // [rsp+0h] [rbp-50h] BYREF
  __int128 v1; // [rsp+38h] [rbp-18h]

  v0[4] = &off_442A90;
  v0[5] = 1LL;
  v0[6] = 8LL;
  v1 = 0LL;
  sub_405240(&v0[4], &off_442AD0);
}
// 405240: using guessed type void __fastcall __noreturn sub_405240(_QWORD, _QWORD);
// 442A90: using guessed type char *off_442A90;
// 442AD0: using guessed type char *off_442AD0;

//----- (0000000000408380) ----------------------------------------------------
void __noreturn sub_408380()
{
  _QWORD v0[7]; // [rsp+0h] [rbp-50h] BYREF
  __int128 v1; // [rsp+38h] [rbp-18h]

  v0[4] = &off_442B18;
  v0[5] = 1LL;
  v0[6] = 8LL;
  v1 = 0LL;
  sub_405240(&v0[4], &off_447140);
}
// 405240: using guessed type void __fastcall __noreturn sub_405240(_QWORD, _QWORD);
// 442B18: using guessed type char *off_442B18;
// 447140: using guessed type char *off_447140;

//----- (00000000004083C0) ----------------------------------------------------
__int64 __fastcall sub_4083C0(_QWORD *a1, __int64 a2, __int64 a3, _BYTE *a4, unsigned __int64 a5)
{
  unsigned __int64 v8; // r13
  unsigned __int64 v9; // rax
  __int64 v10; // rdx
  size_t v11; // r12
  unsigned __int64 v12; // r15
  unsigned __int64 v13; // rdx
  __int64 result; // rax
  __int64 v15; // rdx
  __int64 v16; // r10
  __int64 v17; // r9
  __int64 v18; // r8
  __int64 v19; // rcx
  size_t v20; // rcx
  unsigned __int8 v21; // cl
  __int64 v22; // r8
  __int64 v23; // r10
  __int64 v24; // r11
  __int64 v25; // r10
  __int64 v26; // r9
  __int64 v27; // rcx
  unsigned __int8 v28; // cl
  __int64 v29; // r9
  __int64 v30; // r11
  __int64 v31; // r9
  __int64 v32; // r10
  __int64 v33; // r11
  unsigned __int64 v34; // rdx
  __int64 v35; // r15
  unsigned __int64 v36; // rcx
  unsigned __int64 v37; // rax
  unsigned __int8 v38; // al
  __int64 v39; // r10
  __int64 v40; // rax
  __int64 v41; // rbx
  __int64 v42; // r11
  __int64 v43; // r15
  unsigned __int64 v44; // r9
  __int64 v45; // r10
  unsigned __int8 v46; // al
  __int64 v47; // r11
  __int64 v48; // rax
  size_t v49; // rcx
  __int64 v50; // r15
  __int64 v51; // r9
  char *v52; // rdx
  __int64 v53; // r8
  __int64 v54; // r8
  __int64 v55; // rdx
  char *v56; // r9
  __int64 v57; // r10
  __int64 v58; // [rsp+28h] [rbp-8h]

  if ( a5 != 1 )
  {
    v16 = 1LL;
    v9 = 0LL;
    v17 = 1LL;
    v18 = 0LL;
    v8 = 1LL;
    do
    {
      v20 = v18 + v9;
      if ( v18 + v9 >= a5 )
        goto LABEL_86;
      v21 = a4[v20];
      if ( a4[v16] < v21 )
      {
        v19 = v17 + v18 + 1;
        v8 = v19 - v9;
        v18 = 0LL;
      }
      else if ( a4[v16] == v21 )
      {
        v22 = v18 + 1;
        v23 = v22;
        if ( v22 == v8 )
          v23 = 0LL;
        else
          v22 = 0LL;
        v19 = v17 + v22;
        v18 = v23;
      }
      else
      {
        v19 = v17 + 1;
        v8 = 1LL;
        v18 = 0LL;
        v9 = v17;
      }
      v16 = v19 + v18;
      v17 = v19;
    }
    while ( v19 + v18 < a5 );
    v24 = 1LL;
    v11 = 0LL;
    v25 = 1LL;
    v26 = 0LL;
    v10 = 1LL;
    while ( 1 )
    {
      v20 = v26 + v11;
      if ( v26 + v11 >= a5 )
        break;
      v28 = a4[v20];
      if ( a4[v24] > v28 )
      {
        v27 = v25 + v26 + 1;
        v10 = v27 - v11;
        v26 = 0LL;
      }
      else if ( a4[v24] == v28 )
      {
        v29 = v26 + 1;
        v30 = v29;
        if ( v29 == v10 )
          v30 = 0LL;
        else
          v29 = 0LL;
        v27 = v25 + v29;
        v26 = v30;
      }
      else
      {
        v27 = v25 + 1;
        v10 = 1LL;
        v26 = 0LL;
        v11 = v25;
      }
      v24 = v27 + v26;
      v25 = v27;
      if ( v27 + v26 >= a5 )
        goto LABEL_3;
    }
LABEL_86:
    sub_4050B0(v20, a5, &off_442B98);
  }
  v8 = 1LL;
  v9 = 0LL;
  v10 = 1LL;
  v11 = 0LL;
LABEL_3:
  if ( v9 > v11 )
    v11 = v9;
  else
    v8 = v10;
  v12 = a5 - v11;
  if ( a5 < v11 )
    sub_405B00(v11, a5, (__int64)&off_442B68);
  v13 = v11 + v8;
  if ( __CFADD__(v11, v8) )
    sub_406FD0(v8, v13, (__int64)&off_442B80);
  if ( v13 > a5 )
    sub_405B00(v11 + v8, a5, (__int64)&off_442B80);
  if ( !memcmp(a4, &a4[v8], v11) )
  {
    v58 = a3;
    v31 = 1LL;
    v32 = 0LL;
    v33 = 1LL;
    v34 = 0LL;
    do
    {
      if ( v33 + v32 >= a5 )
        break;
      v36 = ~v33 + a5 - v32;
      if ( v36 >= a5 )
LABEL_87:
        sub_4050B0(v36, a5, &off_442BB0);
      v37 = a5 + ~v32 - v34;
      if ( v37 >= a5 )
LABEL_88:
        sub_4050B0(v37, a5, &off_442BC8);
      v35 = v33 + 1;
      v38 = a4[v37];
      if ( a4[v36] < v38 )
      {
        v35 = v32 + v33 + 1;
        v31 = v35 - v34;
        v32 = 0LL;
      }
      else if ( a4[v36] == v38 )
      {
        v39 = v32 + 1;
        v40 = v39;
        if ( v39 == v31 )
          v40 = 0LL;
        else
          v39 = 0LL;
        v35 = v33 + v39;
        v32 = v40;
      }
      else
      {
        v31 = 1LL;
        v32 = 0LL;
        v34 = v33;
      }
      v33 = v35;
    }
    while ( v31 != v8 );
    v41 = 1LL;
    v42 = 0LL;
    v43 = 1LL;
    v44 = 0LL;
    while ( v43 + v42 < a5 )
    {
      v36 = ~v43 + a5 - v42;
      if ( v36 >= a5 )
        goto LABEL_87;
      v37 = a5 + ~v42 - v44;
      if ( v37 >= a5 )
        goto LABEL_88;
      v45 = v43 + 1;
      v46 = a4[v37];
      if ( a4[v36] > v46 )
      {
        v45 = v42 + v43 + 1;
        v41 = v45 - v44;
        v42 = 0LL;
      }
      else if ( a4[v36] == v46 )
      {
        v47 = v42 + 1;
        v48 = v47;
        if ( v47 == v41 )
          v48 = 0LL;
        else
          v47 = 0LL;
        v45 = v43 + v47;
        v42 = v48;
      }
      else
      {
        v41 = 1LL;
        v42 = 0LL;
        v44 = v43;
      }
      v43 = v45;
      if ( v41 == v8 )
        break;
    }
    if ( v34 > v44 )
      v44 = v34;
    v49 = a5 - v44;
    if ( v8 )
    {
      a3 = v58;
      v50 = a2;
      if ( v8 >= 4 )
      {
        result = 0LL;
        v51 = 0LL;
        do
        {
          result |= (1LL << a4[v51]) | (1LL << a4[v51 + 1]) | (1LL << a4[v51 + 2]) | (1LL << a4[v51 + 3]);
          v51 += 4LL;
        }
        while ( (v8 & 0xFFFFFFFFFFFFFFFCuLL) != v51 );
      }
      else
      {
        result = 0LL;
        v51 = 0LL;
      }
      if ( (v8 & 3) != 0 )
      {
        v56 = &a4[v51];
        v54 = 0LL;
        v57 = 0LL;
        do
          result |= 1LL << v56[v57++];
        while ( (v8 & 3) != v57 );
      }
      else
      {
        v54 = 0LL;
      }
      v55 = a5;
    }
    else
    {
      v54 = 0LL;
      v55 = a5;
      result = 0LL;
      v8 = 0LL;
      a3 = v58;
      v50 = a2;
    }
  }
  else
  {
    if ( v11 > v12 )
      v12 = v11;
    if ( a5 - 1 >= 3 )
    {
      result = 0LL;
      v15 = 0LL;
      do
      {
        result |= (1LL << a4[v15]) | (1LL << a4[v15 + 1]) | (1LL << a4[v15 + 2]) | (1LL << a4[v15 + 3]);
        v15 += 4LL;
      }
      while ( (a5 & 0xFFFFFFFFFFFFFFFCuLL) != v15 );
    }
    else
    {
      result = 0LL;
      v15 = 0LL;
    }
    if ( (a5 & 3) != 0 )
    {
      v52 = &a4[v15];
      v53 = 0LL;
      do
        result |= 1LL << v52[v53++];
      while ( (a5 & 3) != v53 );
    }
    v54 = -1LL;
    v55 = -1LL;
    v8 = v12 + 1;
    v49 = v11;
    v50 = a2;
  }
  a1[9] = v50;
  a1[10] = a3;
  a1[11] = a4;
  a1[12] = a5;
  *a1 = 1LL;
  a1[1] = v11;
  a1[2] = v49;
  a1[3] = v8;
  a1[4] = result;
  a1[5] = 0LL;
  a1[6] = a3;
  a1[7] = v54;
  a1[8] = v55;
  return result;
}
// 4050B0: using guessed type void __fastcall __noreturn sub_4050B0(_QWORD, _QWORD, _QWORD);
// 442B68: using guessed type char *off_442B68;
// 442B80: using guessed type char *off_442B80;
// 442B98: using guessed type char *off_442B98;
// 442BB0: using guessed type char *off_442BB0;
// 442BC8: using guessed type char *off_442BC8;

//----- (00000000004088C0) ----------------------------------------------------
void __fastcall sub_4088C0(_QWORD *a1, __int64 *a2)
{
  unsigned __int64 v2; // r8
  __int64 v3; // rax
  unsigned __int64 v4; // r9
  unsigned __int64 v5; // r9
  unsigned __int64 v6; // r10
  __int64 v7; // rdi
  int v8; // ebx
  _BYTE *v9; // rdi
  char *v10; // rbx
  char v11; // bl
  char *v12; // rbx
  char v13; // bl
  _BYTE *v14; // rdi
  _BYTE *v15; // rdi
  _BYTE *v16; // rdi

  v2 = a2[1];
  if ( v2 )
  {
    v3 = *a2;
    v4 = 0LL;
    while ( 1 )
    {
      v7 = *(unsigned __int8 *)(v3 + v4);
      v6 = v4 + 1;
      if ( (v7 & 0x80u) != 0LL )
      {
        v8 = byte_449C04[v7];
        switch ( v8 )
        {
          case 4:
            v12 = (char *)(v3 + v6);
            if ( v6 >= v2 )
              v12 = (char *)&unk_442660;
            v13 = *v12;
            if ( v7 == 240 )
            {
              if ( (unsigned __int8)(v13 + 112) >= 0x30u )
                goto LABEL_45;
            }
            else if ( (_DWORD)v7 == 244 )
            {
              if ( v13 > -113 )
                goto LABEL_45;
            }
            else if ( (unsigned __int8)(v7 + 15) > 2u || v13 >= -64 )
            {
              goto LABEL_45;
            }
            v6 = v4 + 2;
            v15 = (_BYTE *)(v3 + v4 + 2);
            if ( v4 + 2 >= v2 )
              v15 = &unk_442660;
            if ( !__OFSUB__(-(*v15 & 0xC0), 1) )
              goto LABEL_45;
            v6 = v4 + 3;
            v16 = (_BYTE *)(v3 + v4 + 3);
            if ( v4 + 3 >= v2 )
              v16 = &unk_442660;
            if ( !__OFSUB__(-(*v16 & 0xC0), 1) )
              goto LABEL_45;
            v5 = v4 + 4;
            break;
          case 3:
            v10 = (char *)(v3 + v6);
            if ( v6 >= v2 )
              v10 = (char *)&unk_442660;
            v11 = *v10;
            if ( v7 == 224 )
            {
              if ( (v11 & 0xE0) != 0xA0 )
                goto LABEL_45;
            }
            else if ( (_DWORD)v7 == 237 )
            {
              if ( v11 > -97 )
                goto LABEL_45;
            }
            else if ( (unsigned __int8)(v7 + 31) >= 0xCu && (v7 & 0xFE) != 0xEE || v11 >= -64 )
            {
              goto LABEL_45;
            }
            v6 = v4 + 2;
            v14 = (_BYTE *)(v3 + v4 + 2);
            if ( v4 + 2 >= v2 )
              v14 = &unk_442660;
            if ( !__OFSUB__(-(*v14 & 0xC0), 1) )
            {
LABEL_45:
              *a2 = v3 + v6;
              a2[1] = v2 - v6;
              *a1 = v3;
              a1[1] = v4;
              a1[2] = v4 + v3;
              a1[3] = v6 - v4;
              return;
            }
            v5 = v4 + 3;
            break;
          case 2:
            v9 = (_BYTE *)(v3 + v6);
            if ( v6 >= v2 )
              v9 = &unk_442660;
            if ( !__OFSUB__(-(*v9 & 0xC0), 1) )
              goto LABEL_45;
            v5 = v4 + 2;
            break;
          default:
            goto LABEL_45;
        }
        v6 = v5;
      }
      v4 = v6;
      if ( v6 >= v2 )
        goto LABEL_45;
    }
  }
  *a1 = 0LL;
}
// 449C04: using guessed type unsigned __int8 byte_449C04[256];

//----- (0000000000408A70) ----------------------------------------------------
void __noreturn sub_408A70()
{
  _QWORD v0[7]; // [rsp+0h] [rbp-50h] BYREF
  __int128 v1; // [rsp+38h] [rbp-18h]

  v0[4] = &off_443400;
  v0[5] = 1LL;
  v0[6] = 8LL;
  v1 = 0LL;
  sub_405240(&v0[4], &off_447F40);
}
// 405240: using guessed type void __fastcall __noreturn sub_405240(_QWORD, _QWORD);
// 443400: using guessed type char *off_443400;
// 447F40: using guessed type char *off_447F40;

//----- (0000000000408AB0) ----------------------------------------------------
__int64 __fastcall sub_408AB0(int *a1, __int64 a2)
{
  int v2; // eax
  __int64 v3; // r9
  __int64 v4; // r8
  __int64 v5; // rsi
  unsigned int v6; // r11d
  bool v7; // cc
  __int64 v8; // r8
  _WORD v10[19]; // [rsp+3Ah] [rbp-6h] BYREF

  v2 = *a1;
  LODWORD(v3) = -*a1;
  if ( *a1 > 0 )
    LODWORD(v3) = *a1;
  v4 = 10LL;
  if ( (unsigned int)v3 >= 0x2710 )
  {
    v5 = 5LL;
    do
    {
      v6 = (unsigned int)v3 / 0x2710;
      v4 = v5 * 2 - 4;
      v10[v5] = a0001020304[(5243 * ((unsigned int)v3 % 0x2710)) >> 19];
      v10[v5 + 1] = a0001020304[(unsigned __int16)((unsigned int)v3 % 0x2710
                                                 - 100
                                                 * ((unsigned __int16)((5243 * ((unsigned int)v3 % 0x2710)) >> 16) >> 3))];
      v5 -= 2LL;
      v7 = (unsigned int)v3 <= 0x5F5E0FF;
      LODWORD(v3) = (unsigned int)v3 / 0x2710;
    }
    while ( !v7 );
    v3 = v6;
    if ( v6 <= 0x63 )
      goto LABEL_8;
    goto LABEL_7;
  }
  v3 = (unsigned int)v3;
  if ( (unsigned int)v3 > 0x63 )
  {
LABEL_7:
    *(_WORD *)((char *)&v10[1] + v4) = a0001020304[(unsigned __int16)v3 % 0x64u];
    v4 -= 2LL;
    v3 = (unsigned int)(5243 * ((unsigned __int16)v3 >> 2)) >> 17;
  }
LABEL_8:
  if ( (unsigned int)v3 >= 0xA )
  {
    *(_WORD *)((char *)&v10[1] + v4) = a0001020304[v3];
    v8 = v4 - 2;
  }
  else
  {
    *((_BYTE *)&v10[1] + v4 + 1) = v3 | 0x30;
    v8 = v4 - 1;
  }
  return sub_405270(a2, v2 >= 0, 1LL, 0LL, (__int64)&v10[2] + v8, 10 - v8);
}
// 4428DB: using guessed type _WORD a0001020304[100];

//----- (0000000000408C00) ----------------------------------------------------
char __fastcall sub_408C00(unsigned int a1)
{
  unsigned int v1; // eax
  __int64 v2; // r8
  __int64 v3; // r9
  __int64 v4; // r8
  __int64 v5; // r9
  __int64 v6; // r8
  __int64 v7; // r10
  unsigned __int64 v8; // r9
  unsigned __int64 v9; // rax
  __int64 v10; // r8
  int v11; // r10d
  unsigned int v12; // ecx
  __int64 v13; // r8
  unsigned int v14; // edx
  unsigned __int64 v15; // r9
  __int64 v17; // rcx

  v1 = a1 << 11;
  v2 = 18LL;
  if ( a1 < 0x11C30 )
    v2 = 0LL;
  v3 = v2 + 9;
  if ( dword_4434E0[v2 + 9] << 11 > v1 )
    v3 = v2;
  v4 = v3 + 5;
  if ( dword_4434E0[v3 + 5] << 11 > v1 )
    v4 = v3;
  v5 = v4 + 2;
  if ( dword_4434E0[v4 + 2] << 11 > v1 )
    v5 = v4;
  v6 = v5 + 1;
  if ( dword_4434E0[v5 + 1] << 11 > v1 )
    v6 = v5;
  v7 = v6 + 1;
  if ( dword_4434E0[v6 + 1] << 11 > v1 )
    v7 = v6;
  v8 = v7 + (dword_4434E0[v7] << 11 < v1) + (unsigned __int64)(dword_4434E0[v7] << 11 == v1);
  if ( v8 > 0x24 )
    sub_4050B0(v8, 37LL, (__int64)&off_443360);
  v9 = dword_4434E0[v8] >> 21;
  v10 = 905LL;
  if ( v8 == 36 || (v10 = dword_4434E0[v8 + 1] >> 21, v8) )
  {
    v11 = dword_4434E0[v8 - 1] & 0x1FFFFF;
    if ( !(v10 + ~v9) )
      return v9 & 1;
  }
  else
  {
    v11 = 0;
    if ( !(v10 + ~v9) )
      return v9 & 1;
  }
  v12 = a1 - v11;
  v13 = v10 - 1;
  v14 = 0;
  v15 = dword_4434E0[v8] >> 21;
  while ( 1 )
  {
    if ( v15 > 0x388 )
    {
      v17 = 905LL;
      if ( v9 >= 0x38A )
        v17 = v9;
      sub_4050B0(v17, 905LL, (__int64)&off_443378);
    }
    v14 += byte_443574[v15];
    if ( v14 > v12 )
      break;
    if ( v13 == ++v15 )
    {
      LOBYTE(v9) = v13;
      return v9 & 1;
    }
  }
  LOBYTE(v9) = v15;
  return v9 & 1;
}
// 443360: using guessed type char *off_443360;
// 443378: using guessed type char *off_443378;
// 4434E0: using guessed type _DWORD dword_4434E0[37];
// 443574: using guessed type unsigned __int8 byte_443574[908];

//----- (0000000000408D80) ----------------------------------------------------
char __fastcall sub_408D80(unsigned int a1)
{
  unsigned int v1; // eax
  __int64 v2; // r8
  __int64 v3; // r9
  __int64 v4; // r8
  __int64 v5; // r9
  __int64 v6; // r8
  unsigned __int64 v7; // r9
  unsigned __int64 v8; // rax
  __int64 v9; // r8
  int v10; // r10d
  unsigned int v11; // ecx
  __int64 v12; // r8
  unsigned int v13; // edx
  unsigned __int64 v14; // r9
  __int64 v16; // rcx

  v1 = a1 << 11;
  v2 = 11LL;
  if ( a1 < 0x10780 )
    v2 = 0LL;
  v3 = v2 + 5;
  if ( dword_443900[v2 + 5] << 11 > v1 )
    v3 = v2;
  v4 = v3 + 3;
  if ( dword_443900[v3 + 3] << 11 > v1 )
    v4 = v3;
  v5 = v4 + 1;
  if ( dword_443900[v4 + 1] << 11 > v1 )
    v5 = v4;
  v6 = v5 + 1;
  if ( dword_443900[v5 + 1] << 11 > v1 )
    v6 = v5;
  v7 = v6 + (dword_443900[v6] << 11 < v1) + (unsigned __int64)(dword_443900[v6] << 11 == v1);
  if ( v7 > 0x15 )
    sub_4050B0(v7, 22LL, (__int64)&off_443360);
  v8 = dword_443900[v7] >> 21;
  v9 = 319LL;
  if ( v7 == 21 || (v9 = dword_443900[v7 + 1] >> 21, v7) )
  {
    v10 = dword_443900[v7 - 1] & 0x1FFFFF;
    if ( !(v9 + ~v8) )
      return v8 & 1;
  }
  else
  {
    v10 = 0;
    if ( !(v9 + ~v8) )
      return v8 & 1;
  }
  v11 = a1 - v10;
  v12 = v9 - 1;
  v13 = 0;
  v14 = dword_443900[v7] >> 21;
  while ( 1 )
  {
    if ( v14 > 0x13E )
    {
      v16 = 319LL;
      if ( v8 >= 0x140 )
        v16 = v8;
      sub_4050B0(v16, 319LL, (__int64)&off_443378);
    }
    v13 += byte_443958[v14];
    if ( v13 > v11 )
      break;
    if ( v12 == ++v14 )
    {
      LOBYTE(v8) = v12;
      return v8 & 1;
    }
  }
  LOBYTE(v8) = v14;
  return v8 & 1;
}
// 443360: using guessed type char *off_443360;
// 443378: using guessed type char *off_443378;
// 443900: using guessed type _DWORD dword_443900[22];
// 443958: using guessed type unsigned __int8 byte_443958[320];

//----- (0000000000408ED2) ----------------------------------------------------
LPVOID sub_408ED2()
{
  LPVOID result; // rax

  result = sub_43C4F0(0x538uLL);
  if ( !result )
    sub_4040E9(8LL, 1336LL);
  return result;
}

//----- (0000000000408F07) ----------------------------------------------------
void __fastcall sub_408F07(_QWORD *a1)
{
  void *v1; // rsi
  HANDLE ProcessHeap; // rax

  if ( *a1 )
  {
    if ( a1[1] )
    {
      v1 = (void *)a1[2];
      ProcessHeap = GetProcessHeap();
      HeapFree(ProcessHeap, 0, v1);
    }
  }
}

//----- (0000000000408F43) ----------------------------------------------------
LPVOID sub_408F43()
{
  LPVOID result; // rax

  result = sub_43C4F0(0x598uLL);
  if ( !result )
    sub_4040E9(8LL, 1432LL);
  return result;
}

//----- (0000000000408F78) ----------------------------------------------------
void *__fastcall sub_408F78(__int64 a1, __int64 a2, __int64 a3, const void *a4, __int64 a5)
{
  unsigned __int64 v9; // r15
  __int16 v10; // r13
  unsigned __int64 v11; // r12
  _QWORD *v12; // rdx
  __int64 v13; // rdx
  void *result; // rax
  __int64 v15; // rbx
  _BYTE v16[112]; // [rsp+20h] [rbp-60h] BYREF
  int v17; // [rsp+94h] [rbp+14h]

  v9 = *(unsigned __int16 *)(a1 + 1330);
  v10 = v9 + 1;
  v11 = a2 + 1;
  v12 = (_QWORD *)(a1 + 8 * a2 + 1240);
  if ( v11 <= v9 )
  {
    v17 = v9 + 1;
    memmove((void *)(a1 + 1240 + 8 * v11), v12, 8 * (v9 - a2));
    *(_QWORD *)(a1 + 8 * a2 + 1240) = a3;
    qmemcpy(v16, a4, sizeof(v16));
    v10 = v17;
    memmove((void *)(a1 + 112 * v11), (const void *)(a1 + 112 * a2), 112 * (v9 - a2));
  }
  else
  {
    *v12 = a3;
    qmemcpy(v16, a4, sizeof(v16));
  }
  v13 = a5;
  qmemcpy((void *)(a1 + 112 * a2), v16, 0x70uLL);
  result = (void *)(a2 + 2);
  if ( a2 + 2 < v9 + 2 )
  {
    result = memmove((void *)(a1 + 1336 + 8LL * (_QWORD)result), (const void *)(a1 + 1336 + 8 * v11), 8 * (v9 - a2));
    v13 = a5;
  }
  *(_QWORD *)(a1 + 8 * a2 + 1344) = v13;
  *(_WORD *)(a1 + 1330) = v10;
  if ( v11 < v9 + 2 )
  {
    v15 = a2 - 1;
    do
    {
      result = *(void **)(a1 + 8 * v15 + 1352);
      *((_QWORD *)result + 154) = a1;
      *((_WORD *)result + 664) = v15++ + 2;
    }
    while ( v9 != v15 );
  }
  return result;
}

//----- (00000000004090B9) ----------------------------------------------------
__int64 __fastcall sub_4090B9(_QWORD *a1, __int64 *a2)
{
  __int64 v4; // r15
  __int64 v5; // r13
  unsigned __int16 *v6; // rbx
  __int64 v7; // rdi
  unsigned __int64 v8; // r12
  unsigned __int64 v9; // r8
  __int64 result; // rax
  unsigned __int64 v11; // rcx
  unsigned __int64 v12; // rdx
  __int64 v13; // r8
  LPVOID v14[22]; // [rsp+20h] [rbp-60h] BYREF

  v4 = *a2;
  v5 = *(unsigned __int16 *)(*a2 + 1330);
  v6 = (unsigned __int16 *)sub_408F43();
  *((_QWORD *)v6 + 154) = 0LL;
  v6[665] = 0;
  v7 = a2[2];
  sub_40923F(v14, v4, v7, v6);
  v8 = v6[665];
  v9 = v8 + 1;
  if ( v8 >= 0xC )
    sub_405B00(v8 + 1, 12LL, (__int64)&off_446C70);
  if ( v5 - v7 != v9 )
    sub_405FC0((__int64)"assertion failed: src.len() == dst.len()", 40LL, (__int64)&off_446C40);
  memcpy(v6 + 668, (const void *)(v4 + 8 * v7 + 1344), (unsigned int)(8 * v9));
  result = a2[1];
  v11 = 0LL;
  do
  {
    v12 = v11;
    v11 += v11 < v8;
    v13 = *(_QWORD *)&v6[4 * v12 + 668];
    *(_QWORD *)(v13 + 1232) = v6;
    *(_WORD *)(v13 + 1328) = v12;
  }
  while ( v12 < v8 && v11 <= v8 );
  qmemcpy(a1, v14, 0x78uLL);
  a1[15] = v4;
  a1[16] = result;
  a1[17] = v6;
  a1[18] = result;
  return result;
}
// 446C40: using guessed type char *off_446C40;
// 446C70: using guessed type char *off_446C70;

//----- (000000000040923F) ----------------------------------------------------
LPVOID __fastcall sub_40923F(_QWORD *a1, __int64 a2, __int64 a3, _WORD *a4)
{
  __int64 v6; // rax
  unsigned __int64 v7; // r15
  __int64 v8; // rdx
  __int16 v9; // bx
  __int64 v10; // rsi
  LPVOID result; // rax
  __int64 v13; // [rsp+0h] [rbp-80h] BYREF
  _BYTE v14[88]; // [rsp+20h] [rbp-60h] BYREF
  __int64 v15; // [rsp+78h] [rbp-8h]
  __int64 v16; // [rsp+80h] [rbp+0h]
  __int64 v17; // [rsp+88h] [rbp+8h]
  LPVOID lpMem; // [rsp+90h] [rbp+10h]

  v6 = *(unsigned __int16 *)(a2 + 1330);
  v7 = v6 + ~a3;
  a4[665] = v7;
  v8 = *(_QWORD *)(a2 + 8 * a3 + 1240);
  v17 = *(_QWORD *)(a2 + 112 * a3);
  v16 = *(_QWORD *)(a2 + 112 * a3 + 8);
  lpMem = *(LPVOID *)(a2 + 112 * a3 + 16);
  qmemcpy(&v13 + 4, (const void *)(a2 + 112 * a3 + 24), 0x58uLL);
  if ( v7 >= 0xC )
    sub_405B00(v7, 11LL, (__int64)&off_446C58);
  v9 = a3;
  v10 = a3 + 1;
  if ( v6 - (a3 + 1) != v7 )
    sub_405FC0((__int64)"assertion failed: src.len() == dst.len()", 40LL, (__int64)&off_446C40);
  v15 = v8;
  memcpy(a4 + 620, (const void *)(a2 + 1240 + 8 * v10), 8 * v7);
  memcpy(a4, (const void *)(a2 + 112 * v10), 112 * v7);
  *(_WORD *)(a2 + 1330) = v9;
  qmemcpy(a1 + 4, v14, 0x58uLL);
  *a1 = v15;
  a1[1] = v17;
  a1[2] = v16;
  result = lpMem;
  a1[3] = lpMem;
  return result;
}
// 446C40: using guessed type char *off_446C40;
// 446C58: using guessed type char *off_446C58;

//----- (00000000004093B6) ----------------------------------------------------
__int64 __fastcall sub_4093B6(_QWORD *a1, _QWORD *a2, __int64 a3, const void *a4)
{
  _QWORD *v6; // rax
  _QWORD *v7; // r8
  __int64 v8; // r12
  __int64 v9; // r15
  unsigned __int64 v10; // r13
  __int64 v11; // rbx
  _QWORD *v12; // rdx
  __int64 result; // rax
  _BYTE v14[112]; // [rsp+28h] [rbp-58h] BYREF
  _QWORD *v15; // [rsp+98h] [rbp+18h]
  _QWORD *v16; // [rsp+A0h] [rbp+20h]

  v6 = a2;
  v7 = a1;
  v8 = *a2;
  v9 = a2[2];
  v10 = *(unsigned __int16 *)(*a2 + 1330LL);
  v11 = v9 + 1;
  v12 = (_QWORD *)(*a2 + 8 * v9 + 1240);
  if ( v9 + 1 <= v10 )
  {
    v16 = v6;
    v15 = a1;
    memmove((void *)(v8 + 1240 + 8 * v11), v12, 8 * (v10 - v9));
    *(_QWORD *)(v8 + 8 * v9 + 1240) = a3;
    qmemcpy(v14, a4, sizeof(v14));
    memmove((void *)(v8 + 112 * v11), (const void *)(v8 + 112 * v9), 112 * (v10 - v9));
    v6 = v16;
    v7 = v15;
  }
  else
  {
    *v12 = a3;
    qmemcpy(v14, a4, sizeof(v14));
  }
  qmemcpy((void *)(v8 + 112 * v9), v14, 0x70uLL);
  *(_WORD *)(v8 + 1330) = v10 + 1;
  result = v6[1];
  *v7 = v8;
  v7[1] = result;
  v7[2] = v9;
  return result;
}

//----- (00000000004094AE) ----------------------------------------------------
__int64 __fastcall sub_4094AE(_QWORD *a1, __int64 *a2)
{
  _QWORD *v4; // rbx
  __int64 v5; // r15
  __int64 result; // rax
  _QWORD v7[20]; // [rsp+20h] [rbp-60h] BYREF

  v4 = sub_408ED2();
  v4[154] = 0LL;
  *((_WORD *)v4 + 665) = 0;
  v5 = *a2;
  sub_40923F(v7, *a2, a2[2], v4);
  result = a2[1];
  qmemcpy(a1, v7, 0x78uLL);
  a1[15] = v5;
  a1[16] = result;
  a1[17] = v4;
  a1[18] = 0LL;
  return result;
}

//----- (000000000040955B) ----------------------------------------------------
LPVOID __fastcall sub_40955B(_QWORD *a1, void *a2, SIZE_T a3, __int64 a4)
{
  LPVOID v5; // rbx
  void *v7; // r14
  HANDLE ProcessHeap; // rax
  LPVOID result; // rax
  __int64 v10; // rcx

  v5 = a2;
  if ( *(_QWORD *)(a4 + 8) && *(_QWORD *)(a4 + 16) )
  {
    v7 = *(void **)a4;
    ProcessHeap = GetProcessHeap();
    result = HeapReAlloc(ProcessHeap, 0, v7, a3);
  }
  else if ( a3 )
  {
    result = sub_43C4F0(a3);
  }
  else
  {
    result = a2;
  }
  v10 = 0LL;
  if ( result )
    v5 = result;
  LOBYTE(v10) = result == 0LL;
  a1[1] = v5;
  a1[2] = a3;
  *a1 = v10;
  return result;
}

//----- (00000000004095D5) ----------------------------------------------------
unsigned __int64 __fastcall sub_4095D5(unsigned __int64 *a1)
{
  unsigned __int64 result; // rax
  __int64 v2; // rdx

  result = sub_409621(a1, *a1, 1LL, 8LL, 112LL);
  if ( result != 0x8000000000000001uLL )
    sub_40408F(result, v2, (__int64)&off_446D08);
  return result;
}
// 40961B: variable 'v2' is possibly undefined
// 446D08: using guessed type char *off_446D08;

//----- (0000000000409621) ----------------------------------------------------
unsigned __int64 __fastcall sub_409621(unsigned __int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  unsigned __int64 v5; // rsi
  unsigned __int64 v7; // rcx
  SIZE_T v8; // rax
  __int64 v11; // rcx
  _QWORD v12[3]; // [rsp+20h] [rbp-30h] BYREF
  __int64 v13; // [rsp+38h] [rbp-18h] BYREF
  unsigned __int64 v14; // [rsp+40h] [rbp-10h]

  v5 = a3 + a2;
  if ( __CFADD__(a3, a2) )
    return 0LL;
  v7 = *a1;
  if ( 2 * v7 > v5 )
    v5 = 2 * v7;
  if ( 4 * (unsigned __int64)(a5 == 1) + 4 > v5 )
    v5 = 4LL * (a5 == 1) + 4;
  v8 = v5 * ((a4 + a5 - 1) & -a4);
  if ( (v5 * (unsigned __int128)((a4 + a5 - 1) & (unsigned __int64)-a4)) >> 64 != 0 || v8 > 0x8000000000000000uLL - a4 )
    return 0LL;
  if ( v7 )
  {
    v12[0] = a1[1];
    v12[2] = a5 * v7;
    v11 = a4;
  }
  else
  {
    v11 = 0LL;
  }
  v12[1] = v11;
  sub_40955B(&v13, (void *)a4, v8, (__int64)v12);
  if ( (v13 & 1) != 0 )
    return v14;
  a1[1] = v14;
  *a1 = v5;
  return 0x8000000000000001uLL;
}

//----- (0000000000409700) ----------------------------------------------------
unsigned __int64 __fastcall sub_409700(unsigned __int64 *a1, __int64 a2)
{
  unsigned __int64 result; // rax
  __int64 v4; // rdx

  result = sub_409621(a1, *a1, 1LL, 8LL, 16LL);
  if ( result != 0x8000000000000001uLL )
    sub_40408F(result, v4, a2);
  return result;
}
// 409747: variable 'v4' is possibly undefined

//----- (000000000040974D) ----------------------------------------------------
char __fastcall sub_40974D(unsigned __int64 *a1, __int64 *a2)
{
  unsigned __int64 v3; // rbx
  unsigned __int64 v4; // rdi
  unsigned __int64 v7; // rax
  unsigned __int64 v8; // rcx
  __int64 v9; // r10
  __int64 v10; // r8
  char v11; // r11
  bool v12; // cf
  unsigned __int64 *v13; // r12
  __int64 v14; // rax
  unsigned __int64 v15; // rcx
  __int64 v16; // r9
  unsigned __int64 v17; // rdi
  char v18; // r10
  __int64 v19; // r13
  __int64 v20; // r12
  __int64 v21; // r15
  _QWORD *v22; // rdi
  _QWORD *v23; // rax
  __int64 *v24; // r14
  __int64 *v25; // r15
  __int64 v26; // rax
  __int64 v27; // r13
  __int64 v28; // r14
  __int64 v29; // rbx
  __int64 v30; // r8
  __int64 v31; // rdx
  __int64 v32; // r9
  __int64 v33; // r15
  __int64 v34; // rax
  __int64 v35; // r12
  __int64 v36; // r13
  __int64 v37; // rsi
  __int64 *v38; // rax
  unsigned __int64 v39; // rdi
  __int64 v40; // rsi
  unsigned __int64 v41; // rbx
  _QWORD *v42; // rax
  _QWORD v43[11]; // [rsp+28h] [rbp-58h] BYREF
  _QWORD v44[11]; // [rsp+80h] [rbp+0h] BYREF
  _BYTE v45[112]; // [rsp+D8h] [rbp+58h] BYREF
  __int64 v46; // [rsp+148h] [rbp+C8h] BYREF
  _QWORD v47[14]; // [rsp+150h] [rbp+D0h] BYREF
  __int64 v48; // [rsp+1C0h] [rbp+140h] BYREF
  __int64 v49; // [rsp+1C8h] [rbp+148h] BYREF
  __int64 v50; // [rsp+1D0h] [rbp+150h] BYREF
  __int64 v51; // [rsp+1D8h] [rbp+158h] BYREF
  unsigned __int64 *v52; // [rsp+1E0h] [rbp+160h]
  unsigned __int64 v53; // [rsp+1E8h] [rbp+168h]
  _QWORD v54[3]; // [rsp+1F0h] [rbp+170h] BYREF
  __int64 v55; // [rsp+208h] [rbp+188h] BYREF
  __int64 v56; // [rsp+210h] [rbp+190h]
  __int64 v57; // [rsp+218h] [rbp+198h]
  LPVOID lpMem; // [rsp+220h] [rbp+1A0h]

  v3 = a2[12];
  v4 = v3 - 1;
  if ( v3 - 1 < a1[2] )
  {
LABEL_2:
    sub_408F07(a2);
    return 1;
  }
  if ( v3 - 1 == a1[2] )
  {
    if ( a1[5] )
    {
      v7 = a1[3];
      if ( v7 )
      {
        v8 = a1[4];
        while ( 1 )
        {
          v9 = 8 * (unsigned int)*(unsigned __int16 *)(v7 + 1330);
          v10 = -1LL;
          do
          {
            if ( !v9 )
            {
              v10 = *(unsigned __int16 *)(v7 + 1330);
              goto LABEL_15;
            }
            v11 = v3 != *(_QWORD *)(v7 + 8 * v10 + 1248);
            if ( v3 < *(_QWORD *)(v7 + 8 * v10 + 1248) )
              v11 = -1;
            ++v10;
            v9 -= 8LL;
          }
          while ( v11 == 1 );
          if ( !v11 )
            goto LABEL_2;
LABEL_15:
          v12 = v8-- == 0;
          if ( v12 )
            break;
          v7 = *(_QWORD *)(v7 + 8 * v10 + 1336);
        }
      }
    }
    v19 = *a2;
    v20 = a2[1];
    v21 = a2[2];
    if ( v4 == *a1 )
      sub_4095D5(a1);
    v22 = (_QWORD *)(a1[1] + 112 * v4 + 24);
    *(v22 - 3) = v19;
    *(v22 - 2) = v20;
    *(v22 - 1) = v21;
    qmemcpy(v22, a2 + 3, 0x58uLL);
    a1[2] = v3;
    return 0;
  }
  v13 = a1 + 3;
  v14 = a1[3];
  if ( !v14 )
  {
    v52 = a1 + 3;
    v53 = v3;
    v54[0] = 0LL;
    v23 = sub_408ED2();
    v23[154] = 0LL;
    *((_WORD *)v23 + 665) = 0;
    a1[3] = (unsigned __int64)v23;
    a1[4] = 0LL;
    *((_WORD *)v23 + 665) = 1;
    v23[155] = v3;
    qmemcpy(v23, a2, 0x70uLL);
    goto LABEL_33;
  }
  v15 = a1[4];
  while ( 1 )
  {
    v16 = 8 * (unsigned int)*(unsigned __int16 *)(v14 + 1330);
    v17 = -1LL;
    do
    {
      if ( !v16 )
      {
        v17 = *(unsigned __int16 *)(v14 + 1330);
        goto LABEL_27;
      }
      v18 = *(_QWORD *)(v14 + 8 * v17 + 1248) != v3;
      if ( *(_QWORD *)(v14 + 8 * v17 + 1248) > v3 )
        v18 = -1;
      ++v17;
      v16 -= 8LL;
    }
    while ( v18 == 1 );
    if ( !v18 )
      goto LABEL_2;
LABEL_27:
    v12 = v15-- == 0;
    if ( v12 )
      break;
    v14 = *(_QWORD *)(v14 + 8 * v17 + 1336);
  }
  v52 = a1 + 3;
  v53 = v3;
  v54[0] = v14;
  v54[1] = 0LL;
  v54[2] = v17;
  if ( *(_WORD *)(v14 + 1330) < 0xBu )
  {
    sub_4093B6(&v46, v54, v3, a2);
    goto LABEL_33;
  }
  v55 = v14;
  v56 = 0LL;
  if ( v17 < 5 )
  {
    v57 = 4LL;
LABEL_43:
    sub_4094AE(&v46, &v55);
    v24 = &v49;
    v25 = &v48;
    goto LABEL_44;
  }
  if ( v17 == 5 )
  {
    v57 = 5LL;
    goto LABEL_43;
  }
  v24 = &v51;
  v25 = &v50;
  if ( v17 == 6 )
  {
    v57 = 5LL;
    sub_4094AE(&v46, &v55);
    v17 = 0LL;
  }
  else
  {
    v57 = 6LL;
    sub_4094AE(&v46, &v55);
    v17 -= 7LL;
  }
LABEL_44:
  v26 = *v24;
  v43[0] = *v25;
  v43[1] = v26;
  v43[2] = v17;
  sub_4093B6(v44, v43, v3, a2);
  v27 = v46;
  v28 = v47[0];
  v29 = v47[1];
  qmemcpy(v45, &v47[3], 0x58uLL);
  if ( v47[0] == 2LL )
    goto LABEL_33;
  lpMem = (LPVOID)v47[2];
  v30 = v48;
  v31 = v49;
  v32 = v50;
  v33 = v51;
  qmemcpy(v44, v45, sizeof(v44));
  v34 = *(_QWORD *)(v48 + 1232);
  if ( !v34 )
  {
LABEL_59:
    qmemcpy(&v47[3], v44, 0x58uLL);
    v46 = v27;
    v47[0] = v28;
    v47[1] = v29;
    v47[2] = lpMem;
    v48 = v30;
    v49 = v31;
    v50 = v32;
    v51 = v33;
    v39 = *v13;
    if ( !*v13 )
      sub_407050((__int64)&off_446B58);
    v40 = v32;
    v41 = v13[1];
    v42 = sub_408F43();
    v42[154] = 0LL;
    *((_WORD *)v42 + 665) = 0;
    v42[167] = v39;
    *(_QWORD *)(v39 + 1232) = v42;
    *(_WORD *)(v39 + 1328) = 0;
    *v13 = (unsigned __int64)v42;
    v13[1] = v41 + 1;
    if ( v41 != v33 )
      sub_405FC0((__int64)aAssertionFaile_0, 48LL, (__int64)&off_446C00);
    *((_WORD *)v42 + 665) = 1;
    v42[155] = v27;
    qmemcpy(v42, v47, 0x70uLL);
    v42[168] = v40;
    *(_QWORD *)(v40 + 1232) = v42;
    *(_WORD *)(v40 + 1328) = 1;
    goto LABEL_33;
  }
  while ( 1 )
  {
    v35 = v27;
    v36 = *(unsigned __int16 *)(v30 + 1328);
    *(_QWORD *)v45 = v28;
    *(_QWORD *)&v45[8] = v29;
    *(_QWORD *)&v45[16] = lpMem;
    qmemcpy(&v45[24], v44, 0x58uLL);
    if ( v31 != v33 )
      sub_405FC0((__int64)aAssertionFaile, 53LL, (__int64)&off_446CC0);
    if ( *(_WORD *)(v34 + 1330) < 0xBu )
      break;
    v55 = v34;
    v56 = v31 + 1;
    v37 = v32;
    if ( (unsigned __int16)v36 >= 5u )
    {
      if ( v36 == 5 )
      {
        v57 = 5LL;
        sub_4090B9(&v46, &v55);
        sub_408F78(v48, 5LL, v35, v45, v37);
        goto LABEL_56;
      }
      if ( (_DWORD)v36 == 6 )
      {
        v57 = 5LL;
        sub_4090B9(&v46, &v55);
        v38 = &v50;
        v36 = 0LL;
      }
      else
      {
        v57 = 6LL;
        sub_4090B9(&v46, &v55);
        v36 -= 7LL;
        v38 = &v50;
      }
    }
    else
    {
      v57 = 4LL;
      sub_4090B9(&v46, &v55);
      v38 = &v48;
    }
    sub_408F78(*v38, v36, v35, v45, v37);
LABEL_56:
    v27 = v46;
    v28 = v47[0];
    v29 = v47[1];
    lpMem = (LPVOID)v47[2];
    qmemcpy(v43, &v47[3], sizeof(v43));
    v30 = v48;
    v31 = v49;
    v32 = v50;
    v33 = v51;
    if ( v47[0] == 2LL )
      goto LABEL_64;
    qmemcpy(v44, v43, sizeof(v44));
    v34 = *(_QWORD *)(v48 + 1232);
    if ( !v34 )
    {
      v13 = v52;
      goto LABEL_59;
    }
  }
  sub_408F78(v34, v36, v35, v45, v32);
LABEL_64:
  v13 = v52;
LABEL_33:
  ++v13[2];
  return 0;
}
// 446B58: using guessed type char *off_446B58;
// 446C00: using guessed type char *off_446C00;
// 446CC0: using guessed type char *off_446CC0;

//----- (0000000000409E2D) ----------------------------------------------------
__int64 __fastcall sub_409E2D(__int64 a1)
{
  unsigned __int64 v3; // rcx

  if ( (*(_BYTE *)a1 & 1) != 0 )
    return *(_QWORD *)(a1 + 16);
  v3 = *(_QWORD *)(a1 + 8);
  if ( v3 >= 6 )
    sub_405B00(v3, 5LL, (__int64)&off_446D68);
  return a1 + 16;
}
// 446D68: using guessed type char *off_446D68;

//----- (0000000000409E80) ----------------------------------------------------
_BOOL8 __fastcall sub_409E80(unsigned __int8 a1, unsigned __int64 a2, const __m128i *a3)
{
  unsigned __int64 v3; // r9
  _BOOL8 result; // rax
  __m128i v5; // xmm0
  __m128i v6; // xmm0
  const __m128i *v9; // rdx
  __m128i v10; // xmm4
  __m128i v11; // xmm3
  __m128i v12; // xmm2
  __m128i v13; // xmm1

  off_43F010 = (__int64 (__fastcall *)())sub_40A050;
  if ( a2 >= (unsigned __int64)a3 )
    return 0LL;
  v3 = (unsigned __int64)a3 - a2;
  if ( (unsigned __int64)a3 - a2 <= 0xF )
  {
    result = 0LL;
    while ( *(_BYTE *)a2 != a1 )
    {
      if ( (const __m128i *)++a2 == a3 )
        return result;
    }
    return 1LL;
  }
  v5 = _mm_cvtsi32_si128(a1);
  v6 = _mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v5, v5), 0), 0);
  _EAX = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_loadu_si128((const __m128i *)a2), v6));
  if ( _EAX )
    goto LABEL_8;
  v9 = (const __m128i *)((a2 & 0xFFFFFFFFFFFFFFF0uLL) + 16);
  if ( v3 >= 0x40 && v9 <= &a3[-4] )
  {
    while ( 1 )
    {
      v10 = _mm_cmpeq_epi8(_mm_load_si128(v9), v6);
      v11 = _mm_cmpeq_epi8(_mm_load_si128(v9 + 1), v6);
      v12 = _mm_cmpeq_epi8(_mm_load_si128(v9 + 2), v6);
      v13 = _mm_cmpeq_epi8(_mm_load_si128(v9 + 3), v6);
      if ( _mm_movemask_epi8(_mm_or_si128(_mm_or_si128(v12, v13), _mm_or_si128(v11, v10))) )
        break;
      v9 += 4;
      if ( v9 > &a3[-4] )
        goto LABEL_13;
    }
    _EAX = _mm_movemask_epi8(v10);
    if ( !_EAX )
    {
      _EAX = _mm_movemask_epi8(v11);
      if ( !_EAX )
      {
        _EAX = _mm_movemask_epi8(v12);
        if ( !_EAX )
        {
          if ( _mm_movemask_epi8(v13) )
            __asm { tzcnt   eax, eax }
          return 1LL;
        }
      }
    }
LABEL_8:
    __asm { tzcnt   eax, eax }
    return 1LL;
  }
LABEL_13:
  while ( v9 <= &a3[-1] )
  {
    _EAX = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_loadu_si128(v9), v6));
    if ( _EAX )
      goto LABEL_8;
    ++v9;
  }
  if ( v9 >= a3 )
    return 0LL;
  _EDX = _mm_movemask_epi8(_mm_cmpeq_epi8(v6, _mm_loadu_si128(a3 - 1)));
  if ( _EDX )
    __asm { tzcnt   r8d, edx }
  return (_WORD)_EDX != 0;
}
// 43F010: using guessed type __int64 (__fastcall *off_43F010)();

//----- (000000000040A050) ----------------------------------------------------
_BOOL8 __fastcall sub_40A050(unsigned __int8 a1, unsigned __int64 a2, const __m128i *a3)
{
  unsigned __int64 v3; // r9
  _BOOL8 result; // rax
  __m128i v5; // xmm0
  __m128i v6; // xmm0
  const __m128i *v9; // rdx
  __m128i v10; // xmm4
  __m128i v11; // xmm3
  __m128i v12; // xmm2
  __m128i v13; // xmm1

  if ( a2 >= (unsigned __int64)a3 )
    return 0LL;
  v3 = (unsigned __int64)a3 - a2;
  if ( (unsigned __int64)a3 - a2 <= 0xF )
  {
    result = 0LL;
    while ( *(_BYTE *)a2 != a1 )
    {
      if ( (const __m128i *)++a2 == a3 )
        return result;
    }
    return 1LL;
  }
  v5 = _mm_cvtsi32_si128(a1);
  v6 = _mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v5, v5), 0), 0);
  _EAX = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_loadu_si128((const __m128i *)a2), v6));
  if ( _EAX )
    goto LABEL_8;
  v9 = (const __m128i *)((a2 & 0xFFFFFFFFFFFFFFF0uLL) + 16);
  if ( v3 >= 0x40 && v9 <= &a3[-4] )
  {
    while ( 1 )
    {
      v10 = _mm_cmpeq_epi8(_mm_load_si128(v9), v6);
      v11 = _mm_cmpeq_epi8(_mm_load_si128(v9 + 1), v6);
      v12 = _mm_cmpeq_epi8(_mm_load_si128(v9 + 2), v6);
      v13 = _mm_cmpeq_epi8(_mm_load_si128(v9 + 3), v6);
      if ( _mm_movemask_epi8(_mm_or_si128(_mm_or_si128(v12, v13), _mm_or_si128(v11, v10))) )
        break;
      v9 += 4;
      if ( v9 > &a3[-4] )
        goto LABEL_13;
    }
    _EAX = _mm_movemask_epi8(v10);
    if ( !_EAX )
    {
      _EAX = _mm_movemask_epi8(v11);
      if ( !_EAX )
      {
        _EAX = _mm_movemask_epi8(v12);
        if ( !_EAX )
        {
          if ( _mm_movemask_epi8(v13) )
            __asm { tzcnt   eax, eax }
          return 1LL;
        }
      }
    }
LABEL_8:
    __asm { tzcnt   eax, eax }
    return 1LL;
  }
LABEL_13:
  while ( v9 <= &a3[-1] )
  {
    _EAX = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_loadu_si128(v9), v6));
    if ( _EAX )
      goto LABEL_8;
    ++v9;
  }
  if ( v9 >= a3 )
    return 0LL;
  _EDX = _mm_movemask_epi8(_mm_cmpeq_epi8(v6, _mm_loadu_si128(a3 - 1)));
  if ( _EDX )
    __asm { tzcnt   r8d, edx }
  return (_WORD)_EDX != 0;
}

//----- (000000000040A210) ----------------------------------------------------
void __fastcall sub_40A210(__int64 a1, _BYTE *a2)
{
  char v2; // r8
  int v3; // r8d
  unsigned __int8 v4; // al
  unsigned __int64 v5; // rax
  const char *v6; // rax
  int v7; // r9d
  unsigned __int8 v8; // r8
  unsigned __int8 v9; // r9
  int v10; // r10d
  unsigned __int8 v11; // r9
  unsigned __int8 v12; // r10
  int v13; // r11d
  unsigned __int8 v14; // r10
  unsigned __int8 v15; // r11
  int v16; // esi
  unsigned __int8 v17; // r11
  unsigned __int8 v18; // si
  int v19; // esi
  unsigned __int8 v20; // dl
  unsigned __int8 v21; // si

  if ( *a2 == 47 )
  {
    v2 = a2[1];
    if ( v2 != 47 )
    {
      LODWORD(v5) = 0;
      if ( (unsigned __int8)(v2 - 48) >= 0xAu )
        goto LABEL_15;
      LODWORD(v5) = (unsigned __int8)(v2 - 48);
      v2 = a2[2];
      if ( (unsigned __int8)(v2 - 48) > 9u )
        goto LABEL_15;
      LODWORD(v5) = (unsigned __int8)(v2 - 48) + 10 * v5;
      v2 = a2[3];
      if ( (unsigned __int8)(v2 - 48) > 9u )
        goto LABEL_15;
      LODWORD(v5) = (unsigned __int8)(v2 - 48) + 10 * v5;
      v2 = a2[4];
      if ( (unsigned __int8)(v2 - 48) > 9u
        || (LODWORD(v5) = (unsigned __int8)(v2 - 48) + 10 * v5, v2 = a2[5], (unsigned __int8)(v2 - 48) > 9u)
        || (LODWORD(v5) = (unsigned __int8)(v2 - 48) + 10 * v5, v2 = a2[6], (unsigned __int8)(v2 - 48) > 9u)
        || (LODWORD(v5) = (unsigned __int8)(v2 - 48) + 10 * v5, v2 = a2[7], (unsigned __int8)(v2 - 48) > 9u) )
      {
LABEL_15:
        if ( v2 )
        {
          v6 = "Invalid COFF section name base-10 offset";
LABEL_55:
          *(_QWORD *)a1 = v6;
          *(_QWORD *)(a1 + 8) = 40LL;
          return;
        }
      }
      else
      {
        LODWORD(v5) = (unsigned __int8)(v2 - 48) + 10 * v5;
      }
LABEL_56:
      *(_DWORD *)(a1 + 8) = 1;
      *(_DWORD *)(a1 + 12) = v5;
      goto LABEL_57;
    }
    v3 = (unsigned __int8)a2[2];
    v4 = v3 - 65;
    if ( (unsigned __int8)(v3 - 65) >= 0x1Au )
    {
      if ( (unsigned __int8)(v3 - 97) >= 0x1Au )
      {
        if ( (unsigned __int8)(v3 - 48) >= 0xAu )
        {
          if ( v3 == 43 )
          {
            v4 = 62;
          }
          else
          {
            if ( v3 != 47 )
            {
LABEL_54:
              v6 = "Invalid COFF section name base-64 offsetInvalid COFF section name base-10 offset";
              goto LABEL_55;
            }
            v4 = 63;
          }
        }
        else
        {
          v4 = v3 + 4;
        }
      }
      else
      {
        v4 = v3 - 71;
      }
    }
    v7 = (unsigned __int8)a2[3];
    v8 = v7 - 65;
    if ( (unsigned __int8)(v7 - 65) >= 0x1Au )
    {
      if ( (unsigned __int8)(v7 - 97) < 0x1Au )
      {
        v9 = v7 - 71;
LABEL_28:
        v8 = v9;
        goto LABEL_29;
      }
      if ( (unsigned __int8)(v7 - 48) < 0xAu )
      {
        v9 = v7 + 4;
        goto LABEL_28;
      }
      if ( v7 == 43 )
      {
        v8 = 62;
      }
      else
      {
        if ( v7 != 47 )
          goto LABEL_54;
        v8 = 63;
      }
    }
LABEL_29:
    v10 = (unsigned __int8)a2[4];
    v11 = v10 - 65;
    if ( (unsigned __int8)(v10 - 65) < 0x1Au )
      goto LABEL_35;
    if ( (unsigned __int8)(v10 - 97) >= 0x1Au )
    {
      if ( (unsigned __int8)(v10 - 48) >= 0xAu )
      {
        if ( v10 == 43 )
        {
          v11 = 62;
        }
        else
        {
          if ( v10 != 47 )
            goto LABEL_54;
          v11 = 63;
        }
LABEL_35:
        v13 = (unsigned __int8)a2[5];
        v14 = v13 - 65;
        if ( (unsigned __int8)(v13 - 65) < 0x1Au )
          goto LABEL_41;
        if ( (unsigned __int8)(v13 - 97) >= 0x1Au )
        {
          if ( (unsigned __int8)(v13 - 48) >= 0xAu )
          {
            if ( v13 == 43 )
            {
              v14 = 62;
            }
            else
            {
              if ( v13 != 47 )
                goto LABEL_54;
              v14 = 63;
            }
LABEL_41:
            v16 = (unsigned __int8)a2[6];
            v17 = v16 - 65;
            if ( (unsigned __int8)(v16 - 65) < 0x1Au )
              goto LABEL_47;
            if ( (unsigned __int8)(v16 - 97) >= 0x1Au )
            {
              if ( (unsigned __int8)(v16 - 48) >= 0xAu )
              {
                if ( v16 == 43 )
                {
                  v17 = 62;
                }
                else
                {
                  if ( v16 != 47 )
                    goto LABEL_54;
                  v17 = 63;
                }
LABEL_47:
                v19 = (unsigned __int8)a2[7];
                v20 = v19 - 65;
                if ( (unsigned __int8)(v19 - 65) < 0x1Au )
                  goto LABEL_53;
                if ( (unsigned __int8)(v19 - 97) >= 0x1Au )
                {
                  if ( (unsigned __int8)(v19 - 48) >= 0xAu )
                  {
                    if ( v19 == 43 )
                    {
                      v20 = 62;
                    }
                    else
                    {
                      if ( v19 != 47 )
                        goto LABEL_54;
                      v20 = 63;
                    }
LABEL_53:
                    v5 = (((((v4 << 12) + (unsigned __int64)(v8 << 6) + v11) << 12) + (v14 << 6) + (unsigned __int64)v17) << 6)
                       + v20;
                    if ( HIDWORD(v5) )
                      goto LABEL_54;
                    goto LABEL_56;
                  }
                  v21 = v19 + 4;
                }
                else
                {
                  v21 = v19 - 71;
                }
                v20 = v21;
                goto LABEL_53;
              }
              v18 = v16 + 4;
            }
            else
            {
              v18 = v16 - 71;
            }
            v17 = v18;
            goto LABEL_47;
          }
          v15 = v13 + 4;
        }
        else
        {
          v15 = v13 - 71;
        }
        v14 = v15;
        goto LABEL_41;
      }
      v12 = v10 + 4;
    }
    else
    {
      v12 = v10 - 71;
    }
    v11 = v12;
    goto LABEL_35;
  }
  *(_DWORD *)(a1 + 8) = 0;
LABEL_57:
  *(_QWORD *)a1 = 0LL;
}

//----- (000000000040A540) ----------------------------------------------------
void __noreturn sub_40A540()
{
  sub_405FC0((__int64)"internal error: entered unreachable code", 40LL, (__int64)&off_446E40);
}
// 446E40: using guessed type char *off_446E40;

//----- (000000000040A570) ----------------------------------------------------
char __fastcall sub_40A570(__int64 *a1, __int64 a2)
{
  size_t v2; // r13
  size_t v3; // r14
  __int64 v4; // rax
  size_t v5; // r15
  size_t v6; // r11
  __int64 v7; // rdi
  size_t v8; // r8
  __int64 v9; // r10
  unsigned __int64 v10; // r9
  unsigned __int64 v11; // r10
  __int64 v12; // r10
  size_t v13; // r12
  size_t v14; // r14
  __int64 v15; // r8
  unsigned __int64 v16; // r8
  __int64 v17; // r9
  __int64 *v18; // rbx
  __int64 v19; // rsi
  size_t v20; // r12
  __int64 v21; // rdx
  __int64 v23; // [rsp+28h] [rbp-28h]
  void *Buf2; // [rsp+30h] [rbp-20h]
  size_t v25; // [rsp+38h] [rbp-18h]
  __int64 v26; // [rsp+40h] [rbp-10h]
  size_t v27; // [rsp+48h] [rbp-8h]
  __int64 *v28; // [rsp+48h] [rbp-8h]
  size_t v29; // [rsp+50h] [rbp+0h]
  __int64 v30; // [rsp+50h] [rbp+0h]

  v2 = *(_QWORD *)(a2 + 24);
  v3 = *(_QWORD *)(a2 + 8);
  LOBYTE(v4) = v2 > v3;
  v5 = *(_QWORD *)(a2 + 16);
  if ( v2 > v3 || v2 < v5 )
  {
LABEL_41:
    v15 = 0LL;
  }
  else
  {
    v4 = *(_QWORD *)a2;
    v6 = *(unsigned __int8 *)(a2 + 40);
    v7 = *(unsigned __int8 *)(a2 + v6 + 31);
    v26 = *(_QWORD *)a2;
    if ( v6 >= 5 )
    {
      while ( 1 )
      {
        v16 = v2 - v5;
        v4 += v5;
        if ( v2 - v5 >= 0x10 )
        {
          v18 = a1;
          v19 = a2;
          v20 = v6;
          v4 = sub_408240(v7, v4, v16);
          a1 = v18;
          v17 = v21;
          a2 = v19;
          if ( v4 != 1 )
          {
LABEL_40:
            *(_QWORD *)(a2 + 16) = v2;
            goto LABEL_41;
          }
          v6 = v20;
        }
        else
        {
          if ( v2 == v5 )
            goto LABEL_40;
          v17 = 0LL;
          while ( *(_BYTE *)(v4 + v17) != (_BYTE)v7 )
          {
            if ( v16 == ++v17 )
              goto LABEL_40;
          }
        }
        v5 += v17 + 1;
        *(_QWORD *)(a2 + 16) = v5;
        if ( v5 <= v3 && v5 >= v6 )
          sub_405B00(v6, 4LL, (__int64)&off_446FB0);
        v4 = v26;
        v15 = 0LL;
        if ( v2 < v5 )
          goto LABEL_42;
      }
    }
    Buf2 = (void *)(a2 + 32);
    v23 = v4 + 8;
    v25 = *(_QWORD *)(a2 + 8);
    while ( 1 )
    {
      v8 = v2 - v5;
      v4 += v5;
      if ( v2 - v5 > 0xF )
      {
        v10 = ((v4 + 7) & 0xFFFFFFFFFFFFFFF8uLL) - v4;
        if ( v10 )
        {
          v9 = 0LL;
          while ( *(_BYTE *)(v4 + v9) != (_BYTE)v7 )
          {
            if ( v10 == ++v9 )
            {
              v29 = v6;
              v27 = v2;
              v11 = v8 - 16;
              if ( v10 <= v8 - 16 )
                goto LABEL_13;
              goto LABEL_20;
            }
          }
        }
        else
        {
          v29 = v6;
          v27 = v2;
          v11 = v8 - 16;
          v10 = 0LL;
          do
          {
LABEL_13:
            if ( (((0x101010101010101LL * v7) ^ *(_QWORD *)(v5 + v23 + v10) | (0x101010101010100LL
                                                                             - ((0x101010101010101LL * v7) ^ *(_QWORD *)(v5 + v23 + v10)))) & ((0x101010101010101LL * v7) ^ *(_QWORD *)(v5 + v23 + v10 - 8) | (0x101010101010100LL - ((0x101010101010101LL * v7) ^ *(_QWORD *)(v5 + v23 + v10 - 8)))) & 0x8080808080808080uLL) != 0x8080808080808080uLL )
              break;
            v10 += 16LL;
          }
          while ( v10 <= v11 );
LABEL_20:
          v2 = v27;
          v3 = v25;
          v6 = v29;
          if ( v10 == v8 )
            goto LABEL_40;
          v4 += v10;
          v12 = 0LL;
          while ( *(_BYTE *)(v4 + v12) != (_BYTE)v7 )
          {
            if ( v27 - v10 - v5 == ++v12 )
              goto LABEL_40;
          }
          v9 = v10 + v12;
        }
      }
      else
      {
        if ( v2 == v5 )
          goto LABEL_40;
        v9 = 0LL;
        while ( *(_BYTE *)(v4 + v9) != (_BYTE)v7 )
        {
          if ( v8 == ++v9 )
            goto LABEL_40;
        }
      }
      v5 += v9 + 1;
      *(_QWORD *)(a2 + 16) = v5;
      v13 = v5 - v6;
      if ( v5 >= v6 && v5 <= v3 )
      {
        v28 = a1;
        v30 = a2;
        v14 = v6;
        LODWORD(v4) = memcmp((const void *)(v13 + v26), Buf2, v6);
        v6 = v14;
        a2 = v30;
        v3 = v25;
        a1 = v28;
        if ( !(_DWORD)v4 )
          break;
      }
      v4 = v26;
      if ( v2 < v5 )
        goto LABEL_41;
    }
    v28[1] = v13;
    v28[2] = v5;
    v15 = 1LL;
  }
LABEL_42:
  *a1 = v15;
  return v4;
}
// 40A7F1: variable 'v21' is possibly undefined
// 446FB0: using guessed type char *off_446FB0;

//----- (000000000040A860) ----------------------------------------------------
char __fastcall sub_40A860(__int64 a1, __int64 a2)
{
  char v3; // al
  char v4; // al
  char *v5; // rdx
  __int64 v6; // r8
  __int64 v8; // [rsp+30h] [rbp-10h] BYREF
  __int64 v9; // [rsp+38h] [rbp-8h] BYREF
  char v10; // [rsp+40h] [rbp+0h]
  char v11; // [rsp+41h] [rbp+1h]

  v8 = a1;
  v3 = (*(__int64 (__fastcall **)(_QWORD, const char *, __int64))(*(_QWORD *)(a2 + 56) + 24LL))(
         *(_QWORD *)(a2 + 48),
         aParseinterror,
         13LL);
  v9 = a2;
  v10 = v3;
  v11 = 0;
  sub_406A60(&v9, (__int64)aKind, 4uLL, (__int64)&v8, (unsigned __int8 (__fastcall *)(__int64, _OWORD *))sub_40A920);
  if ( v10 & 1 | ((v11 & 1) == 0) )
  {
    v4 = v10 | v11;
  }
  else
  {
    if ( (*(_BYTE *)(v9 + 36) & 4) != 0 )
    {
      v5 = "}";
      v6 = 1LL;
    }
    else
    {
      v5 = asc_447561;
      v6 = 2LL;
    }
    v4 = (*(__int64 (__fastcall **)(_QWORD, char *, __int64))(*(_QWORD *)(v9 + 56) + 24LL))(
           *(_QWORD *)(v9 + 48),
           v5,
           v6);
  }
  return v4 & 1;
}

//----- (000000000040A920) ----------------------------------------------------
__int64 __fastcall sub_40A920(unsigned __int8 **a1, __int64 a2)
{
  return (*(__int64 (__fastcall **)(_QWORD, char *, _QWORD))(*(_QWORD *)(a2 + 56) + 24LL))(
           *(_QWORD *)(a2 + 48),
           (char *)&unk_447690 + *((int *)&unk_447690 + **a1),
           qword_447668[**a1]);
}
// 447668: using guessed type _QWORD qword_447668[5];

//----- (000000000040A960) ----------------------------------------------------
char __fastcall sub_40A960(__int64 a1, __int64 a2)
{
  __int64 v3; // rcx
  unsigned int v4; // eax
  unsigned __int64 v5; // r8
  unsigned __int64 v6; // rax
  int v7; // ebx
  unsigned __int64 v8; // r9
  unsigned __int64 v9; // r9
  __int64 v10; // rcx
  char v11; // di
  unsigned int v12; // edi
  __int64 v13; // rax
  unsigned __int64 v14; // rbx
  __int64 v15; // rcx
  char *v16; // rdx
  unsigned __int64 v17; // r8
  char v18; // bl
  __int64 v19; // rcx
  char *v20; // rdx
  unsigned __int64 v21; // r8
  char v22; // al
  __int64 v23; // rdi
  char v24; // bl
  __int64 v25; // rcx
  __int64 v26; // rcx
  char v27; // al
  __int64 v28; // r14
  unsigned __int64 v29; // rbx
  __int64 v30; // rcx
  _QWORD *v31; // rdx
  unsigned __int64 v32; // rbx
  _QWORD *v33; // rdx
  __int64 v34; // rax
  unsigned __int64 v35; // rax
  char v36; // dl
  unsigned __int8 v37; // r11
  unsigned __int8 v38; // dl
  __int64 v39; // rax
  unsigned __int64 v40; // kr00_8
  bool v41; // cf
  __int64 v42; // rcx
  __int64 v43; // rcx
  __int64 v44; // rcx
  char v46; // al
  __int64 v47; // rcx
  __int64 v48; // rcx
  char *v49; // rdx
  __int64 v50; // rcx
  _QWORD *v51; // rax
  char *v52; // rdx
  unsigned __int64 v53; // r8
  char v54; // al
  __int64 v55; // rcx
  __int64 v56; // rdx
  _QWORD *v57; // rdx
  _OWORD v58[2]; // [rsp+30h] [rbp-50h] BYREF
  __int128 v59; // [rsp+50h] [rbp-30h] BYREF
  __int128 v60; // [rsp+60h] [rbp-20h]
  __int128 v61; // [rsp+70h] [rbp-10h] BYREF
  __int128 v62; // [rsp+80h] [rbp+0h]

  v3 = *(_QWORD *)a1;
  if ( !v3 )
  {
LABEL_78:
    v44 = *(_QWORD *)(a1 + 32);
    if ( v44 )
      return sub_405B80(v44, (unsigned __int16 *)asc_4474E9, 1uLL);
    return 0;
  }
  v4 = *(_DWORD *)(a1 + 24) + 1;
  *(_DWORD *)(a1 + 24) = v4;
  if ( v4 >= 0x1F5 )
  {
    v10 = *(_QWORD *)(a1 + 32);
    if ( v10 )
    {
      v11 = 1;
      if ( sub_405B80(v10, (unsigned __int16 *)aRecursionLimit, 0x19uLL) )
        return v11;
    }
    *(_QWORD *)a1 = 0LL;
    *(_BYTE *)(a1 + 8) = 1;
    return 0;
  }
  v5 = *(_QWORD *)(a1 + 8);
  v6 = *(_QWORD *)(a1 + 16);
  if ( v6 >= v5 )
  {
LABEL_63:
    v42 = *(_QWORD *)(a1 + 32);
    if ( v42 )
    {
      v11 = 1;
      if ( sub_405B80(v42, (unsigned __int16 *)aInvalidSyntax, 0x10uLL) )
        return v11;
    }
    *(_QWORD *)a1 = 0LL;
    *(_BYTE *)(a1 + 8) = 0;
    return 0;
  }
  v7 = *(unsigned __int8 *)(v3 + v6);
  v8 = v6 + 1;
  *(_QWORD *)(a1 + 16) = v6 + 1;
  switch ( v7 )
  {
    case 'B':
      v22 = sub_40B090((__int64 *)a1, a2);
      v11 = 1;
      goto LABEL_93;
    case 'C':
      sub_40B250((__int64)&v61, (__int64 *)a1);
      if ( (_BYTE)v61 )
        goto LABEL_18;
      if ( !*(_QWORD *)a1 )
        goto LABEL_78;
      v32 = *((_QWORD *)&v61 + 1);
      sub_40B330((__int64 *)&v61, (_QWORD *)a1);
      if ( !(_QWORD)v61 )
        goto LABEL_70;
      v58[1] = v62;
      v58[0] = v61;
      v33 = *(_QWORD **)(a1 + 32);
      if ( !v33 )
        goto LABEL_94;
      v11 = 1;
      if ( (unsigned __int8)sub_40B550((unsigned __int8 **)v58, v33) )
        return v11;
      v34 = *(_QWORD *)(a1 + 32);
      if ( !v34 || !v32 || (*(_DWORD *)(v34 + 36) & 4) != 0 )
        goto LABEL_94;
      if ( (*(unsigned __int8 (__fastcall **)(_QWORD, const char *, __int64))(*(_QWORD *)(v34 + 56) + 24LL))(
             *(_QWORD *)(v34 + 48),
             asc_4474F3,
             1LL)
        || (unsigned __int8)sub_4071E0(v32, *(_QWORD *)(a1 + 32)) )
      {
        return v11;
      }
      v22 = (*(__int64 (__fastcall **)(_QWORD, const char *, __int64))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 56LL) + 24LL))(
              *(_QWORD *)(*(_QWORD *)(a1 + 32) + 48LL),
              asc_4474F4,
              1LL);
      goto LABEL_93;
    case 'I':
      v24 = a2;
      v11 = 1;
      if ( (unsigned __int8)sub_40A960(a1, a2) )
        return v11;
      if ( v24 )
      {
        v25 = *(_QWORD *)(a1 + 32);
        if ( v25 )
        {
          if ( sub_405B80(v25, (unsigned __int16 *)"::_$", 2uLL) )
            return v11;
        }
      }
      v26 = *(_QWORD *)(a1 + 32);
      if ( v26 )
      {
        if ( sub_405B80(v26, (unsigned __int16 *)"<&@", 1uLL) )
          return v11;
      }
      if ( sub_40C140((__int64 *)a1) )
        return v11;
      goto LABEL_90;
    case 'M':
    case 'X':
      if ( v8 >= v5 || *(_BYTE *)(v3 + v8) != 115 )
        goto LABEL_81;
      v9 = v6 + 2;
      *(_QWORD *)(a1 + 16) = v6 + 2;
      if ( v6 + 2 < v5 && *(_BYTE *)(v3 + v9) == 95 )
      {
        *(_QWORD *)(a1 + 16) = v6 + 3;
      }
      else
      {
        v35 = 0LL;
        while ( 1 )
        {
          if ( v9 >= v5 )
            goto LABEL_63;
          v36 = *(_BYTE *)(v3 + v9);
          if ( v36 == 95 )
            break;
          v37 = v36 - 48;
          if ( (unsigned __int8)(v36 - 48) >= 0xAu )
          {
            if ( (unsigned __int8)(v36 - 97) >= 0x1Au )
            {
              if ( (unsigned __int8)(v36 - 65) >= 0x1Au )
                goto LABEL_63;
              v38 = v36 - 29;
            }
            else
            {
              v38 = v36 - 87;
            }
            v37 = v38;
          }
          *(_QWORD *)(a1 + 16) = ++v9;
          v40 = v35;
          v39 = 62 * v35;
          if ( is_mul_ok(0x3EuLL, v40) )
          {
            v41 = __CFADD__(v37, v39);
            v35 = v37 + v39;
            if ( !v41 )
              continue;
          }
          goto LABEL_63;
        }
        *(_QWORD *)(a1 + 16) = v9 + 1;
        if ( v35 > 0xFFFFFFFFFFFFFFFDuLL )
          goto LABEL_63;
      }
LABEL_81:
      v23 = *(_QWORD *)(a1 + 32);
      *(_QWORD *)(a1 + 32) = 0LL;
      if ( (unsigned __int8)sub_40A960(a1, 0LL) )
        sub_406F40((__int64)aFmtErrorSShoul, 61LL, (__int64)&v61, (__int64)&unk_446EE8, (__int64)&off_4474A8);
      *(_QWORD *)(a1 + 32) = v23;
LABEL_83:
      if ( v23 )
      {
        v46 = sub_405B80(v23, (unsigned __int16 *)"<&@", 1uLL);
        v11 = 1;
        if ( v46 )
          return v11;
      }
      v11 = 1;
      if ( sub_40BC10(a1) )
        return v11;
      if ( (_BYTE)v7 != 77 )
      {
        v47 = *(_QWORD *)(a1 + 32);
        if ( v47 )
        {
          if ( sub_405B80(v47, (unsigned __int16 *)aAs, 4uLL) )
            return v11;
        }
        if ( (unsigned __int8)sub_40A960(a1, 0LL) )
          return v11;
      }
LABEL_90:
      v48 = *(_QWORD *)(a1 + 32);
      if ( !v48 )
        goto LABEL_94;
      v49 = "><&@";
      goto LABEL_92;
    case 'N':
      v12 = a2;
      v13 = sub_40BBB0((_QWORD *)a1);
      v14 = v13;
      if ( (v13 & 1) != 0 )
      {
        v15 = *(_QWORD *)(a1 + 32);
        if ( (v13 & 0x100) != 0 )
        {
          if ( v15 )
          {
            v16 = aRecursionLimit;
            v17 = 25LL;
LABEL_68:
            v11 = 1;
            if ( sub_405B80(v15, (unsigned __int16 *)v16, v17) )
              return v11;
          }
        }
        else if ( v15 )
        {
          v16 = aInvalidSyntax;
          v17 = 16LL;
          goto LABEL_68;
        }
        *(_QWORD *)a1 = 0LL;
        *(_BYTE *)(a1 + 8) = BYTE1(v14) & 1;
        return 0;
      }
      v27 = sub_40A960(a1, v12);
      v11 = 1;
      if ( v27 )
        return v11;
      if ( *(_QWORD *)a1 )
        goto LABEL_33;
      v43 = *(_QWORD *)(a1 + 32);
      if ( !v43 )
        return 0;
      if ( sub_405B80(v43, (unsigned __int16 *)"::_$", 2uLL) )
        return v11;
      if ( !*(_QWORD *)a1 )
        goto LABEL_78;
LABEL_33:
      sub_40B250((__int64)&v61, (__int64 *)a1);
      if ( (_BYTE)v61 )
      {
LABEL_18:
        v18 = BYTE1(v61);
        v19 = *(_QWORD *)(a1 + 32);
        if ( !BYTE1(v61) )
          goto LABEL_71;
        goto LABEL_19;
      }
      if ( !*(_QWORD *)a1 )
        goto LABEL_78;
      v28 = *((_QWORD *)&v61 + 1);
      sub_40B330((__int64 *)&v61, (_QWORD *)a1);
      if ( !(_QWORD)v61 )
      {
LABEL_70:
        v18 = BYTE8(v61);
        v19 = *(_QWORD *)(a1 + 32);
        if ( !BYTE8(v61) )
        {
LABEL_71:
          if ( v19 )
          {
            v20 = aInvalidSyntax;
            v21 = 16LL;
LABEL_73:
            v11 = 1;
            if ( sub_405B80(v19, (unsigned __int16 *)v20, v21) )
              return v11;
            goto LABEL_74;
          }
          goto LABEL_74;
        }
LABEL_19:
        if ( v19 )
        {
          v20 = aRecursionLimit;
          v21 = 25LL;
          goto LABEL_73;
        }
LABEL_74:
        *(_QWORD *)a1 = 0LL;
        *(_BYTE *)(a1 + 8) = v18;
        return 0;
      }
      v29 = HIDWORD(v14);
      v60 = v62;
      v59 = v61;
      if ( (_DWORD)v29 == 1114112 )
      {
        if ( !(*((_QWORD *)&v59 + 1) | *((_QWORD *)&v60 + 1)) )
          goto LABEL_94;
        v30 = *(_QWORD *)(a1 + 32);
        if ( !v30 )
          goto LABEL_94;
        if ( sub_405B80(v30, (unsigned __int16 *)"::_$", 2uLL) )
          return v11;
        v31 = *(_QWORD **)(a1 + 32);
        if ( !v31 )
          goto LABEL_94;
        v22 = sub_40B550((unsigned __int8 **)&v59, v31);
        goto LABEL_93;
      }
      v50 = *(_QWORD *)(a1 + 32);
      if ( v50 )
      {
        if ( sub_405B80(v50, (unsigned __int16 *)asc_4474F5, 3uLL) )
          return v11;
        v51 = *(_QWORD **)(a1 + 32);
      }
      else
      {
        v51 = 0LL;
      }
      if ( (_DWORD)v29 == 67 )
      {
        if ( v51 )
        {
          v52 = aClosure;
          v53 = 7LL;
          goto LABEL_108;
        }
      }
      else if ( (_DWORD)v29 == 83 )
      {
        if ( v51 )
        {
          v52 = aShim;
          v53 = 4LL;
LABEL_108:
          v54 = sub_405B80((__int64)v51, (unsigned __int16 *)v52, v53);
          goto LABEL_111;
        }
      }
      else
      {
        LODWORD(v61) = v29;
        if ( v51 )
        {
          v54 = sub_408160((unsigned int *)&v61, v51);
LABEL_111:
          if ( v54 )
            return v11;
        }
      }
      v55 = *(_QWORD *)(a1 + 32);
      if ( *((_QWORD *)&v59 + 1) | *((_QWORD *)&v60 + 1) )
      {
        if ( !v55 )
          goto LABEL_94;
        if ( sub_405B80(v55, word_448110, 1uLL) )
          return v11;
        v57 = *(_QWORD **)(a1 + 32);
        if ( !v57 )
          goto LABEL_94;
        if ( (unsigned __int8)sub_40B550((unsigned __int8 **)&v59, v57) )
          return v11;
        v55 = *(_QWORD *)(a1 + 32);
        if ( !v55 )
          goto LABEL_94;
      }
      else if ( !v55 )
      {
LABEL_94:
        if ( *(_QWORD *)a1 )
          --*(_DWORD *)(a1 + 24);
        return 0;
      }
      if ( sub_405B80(v55, (unsigned __int16 *)asc_447503, 1uLL) )
        return v11;
      v56 = *(_QWORD *)(a1 + 32);
      *(_QWORD *)&v61 = v28;
      if ( !v56 )
        goto LABEL_94;
      if ( (unsigned __int8)sub_405120((unsigned __int64 *)&v61, v56) )
        return v11;
      v48 = *(_QWORD *)(a1 + 32);
      if ( !v48 )
        goto LABEL_94;
      v49 = "}";
LABEL_92:
      v22 = sub_405B80(v48, (unsigned __int16 *)v49, 1uLL);
LABEL_93:
      if ( !v22 )
        goto LABEL_94;
      return v11;
    case 'Y':
      v23 = *(_QWORD *)(a1 + 32);
      goto LABEL_83;
    default:
      goto LABEL_63;
  }
}
// 4474A8: using guessed type char *off_4474A8;
// 4474E9: using guessed type char asc_4474E9;
// 4474F3: using guessed type char asc_4474F3;
// 4474F4: using guessed type char asc_4474F4;
// 447503: using guessed type char asc_447503;
// 448110: using guessed type unsigned __int16 word_448110[4];

//----- (000000000040B090) ----------------------------------------------------
char __fastcall sub_40B090(__int64 *a1, unsigned int a2)
{
  __int64 v2; // r10
  unsigned __int64 v4; // r11
  unsigned __int64 v5; // r9
  unsigned __int64 v6; // rax
  unsigned __int64 v7; // rax
  unsigned __int64 v8; // rsi
  char v9; // dl
  unsigned __int8 v10; // bl
  unsigned __int8 v11; // dl
  __int64 v12; // rax
  unsigned __int64 v13; // kr00_8
  bool v14; // cf
  __int64 v15; // rcx
  char result; // al
  unsigned int v17; // edx
  unsigned __int8 v18; // si
  _OWORD *v19; // rsi
  __int64 v20; // rax
  char *v21; // rdx
  __int64 *v22; // rdi
  char v23; // al
  char v24; // dl
  __int128 v25; // [rsp+20h] [rbp-20h]
  __int128 v26; // [rsp+30h] [rbp-10h]

  v2 = *a1;
  if ( !*a1 )
  {
    v15 = a1[4];
    if ( v15 )
      return sub_405B80(v15, (unsigned __int16 *)asc_4474E9, 1uLL);
    return 0;
  }
  v4 = a1[1];
  v5 = a1[2];
  if ( v5 < v4 && *(_BYTE *)(v2 + v5) == 95 )
  {
    a1[2] = v5 + 1;
    v6 = 0LL;
    if ( v5 != 1 )
    {
LABEL_22:
      v17 = *((_DWORD *)a1 + 6) + 1;
      v18 = 1;
      if ( v17 <= 0x1F4 )
      {
        if ( a1[4] )
        {
          v26 = *((_OWORD *)a1 + 1);
          v25 = *(_OWORD *)a1;
          a1[2] = v6;
          *((_DWORD *)a1 + 6) = v17;
          LOBYTE(a2) = a2 & 1;
          v19 = a1;
          result = sub_40A960(a1, a2);
          *v19 = v25;
          v19[1] = v26;
          return result;
        }
        return 0;
      }
LABEL_28:
      v20 = a1[4];
      if ( !v20 )
        goto LABEL_32;
      goto LABEL_29;
    }
  }
  else
  {
    v7 = 0LL;
    v8 = a1[2];
    while ( v8 < v4 )
    {
      v9 = *(_BYTE *)(v2 + v8);
      if ( v9 == 95 )
      {
        a1[2] = v8 + 1;
        if ( v7 == -1LL )
          break;
        v6 = v7 + 1;
        if ( v6 >= v5 - 1 )
          break;
        goto LABEL_22;
      }
      v10 = v9 - 48;
      if ( (unsigned __int8)(v9 - 48) >= 0xAu )
      {
        if ( (unsigned __int8)(v9 - 97) >= 0x1Au )
        {
          if ( (unsigned __int8)(v9 - 65) >= 0x1Au )
          {
            v18 = 0;
            goto LABEL_28;
          }
          v11 = v9 - 29;
        }
        else
        {
          v11 = v9 - 87;
        }
        v10 = v11;
      }
      a1[2] = ++v8;
      v13 = v7;
      v12 = 62 * v7;
      if ( is_mul_ok(0x3EuLL, v13) )
      {
        v14 = __CFADD__(v10, v12);
        v7 = v10 + v12;
        if ( !v14 )
          continue;
      }
      break;
    }
  }
  v18 = 0;
  v20 = a1[4];
  if ( !v20 )
  {
LABEL_32:
    *a1 = 0LL;
    *((_BYTE *)a1 + 8) = v18;
    return 0;
  }
LABEL_29:
  v21 = aInvalidSyntax;
  if ( v18 )
    v21 = aRecursionLimit;
  v22 = a1;
  v23 = sub_405B80(v20, (unsigned __int16 *)v21, 9LL * v18 + 16);
  a1 = v22;
  v24 = v23;
  result = 1;
  if ( !v24 )
    goto LABEL_32;
  return result;
}
// 40A960: using guessed type __int64 __fastcall sub_40A960(_QWORD, _QWORD);
// 4474E9: using guessed type char asc_4474E9;

//----- (000000000040B250) ----------------------------------------------------
char __fastcall sub_40B250(__int64 a1, __int64 *a2)
{
  unsigned __int64 v2; // r9
  unsigned __int64 v3; // rax
  __int64 v5; // r10
  unsigned __int64 v6; // r11
  unsigned __int64 v7; // rax
  char result; // al
  unsigned __int64 v9; // rax
  char v10; // dl
  unsigned __int8 v11; // di
  unsigned __int8 v12; // dl
  __int64 v13; // rax
  unsigned __int64 v14; // kr00_8
  bool v15; // cf

  v2 = a2[1];
  v3 = a2[2];
  if ( v3 < v2 && (v5 = *a2, *(_BYTE *)(*a2 + v3) == 115) )
  {
    v6 = v3 + 1;
    a2[2] = v3 + 1;
    if ( v3 + 1 < v2 && *(_BYTE *)(v5 + v6) == 95 )
    {
      a2[2] = v3 + 2;
      v7 = 0LL;
    }
    else
    {
      v9 = 0LL;
      while ( 1 )
      {
        if ( v6 >= v2 )
          goto LABEL_20;
        v10 = *(_BYTE *)(v5 + v6);
        if ( v10 == 95 )
          break;
        v11 = v10 - 48;
        if ( (unsigned __int8)(v10 - 48) >= 0xAu )
        {
          if ( (unsigned __int8)(v10 - 97) >= 0x1Au )
          {
            if ( (unsigned __int8)(v10 - 65) >= 0x1Au )
              goto LABEL_20;
            v12 = v10 - 29;
          }
          else
          {
            v12 = v10 - 87;
          }
          v11 = v12;
        }
        a2[2] = ++v6;
        v14 = v9;
        v13 = 62 * v9;
        if ( is_mul_ok(0x3EuLL, v14) )
        {
          v15 = __CFADD__(v11, v13);
          v9 = v11 + v13;
          if ( !v15 )
            continue;
        }
        goto LABEL_20;
      }
      a2[2] = v6 + 1;
      if ( v9 == -1LL || (v7 = v9 + 1, v7 == -1LL) )
      {
LABEL_20:
        *(_BYTE *)(a1 + 1) = 0;
        result = 1;
        goto LABEL_8;
      }
    }
    *(_QWORD *)(a1 + 8) = v7 + 1;
  }
  else
  {
    *(_QWORD *)(a1 + 8) = 0LL;
  }
  result = 0;
LABEL_8:
  *(_BYTE *)a1 = result;
  return result;
}

//----- (000000000040B330) ----------------------------------------------------
void __fastcall sub_40B330(__int64 *a1, _QWORD *a2)
{
  unsigned __int64 v2; // rsi
  unsigned __int64 v3; // r8
  char v4; // di
  _BYTE *v5; // r11
  unsigned __int64 v6; // rax
  unsigned __int64 v7; // r8
  unsigned __int8 v8; // bl
  __int64 v9; // rax
  unsigned __int64 v10; // kr00_8
  bool v11; // cf
  unsigned __int64 v12; // r9
  _BYTE *v13; // rdx
  __int64 v14; // r10
  unsigned __int64 v15; // r9
  unsigned __int64 v16; // r8
  __int64 v17; // r8
  unsigned __int64 v18; // r10

  v2 = a2[1];
  v3 = a2[2];
  if ( v3 < v2 && *(_BYTE *)(*a2 + v3) == 117 )
  {
    a2[2] = ++v3;
    v4 = 1;
    if ( v3 >= v2 )
      goto LABEL_45;
  }
  else
  {
    v4 = 0;
    if ( v3 >= v2 )
      goto LABEL_45;
  }
  v5 = (_BYTE *)*a2;
  LOBYTE(v6) = *(_BYTE *)(*a2 + v3) - 48;
  if ( (unsigned __int8)v6 <= 9u )
  {
    v7 = v3 + 1;
    a2[2] = v7;
    if ( (_BYTE)v6 )
    {
      v6 = (unsigned __int8)v6;
      while ( v2 != v7 )
      {
        v8 = v5[v7] - 48;
        if ( v8 > 9u )
          goto LABEL_15;
        a2[2] = ++v7;
        v10 = v6;
        v9 = 10 * v6;
        if ( is_mul_ok(0xAuLL, v10) )
        {
          v11 = __CFADD__(v8, v9);
          v6 = v8 + v9;
          if ( !v11 )
            continue;
        }
        goto LABEL_45;
      }
      v7 = v2;
      v12 = v6 + v2;
      if ( __CFADD__(v6, v2) )
        goto LABEL_45;
    }
    else
    {
      v6 = 0LL;
LABEL_15:
      if ( v7 < v2 && v5[v7] == 95 )
        a2[2] = ++v7;
      v12 = v6 + v7;
      if ( __CFADD__(v6, v7) )
        goto LABEL_45;
    }
    a2[2] = v12;
    if ( v12 <= v2 )
    {
      if ( v7 < v2 && (char)v5[v7] <= -65 || v12 < v2 && (char)v5[v12] <= -65 )
        sub_4079A0(v5, v2, v7, v12, (__int64)&off_447460);
      v13 = &v5[v7];
      if ( !v4 )
      {
        *a1 = (__int64)v13;
        a1[1] = v6;
        a1[2] = 1LL;
        a1[3] = 0LL;
        return;
      }
      v14 = (__int64)&v5[v7 - 1];
      v15 = v6;
      do
      {
        if ( !v15 )
        {
          v17 = 1LL;
          v15 = 0LL;
          goto LABEL_43;
        }
        v16 = v15--;
      }
      while ( *(_BYTE *)(v14 + v16) != 95 );
      if ( v15 )
      {
        if ( v15 >= v6 )
        {
          if ( v15 != v6 )
            goto LABEL_47;
        }
        else if ( (char)v13[v15] <= -65 )
        {
LABEL_47:
          sub_4079A0(v13, v6, 0LL, v15, (__int64)&off_447478);
        }
      }
      if ( v16 < v6 )
      {
        if ( (char)v13[v16] > -65 )
        {
          v18 = v16;
          goto LABEL_42;
        }
LABEL_41:
        sub_4079A0(v13, v6, v16, v6, (__int64)&off_447490);
      }
      v18 = v6;
      if ( v16 != v6 )
        goto LABEL_41;
LABEL_42:
      v6 -= v18;
      v17 = (__int64)v13;
      v13 += v18;
LABEL_43:
      if ( v6 )
      {
        *a1 = v17;
        a1[1] = v15;
        a1[2] = (__int64)v13;
        a1[3] = v6;
        return;
      }
    }
  }
LABEL_45:
  *((_BYTE *)a1 + 8) = 0;
  *a1 = 0LL;
}
// 40B4A5: conditional instruction was optimized away because r8.8!=0
// 447460: using guessed type char *off_447460;
// 447478: using guessed type char *off_447478;
// 447490: using guessed type char *off_447490;

//----- (000000000040B550) ----------------------------------------------------
__int64 __fastcall sub_40B550(unsigned __int8 **a1, _QWORD *a2)
{
  unsigned __int8 *v2; // r13
  unsigned __int64 i; // r9
  unsigned __int8 v6; // r8
  unsigned __int8 *v7; // rcx
  unsigned __int8 *v8; // rax
  unsigned __int8 *v9; // rax
  unsigned __int64 v10; // rdi
  int v11; // edx
  int v12; // r9d
  int v13; // r11d
  int v14; // r10d
  _BYTE *v16; // r12
  unsigned __int64 v17; // r14
  unsigned __int64 v18; // rax
  unsigned __int64 v19; // rax
  unsigned __int64 v20; // rcx
  bool v21; // cf
  unsigned __int64 v22; // r15
  unsigned __int64 v23; // rax
  unsigned __int64 v24; // r10
  unsigned __int64 v25; // r8
  unsigned __int64 v26; // r15
  unsigned __int64 v27; // rbx
  unsigned __int64 v28; // rbx
  unsigned __int8 v29; // al
  unsigned __int8 v30; // dl
  unsigned __int64 v31; // rax
  bool v32; // of
  unsigned __int64 v33; // r8
  unsigned __int64 v34; // rax
  unsigned __int64 v35; // rdx
  __int64 v36; // rax
  __int64 v37; // r9
  __int128 v38; // xmm0
  unsigned __int64 v39; // rcx
  unsigned __int64 v40; // rdx
  __int64 v41; // r9
  unsigned __int64 v42; // rcx
  bool v43; // cc
  __int64 v44; // r14
  __int64 (__fastcall *v45)(__int64, char *, __int64); // rsi
  _QWORD *v46; // rdi
  unsigned int *v47; // rbx
  __int64 v48; // r14
  int v49; // eax
  _BYTE v50[40]; // [rsp+0h] [rbp-80h] BYREF
  _DWORD v51[128]; // [rsp+28h] [rbp-58h] BYREF
  unsigned __int8 *v52; // [rsp+228h] [rbp+1A8h]
  unsigned __int8 *v53; // [rsp+230h] [rbp+1B0h]
  unsigned __int8 *v54; // [rsp+238h] [rbp+1B8h]
  unsigned __int8 *v55; // [rsp+240h] [rbp+1C0h]
  _QWORD *v56; // [rsp+248h] [rbp+1C8h]
  unsigned __int8 *v57; // [rsp+250h] [rbp+1D0h]
  unsigned __int64 v58; // [rsp+258h] [rbp+1D8h]
  __int64 v59; // [rsp+260h] [rbp+1E0h]
  unsigned int v60; // [rsp+26Ch] [rbp+1ECh] BYREF
  unsigned __int64 v61; // [rsp+270h] [rbp+1F0h]
  unsigned __int64 v62; // [rsp+278h] [rbp+1F8h]
  unsigned __int64 v63; // [rsp+280h] [rbp+200h]

  memset(&v50[40], 0, 0x200uLL);
  v55 = a1[3];
  if ( !v55 )
    return (*(__int64 (__fastcall **)(_QWORD, unsigned __int8 *, unsigned __int8 *))(a2[7] + 24LL))(a2[6], *a1, a1[1]);
  v56 = a2;
  v57 = a1[2];
  v6 = *v57;
  v7 = *a1;
  v8 = a1[1];
  v53 = *a1;
  v52 = v8;
  if ( !v8 )
  {
    v10 = 0LL;
LABEL_19:
    v2 = v57;
    v54 = &v55[(_QWORD)v57];
    v59 = 4 * v10 + 4;
    v58 = ~v10;
    v62 = v10 + 1;
    v16 = &v50[4 * v10 + 28];
    v61 = 700LL;
    v17 = 72LL;
    v63 = 128LL;
    for ( i = 0LL; ; i = v24 + 1 )
    {
      v18 = 0LL;
      if ( v17 <= 0x24 )
        v18 = 36 - v17;
      v19 = (v18 == 0) + v18;
      if ( v19 >= 0x1A )
        v19 = 26LL;
      LOBYTE(v20) = v6 - 97;
      if ( (unsigned __int8)(v6 - 97) >= 0x1Au )
      {
        if ( (unsigned __int8)(v6 - 48) > 9u )
          goto LABEL_74;
        LOBYTE(v20) = v6 - 22;
      }
      ++v2;
      v20 = (unsigned __int8)v20;
      if ( v19 <= (unsigned __int8)v20 )
      {
        v25 = 36 - v19;
        v26 = 72LL;
        do
        {
          v27 = 0LL;
          if ( v26 >= v17 )
            v27 = v26 - v17;
          v28 = (v27 == 0) + v27;
          if ( v28 >= 0x1A )
            v28 = 26LL;
          if ( v2 == v54 )
            break;
          v29 = *v2;
          v30 = *v2 - 97;
          if ( v30 >= 0x1Au )
          {
            if ( (unsigned __int8)(v29 - 48) > 9u )
              goto LABEL_74;
            v30 = v29 - 22;
          }
          v31 = v25 * v30;
          if ( !is_mul_ok(v25, v30) )
            break;
          v21 = __CFADD__(v31, v20);
          v20 += v31;
          if ( v21 )
            break;
          ++v2;
          if ( v28 > v30 )
            goto LABEL_29;
          v26 += 36LL;
          v32 = ((36 - v28) * (unsigned __int128)v25) >> 64 != 0;
          v25 *= 36 - v28;
        }
        while ( !v32 );
        goto LABEL_74;
      }
LABEL_29:
      v21 = __CFADD__(v20, i);
      i += v20;
      if ( v21 )
        goto LABEL_74;
      v22 = v10 + 1;
      if ( ((v10 + 1) | i) >> 32 )
      {
        v23 = i / v22;
        v24 = i % v22;
      }
      else
      {
        v23 = (unsigned int)i / (unsigned int)v22;
        v24 = (unsigned int)i % (unsigned int)v22;
      }
      v21 = __CFADD__(v23, v63);
      v63 += v23;
      if ( HIDWORD(v63) != 0 || v21 || ((unsigned int)v63 ^ 0xD800) - 2048 > 0x10F7FF || v63 == 1114112 || v10 > 0x7F )
        goto LABEL_74;
      v33 = v10 - v24;
      if ( v10 <= v24 )
      {
        if ( v24 >= 0x80 )
          sub_4050B0(v24, 128LL, &off_4472D0);
      }
      else
      {
        if ( v33 <= 7 )
          goto LABEL_62;
        if ( (v62 | i) >> 32 )
          v34 = i / v62;
        else
          v34 = (unsigned int)i / (unsigned int)v62;
        v35 = v33 & 0xFFFFFFFFFFFFFFF8uLL;
        v36 = -(__int64)((v10 - (v58 * v34 + i)) & 0xFFFFFFFFFFFFFFF8uLL);
        v37 = 0LL;
        do
        {
          v38 = *(_OWORD *)&v16[4 * v37 - 20];
          *(_OWORD *)&v16[4 * v37] = *(_OWORD *)&v16[4 * v37 - 4];
          *(_OWORD *)&v16[4 * v37 - 16] = v38;
          v37 -= 8LL;
        }
        while ( v36 != v37 );
        if ( v33 != v35 )
        {
          v10 -= v35;
          do
          {
LABEL_62:
            v51[v10] = *(_DWORD *)&v50[4 * v10 + 36];
            --v10;
          }
          while ( v10 > v24 );
        }
      }
      v51[v24] = v63;
      if ( v2 == v54 )
      {
        v46 = v56;
        v47 = v51;
        v48 = v59;
        do
        {
          v60 = *v47;
          LOBYTE(v49) = sub_408160(&v60, v46);
          LODWORD(v2) = v49;
          if ( (_BYTE)v49 )
            break;
          ++v47;
          v48 -= 4LL;
        }
        while ( v48 );
        return (unsigned int)v2;
      }
      v6 = *v2;
      if ( HIDWORD(v20) )
        v39 = v20 / v61;
      else
        v39 = (unsigned int)v20 / (unsigned int)v61;
      if ( (v22 | v39) >> 32 )
      {
        v40 = v39 + v39 / v22;
        v41 = 0LL;
        if ( v40 < 0x1C8 )
          goto LABEL_20;
      }
      else
      {
        v40 = v39 + (unsigned int)v39 / (unsigned int)v22;
        v41 = 0LL;
        if ( v40 < 0x1C8 )
          goto LABEL_20;
      }
      v42 = v40;
      do
      {
        v40 = v42 / 0x23;
        v41 += 36LL;
        v43 = v42 <= 0x3E57;
        v42 /= 0x23uLL;
      }
      while ( !v43 );
LABEL_20:
      v17 = v41 + (unsigned __int16)((unsigned __int16)(36 * v40) / (unsigned __int16)(v40 + 38));
      v59 += 4LL;
      --v58;
      ++v62;
      v16 += 4;
      v61 = 2LL;
      v10 = v22;
    }
  }
  v9 = &v8[(_QWORD)v7];
  v10 = 0LL;
  while ( 1 )
  {
    v11 = *v7;
    if ( (v11 & 0x80u) == 0 )
    {
      ++v7;
      if ( v10 == 128 )
        break;
      goto LABEL_15;
    }
    v12 = v11 & 0x1F;
    v13 = v7[1] & 0x3F;
    if ( (unsigned __int8)v11 <= 0xDFu )
    {
      v7 += 2;
      i = v13 | (unsigned int)(v12 << 6);
      v11 = i;
      if ( v10 == 128 )
        break;
      goto LABEL_15;
    }
    v14 = (v13 << 6) | v7[2] & 0x3F;
    if ( (unsigned __int8)v11 < 0xF0u )
    {
      v7 += 3;
      i = (unsigned int)(v12 << 12);
      v11 = i | v14;
      if ( v10 == 128 )
        break;
      goto LABEL_15;
    }
    i = (unsigned __int8)(v11 & 7) << 18;
    v11 = i | (v14 << 6) | v7[3] & 0x3F;
    if ( v11 == 1114112 )
      goto LABEL_19;
    v7 += 4;
    if ( v10 == 128 )
      break;
LABEL_15:
    v51[v10++] = v11;
    if ( v7 == v9 )
      goto LABEL_19;
  }
LABEL_74:
  v44 = v56[6];
  v45 = *(__int64 (__fastcall **)(__int64, char *, __int64))(v56[7] + 24LL);
  LOBYTE(v2) = 1;
  if ( ((unsigned __int8 (__fastcall *)(__int64, const char *, __int64, unsigned __int64))v45)(
         v44,
         "punycode{-0",
         9LL,
         i)
    || v52
    && (((unsigned __int8 (__fastcall *)(__int64, unsigned __int8 *))v45)(v44, v53)
     || (unsigned __int8)v45(v44, "-0", 1LL))
    || (unsigned __int8)v45(v44, (char *)v57, (__int64)v55) )
  {
    return (unsigned int)v2;
  }
  else
  {
    return v45(v44, "}", 1LL);
  }
}
// 40BAC5: variable 'i' is possibly undefined
// 40BB1D: variable 'v2' is possibly undefined
// 40BB83: variable 'v49' is possibly undefined
// 4050B0: using guessed type void __fastcall __noreturn sub_4050B0(_QWORD, _QWORD, _QWORD);
// 4472D0: using guessed type char *off_4472D0;
// 4472F1: using guessed type char asc_4472F1;

//----- (000000000040BBB0) ----------------------------------------------------
__int64 __fastcall sub_40BBB0(_QWORD *a1)
{
  unsigned __int64 v1; // rax
  __int64 v2; // rdx
  bool v4; // cf
  __int64 v5; // rdx

  v1 = a1[2];
  if ( v1 >= a1[1] )
    return 1LL;
  v2 = *(unsigned __int8 *)(*a1 + v1);
  a1[2] = v1 + 1;
  if ( (unsigned __int8)(v2 - 65) < 0x1Au )
    return v2 << 32;
  v4 = (unsigned __int8)(v2 - 123) < 0xE6u;
  v5 = 0x11000000000000LL;
  if ( v4 )
    v5 = 0LL;
  return v5 | v4;
}

//----- (000000000040BC10) ----------------------------------------------------
char __fastcall sub_40BC10(__int64 a1)
{
  __int64 v2; // rax
  unsigned __int64 v3; // r8
  unsigned __int64 v4; // rcx
  int v5; // ebx
  unsigned __int64 v6; // rdx
  unsigned __int8 v7; // r9
  int v8; // r10d
  __int64 v9; // rcx
  unsigned int v10; // r9d
  unsigned __int16 *v11; // rdx
  unsigned __int64 v12; // r8
  __int64 v14; // rcx
  char v15; // di
  unsigned int v16; // r9d
  __int64 v17; // rcx
  __int64 v18; // rdx
  __int64 v19; // rcx
  __int64 v20; // rcx
  char v21; // al
  __int64 v22; // rcx
  __int64 v23; // rcx
  char v24; // bl
  __int64 v25; // rcx
  char *v26; // rdx
  unsigned __int64 v27; // r8
  __int64 v28; // rcx
  __int64 v29; // rcx
  __int64 v30; // rcx
  unsigned __int64 v31; // rax
  unsigned __int64 v32; // rbx
  __int64 v33; // rcx
  __int64 v34; // rcx
  __int64 v35; // rdx
  __int64 v36; // rcx
  __int64 v37; // rcx
  char *v38; // rdx
  unsigned __int64 v39; // r8
  __int64 v40; // rcx
  __int64 v41; // rcx
  char v42; // [rsp+28h] [rbp-8h] BYREF
  char v43; // [rsp+29h] [rbp-7h]
  unsigned __int64 v44; // [rsp+30h] [rbp+0h]

  v2 = *(_QWORD *)a1;
  if ( !*(_QWORD *)a1 )
  {
    v9 = *(_QWORD *)(a1 + 32);
    if ( v9 )
    {
      v11 = (unsigned __int16 *)asc_4474E9;
      v12 = 1LL;
      return sub_405B80(v9, v11, v12);
    }
    return 0;
  }
  v3 = *(_QWORD *)(a1 + 8);
  v4 = *(_QWORD *)(a1 + 16);
  if ( v4 >= v3 )
  {
    v14 = *(_QWORD *)(a1 + 32);
    if ( v14 )
    {
      v15 = 1;
      if ( sub_405B80(v14, (unsigned __int16 *)aInvalidSyntax, 0x10uLL) )
        return v15;
    }
  }
  else
  {
    v5 = *(unsigned __int8 *)(v2 + v4);
    v6 = v4 + 1;
    *(_QWORD *)(a1 + 16) = v4 + 1;
    v7 = v5 - 97;
    if ( (unsigned __int8)(v5 - 97) <= 0x19u )
    {
      v8 = 62716863;
      if ( _bittest(&v8, v7) )
      {
        v9 = *(_QWORD *)(a1 + 32);
        if ( v9 )
        {
          v10 = v7;
          v11 = *(unsigned __int16 **)((char *)&off_447778 + v10 * 8);
          v12 = qword_4476A8[v10];
          return sub_405B80(v9, v11, v12);
        }
        return 0;
      }
    }
    v16 = *(_DWORD *)(a1 + 24) + 1;
    *(_DWORD *)(a1 + 24) = v16;
    if ( v16 > 0x1F4 )
    {
      v22 = *(_QWORD *)(a1 + 32);
      if ( v22 )
      {
        v15 = 1;
        if ( sub_405B80(v22, (unsigned __int16 *)aRecursionLimit, 0x19uLL) )
          return v15;
      }
      *(_QWORD *)a1 = 0LL;
      *(_BYTE *)(a1 + 8) = 1;
      return 0;
    }
    switch ( v5 )
    {
      case 'A':
      case 'S':
        v17 = *(_QWORD *)(a1 + 32);
        if ( !v17 || (v15 = 1, !sub_405B80(v17, (unsigned __int16 *)asc_4474F3, 1uLL)) )
        {
          v15 = 1;
          if ( !(unsigned __int8)sub_40BC10(a1) )
          {
            if ( v5 != 65
              || ((v19 = *(_QWORD *)(a1 + 32)) == 0 || !sub_405B80(v19, (unsigned __int16 *)asc_447513, 2uLL))
              && (v15 = 1, LOBYTE(v18) = 1, !sub_40C310(a1, v18)) )
            {
              v20 = *(_QWORD *)(a1 + 32);
              if ( !v20 )
                goto LABEL_83;
              v21 = sub_405B80(v20, (unsigned __int16 *)asc_4474F4, 1uLL);
              goto LABEL_81;
            }
          }
        }
        return v15;
      case 'B':
        v21 = sub_40EAD0((__int64 *)a1);
        goto LABEL_81;
      case 'D':
        v30 = *(_QWORD *)(a1 + 32);
        if ( v30 )
        {
          v15 = 1;
          if ( sub_405B80(v30, (unsigned __int16 *)aDyn, 4uLL) )
            return v15;
        }
        v15 = 1;
        if ( sub_40EDE0(a1) )
          return v15;
        if ( *(_QWORD *)a1 )
        {
          v31 = *(_QWORD *)(a1 + 16);
          if ( v31 < *(_QWORD *)(a1 + 8) && *(_BYTE *)(*(_QWORD *)a1 + v31) == 76 )
          {
            *(_QWORD *)(a1 + 16) = v31 + 1;
            sub_40EC80((__int64)&v42, (__int64 *)a1);
            if ( !v42 )
            {
              v32 = v44;
              if ( !v44 )
                goto LABEL_83;
              v33 = *(_QWORD *)(a1 + 32);
              if ( !v33 || !sub_405B80(v33, (unsigned __int16 *)asc_447519, 3uLL) )
              {
                v21 = sub_40C980(a1, v32);
                goto LABEL_82;
              }
              return v15;
            }
LABEL_36:
            v24 = v43;
            v25 = *(_QWORD *)(a1 + 32);
            if ( v43 )
            {
              if ( v25 )
              {
                v26 = aRecursionLimit;
                v27 = 25LL;
                goto LABEL_87;
              }
            }
            else if ( v25 )
            {
              v26 = aInvalidSyntax;
              v27 = 16LL;
LABEL_87:
              v15 = 1;
              if ( sub_405B80(v25, (unsigned __int16 *)v26, v27) )
                return v15;
            }
            *(_QWORD *)a1 = 0LL;
            *(_BYTE *)(a1 + 8) = v24;
            return 0;
          }
        }
        v40 = *(_QWORD *)(a1 + 32);
        if ( v40 && sub_405B80(v40, (unsigned __int16 *)aInvalidSyntax, 0x10uLL) )
          return v15;
        break;
      case 'F':
        v21 = sub_40E880(a1);
        goto LABEL_81;
      case 'O':
      case 'P':
        v28 = *(_QWORD *)(a1 + 32);
        if ( v28 )
        {
          v15 = 1;
          if ( sub_405B80(v28, (unsigned __int16 *)asc_449A78, 1uLL) )
            return v15;
          v29 = *(_QWORD *)(a1 + 32);
        }
        else
        {
          v29 = 0LL;
        }
        if ( v5 == 80 )
        {
          if ( !v29 )
            goto LABEL_80;
          v38 = aConst;
          v39 = 6LL;
        }
        else
        {
LABEL_77:
          if ( !v29 )
            goto LABEL_80;
          v38 = aMut;
          v39 = 4LL;
        }
        v15 = 1;
        if ( sub_405B80(v29, (unsigned __int16 *)v38, v39) )
          return v15;
LABEL_80:
        v21 = sub_40BC10(a1);
LABEL_81:
        v15 = 1;
LABEL_82:
        if ( v21 )
          return v15;
LABEL_83:
        if ( *(_QWORD *)a1 )
          --*(_DWORD *)(a1 + 24);
        return 0;
      case 'Q':
      case 'R':
        v23 = *(_QWORD *)(a1 + 32);
        if ( !v23 )
          goto LABEL_33;
        v15 = 1;
        if ( sub_405B80(v23, (unsigned __int16 *)"&@", 1uLL) )
          return v15;
        v2 = *(_QWORD *)a1;
        if ( !*(_QWORD *)a1 )
          goto LABEL_75;
        v3 = *(_QWORD *)(a1 + 8);
        v6 = *(_QWORD *)(a1 + 16);
LABEL_33:
        if ( v6 >= v3 || *(_BYTE *)(v2 + v6) != 76 )
          goto LABEL_75;
        *(_QWORD *)(a1 + 16) = v6 + 1;
        sub_40EC80((__int64)&v42, (__int64 *)a1);
        if ( v42 )
          goto LABEL_36;
        if ( v44 )
        {
          v15 = 1;
          if ( sub_40C980(a1, v44) )
            return v15;
          v41 = *(_QWORD *)(a1 + 32);
          if ( v41 )
          {
            if ( sub_405B80(v41, (unsigned __int16 *)asc_447508, 1uLL) )
              return v15;
          }
        }
LABEL_75:
        if ( v5 == 82 )
          goto LABEL_80;
        v29 = *(_QWORD *)(a1 + 32);
        goto LABEL_77;
      case 'T':
        v34 = *(_QWORD *)(a1 + 32);
        if ( v34 )
        {
          v15 = 1;
          if ( sub_405B80(v34, (unsigned __int16 *)"(><&@", 1uLL) )
            return v15;
        }
        v15 = 1;
        if ( sub_40ED40((__int64 *)a1) )
          return v15;
        if ( v35 != 1 )
          goto LABEL_61;
        v36 = *(_QWORD *)(a1 + 32);
        if ( !v36 )
          goto LABEL_83;
        if ( sub_405B80(v36, (unsigned __int16 *)",(><&@", 1uLL) )
          return v15;
LABEL_61:
        v37 = *(_QWORD *)(a1 + 32);
        if ( !v37 )
          goto LABEL_83;
        v21 = sub_405B80(v37, (unsigned __int16 *)asc_448BDD, 1uLL);
        goto LABEL_82;
      default:
        *(_QWORD *)(a1 + 16) = v4;
        v21 = sub_40A960(a1, 0LL);
        goto LABEL_81;
    }
  }
  *(_QWORD *)a1 = 0LL;
  *(_BYTE *)(a1 + 8) = 0;
  return 0;
}
// 40BD85: variable 'v18' is possibly undefined
// 40BFC8: variable 'v35' is possibly undefined
// 40A960: using guessed type __int64 __fastcall sub_40A960(_QWORD, _QWORD);
// 4474E9: using guessed type char asc_4474E9;
// 4474F3: using guessed type char asc_4474F3;
// 4474F4: using guessed type char asc_4474F4;
// 447508: using guessed type char asc_447508;
// 4476A8: using guessed type _QWORD qword_4476A8[26];
// 447778: using guessed type _UNKNOWN *off_447778;
// 448BDD: using guessed type char asc_448BDD;
// 449A78: using guessed type char asc_449A78;

//----- (000000000040C140) ----------------------------------------------------
__int64 __fastcall sub_40C140(__int64 *a1)
{
  __int64 v1; // rax
  __int64 v3; // rsi
  __int64 v4; // r14
  unsigned __int64 v5; // rcx
  __int64 v7; // rcx

  v1 = *a1;
  if ( !*a1 )
    return 0LL;
  v3 = 0LL;
  v4 = 0LL;
  while ( 1 )
  {
    v5 = a1[2];
    if ( v5 < a1[1] && *(_BYTE *)(v1 + v5) == 69 )
      break;
    if ( v4-- != 0 )
    {
      v7 = a1[4];
      if ( v7 )
      {
        if ( sub_405B80(v7, (unsigned __int16 *)asc_4474F1, 2uLL) )
          return 1LL;
      }
    }
    if ( sub_40C1E0(a1) )
      return 1LL;
    v1 = *a1;
    if ( !*a1 )
      return v3;
  }
  a1[2] = v5 + 1;
  return 0LL;
}

//----- (000000000040C1E0) ----------------------------------------------------
char __fastcall sub_40C1E0(_QWORD *a1)
{
  __int64 v1; // r8
  unsigned __int64 v2; // r9
  unsigned __int64 v3; // rax
  int v4; // edx
  unsigned __int64 v5; // r10
  unsigned __int64 v6; // rax
  char result; // al
  unsigned __int64 v8; // rax
  char v9; // dl
  unsigned __int8 v10; // si
  unsigned __int8 v11; // dl
  __int64 v12; // rax
  unsigned __int64 v13; // kr00_8
  bool v14; // cf
  _QWORD *v15; // rsi
  char v16; // al
  char v17; // dl

  v1 = *a1;
  if ( !*a1 )
    return sub_40BC10(a1);
  v2 = a1[1];
  v3 = a1[2];
  if ( v3 >= v2 )
    return sub_40BC10(a1);
  v4 = *(unsigned __int8 *)(v1 + v3);
  if ( v4 == 75 )
  {
    a1[2] = v3 + 1;
    return sub_40C310((__int64)a1, 0LL);
  }
  if ( v4 != 76 )
    return sub_40BC10(a1);
  v5 = v3 + 1;
  a1[2] = v3 + 1;
  if ( v3 + 1 < v2 && *(_BYTE *)(v1 + v5) == 95 )
  {
    a1[2] = v3 + 2;
    v6 = 0LL;
    return sub_40C980((__int64)a1, v6);
  }
  else
  {
    v8 = 0LL;
    while ( v5 < v2 )
    {
      v9 = *(_BYTE *)(v1 + v5);
      if ( v9 == 95 )
      {
        a1[2] = v5 + 1;
        if ( v8 != -1LL )
        {
          v6 = v8 + 1;
          return sub_40C980((__int64)a1, v6);
        }
        break;
      }
      v10 = v9 - 48;
      if ( (unsigned __int8)(v9 - 48) >= 0xAu )
      {
        if ( (unsigned __int8)(v9 - 97) >= 0x1Au )
        {
          if ( (unsigned __int8)(v9 - 65) >= 0x1Au )
            break;
          v11 = v9 - 29;
        }
        else
        {
          v11 = v9 - 87;
        }
        v10 = v11;
      }
      a1[2] = ++v5;
      v13 = v8;
      v12 = 62 * v8;
      if ( is_mul_ok(0x3EuLL, v13) )
      {
        v14 = __CFADD__(v10, v12);
        v8 = v10 + v12;
        if ( !v14 )
          continue;
      }
      break;
    }
    if ( !a1[4]
      || (v15 = a1,
          v16 = sub_405B80(a1[4], (unsigned __int16 *)aInvalidSyntax, 0x10uLL),
          a1 = v15,
          v17 = v16,
          result = 1,
          !v17) )
    {
      *a1 = 0LL;
      *((_BYTE *)a1 + 8) = 0;
      return 0;
    }
  }
  return result;
}
// 40BC10: using guessed type __int64 __fastcall sub_40BC10(_QWORD);

//----- (000000000040C310) ----------------------------------------------------
char __fastcall sub_40C310(__int64 a1, __int64 a2)
{
  __int64 v3; // rcx
  unsigned __int64 v4; // r9
  unsigned __int64 v5; // rax
  int v6; // ebx
  unsigned __int64 v7; // r8
  unsigned int v8; // r10d
  __int64 v9; // rcx
  char v10; // di
  char v11; // al
  __int64 v12; // rcx
  __int64 v13; // rdx
  __int64 v14; // rcx
  char *v15; // rdx
  unsigned __int64 v16; // r8
  char v17; // r14
  __int64 v18; // rcx
  __int64 v19; // rdx
  unsigned __int64 v20; // rcx
  int v21; // eax
  __int64 v22; // rcx
  char v23; // al
  __int64 v24; // rcx
  __int64 v26; // rax
  unsigned __int64 v27; // rdx
  __int64 v28; // rcx
  __int64 v29; // rcx
  __int64 v30; // rcx
  __int64 v31; // rcx
  char *v32; // rdx
  __int64 v33; // rcx
  __int64 v34; // rcx
  __int64 v35; // rcx
  char v36; // al
  __int64 v37; // rcx
  __int64 v38; // rcx
  __int64 v39; // rdx
  __int64 v40; // rcx
  __int64 v41; // rcx
  __int64 v42; // rcx
  char v43; // bl
  __int64 v44; // rcx
  char *v45; // rdx
  unsigned __int64 v46; // r8
  __int64 v47; // rcx
  unsigned __int64 v48; // r8
  __int64 v49; // rcx
  __int64 v50; // [rsp+20h] [rbp-10h] BYREF
  __int64 v51; // [rsp+28h] [rbp-8h]

  v3 = *(_QWORD *)a1;
  if ( !v3 )
  {
LABEL_35:
    v24 = *(_QWORD *)(a1 + 32);
    if ( v24 )
      return sub_405B80(v24, (unsigned __int16 *)asc_4474E9, 1uLL);
    return 0;
  }
  v4 = *(_QWORD *)(a1 + 8);
  v5 = *(_QWORD *)(a1 + 16);
  if ( v5 >= v4 )
    goto LABEL_40;
  v6 = *(unsigned __int8 *)(v3 + v5);
  v7 = v5 + 1;
  *(_QWORD *)(a1 + 16) = v5 + 1;
  v8 = *(_DWORD *)(a1 + 24) + 1;
  *(_DWORD *)(a1 + 24) = v8;
  if ( v8 > 0x1F4 )
  {
    v12 = *(_QWORD *)(a1 + 32);
    if ( v12 )
    {
      v10 = 1;
      if ( sub_405B80(v12, (unsigned __int16 *)aRecursionLimit, 0x19uLL) )
        return v10;
    }
    *(_QWORD *)a1 = 0LL;
    *(_BYTE *)(a1 + 8) = 1;
    return 0;
  }
  switch ( v6 )
  {
    case 'A':
      v17 = a2;
      if ( !(_BYTE)a2 )
      {
        v29 = *(_QWORD *)(a1 + 32);
        if ( v29 )
        {
          v10 = 1;
          if ( sub_405B80(v29, (unsigned __int16 *)asc_44755D, 1uLL) )
            return v10;
        }
      }
      v30 = *(_QWORD *)(a1 + 32);
      if ( v30 )
      {
        v10 = 1;
        if ( sub_405B80(v30, (unsigned __int16 *)asc_4474F3, 1uLL) )
          return v10;
      }
      v10 = 1;
      if ( sub_40D650((__int64 *)a1, a2) )
        return v10;
      v31 = *(_QWORD *)(a1 + 32);
      if ( !v31 )
        goto LABEL_101;
      v32 = asc_4474F4;
      goto LABEL_98;
    case 'B':
      v11 = sub_40CE30((__int64 *)a1, a2);
      goto LABEL_10;
    case 'Q':
      goto LABEL_58;
    case 'R':
      if ( v7 < v4 && *(_BYTE *)(v3 + v7) == 101 )
      {
        *(_QWORD *)(a1 + 16) = v5 + 2;
        v11 = sub_40D380(a1);
        goto LABEL_10;
      }
LABEL_58:
      v17 = a2;
      if ( !(_BYTE)a2 )
      {
        v33 = *(_QWORD *)(a1 + 32);
        if ( v33 )
        {
          v10 = 1;
          if ( sub_405B80(v33, (unsigned __int16 *)asc_44755D, 1uLL) )
            return v10;
        }
      }
      v34 = *(_QWORD *)(a1 + 32);
      if ( v34 )
      {
        v10 = 1;
        if ( sub_405B80(v34, (unsigned __int16 *)"&@", 1uLL) )
          return v10;
      }
      if ( v6 != 82 )
      {
        v35 = *(_QWORD *)(a1 + 32);
        if ( v35 )
        {
          v10 = 1;
          if ( sub_405B80(v35, (unsigned __int16 *)aMut, 4uLL) )
            return v10;
        }
      }
      v10 = 1;
      LOBYTE(a2) = 1;
      v36 = sub_40C310(a1, a2);
      goto LABEL_100;
    case 'T':
      v17 = a2;
      if ( !(_BYTE)a2 )
      {
        v37 = *(_QWORD *)(a1 + 32);
        if ( v37 )
        {
          v10 = 1;
          if ( sub_405B80(v37, (unsigned __int16 *)asc_44755D, 1uLL) )
            return v10;
        }
      }
      v38 = *(_QWORD *)(a1 + 32);
      if ( v38 )
      {
        v10 = 1;
        if ( sub_405B80(v38, (unsigned __int16 *)"(><&@", 1uLL) )
          return v10;
      }
      v10 = 1;
      if ( sub_40D6F0((__int64 *)a1, a2) )
        return v10;
      if ( v39 != 1 )
        goto LABEL_96;
      v40 = *(_QWORD *)(a1 + 32);
      if ( !v40 )
        goto LABEL_101;
      if ( !sub_405B80(v40, (unsigned __int16 *)",(><&@", 1uLL) )
        goto LABEL_96;
      return v10;
    case 'V':
      v17 = a2;
      if ( !(_BYTE)a2 )
      {
        v18 = *(_QWORD *)(a1 + 32);
        if ( v18 )
        {
          v10 = 1;
          if ( sub_405B80(v18, (unsigned __int16 *)asc_44755D, 1uLL) )
            return v10;
        }
      }
      v10 = 1;
      LOBYTE(a2) = 1;
      if ( (unsigned __int8)sub_40A960(a1, a2) )
        return v10;
      if ( !*(_QWORD *)a1 )
        goto LABEL_35;
      v20 = *(_QWORD *)(a1 + 16);
      if ( v20 >= *(_QWORD *)(a1 + 8) )
        goto LABEL_33;
      v21 = *(unsigned __int8 *)(*(_QWORD *)a1 + v20);
      *(_QWORD *)(a1 + 16) = v20 + 1;
      if ( v21 == 83 )
      {
        v49 = *(_QWORD *)(a1 + 32);
        if ( v49 && sub_405B80(v49, (unsigned __int16 *)asc_44755E, 3uLL) || sub_40D7A0((_QWORD *)a1) )
          return v10;
        v31 = *(_QWORD *)(a1 + 32);
        if ( !v31 )
          goto LABEL_101;
        v32 = asc_447561;
        v48 = 2LL;
        goto LABEL_99;
      }
      if ( v21 == 84 )
      {
        v47 = *(_QWORD *)(a1 + 32);
        if ( v47 && sub_405B80(v47, (unsigned __int16 *)"(><&@", 1uLL) || sub_40D650((__int64 *)a1, v19) )
          return v10;
LABEL_96:
        v31 = *(_QWORD *)(a1 + 32);
        if ( !v31 )
          goto LABEL_101;
        v32 = asc_448BDD;
LABEL_98:
        v48 = 1LL;
LABEL_99:
        v36 = sub_405B80(v31, (unsigned __int16 *)v32, v48);
LABEL_100:
        if ( v36 )
          return v10;
        goto LABEL_101;
      }
      if ( v21 != 85 )
      {
LABEL_33:
        v22 = *(_QWORD *)(a1 + 32);
        if ( !v22 )
          goto LABEL_43;
        v23 = sub_405B80(v22, (unsigned __int16 *)aInvalidSyntax, 0x10uLL);
        goto LABEL_42;
      }
LABEL_101:
      if ( v17 )
        goto LABEL_11;
      v14 = *(_QWORD *)(a1 + 32);
      if ( !v14 )
        goto LABEL_11;
      v15 = "}";
LABEL_104:
      v16 = 1LL;
LABEL_105:
      v11 = sub_405B80(v14, (unsigned __int16 *)v15, v16);
LABEL_10:
      v10 = 1;
      if ( !v11 )
      {
LABEL_11:
        if ( *(_QWORD *)a1 )
          --*(_DWORD *)(a1 + 24);
        return 0;
      }
      return v10;
    case 'a':
    case 'i':
    case 'l':
    case 'n':
    case 's':
    case 'x':
      if ( v7 < v4 && *(_BYTE *)(v3 + v7) == 110 )
      {
        *(_QWORD *)(a1 + 16) = v5 + 2;
        v9 = *(_QWORD *)(a1 + 32);
        if ( v9 )
        {
          v10 = 1;
          if ( sub_405B80(v9, (unsigned __int16 *)"-0", 1uLL) )
            return v10;
        }
      }
      goto LABEL_9;
    case 'b':
      sub_40CFF0((__int64)&v50, a1);
      if ( !v50 )
        goto LABEL_83;
      if ( sub_40D0A0(v50, v51) != 1 )
        goto LABEL_40;
      if ( v13 )
      {
        if ( v13 != 1 )
          goto LABEL_40;
        v14 = *(_QWORD *)(a1 + 32);
        if ( v14 )
        {
          v15 = aTrue;
          v16 = 4LL;
          goto LABEL_105;
        }
        goto LABEL_11;
      }
      v14 = *(_QWORD *)(a1 + 32);
      if ( !v14 )
        goto LABEL_11;
      v15 = aFalse;
      v16 = 5LL;
      goto LABEL_105;
    case 'c':
      sub_40CFF0((__int64)&v50, a1);
      if ( v50 )
      {
        v26 = sub_40D0A0(v50, v51);
        if ( HIDWORD(v27) == 0 && v26 != 0 && ((unsigned int)v27 ^ 0xD800) - 1114112 >= 0xFFEF0800 && v27 != 1114112 )
        {
          v11 = sub_40D220(*(_QWORD *)(a1 + 32), v27);
          goto LABEL_10;
        }
LABEL_40:
        v28 = *(_QWORD *)(a1 + 32);
        if ( v28 )
        {
          v23 = sub_405B80(v28, (unsigned __int16 *)aInvalidSyntax, 0x10uLL);
          v10 = 1;
LABEL_42:
          if ( v23 )
            return v10;
        }
LABEL_43:
        *(_QWORD *)a1 = 0LL;
        *(_BYTE *)(a1 + 8) = 0;
        return 0;
      }
LABEL_83:
      v43 = v51;
      v44 = *(_QWORD *)(a1 + 32);
      if ( (_BYTE)v51 )
      {
        if ( v44 )
        {
          v45 = aRecursionLimit;
          v46 = 25LL;
          goto LABEL_88;
        }
      }
      else if ( v44 )
      {
        v45 = aInvalidSyntax;
        v46 = 16LL;
LABEL_88:
        v10 = 1;
        if ( sub_405B80(v44, (unsigned __int16 *)v45, v46) )
          return v10;
      }
      *(_QWORD *)a1 = 0LL;
      *(_BYTE *)(a1 + 8) = v43;
      return 0;
    case 'e':
      v17 = a2;
      if ( !(_BYTE)a2 )
      {
        v41 = *(_QWORD *)(a1 + 32);
        if ( v41 )
        {
          v10 = 1;
          if ( sub_405B80(v41, (unsigned __int16 *)asc_44755D, 1uLL) )
            return v10;
        }
      }
      v42 = *(_QWORD *)(a1 + 32);
      if ( v42 )
      {
        v10 = 1;
        if ( sub_405B80(v42, (unsigned __int16 *)asc_449A78, 1uLL) )
          return v10;
      }
      v36 = sub_40D380(a1);
      v10 = 1;
      goto LABEL_100;
    case 'h':
    case 'j':
    case 'm':
    case 'o':
    case 't':
    case 'y':
LABEL_9:
      v11 = sub_40CB60(a1, v6);
      goto LABEL_10;
    case 'p':
      v14 = *(_QWORD *)(a1 + 32);
      if ( !v14 )
        goto LABEL_11;
      v15 = asc_447442;
      goto LABEL_104;
    default:
      goto LABEL_40;
  }
}
// 40C448: variable 'v13' is possibly undefined
// 40C4C5: variable 'a2' is possibly undefined
// 40C582: variable 'v27' is possibly undefined
// 40C78F: variable 'v39' is possibly undefined
// 40C8C5: variable 'v19' is possibly undefined
// 40A960: using guessed type __int64 __fastcall sub_40A960(_QWORD, _QWORD);
// 4472F1: using guessed type char asc_4472F1;
// 447442: using guessed type char asc_447442;
// 4474E9: using guessed type char asc_4474E9;
// 4474F3: using guessed type char asc_4474F3;
// 4474F4: using guessed type char asc_4474F4;
// 44755D: using guessed type char asc_44755D;
// 448BDD: using guessed type char asc_448BDD;
// 449A78: using guessed type char asc_449A78;

//----- (000000000040C980) ----------------------------------------------------
char __fastcall sub_40C980(__int64 a1, unsigned __int64 a2)
{
  _QWORD *v2; // rsi
  char v5; // bl
  unsigned __int64 v6; // rdi
  bool v7; // cf
  unsigned __int64 v8; // rdi
  __int64 v10; // rax
  __int64 v11; // r9
  unsigned __int64 v12; // rdx
  int v13; // r10d
  bool v14; // cc
  __int64 v15; // rax
  _WORD v16[2]; // [rsp+30h] [rbp-10h]
  unsigned int v17[15]; // [rsp+34h] [rbp-Ch] BYREF

  v2 = *(_QWORD **)(a1 + 32);
  if ( !v2 )
    return 0;
  v5 = 1;
  if ( sub_405B80(*(_QWORD *)(a1 + 32), (unsigned __int16 *)asc_4474EA, 1uLL) )
    return v5;
  if ( a2 )
  {
    v6 = *(unsigned int *)(a1 + 40);
    v7 = v6 < a2;
    v8 = v6 - a2;
    if ( !v7 )
    {
      if ( v8 >= 0x1A )
      {
        if ( !sub_405B80((__int64)v2, (unsigned __int16 *)asc_447442, 1uLL) )
        {
          v10 = 20LL;
          if ( (unsigned int)v8 < 0x2710 )
          {
            v12 = v8;
          }
          else
          {
            v11 = 10LL;
            do
            {
              v12 = v8 / 0x2710;
              v13 = v8 % 0x2710;
              v10 = v11 * 2 - 4;
              v16[v11] = a0001020304[(unsigned int)(5243 * v13) >> 19];
              v16[v11 + 1] = a0001020304[(unsigned __int16)(v13
                                                          - 100
                                                          * ((unsigned __int16)((unsigned int)(5243 * v13) >> 16) >> 3))];
              v11 -= 2LL;
              v14 = v8 <= 0x5F5E0FF;
              v8 /= 0x2710uLL;
            }
            while ( !v14 );
          }
          if ( v12 > 0x63 )
          {
            *(_WORD *)((char *)&v16[1] + v10) = a0001020304[(unsigned __int16)v12 % 0x64u];
            v10 -= 2LL;
            v12 = (unsigned int)(5243 * ((unsigned __int16)v12 >> 2)) >> 17;
          }
          if ( v12 >= 0xA )
          {
            *(_WORD *)((char *)&v16[1] + v10) = a0001020304[v12];
            v15 = v10 - 2;
          }
          else
          {
            *((_BYTE *)&v16[1] + v10 + 1) = v12 | 0x30;
            v15 = v10 - 1;
          }
          return sub_405270((__int64)v2, 1, 1LL, 0LL, (__int64)v17 + v15, 20 - v15);
        }
      }
      else
      {
        v17[0] = v8 + 97;
        return sub_408160(v17, v2);
      }
      return v5;
    }
    if ( !sub_405B80((__int64)v2, (unsigned __int16 *)aInvalidSyntax, 0x10uLL) )
    {
      *(_QWORD *)a1 = 0LL;
      *(_BYTE *)(a1 + 8) = 0;
      return 0;
    }
    return v5;
  }
  return sub_405B80((__int64)v2, (unsigned __int16 *)asc_447442, 1uLL);
}
// 4428DB: using guessed type _WORD a0001020304[100];
// 447442: using guessed type char asc_447442;
// 4474EA: using guessed type char asc_4474EA;

//----- (000000000040CB60) ----------------------------------------------------
char __fastcall sub_40CB60(__int64 a1, char a2)
{
  _BYTE *v3; // rdi
  unsigned __int64 v5; // rdx
  unsigned __int64 v6; // r8
  unsigned __int64 v7; // r10
  unsigned __int64 v8; // r9
  char v9; // cl
  unsigned __int64 v10; // r14
  char v11; // r15
  unsigned __int16 *v12; // rdi
  __int64 v13; // rax
  unsigned __int64 v14; // rdx
  __int64 v15; // rsi
  unsigned __int64 v16; // rcx
  __int64 v17; // rax
  __int64 v18; // r10
  int v19; // r11d
  bool v20; // cc
  __int64 v21; // rcx
  char v22; // bl
  __int64 v23; // rcx
  char v25; // al
  __int64 v26; // rax
  unsigned __int8 v27; // r15
  int v28; // ecx
  _WORD v29[32]; // [rsp+30h] [rbp-10h] BYREF

  v3 = *(_BYTE **)a1;
  if ( *(_QWORD *)a1 )
  {
    v5 = *(_QWORD *)(a1 + 8);
    v6 = *(_QWORD *)(a1 + 16);
    v7 = v6;
    do
    {
      if ( v7 >= v5 )
        goto LABEL_15;
      v8 = v7;
      v9 = v3[v7++];
      *(_QWORD *)(a1 + 16) = v7;
    }
    while ( (unsigned __int8)(v9 - 48) < 0xAu || (unsigned __int8)(v9 - 97) < 6u );
    if ( v9 != 95 )
    {
LABEL_15:
      v21 = *(_QWORD *)(a1 + 32);
      if ( !v21 || (v22 = 1, !sub_405B80(v21, (unsigned __int16 *)aInvalidSyntax, 0x10uLL)) )
      {
        *(_QWORD *)a1 = 0LL;
        *(_BYTE *)(a1 + 8) = 0;
        return 0;
      }
      return v22;
    }
    v10 = v8 - v6;
    if ( v8 < v6 || (v11 = a2, v6) && (char)v3[v6] <= -65 )
      sub_4079A0(v3, v5, v6, v8, (__int64)&off_447448);
    v12 = (unsigned __int16 *)&v3[v6];
    v13 = sub_40D0A0((__int64)v12, v8 - v6);
    v15 = *(_QWORD *)(a1 + 32);
    if ( v13 )
    {
      if ( !v15 )
        return 0;
      v16 = v14;
      v17 = 20LL;
      if ( v14 >= 0x2710 )
      {
        v18 = 10LL;
        do
        {
          v14 = v16 / 0x2710;
          v19 = v16 % 0x2710;
          v17 = v18 * 2 - 4;
          v29[v18] = a0001020304[(unsigned int)(5243 * v19) >> 19];
          v29[v18 + 1] = a0001020304[(unsigned __int16)(v19
                                                      - 100
                                                      * ((unsigned __int16)((unsigned int)(5243 * v19) >> 16) >> 3))];
          v18 -= 2LL;
          v20 = v16 <= 0x5F5E0FF;
          v16 /= 0x2710uLL;
        }
        while ( !v20 );
      }
      if ( v14 > 0x63 )
      {
        *(_WORD *)((char *)&v29[1] + v17) = a0001020304[(unsigned __int16)v14 % 0x64u];
        v17 -= 2LL;
        v14 = (unsigned int)(5243 * ((unsigned __int16)v14 >> 2)) >> 17;
      }
      if ( v14 >= 0xA )
      {
        *(_WORD *)((char *)&v29[1] + v17) = a0001020304[v14];
        v26 = v17 - 2;
      }
      else
      {
        *((_BYTE *)&v29[1] + v17 + 1) = v14 | 0x30;
        v26 = v17 - 1;
      }
      v22 = 1;
      v25 = sub_405270(v15, 1, 1LL, 0LL, (__int64)&v29[2] + v26, 20 - v26);
    }
    else
    {
      if ( !v15 )
        return 0;
      v22 = 1;
      if ( sub_405B80(v15, (unsigned __int16 *)a0x, 2uLL) )
        return v22;
      v25 = sub_405B80(v15, v12, v10);
    }
    if ( v25 )
      return v22;
    if ( (*(_BYTE *)(v15 + 36) & 4) == 0 )
    {
      v27 = v11 - 97;
      if ( v27 >= 0x1Au || (v28 = 62716863, !_bittest(&v28, v27)) )
        sub_407050((__int64)&off_447568);
      return sub_405B80(v15, (unsigned __int16 *)*(&off_447778 + (unsigned int)v27), qword_4476A8[v27]);
    }
  }
  else
  {
    v23 = *(_QWORD *)(a1 + 32);
    if ( v23 )
      return sub_405B80(v23, (unsigned __int16 *)asc_4474E9, 1uLL);
  }
  return 0;
}
// 40CC0E: variable 'v14' is possibly undefined
// 4428DB: using guessed type _WORD a0001020304[100];
// 447448: using guessed type char *off_447448;
// 4474E9: using guessed type char asc_4474E9;
// 447568: using guessed type char *off_447568;
// 4476A8: using guessed type _QWORD qword_4476A8[26];
// 447778: using guessed type _UNKNOWN *off_447778;

//----- (000000000040CE30) ----------------------------------------------------
char __fastcall sub_40CE30(__int64 *a1, unsigned int a2)
{
  __int64 v2; // r10
  unsigned __int64 v4; // r11
  unsigned __int64 v5; // r9
  unsigned __int64 v6; // rax
  unsigned __int64 v7; // rax
  unsigned __int64 v8; // rsi
  char v9; // dl
  unsigned __int8 v10; // bl
  unsigned __int8 v11; // dl
  __int64 v12; // rax
  unsigned __int64 v13; // kr00_8
  bool v14; // cf
  __int64 v15; // rcx
  char result; // al
  unsigned int v17; // edx
  unsigned __int8 v18; // si
  _OWORD *v19; // rsi
  __int64 v20; // rax
  char *v21; // rdx
  __int64 *v22; // rdi
  char v23; // al
  char v24; // dl
  __int128 v25; // [rsp+20h] [rbp-20h]
  __int128 v26; // [rsp+30h] [rbp-10h]

  v2 = *a1;
  if ( !*a1 )
  {
    v15 = a1[4];
    if ( v15 )
      return sub_405B80(v15, (unsigned __int16 *)asc_4474E9, 1uLL);
    return 0;
  }
  v4 = a1[1];
  v5 = a1[2];
  if ( v5 < v4 && *(_BYTE *)(v2 + v5) == 95 )
  {
    a1[2] = v5 + 1;
    v6 = 0LL;
    if ( v5 != 1 )
    {
LABEL_22:
      v17 = *((_DWORD *)a1 + 6) + 1;
      v18 = 1;
      if ( v17 <= 0x1F4 )
      {
        if ( a1[4] )
        {
          v26 = *((_OWORD *)a1 + 1);
          v25 = *(_OWORD *)a1;
          a1[2] = v6;
          *((_DWORD *)a1 + 6) = v17;
          LOBYTE(a2) = a2 & 1;
          v19 = a1;
          result = sub_40C310(a1, a2);
          *v19 = v25;
          v19[1] = v26;
          return result;
        }
        return 0;
      }
LABEL_28:
      v20 = a1[4];
      if ( !v20 )
        goto LABEL_32;
      goto LABEL_29;
    }
  }
  else
  {
    v7 = 0LL;
    v8 = a1[2];
    while ( v8 < v4 )
    {
      v9 = *(_BYTE *)(v2 + v8);
      if ( v9 == 95 )
      {
        a1[2] = v8 + 1;
        if ( v7 == -1LL )
          break;
        v6 = v7 + 1;
        if ( v6 >= v5 - 1 )
          break;
        goto LABEL_22;
      }
      v10 = v9 - 48;
      if ( (unsigned __int8)(v9 - 48) >= 0xAu )
      {
        if ( (unsigned __int8)(v9 - 97) >= 0x1Au )
        {
          if ( (unsigned __int8)(v9 - 65) >= 0x1Au )
          {
            v18 = 0;
            goto LABEL_28;
          }
          v11 = v9 - 29;
        }
        else
        {
          v11 = v9 - 87;
        }
        v10 = v11;
      }
      a1[2] = ++v8;
      v13 = v7;
      v12 = 62 * v7;
      if ( is_mul_ok(0x3EuLL, v13) )
      {
        v14 = __CFADD__(v10, v12);
        v7 = v10 + v12;
        if ( !v14 )
          continue;
      }
      break;
    }
  }
  v18 = 0;
  v20 = a1[4];
  if ( !v20 )
  {
LABEL_32:
    *a1 = 0LL;
    *((_BYTE *)a1 + 8) = v18;
    return 0;
  }
LABEL_29:
  v21 = aInvalidSyntax;
  if ( v18 )
    v21 = aRecursionLimit;
  v22 = a1;
  v23 = sub_405B80(v20, (unsigned __int16 *)v21, 9LL * v18 + 16);
  a1 = v22;
  v24 = v23;
  result = 1;
  if ( !v24 )
    goto LABEL_32;
  return result;
}
// 40C310: using guessed type __int64 __fastcall sub_40C310(_QWORD, _QWORD);
// 4474E9: using guessed type char asc_4474E9;

//----- (000000000040CFF0) ----------------------------------------------------
__int64 __fastcall sub_40CFF0(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  unsigned __int64 v4; // r8
  _BYTE *v5; // rcx
  unsigned __int64 v6; // rdx
  unsigned __int64 v7; // rsi
  unsigned __int64 v8; // r9
  char v9; // r11

  result = a1;
  v4 = *(_QWORD *)(a2 + 16);
  v5 = *(_BYTE **)a2;
  v6 = *(_QWORD *)(a2 + 8);
  v7 = v4;
  do
  {
    if ( v7 >= v6 )
      goto LABEL_9;
    v8 = v7;
    v9 = v5[v7++];
    *(_QWORD *)(a2 + 16) = v7;
  }
  while ( (unsigned __int8)(v9 - 48) < 0xAu || (unsigned __int8)(v9 - 97) < 6u );
  if ( v9 != 95 )
  {
LABEL_9:
    *(_BYTE *)(result + 8) = 0;
    *(_QWORD *)result = 0LL;
    return result;
  }
  if ( v8 < v4 || v4 && (char)v5[v4] <= -65 )
    sub_4079A0(v5, v6, v4, v8, (__int64)&off_447448);
  *(_QWORD *)result = &v5[v4];
  *(_QWORD *)(result + 8) = v8 - v4;
  return result;
}
// 447448: using guessed type char *off_447448;

//----- (000000000040D0A0) ----------------------------------------------------
__int64 __fastcall sub_40D0A0(__int64 a1, __int64 a2)
{
  __int64 v4; // rcx
  __int64 result; // rax
  unsigned __int8 *v6; // rsi
  unsigned __int8 *v7; // rcx
  __int64 v8; // rdx
  unsigned int v9; // r8d
  int v10; // r9d
  int v11; // r11d
  int v12; // r10d
  unsigned __int8 v13; // r8
  unsigned int v14; // r9d
  _BYTE v15[32]; // [rsp+0h] [rbp-80h] BYREF
  __int64 v16; // [rsp+98h] [rbp+18h] BYREF
  __int64 v17; // [rsp+A0h] [rbp+20h]

  sub_4083C0(&v15[48], a1, a2, "0", 1uLL);
  do
    sub_40E480(&v16, (__int64)&v15[48]);
  while ( !v16 );
  if ( (_DWORD)v16 == 1 )
  {
    v4 = v17;
    if ( (unsigned __int64)(a2 - v17) > 0x10 )
      return 0LL;
  }
  else
  {
    v4 = a2;
  }
  result = 1LL;
  if ( a2 != v4 )
  {
    v6 = (unsigned __int8 *)(a1 + a2);
    v7 = (unsigned __int8 *)(a1 + v4);
    v8 = 0LL;
    do
    {
      v9 = *v7;
      if ( (v9 & 0x80u) != 0 )
      {
        v10 = v9 & 0x1F;
        v11 = v7[1] & 0x3F;
        if ( (unsigned __int8)v9 <= 0xDFu )
        {
          v7 += 2;
          v9 = v11 | (v10 << 6);
        }
        else
        {
          v12 = (v11 << 6) | v7[2] & 0x3F;
          if ( (unsigned __int8)v9 < 0xF0u )
          {
            v7 += 3;
            v9 = (v10 << 12) | v12;
          }
          else
          {
            v13 = v7[3];
            v7 += 4;
            v9 = ((v10 & 7) << 18) | (v12 << 6) | v13 & 0x3F;
          }
        }
      }
      else
      {
        ++v7;
      }
      v14 = v9 - 48;
      if ( v9 >= 0x3A )
        v14 = ((v9 - 65) & 0xFFFFFFDF) + 10;
      if ( v14 >= 0x10 )
        sub_407050((__int64)&off_4472F8);
      v8 = (16 * v8) | v14;
    }
    while ( v7 != v6 );
  }
  return result;
}
// 4472F8: using guessed type char *off_4472F8;

//----- (000000000040D220) ----------------------------------------------------
__int64 __fastcall sub_40D220(__int64 a1, unsigned int a2)
{
  unsigned int v2; // edi
  unsigned int v5; // edx
  char v6; // al
  char v7; // r15
  __int64 v8; // rdx
  __int64 v9; // rax
  unsigned __int64 v10; // r15
  unsigned __int64 v11; // r12
  __int64 v12; // rdx
  __int64 v14; // [rsp+20h] [rbp-10h] BYREF
  int v15; // [rsp+28h] [rbp-8h]

  if ( !a1 )
    return 0;
  LOBYTE(v2) = 1;
  if ( (*(unsigned __int8 (__fastcall **)(_QWORD, __int64))(*(_QWORD *)(a1 + 56) + 32LL))(*(_QWORD *)(a1 + 48), 39LL) )
    return v2;
  v5 = a2;
  if ( a2 == 34 )
  {
    v6 = (*(__int64 (__fastcall **)(_QWORD, __int64))(*(_QWORD *)(a1 + 56) + 32LL))(*(_QWORD *)(a1 + 48), 34LL);
    v5 = 1114112;
    if ( v6 )
      return v2;
  }
  while ( v5 != 1114112 )
  {
    sub_40DE00((__int64)&v14, v5);
    if ( __OFSUB__(0, (_BYTE)v14) )
    {
      v7 = 0x80;
      while ( 1 )
      {
        if ( __OFSUB__(-v7, 1) )
        {
          v8 = HIDWORD(v14);
          v15 = 0;
          v14 = 0LL;
          v7 = 0;
        }
        else
        {
          v9 = BYTE2(v15);
          if ( BYTE2(v15) >= HIBYTE(v15) )
            goto LABEL_17;
          ++BYTE2(v15);
          v8 = *((unsigned __int8 *)&v14 + v9);
        }
        if ( (*(unsigned __int8 (__fastcall **)(_QWORD, __int64))(*(_QWORD *)(a1 + 56) + 32LL))(
               *(_QWORD *)(a1 + 48),
               v8) )
        {
          return v2;
        }
      }
    }
    v10 = HIBYTE(v15);
    v11 = BYTE2(v15);
    while ( v11 < v10 )
    {
      v12 = *((unsigned __int8 *)&v14 + v11++);
      if ( (*(unsigned __int8 (__fastcall **)(_QWORD, __int64))(*(_QWORD *)(a1 + 56) + 32LL))(*(_QWORD *)(a1 + 48), v12) )
        return v2;
    }
LABEL_17:
    v5 = 1114112;
  }
  return (*(__int64 (__fastcall **)(_QWORD, __int64))(*(_QWORD *)(a1 + 56) + 32LL))(*(_QWORD *)(a1 + 48), 39LL);
}
// 40D345: variable 'v2' is possibly undefined

//----- (000000000040D380) ----------------------------------------------------
char __fastcall sub_40D380(__int64 a1)
{
  _BYTE *v2; // rcx
  unsigned __int64 v3; // rdx
  unsigned __int64 v4; // r14
  unsigned __int64 v5; // r8
  unsigned __int64 v6; // rbx
  char v7; // al
  unsigned __int64 v8; // r12
  _BYTE *v9; // rbx
  unsigned __int8 *v10; // r14
  unsigned int v11; // eax
  __int64 v12; // r15
  char v13; // si
  unsigned int i; // eax
  __int64 v16; // rcx
  __int64 v17; // rcx
  char v18; // r12
  __int64 v19; // rdx
  __int64 v20; // rax
  unsigned __int64 v21; // r12
  unsigned __int64 v22; // r13
  __int64 v23; // rdx
  unsigned __int8 *v24; // [rsp+30h] [rbp-30h] BYREF
  unsigned __int64 v25; // [rsp+38h] [rbp-28h]
  _BYTE *v26; // [rsp+40h] [rbp-20h]
  __int64 v27; // [rsp+48h] [rbp-18h]
  __int64 v28; // [rsp+50h] [rbp-10h]
  __int64 v29; // [rsp+58h] [rbp-8h] BYREF
  int v30; // [rsp+60h] [rbp+0h]

  v2 = *(_BYTE **)a1;
  if ( v2 )
  {
    v3 = *(_QWORD *)(a1 + 8);
    v4 = *(_QWORD *)(a1 + 16);
    v5 = v4;
    do
    {
      if ( v5 >= v3 )
        goto LABEL_17;
      v6 = v5;
      v7 = v2[v5++];
      *(_QWORD *)(a1 + 16) = v5;
    }
    while ( (unsigned __int8)(v7 - 48) < 0xAu || (unsigned __int8)(v7 - 97) < 6u );
    if ( v7 != 95 )
      goto LABEL_17;
    v8 = v6 - v4;
    if ( v6 < v4 || v4 && (char)v2[v4] <= -65 )
      sub_4079A0(v2, v3, v4, v6, (__int64)&off_447448);
    if ( (v8 & 1) != 0 )
      goto LABEL_17;
    v9 = &v2[v6];
    v10 = &v2[v4];
    v24 = v10;
    v25 = v8;
    v26 = v9;
    v27 = 0LL;
    v28 = 2LL;
    do
      v11 = sub_40DA20(&v24);
    while ( v11 < 0x110000 );
    if ( v11 != 1114113 )
    {
LABEL_17:
      v16 = *(_QWORD *)(a1 + 32);
      if ( !v16 || (v13 = 1, !sub_405B80(v16, (unsigned __int16 *)aInvalidSyntax, 0x10uLL)) )
      {
        *(_QWORD *)a1 = 0LL;
        *(_BYTE *)(a1 + 8) = 0;
        return 0;
      }
      return v13;
    }
    v12 = *(_QWORD *)(a1 + 32);
    if ( !v12 )
      return 0;
    v13 = 1;
    if ( !(*(unsigned __int8 (__fastcall **)(_QWORD, __int64))(*(_QWORD *)(v12 + 56) + 32LL))(
            *(_QWORD *)(v12 + 48),
            34LL) )
    {
      v24 = v10;
      v25 = v8;
      v26 = v9;
      v27 = 0LL;
      v28 = 2LL;
      for ( i = sub_40DA20(&v24); i != 1114113; i = sub_40DA20(&v24) )
      {
        if ( i == 1114112 )
          sub_406F40((__int64)aCalledResultUn, 43LL, (__int64)&v29, (__int64)&unk_446F08, (__int64)&off_446EB0);
        if ( i == 39 )
        {
          if ( (*(unsigned __int8 (__fastcall **)(_QWORD, __int64))(*(_QWORD *)(v12 + 56) + 32LL))(
                 *(_QWORD *)(v12 + 48),
                 39LL) )
          {
            return v13;
          }
        }
        else
        {
          sub_40DE00((__int64)&v29, i);
          if ( __OFSUB__(0, (_BYTE)v29) )
          {
            v18 = 0x80;
            while ( 1 )
            {
              if ( __OFSUB__(-v18, 1) )
              {
                v19 = HIDWORD(v29);
                v30 = 0;
                v29 = 0LL;
                v18 = 0;
              }
              else
              {
                v20 = BYTE2(v30);
                if ( BYTE2(v30) >= HIBYTE(v30) )
                  goto LABEL_27;
                ++BYTE2(v30);
                v19 = *((unsigned __int8 *)&v29 + v20);
              }
              if ( (*(unsigned __int8 (__fastcall **)(_QWORD, __int64))(*(_QWORD *)(v12 + 56) + 32LL))(
                     *(_QWORD *)(v12 + 48),
                     v19) )
              {
                return v13;
              }
            }
          }
          v21 = HIBYTE(v30);
          v22 = BYTE2(v30);
          while ( v22 < v21 )
          {
            v23 = *((unsigned __int8 *)&v29 + v22++);
            if ( (*(unsigned __int8 (__fastcall **)(_QWORD, __int64))(*(_QWORD *)(v12 + 56) + 32LL))(
                   *(_QWORD *)(v12 + 48),
                   v23) )
            {
              return v13;
            }
          }
        }
LABEL_27:
        ;
      }
      return (*(__int64 (__fastcall **)(_QWORD, __int64))(*(_QWORD *)(v12 + 56) + 32LL))(*(_QWORD *)(v12 + 48), 34LL);
    }
  }
  else
  {
    v17 = *(_QWORD *)(a1 + 32);
    if ( v17 )
      return sub_405B80(v17, (unsigned __int16 *)asc_4474E9, 1uLL);
    return 0;
  }
  return v13;
}
// 446EB0: using guessed type char *off_446EB0;
// 447448: using guessed type char *off_447448;
// 4474E9: using guessed type char asc_4474E9;

//----- (000000000040D650) ----------------------------------------------------
__int64 __fastcall sub_40D650(__int64 *a1, __int64 a2)
{
  __int64 v2; // rax
  __int64 v4; // rsi
  __int64 v5; // r14
  unsigned __int64 v6; // rcx
  __int64 v8; // rcx

  v2 = *a1;
  if ( !*a1 )
    return 0LL;
  v4 = 0LL;
  v5 = 0LL;
  while ( 1 )
  {
    v6 = a1[2];
    if ( v6 < a1[1] && *(_BYTE *)(v2 + v6) == 69 )
      break;
    if ( v5-- != 0 )
    {
      v8 = a1[4];
      if ( v8 )
      {
        if ( sub_405B80(v8, (unsigned __int16 *)asc_4474F1, 2uLL) )
          return 1LL;
      }
    }
    LOBYTE(a2) = 1;
    if ( (unsigned __int8)sub_40C310(a1, a2) )
      return 1LL;
    v2 = *a1;
    if ( !*a1 )
      return v4;
  }
  a1[2] = v6 + 1;
  return 0LL;
}
// 40D6B6: variable 'a2' is possibly undefined
// 40C310: using guessed type __int64 __fastcall sub_40C310(_QWORD, _QWORD);

//----- (000000000040D6F0) ----------------------------------------------------
__int64 __fastcall sub_40D6F0(__int64 *a1, __int64 a2)
{
  __int64 v2; // rax
  __int64 v4; // rdi
  __int64 i; // rsi
  unsigned __int64 v6; // rcx
  __int64 v7; // rcx

  v2 = *a1;
  if ( !*a1 )
    return 0LL;
  v4 = 0LL;
  for ( i = 0LL; ; ++i )
  {
    v6 = a1[2];
    if ( v6 < a1[1] && *(_BYTE *)(v2 + v6) == 69 )
      break;
    if ( i )
    {
      v7 = a1[4];
      if ( v7 )
      {
        if ( sub_405B80(v7, (unsigned __int16 *)asc_4474F1, 2uLL) )
          return 1LL;
      }
    }
    LOBYTE(a2) = 1;
    if ( (unsigned __int8)sub_40C310(a1, a2) )
      return 1LL;
    v2 = *a1;
    if ( !*a1 )
      return v4;
  }
  a1[2] = v6 + 1;
  return 0LL;
}
// 40D755: variable 'a2' is possibly undefined
// 40C310: using guessed type __int64 __fastcall sub_40C310(_QWORD, _QWORD);

//----- (000000000040D7A0) ----------------------------------------------------
__int64 __fastcall sub_40D7A0(_QWORD *a1)
{
  __int64 v1; // r8
  __int64 i; // r15
  unsigned __int64 v4; // r9
  unsigned __int64 v5; // rax
  __int64 v6; // rcx
  unsigned __int64 v7; // rcx
  unsigned __int64 v8; // rax
  char v9; // dl
  unsigned __int8 v10; // r10
  unsigned __int8 v11; // dl
  __int64 v12; // rax
  unsigned __int64 v13; // kr00_8
  bool v14; // cf
  __int64 v15; // rcx
  char v16; // cl
  __int64 result; // rax
  __int64 v18; // rdx
  __int64 v19; // r13
  __int64 v20; // rcx
  char v21; // bl
  __int64 v22; // rcx
  char *v23; // rdx
  unsigned __int64 v24; // r8
  _OWORD v25[2]; // [rsp+20h] [rbp-40h] BYREF
  _OWORD v26[5]; // [rsp+48h] [rbp-18h] BYREF

  v1 = *a1;
  if ( !*a1 )
    return 0LL;
  for ( i = 0LL; ; ++i )
  {
    v4 = a1[1];
    v5 = a1[2];
    if ( v5 < v4 && *(_BYTE *)(v1 + v5) == 69 )
    {
      a1[2] = v5 + 1;
      return 0LL;
    }
    if ( i )
    {
      v6 = a1[4];
      if ( v6 )
      {
        if ( sub_405B80(v6, (unsigned __int16 *)asc_4474F1, 2uLL) )
          return 1LL;
        v1 = *a1;
        if ( !*a1 )
        {
          v15 = a1[4];
          if ( !v15 )
            return 0LL;
          v16 = sub_405B80(v15, (unsigned __int16 *)asc_4474E9, 1uLL);
          result = 1LL;
          if ( v16 )
            return result;
          goto LABEL_36;
        }
        v4 = a1[1];
        v5 = a1[2];
      }
    }
    if ( v5 < v4 && *(_BYTE *)(v1 + v5) == 115 )
      break;
LABEL_31:
    sub_40B330((__int64 *)v26, a1);
    if ( !*(_QWORD *)&v26[0] )
    {
      v21 = BYTE8(v26[0]);
      v22 = a1[4];
      if ( BYTE8(v26[0]) )
      {
        if ( v22 )
        {
          v23 = aRecursionLimit;
          v24 = 25LL;
          goto LABEL_49;
        }
      }
      else if ( v22 )
      {
        v23 = aInvalidSyntax;
        v24 = 16LL;
LABEL_49:
        if ( sub_405B80(v22, (unsigned __int16 *)v23, v24) )
          return 1LL;
      }
      *a1 = 0LL;
      *((_BYTE *)a1 + 8) = v21;
      return 0LL;
    }
    v25[1] = v26[1];
    v25[0] = v26[0];
    v19 = a1[4];
    if ( v19
      && ((unsigned __int8)sub_40B550((unsigned __int8 **)v25, (_QWORD *)a1[4])
       || sub_405B80(v19, (unsigned __int16 *)asc_448C8B, 2uLL)) )
    {
      return 1LL;
    }
    LOBYTE(v18) = 1;
    if ( (unsigned __int8)sub_40C310(a1, v18) )
      return 1LL;
LABEL_36:
    v1 = *a1;
    if ( !*a1 )
      return 0LL;
  }
  v7 = v5 + 1;
  a1[2] = v5 + 1;
  if ( v5 + 1 < v4 && *(_BYTE *)(v1 + v7) == 95 )
  {
    a1[2] = v5 + 2;
    goto LABEL_31;
  }
  v8 = 0LL;
  while ( v7 < v4 )
  {
    v9 = *(_BYTE *)(v1 + v7);
    if ( v9 == 95 )
    {
      a1[2] = v7 + 1;
      if ( v8 <= 0xFFFFFFFFFFFFFFFDuLL )
        goto LABEL_31;
      break;
    }
    v10 = v9 - 48;
    if ( (unsigned __int8)(v9 - 48) >= 0xAu )
    {
      if ( (unsigned __int8)(v9 - 97) >= 0x1Au )
      {
        if ( (unsigned __int8)(v9 - 65) >= 0x1Au )
          break;
        v11 = v9 - 29;
      }
      else
      {
        v11 = v9 - 87;
      }
      v10 = v11;
    }
    a1[2] = ++v7;
    v13 = v8;
    v12 = 62 * v8;
    if ( is_mul_ok(0x3EuLL, v13) )
    {
      v14 = __CFADD__(v10, v12);
      v8 = v10 + v12;
      if ( !v14 )
        continue;
    }
    break;
  }
  v20 = a1[4];
  if ( v20 && sub_405B80(v20, (unsigned __int16 *)aInvalidSyntax, 0x10uLL) )
    return 1LL;
  *a1 = 0LL;
  *((_BYTE *)a1 + 8) = 0;
  return 0LL;
}
// 40D968: variable 'v18' is possibly undefined
// 40C310: using guessed type __int64 __fastcall sub_40C310(_QWORD, _QWORD);
// 4474E9: using guessed type char asc_4474E9;

//----- (000000000040DA20) ----------------------------------------------------
__int64 __fastcall sub_40DA20(unsigned __int8 **a1)
{
  unsigned __int8 *v1; // r9
  unsigned __int8 *v2; // r10
  __int64 result; // rax
  bool v4; // cf
  unsigned __int64 v5; // r9
  unsigned __int8 *v6; // r8
  unsigned __int8 *v7; // rdx
  unsigned int v8; // r10d
  unsigned int v9; // eax
  unsigned int v10; // r8d
  unsigned int v11; // r10d
  char v12; // r10
  unsigned __int64 v13; // r8
  char v14; // al
  unsigned __int16 *v15; // rdx
  unsigned __int16 *v16; // r9
  int v17; // r8d
  int v18; // r11d
  int v19; // r10d
  unsigned int v20; // edi
  unsigned int v21; // esi
  unsigned int v22; // ebx
  unsigned int v23; // edi
  unsigned int v24; // esi
  unsigned int v25; // r11d
  unsigned int v26; // edi
  unsigned int v27; // esi
  unsigned int v28; // ecx
  unsigned int v29; // eax
  unsigned int v30; // edx
  unsigned int v31; // ecx
  _QWORD v32[6]; // [rsp+20h] [rbp-60h] BYREF
  _QWORD v33[2]; // [rsp+50h] [rbp-30h] BYREF
  char **v34; // [rsp+60h] [rbp-20h] BYREF
  char (__fastcall *v35)(__int64, __int64); // [rsp+68h] [rbp-18h]
  _QWORD *v36; // [rsp+70h] [rbp-10h]
  __int64 (__fastcall *v37)(); // [rsp+78h] [rbp-8h]
  __int64 *v38; // [rsp+80h] [rbp+0h]
  __int64 (__fastcall *v39)(unsigned __int64 *, __int64); // [rsp+88h] [rbp+8h]
  __int64 v40; // [rsp+90h] [rbp+10h] BYREF
  char *v41; // [rsp+98h] [rbp+18h] BYREF
  __int64 v42; // [rsp+A0h] [rbp+20h]
  char v43; // [rsp+ACh] [rbp+2Ch] BYREF
  __int16 v44; // [rsp+ADh] [rbp+2Dh]
  char v45; // [rsp+AFh] [rbp+2Fh]

  v1 = a1[1];
  v2 = a1[4];
  result = 1114113LL;
  v4 = v1 < v2;
  v5 = v1 - v2;
  if ( v4 )
    return result;
  v6 = *a1;
  v7 = &v2[(_QWORD)*a1];
  *a1 = v7;
  a1[1] = (unsigned __int8 *)v5;
  if ( v2 != (unsigned __int8 *)2 )
    sub_405FC0((__int64)"internal error: entered unreachable code", 40LL, (__int64)&off_447310);
  v8 = *v6;
  v9 = v8 - 48;
  if ( v8 >= 0x3A )
    v9 = ((v8 - 65) & 0xFFFFFFDF) + 10;
  if ( v9 >= 0x10 )
    goto LABEL_57;
  v10 = v6[1];
  v11 = v10 - 48;
  if ( v10 >= 0x3A )
    v11 = ((v10 - 65) & 0xFFFFFFDF) + 10;
  if ( v11 >= 0x10 )
    goto LABEL_57;
  v12 = (16 * v9) | v11;
  if ( v12 < 0 )
  {
    result = 1114112LL;
    if ( (unsigned __int8)v12 < 0xC0u )
      return result;
    if ( (unsigned __int8)v12 >= 0xE0u )
    {
      if ( (unsigned __int8)v12 < 0xF0u )
      {
        v13 = 3LL;
        v14 = 1;
LABEL_25:
        v43 = v12;
        v44 = 0;
        v45 = 0;
        v41 = &v43;
        v42 = v13;
        if ( v5 < 2 )
          return 1114112LL;
        *a1 = v7 + 2;
        a1[1] = (unsigned __int8 *)(v5 - 2);
        v20 = *v7;
        v21 = v20 - 48;
        if ( v20 >= 0x3A )
          v21 = ((v20 - 65) & 0xFFFFFFDF) + 10;
        if ( v21 <= 0xF )
        {
          v22 = v7[1];
          v23 = v22 - 48;
          if ( v22 >= 0x3A )
            v23 = ((v22 - 65) & 0xFFFFFFDF) + 10;
          if ( v23 <= 0xF )
          {
            LOBYTE(v44) = (16 * v21) | v23;
            if ( (unsigned __int8)v12 < 0xE0u )
              goto LABEL_11;
            if ( v5 - 2 < 2 )
              return 1114112LL;
            *a1 = v7 + 4;
            a1[1] = (unsigned __int8 *)(v5 - 4);
            v24 = v7[2];
            v25 = v24 - 48;
            if ( v24 >= 0x3A )
              v25 = ((v24 - 65) & 0xFFFFFFDF) + 10;
            if ( v25 <= 0xF )
            {
              v26 = v7[3];
              v27 = v26 - 48;
              if ( v26 >= 0x3A )
                v27 = ((v26 - 65) & 0xFFFFFFDF) + 10;
              if ( v27 <= 0xF )
              {
                HIBYTE(v44) = (16 * v25) | v27;
                if ( v14 )
                  goto LABEL_11;
                if ( v5 - 4 < 2 )
                  return 1114112LL;
                *a1 = v7 + 6;
                a1[1] = (unsigned __int8 *)(v5 - 6);
                v28 = v7[4];
                v29 = v28 - 48;
                if ( v28 >= 0x3A )
                  v29 = ((v28 - 65) & 0xFFFFFFDF) + 10;
                if ( v29 <= 0xF )
                {
                  v30 = v7[5];
                  v31 = v30 - 48;
                  if ( v30 >= 0x3A )
                    v31 = ((v30 - 65) & 0xFFFFFFDF) + 10;
                  if ( v31 <= 0xF )
                  {
                    v45 = (16 * v29) | v31;
                    goto LABEL_11;
                  }
                }
              }
            }
          }
        }
LABEL_57:
        sub_407050((__int64)&off_447328);
      }
      if ( (unsigned __int8)v12 >= 0xF8u )
        return result;
      v13 = 4LL;
    }
    else
    {
      v13 = 2LL;
    }
    v14 = 0;
    goto LABEL_25;
  }
  v43 = v12;
  v44 = 0;
  v45 = 0;
  v41 = &v43;
  v42 = 1LL;
  v13 = 1LL;
LABEL_11:
  sub_406850((__int64)&v34, (__int64)&v43, v13);
  if ( ((unsigned __int8)v34 & 1) != 0 )
    return 1114112LL;
  v33[0] = v35;
  v33[1] = v36;
  v15 = (unsigned __int16 *)((char *)v36 + (_QWORD)v35);
  if ( !v36 )
    goto LABEL_58;
  result = *(unsigned __int8 *)v35;
  if ( (result & 0x80u) != 0LL )
  {
    v17 = result & 0x1F;
    v18 = *((_BYTE *)v35 + 1) & 0x3F;
    if ( (unsigned __int8)result <= 0xDFu )
    {
      v16 = (unsigned __int16 *)((char *)v35 + 2);
      result = v18 | (unsigned int)(v17 << 6);
    }
    else
    {
      v19 = (v18 << 6) | *((_BYTE *)v35 + 2) & 0x3F;
      if ( (unsigned __int8)result < 0xF0u )
      {
        v16 = (unsigned __int16 *)((char *)v35 + 3);
        result = (v17 << 12) | (unsigned int)v19;
      }
      else
      {
        v16 = (unsigned __int16 *)((char *)v35 + 4);
        result = ((result & 7) << 18) | (v19 << 6) | *((_BYTE *)v35 + 3) & 0x3Fu;
      }
    }
  }
  else
  {
    v16 = (unsigned __int16 *)((char *)v35 + 1);
  }
  if ( v16 != v15 || (_DWORD)result == 1114112 )
  {
LABEL_58:
    v40 = sub_40E160((unsigned __int16 *)v35, v15);
    v34 = &v41;
    v35 = sub_40E240;
    v36 = v33;
    v37 = sub_40E460;
    v38 = &v40;
    v39 = sub_405120;
    v32[0] = &off_4473B0;
    v32[1] = 4LL;
    v32[4] = 0LL;
    v32[2] = &v34;
    v32[3] = 3LL;
    sub_405240(v32, &off_4473F0);
  }
  return result;
}
// 405240: using guessed type void __fastcall __noreturn sub_405240(_QWORD, _QWORD);
// 40E460: using guessed type __int64 __fastcall sub_40E460();
// 447310: using guessed type char *off_447310;
// 447328: using guessed type char *off_447328;
// 4473B0: using guessed type char *off_4473B0;
// 4473F0: using guessed type char *off_4473F0;

//----- (000000000040DE00) ----------------------------------------------------
char __fastcall sub_40DE00(__int64 a1, unsigned int a2)
{
  char result; // al
  __int64 v4; // rdi
  unsigned int v5; // eax
  __int64 v6; // rax
  char v7; // cl
  unsigned int v8; // eax
  __int64 v9; // rax
  char v10; // dl
  __int64 v11; // [rsp+30h] [rbp-20h]
  __int64 v12; // [rsp+38h] [rbp-18h]
  __int16 v13; // [rsp+40h] [rbp-10h]
  __int16 v14; // [rsp+42h] [rbp-Eh]
  __int64 v15; // [rsp+44h] [rbp-Ch]
  __int16 v16; // [rsp+4Ch] [rbp-4h]

  result = a2;
  switch ( a2 )
  {
    case 0u:
      *(_WORD *)a1 = 12380;
      goto LABEL_13;
    case 1u:
    case 2u:
    case 3u:
    case 4u:
    case 5u:
    case 6u:
    case 7u:
    case 8u:
    case 0xBu:
    case 0xCu:
    case 0xEu:
    case 0xFu:
    case 0x10u:
    case 0x11u:
    case 0x12u:
    case 0x13u:
    case 0x14u:
    case 0x15u:
    case 0x16u:
    case 0x17u:
    case 0x18u:
    case 0x19u:
    case 0x1Au:
    case 0x1Bu:
    case 0x1Cu:
    case 0x1Du:
    case 0x1Eu:
    case 0x1Fu:
    case 0x20u:
    case 0x21u:
    case 0x23u:
    case 0x24u:
    case 0x25u:
    case 0x26u:
      goto LABEL_5;
    case 9u:
      *(_WORD *)a1 = 29788;
      goto LABEL_13;
    case 0xAu:
      *(_WORD *)a1 = 28252;
      goto LABEL_13;
    case 0xDu:
      *(_WORD *)a1 = 29276;
      goto LABEL_13;
    case 0x22u:
      *(_WORD *)a1 = 8796;
      goto LABEL_13;
    case 0x27u:
      *(_WORD *)a1 = 10076;
      goto LABEL_13;
    default:
      if ( a2 != 92 )
      {
LABEL_5:
        if ( a2 <= 0x2FF )
        {
          if ( a2 < 0x20 )
            goto LABEL_27;
          if ( a2 < 0x7F )
            goto LABEL_20;
        }
        else
        {
          v4 = a1;
          if ( (unsigned __int8)sub_407EB0(a2) )
          {
            _BitScanReverse(&v5, a2 | 1);
            v6 = (v5 ^ 0x1C) >> 2;
            v7 = v6 - 2;
            BYTE2(v15) = 0;
            LOWORD(v15) = 0;
            BYTE3(v15) = a0123456789abcd[a2 >> 20];
            BYTE4(v15) = a0123456789abcd[HIWORD(a2) & 0xF];
            BYTE5(v15) = a0123456789abcd[(unsigned __int16)a2 >> 12];
            BYTE6(v15) = a0123456789abcd[(a2 >> 8) & 0xF];
            HIBYTE(v15) = a0123456789abcd[(unsigned __int8)a2 >> 4];
            LOBYTE(v16) = a0123456789abcd[a2 & 0xF];
            HIBYTE(v16) = 125;
            *(__int16 *)((char *)&v14 + v6) = 30044;
            *((_BYTE *)&v15 + v6) = 123;
            *(_WORD *)(v4 + 8) = v16;
            result = v15;
            *(_QWORD *)v4 = v15;
            *(_BYTE *)(v4 + 10) = v7;
            *(_BYTE *)(v4 + 11) = 10;
            return result;
          }
          a1 = v4;
          if ( a2 >= 0x10000 )
          {
            if ( a2 >= 0x20000 )
            {
              if ( _mm_movemask_ps((__m128)_mm_cmpgt_epi32(
                                             _mm_xor_si128(
                                               _mm_add_epi32(
                                                 _mm_shuffle_epi32(_mm_cvtsi32_si128(a2), 0),
                                                 (__m128i)xmmword_440310),
                                               (__m128i)xmmword_440320),
                                             (__m128i)xmmword_440330)) == 0
                && a2 - 917760 < 0xFFF522B0
                && a2 - 196608 < 0xFFFFFA1E
                && a2 - 201552 < 0xFFFFFFFB
                && (a2 & 0x1FFFE0) != 0x2A6E0
                && a2 <= 0xE01EF )
              {
                result = a2 & 0xFE;
                if ( (a2 & 0x1FFFFE) != 0x2B81E )
                  goto LABEL_20;
              }
              goto LABEL_27;
            }
            result = sub_408030(a2, byte_442D88, 44LL, (__int64)&unk_442DE0, 0xD0uLL, asc_442EB0, 486LL);
LABEL_19:
            a1 = v4;
            if ( result )
            {
LABEL_20:
              *(_BYTE *)a1 = 0x80;
              *(_DWORD *)(a1 + 4) = a2;
              return result;
            }
LABEL_27:
            _BitScanReverse(&v8, a2 | 1);
            v9 = (v8 ^ 0x1C) >> 2;
            v10 = v9 - 2;
            BYTE2(v12) = 0;
            LOWORD(v12) = 0;
            BYTE3(v12) = a0123456789abcd[a2 >> 20];
            BYTE4(v12) = a0123456789abcd[HIWORD(a2) & 0xF];
            BYTE5(v12) = a0123456789abcd[(unsigned __int16)a2 >> 12];
            BYTE6(v12) = a0123456789abcd[(a2 >> 8) & 0xF];
            HIBYTE(v12) = a0123456789abcd[(unsigned __int8)a2 >> 4];
            LOBYTE(v13) = a0123456789abcd[a2 & 0xF];
            HIBYTE(v13) = 125;
            *(_WORD *)((char *)&v11 + v9 + 6) = 30044;
            *((_BYTE *)&v12 + v9) = 123;
            *(_WORD *)(a1 + 8) = v13;
            result = v12;
            *(_QWORD *)a1 = v12;
            *(_BYTE *)(a1 + 10) = v10;
            *(_BYTE *)(a1 + 11) = 10;
            return result;
          }
        }
        v4 = a1;
        result = sub_408030(a2, byte_443096, 40LL, (__int64)&unk_4430E6, 0x122uLL, byte_443208, 297LL);
        goto LABEL_19;
      }
      *(_WORD *)a1 = 23644;
LABEL_13:
      *(_QWORD *)(a1 + 2) = 0LL;
      *(_WORD *)(a1 + 10) = 512;
      return result;
  }
}
// 407EB0: using guessed type __int64 __fastcall sub_407EB0(_QWORD);
// 440310: using guessed type __int128 xmmword_440310;
// 440320: using guessed type __int128 xmmword_440320;
// 440330: using guessed type __int128 xmmword_440330;
// 442D88: using guessed type _BYTE byte_442D88[88];
// 443096: using guessed type _BYTE byte_443096[80];

//----- (000000000040E140) ----------------------------------------------------
char __fastcall sub_40E140(__int64 a1, __int64 a2)
{
  return sub_405B80(a2, (unsigned __int16 *)asc_446E58, 2uLL);
}

//----- (000000000040E160) ----------------------------------------------------
__int64 __fastcall sub_40E160(unsigned __int16 *a1, unsigned __int16 *a2)
{
  unsigned __int64 v3; // rdx
  __int64 result; // rax
  unsigned __int64 v5; // r8
  __m128i v6; // xmm0
  unsigned __int64 v7; // rax
  __m128i si128; // xmm2
  __m128i v9; // xmm3
  __m128i v10; // xmm1
  __m128i v11; // xmm4
  __m128i v12; // xmm5
  __m128i v13; // xmm1

  v3 = (char *)a2 - (char *)a1;
  if ( v3 >= 0x20 )
    return sub_405510(a1, v3);
  if ( a2 == a1 )
    return 0LL;
  if ( v3 < 4 )
  {
    result = 0LL;
    v5 = 0LL;
    do
LABEL_10:
      result += *((_BYTE *)a1 + v5++) >= 0xC0;
    while ( v3 != v5 );
    return result;
  }
  v5 = v3 & 0x1C;
  v6 = 0LL;
  v7 = 0LL;
  si128 = _mm_load_si128((const __m128i *)&xmmword_4403E0);
  v9 = _mm_load_si128((const __m128i *)&xmmword_4403F0);
  v10 = 0LL;
  do
  {
    v11 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(a1[v7 / 2]), si128);
    v6 = _mm_add_epi64(
           v6,
           _mm_and_si128(_mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v11, v11), 212), 212), v9));
    v12 = _mm_cmpgt_epi8(_mm_cvtsi32_si128(a1[v7 / 2 + 1]), si128);
    v10 = _mm_add_epi64(
            v10,
            _mm_and_si128(_mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v12, v12), 212), 212), v9));
    v7 += 4LL;
  }
  while ( v5 != v7 );
  v13 = _mm_add_epi64(v10, v6);
  result = _mm_add_epi64(_mm_shuffle_epi32(v13, 238), v13).m128i_u64[0];
  if ( v5 != v3 )
    goto LABEL_10;
  return result;
}
// 4403E0: using guessed type __int128 xmmword_4403E0;
// 4403F0: using guessed type __int128 xmmword_4403F0;

//----- (000000000040E240) ----------------------------------------------------
char __fastcall sub_40E240(__int64 a1, __int64 a2)
{
  unsigned __int8 *v3; // rdi
  __int64 v4; // r12
  char v5; // cl
  char v6; // al
  char v7; // cl
  __int128 v8; // xmm1
  __int128 v9; // xmm2
  char result; // al
  unsigned __int8 *v11; // rdi
  __int64 v12; // r12
  char v13; // al
  __int128 v14; // xmm1
  __int128 v15; // xmm2
  __int128 v16; // [rsp+20h] [rbp-60h] BYREF
  __int128 v17; // [rsp+30h] [rbp-50h]
  __int128 v18; // [rsp+40h] [rbp-40h]
  __int128 *v19; // [rsp+50h] [rbp-30h]
  __int64 (__fastcall **v20)(_OWORD *, const char *, __int64); // [rsp+58h] [rbp-28h]
  __int128 v21; // [rsp+60h] [rbp-20h] BYREF
  _BYTE *v22; // [rsp+70h] [rbp-10h]
  _BYTE v23[57]; // [rsp+87h] [rbp+7h] BYREF

  v3 = *(unsigned __int8 **)a1;
  v4 = *(_QWORD *)(a1 + 8);
  v5 = (*(__int64 (__fastcall **)(_QWORD, const char *, __int64))(*(_QWORD *)(a2 + 56) + 24LL))(
         *(_QWORD *)(a2 + 48),
         asc_4474F3,
         1LL);
  if ( !v4 )
    goto LABEL_11;
  v6 = 1;
  if ( v5 )
    goto LABEL_9;
  if ( (*(_BYTE *)(a2 + 36) & 4) != 0 )
  {
    v7 = (*(__int64 (__fastcall **)(_QWORD, const char *, __int64))(*(_QWORD *)(a2 + 56) + 24LL))(
           *(_QWORD *)(a2 + 48),
           "\n",
           1LL);
    v6 = 1;
    if ( !v7 )
    {
      v23[0] = 1;
      v21 = *(_OWORD *)(a2 + 48);
      v22 = v23;
      v8 = *(_OWORD *)(a2 + 16);
      v9 = *(_OWORD *)(a2 + 32);
      v16 = *(_OWORD *)a2;
      v17 = v8;
      v18 = v9;
      v19 = &v21;
      v20 = (__int64 (__fastcall **)(_OWORD *, const char *, __int64))&unk_4428A0;
      if ( !(unsigned __int8)sub_4364C0(v3, (__int64)&v16) )
      {
        v6 = v20[3](v19, asc_4428D7, 2LL);
        if ( v4 != 1 )
          goto LABEL_15;
LABEL_10:
        v5 = v6;
        goto LABEL_11;
      }
      v6 = 1;
    }
LABEL_9:
    if ( v4 != 1 )
      goto LABEL_15;
    goto LABEL_10;
  }
  v6 = sub_4364C0(v3, a2);
  if ( v4 == 1 )
    goto LABEL_10;
LABEL_15:
  v11 = v3 + 1;
  v12 = v4 - 1;
  do
  {
    v5 = 1;
    if ( (v6 & 1) == 0 )
    {
      if ( (*(_BYTE *)(a2 + 36) & 4) != 0 )
      {
        v23[0] = 1;
        v21 = *(_OWORD *)(a2 + 48);
        v22 = v23;
        v14 = *(_OWORD *)(a2 + 16);
        v15 = *(_OWORD *)(a2 + 32);
        v16 = *(_OWORD *)a2;
        v17 = v14;
        v18 = v15;
        v19 = &v21;
        v20 = (__int64 (__fastcall **)(_OWORD *, const char *, __int64))&unk_4428A0;
        if ( (unsigned __int8)sub_4364C0(v11, (__int64)&v16) )
          v5 = 1;
        else
          v5 = v20[3](v19, asc_4428D7, 2LL);
      }
      else
      {
        v13 = (*(__int64 (__fastcall **)(_QWORD, const char *, __int64))(*(_QWORD *)(a2 + 56) + 24LL))(
                *(_QWORD *)(a2 + 48),
                asc_4474F1,
                2LL);
        v5 = 1;
        if ( !v13 )
          v5 = sub_4364C0(v11, a2);
      }
    }
    ++v11;
    v6 = v5;
    --v12;
  }
  while ( v12 );
LABEL_11:
  result = 1;
  if ( !v5 )
    return (*(__int64 (__fastcall **)(_QWORD, const char *, __int64))(*(_QWORD *)(a2 + 56) + 24LL))(
             *(_QWORD *)(a2 + 48),
             asc_4474F4,
             1LL);
  return result;
}
// 4474F3: using guessed type char asc_4474F3;
// 4474F4: using guessed type char asc_4474F4;
// 44952F: using guessed type char asc_44952F;

//----- (000000000040E460) ----------------------------------------------------
__int64 __fastcall sub_40E460(__int64 a1, __int64 a2)
{
  return sub_4072E0(*(_BYTE **)a1, *(_QWORD *)(a1 + 8), *(_QWORD *)(a2 + 48), *(_QWORD *)(a2 + 56));
}

//----- (000000000040E480) ----------------------------------------------------
void __fastcall sub_40E480(_QWORD *a1, __int64 a2)
{
  unsigned __int64 v2; // r8
  unsigned __int64 v3; // rax
  __int64 v4; // rsi
  unsigned __int64 v5; // r11
  unsigned __int64 v6; // r9
  unsigned __int64 v7; // r10
  unsigned __int64 v8; // rcx
  __int64 v9; // r14
  __int64 v10; // rdi
  unsigned __int64 v11; // r13
  __int64 v12; // r10
  unsigned __int64 v13; // r15
  char v14; // r10
  _BYTE *v15; // rax
  unsigned __int64 v16; // r9
  unsigned __int64 v17; // r9
  unsigned __int64 v18; // r9
  unsigned __int64 v19; // rdi
  unsigned __int64 v20; // r10
  unsigned __int64 v21; // rdi
  unsigned __int64 v22; // r9
  unsigned __int64 v23; // r10
  unsigned __int64 v24; // r9
  unsigned int v25; // r9d
  int v26; // r11d
  int v27; // edi
  int v28; // esi
  __int64 v29; // rax
  unsigned __int64 v30; // r9
  unsigned __int64 v31; // [rsp+30h] [rbp-30h]
  unsigned __int64 v32; // [rsp+40h] [rbp-20h]
  unsigned __int64 v33; // [rsp+48h] [rbp-18h]
  _QWORD *v34; // [rsp+50h] [rbp-10h]
  __int64 v35; // [rsp+58h] [rbp-8h]
  unsigned __int64 v36; // [rsp+60h] [rbp+0h]

  if ( (*(_BYTE *)a2 & 1) == 0 )
  {
    if ( *(_BYTE *)(a2 + 26) )
      goto LABEL_6;
    v14 = *(_BYTE *)(a2 + 24);
    *(_BYTE *)(a2 + 24) = v14 ^ 1;
    v2 = *(_QWORD *)(a2 + 8);
    v15 = *(_BYTE **)(a2 + 72);
    v16 = *(_QWORD *)(a2 + 80);
    if ( v2 )
    {
      if ( v2 >= v16 )
      {
        if ( v2 != v16 )
LABEL_10:
          sub_4079A0(v15, v16, v2, v16, (__int64)&off_448238);
      }
      else if ( (char)v15[v2] <= -65 )
      {
        goto LABEL_10;
      }
    }
    if ( v2 == v16 )
    {
      if ( !v14 )
      {
        *(_BYTE *)(a2 + 26) = 1;
        *a1 = 2LL;
        return;
      }
      goto LABEL_56;
    }
    v25 = (unsigned __int8)v15[v2];
    if ( (v25 & 0x80u) != 0 )
    {
      v26 = v25 & 0x1F;
      v27 = v15[v2 + 1] & 0x3F;
      if ( (unsigned __int8)v25 <= 0xDFu )
      {
        v25 = v27 | (v26 << 6);
        if ( v14 )
          goto LABEL_56;
      }
      else
      {
        v28 = (v27 << 6) | v15[v2 + 2] & 0x3F;
        if ( (unsigned __int8)v25 < 0xF0u )
        {
          v25 = (v26 << 12) | v28;
          if ( v14 )
            goto LABEL_56;
        }
        else
        {
          v25 = ((v25 & 7) << 18) | (v28 << 6) | v15[v2 + 3] & 0x3F;
          if ( v14 )
            goto LABEL_56;
        }
      }
    }
    else if ( v14 )
    {
LABEL_56:
      a1[1] = v2;
      a1[2] = v2;
      *a1 = 0LL;
      return;
    }
    v29 = 1LL;
    if ( v25 >= 0x80 )
    {
      v29 = 2LL;
      if ( v25 >= 0x800 )
        v29 = 4LL - (v25 < 0x10000);
    }
    v3 = v2 + v29;
    *(_QWORD *)(a2 + 8) = v3;
    goto LABEL_68;
  }
  v2 = *(_QWORD *)(a2 + 40);
  v3 = *(_QWORD *)(a2 + 80);
  if ( v2 == v3 )
  {
LABEL_6:
    *a1 = 2LL;
    return;
  }
  v34 = a1;
  v4 = *(_QWORD *)(a2 + 72);
  v5 = *(_QWORD *)(a2 + 96);
  v6 = v2 + v5 - 1;
  v7 = *(_QWORD *)(a2 + 80);
  if ( v6 < v3 )
  {
    v8 = *(_QWORD *)(a2 + 56);
    v9 = *(_QWORD *)(a2 + 88);
    v31 = v5 - 1;
    v10 = *(_QWORD *)(a2 + 32);
    v11 = *(_QWORD *)(a2 + 8);
    v12 = *(_QWORD *)(a2 + 24);
    v33 = v5 - v12;
    v32 = v2 + v12;
    v36 = v2 + v5;
    v13 = v8;
    v7 = *(_QWORD *)(a2 + 40);
    v35 = v10;
    while ( v2 == v7 )
    {
      if ( _bittest64(&v10, *(unsigned __int8 *)(v4 + v6)) )
      {
        v18 = v13;
        if ( v11 > v13 )
          v18 = v11;
        if ( v8 == -1LL )
          v18 = v11;
        v19 = v18;
        while ( v19 < v5 )
        {
          v20 = v19;
          if ( v2 + v19 >= v3 )
          {
            v30 = v2 + v18;
            if ( v3 > v30 )
              v30 = v3;
            sub_4050B0(v30, v3, &off_4479B8);
          }
          ++v19;
          if ( *(_BYTE *)(v9 + v20) != *(_BYTE *)(v4 + v2 + v20) )
          {
            v7 = v2 - v11 + 1 + v20;
            *(_QWORD *)(a2 + 40) = v7;
            if ( v8 != -1LL )
            {
              v17 = 0LL;
              v10 = v35;
              goto LABEL_12;
            }
            v10 = v35;
            goto LABEL_13;
          }
        }
        v21 = v13;
        if ( v8 == -1LL )
          v21 = 0LL;
        v22 = v11;
        do
        {
          if ( v21 >= v22 )
          {
            *(_QWORD *)(a2 + 40) = v36;
            if ( v8 != -1LL )
              *(_QWORD *)(a2 + 56) = 0LL;
            *v34 = 0LL;
            v34[1] = v2;
            v34[2] = v36;
            return;
          }
          if ( --v22 >= v5 )
            sub_4050B0(v22, v5, &off_447988);
          v23 = v22 + v2;
          if ( v22 + v2 >= v3 )
            sub_4050B0(v23, v3, &off_4479A0);
        }
        while ( *(_BYTE *)(v9 + v22) == *(_BYTE *)(v4 + v23) );
        v7 = v32;
        *(_QWORD *)(a2 + 40) = v32;
        v17 = v33;
        v10 = v35;
        if ( v8 != -1LL )
          goto LABEL_12;
      }
      else
      {
        v7 = v2 + v5;
        *(_QWORD *)(a2 + 40) = v36;
        if ( v8 != -1LL )
        {
          v17 = 0LL;
          v7 = v2 + v5;
LABEL_12:
          *(_QWORD *)(a2 + 56) = v17;
          v13 = v17;
        }
      }
LABEL_13:
      v6 = v7 + v31;
      if ( v7 + v31 >= v3 )
      {
        v7 = v3;
        goto LABEL_38;
      }
    }
  }
  if ( !v7 )
  {
    v3 = 0LL;
    a1 = v34;
    *(_QWORD *)(a2 + 40) = 0LL;
    goto LABEL_68;
  }
LABEL_38:
  v24 = v7;
  a1 = v34;
  while ( v24 >= v3 )
  {
    if ( v24 == v3 )
      goto LABEL_44;
LABEL_40:
    if ( !++v24 )
    {
      v3 = 0LL;
      *(_QWORD *)(a2 + 40) = v7;
      goto LABEL_68;
    }
  }
  if ( *(char *)(v4 + v24) < -64 )
    goto LABEL_40;
  v3 = v24;
LABEL_44:
  if ( v3 > v7 )
    v7 = v3;
  *(_QWORD *)(a2 + 40) = v7;
LABEL_68:
  a1[1] = v2;
  a1[2] = v3;
  *a1 = 1LL;
}
// 4050B0: using guessed type void __fastcall __noreturn sub_4050B0(_QWORD, _QWORD, _QWORD);
// 447988: using guessed type char *off_447988;
// 4479A0: using guessed type char *off_4479A0;
// 4479B8: using guessed type char *off_4479B8;
// 448238: using guessed type char *off_448238;

//----- (000000000040E880) ----------------------------------------------------
char __fastcall sub_40E880(__int64 a1)
{
  __int64 v2; // rcx
  unsigned __int64 v3; // r8
  unsigned __int64 v4; // rax
  unsigned __int64 v5; // r9
  __int64 v6; // rax
  __int64 v7; // rcx
  char result; // al
  __int64 v9; // r14
  char v10; // di
  __int64 v11; // r15
  __int64 v12; // rcx
  __int64 v13; // rcx
  unsigned __int64 v14; // rax
  char v15; // dl
  unsigned __int8 v16; // r11
  unsigned __int8 v17; // dl
  __int64 v18; // rax
  unsigned __int64 v19; // kr00_8
  bool v20; // cf
  __int64 v21; // rcx
  __int64 v22; // rcx

  v2 = *(_QWORD *)a1;
  if ( !v2 )
  {
    v13 = *(_QWORD *)(a1 + 32);
    if ( v13 )
      return sub_405B80(v13, (unsigned __int16 *)asc_4474E9, 1uLL);
    return 0;
  }
  v3 = *(_QWORD *)(a1 + 8);
  v4 = *(_QWORD *)(a1 + 16);
  if ( v4 < v3 && *(_BYTE *)(v2 + v4) == 71 )
  {
    v5 = v4 + 1;
    *(_QWORD *)(a1 + 16) = v4 + 1;
    if ( v4 + 1 >= v3 || *(_BYTE *)(v2 + v5) != 95 )
    {
      v14 = 0LL;
      while ( 1 )
      {
        if ( v5 >= v3 )
          goto LABEL_31;
        v15 = *(_BYTE *)(v2 + v5);
        if ( v15 == 95 )
          break;
        v16 = v15 - 48;
        if ( (unsigned __int8)(v15 - 48) >= 0xAu )
        {
          if ( (unsigned __int8)(v15 - 97) >= 0x1Au )
          {
            if ( (unsigned __int8)(v15 - 65) >= 0x1Au )
              goto LABEL_31;
            v17 = v15 - 29;
          }
          else
          {
            v17 = v15 - 87;
          }
          v16 = v17;
        }
        *(_QWORD *)(a1 + 16) = ++v5;
        v19 = v14;
        v18 = 62 * v14;
        if ( is_mul_ok(0x3EuLL, v19) )
        {
          v20 = __CFADD__(v16, v18);
          v14 = v16 + v18;
          if ( !v20 )
            continue;
        }
        goto LABEL_31;
      }
      *(_QWORD *)(a1 + 16) = v5 + 1;
      if ( v14 > 0xFFFFFFFFFFFFFFFDuLL )
      {
LABEL_31:
        v21 = *(_QWORD *)(a1 + 32);
        if ( !v21 || (v10 = 1, !sub_405B80(v21, (unsigned __int16 *)aInvalidSyntax, 0x10uLL)) )
        {
          *(_QWORD *)a1 = 0LL;
          *(_BYTE *)(a1 + 8) = 0;
          return 0;
        }
        return v10;
      }
      v6 = v14 + 2;
      v7 = *(_QWORD *)(a1 + 32);
      if ( v7 )
        goto LABEL_9;
      return sub_40F580((_QWORD *)a1);
    }
    *(_QWORD *)(a1 + 16) = v4 + 2;
    v6 = 1LL;
    v7 = *(_QWORD *)(a1 + 32);
    if ( !v7 )
      return sub_40F580((_QWORD *)a1);
  }
  else
  {
    v6 = 0LL;
    v7 = *(_QWORD *)(a1 + 32);
    if ( !v7 )
      return sub_40F580((_QWORD *)a1);
  }
LABEL_9:
  v9 = v6;
  if ( v6 )
  {
    v10 = 1;
    if ( sub_405B80(v7, (unsigned __int16 *)aFor, 4uLL) )
      return v10;
    ++*(_DWORD *)(a1 + 40);
    if ( sub_40C980(a1, 1uLL) )
      return v10;
    v11 = v9;
    while ( --v11 )
    {
      v12 = *(_QWORD *)(a1 + 32);
      if ( !v12 || !sub_405B80(v12, (unsigned __int16 *)asc_4474F1, 2uLL) )
      {
        ++*(_DWORD *)(a1 + 40);
        if ( !sub_40C980(a1, 1uLL) )
          continue;
      }
      return v10;
    }
    v22 = *(_QWORD *)(a1 + 32);
    if ( v22 )
    {
      if ( sub_405B80(v22, (unsigned __int16 *)asc_4474EF, 2uLL) )
        return v10;
    }
  }
  result = sub_40F580((_QWORD *)a1);
  *(_DWORD *)(a1 + 40) -= v9;
  return result;
}
// 4474E9: using guessed type char asc_4474E9;

//----- (000000000040EAD0) ----------------------------------------------------
char __fastcall sub_40EAD0(__int64 *a1)
{
  __int64 v1; // r9
  unsigned __int64 v2; // r10
  unsigned __int64 v3; // r8
  unsigned __int64 v4; // rax
  unsigned __int64 v5; // rax
  unsigned __int64 v6; // r11
  char v7; // dl
  unsigned __int8 v8; // di
  unsigned __int8 v9; // dl
  __int64 v10; // rax
  unsigned __int64 v11; // kr00_8
  bool v12; // cf
  __int64 v13; // rcx
  char result; // al
  unsigned int v15; // edx
  unsigned __int8 v16; // si
  _OWORD *v17; // rsi
  __int64 v18; // rax
  char *v19; // rdx
  __int64 *v20; // rdi
  char v21; // al
  char v22; // dl
  __int128 v23; // [rsp+20h] [rbp-20h]
  __int128 v24; // [rsp+30h] [rbp-10h]

  v1 = *a1;
  if ( !*a1 )
  {
    v13 = a1[4];
    if ( v13 )
      return sub_405B80(v13, (unsigned __int16 *)asc_4474E9, 1uLL);
    return 0;
  }
  v2 = a1[1];
  v3 = a1[2];
  if ( v3 < v2 && *(_BYTE *)(v1 + v3) == 95 )
  {
    a1[2] = v3 + 1;
    v4 = 0LL;
    if ( v3 != 1 )
    {
LABEL_22:
      v15 = *((_DWORD *)a1 + 6) + 1;
      v16 = 1;
      if ( v15 <= 0x1F4 )
      {
        if ( a1[4] )
        {
          v24 = *((_OWORD *)a1 + 1);
          v23 = *(_OWORD *)a1;
          a1[2] = v4;
          *((_DWORD *)a1 + 6) = v15;
          v17 = a1;
          result = sub_40BC10(a1);
          *v17 = v23;
          v17[1] = v24;
          return result;
        }
        return 0;
      }
LABEL_28:
      v18 = a1[4];
      if ( !v18 )
        goto LABEL_32;
      goto LABEL_29;
    }
  }
  else
  {
    v5 = 0LL;
    v6 = a1[2];
    while ( v6 < v2 )
    {
      v7 = *(_BYTE *)(v1 + v6);
      if ( v7 == 95 )
      {
        a1[2] = v6 + 1;
        if ( v5 == -1LL )
          break;
        v4 = v5 + 1;
        if ( v4 >= v3 - 1 )
          break;
        goto LABEL_22;
      }
      v8 = v7 - 48;
      if ( (unsigned __int8)(v7 - 48) >= 0xAu )
      {
        if ( (unsigned __int8)(v7 - 97) >= 0x1Au )
        {
          if ( (unsigned __int8)(v7 - 65) >= 0x1Au )
          {
            v16 = 0;
            goto LABEL_28;
          }
          v9 = v7 - 29;
        }
        else
        {
          v9 = v7 - 87;
        }
        v8 = v9;
      }
      a1[2] = ++v6;
      v11 = v5;
      v10 = 62 * v5;
      if ( is_mul_ok(0x3EuLL, v11) )
      {
        v12 = __CFADD__(v8, v10);
        v5 = v8 + v10;
        if ( !v12 )
          continue;
      }
      break;
    }
  }
  v16 = 0;
  v18 = a1[4];
  if ( !v18 )
  {
LABEL_32:
    *a1 = 0LL;
    *((_BYTE *)a1 + 8) = v16;
    return 0;
  }
LABEL_29:
  v19 = aInvalidSyntax;
  if ( v16 )
    v19 = aRecursionLimit;
  v20 = a1;
  v21 = sub_405B80(v18, (unsigned __int16 *)v19, 9LL * v16 + 16);
  a1 = v20;
  v22 = v21;
  result = 1;
  if ( !v22 )
    goto LABEL_32;
  return result;
}
// 40BC10: using guessed type __int64 __fastcall sub_40BC10(_QWORD);
// 4474E9: using guessed type char asc_4474E9;

//----- (000000000040EC80) ----------------------------------------------------
char __fastcall sub_40EC80(__int64 a1, __int64 *a2)
{
  __int64 v3; // r10
  unsigned __int64 v4; // r11
  unsigned __int64 v5; // r9
  unsigned __int64 v6; // rax
  char v7; // dl
  unsigned __int8 v8; // di
  unsigned __int8 v9; // dl
  __int64 v10; // rax
  unsigned __int64 v11; // kr00_8
  bool v12; // cf
  char result; // al

  v3 = *a2;
  v4 = a2[1];
  v5 = a2[2];
  if ( v5 < v4 && *(_BYTE *)(v3 + v5) == 95 )
  {
    a2[2] = v5 + 1;
    *(_QWORD *)(a1 + 8) = 0LL;
  }
  else
  {
    v6 = 0LL;
    while ( 1 )
    {
      if ( v5 >= v4 )
        goto LABEL_15;
      v7 = *(_BYTE *)(v3 + v5);
      if ( v7 == 95 )
        break;
      v8 = v7 - 48;
      if ( (unsigned __int8)(v7 - 48) >= 0xAu )
      {
        if ( (unsigned __int8)(v7 - 97) >= 0x1Au )
        {
          if ( (unsigned __int8)(v7 - 65) >= 0x1Au )
            goto LABEL_15;
          v9 = v7 - 29;
        }
        else
        {
          v9 = v7 - 87;
        }
        v8 = v9;
      }
      a2[2] = ++v5;
      v11 = v6;
      v10 = 62 * v6;
      if ( is_mul_ok(0x3EuLL, v11) )
      {
        v12 = __CFADD__(v8, v10);
        v6 = v8 + v10;
        if ( !v12 )
          continue;
      }
      goto LABEL_15;
    }
    a2[2] = v5 + 1;
    if ( v6 == -1LL )
    {
LABEL_15:
      *(_BYTE *)(a1 + 1) = 0;
      result = 1;
      goto LABEL_19;
    }
    *(_QWORD *)(a1 + 8) = v6 + 1;
  }
  result = 0;
LABEL_19:
  *(_BYTE *)a1 = result;
  return result;
}

//----- (000000000040ED40) ----------------------------------------------------
__int64 __fastcall sub_40ED40(__int64 *a1)
{
  __int64 v1; // rax
  __int64 v3; // rdi
  __int64 i; // rsi
  unsigned __int64 v5; // rcx
  __int64 v6; // rcx

  v1 = *a1;
  if ( !*a1 )
    return 0LL;
  v3 = 0LL;
  for ( i = 0LL; ; ++i )
  {
    v5 = a1[2];
    if ( v5 < a1[1] && *(_BYTE *)(v1 + v5) == 69 )
      break;
    if ( i )
    {
      v6 = a1[4];
      if ( v6 )
      {
        if ( sub_405B80(v6, (unsigned __int16 *)asc_4474F1, 2uLL) )
          return 1LL;
      }
    }
    if ( (unsigned __int8)sub_40BC10(a1) )
      return 1LL;
    v1 = *a1;
    if ( !*a1 )
      return v3;
  }
  a1[2] = v5 + 1;
  return 0LL;
}
// 40BC10: using guessed type __int64 __fastcall sub_40BC10(_QWORD);

//----- (000000000040EDE0) ----------------------------------------------------
char __fastcall sub_40EDE0(__int64 a1)
{
  __int64 v2; // r8
  unsigned __int64 v3; // rcx
  unsigned __int64 v4; // rax
  unsigned __int64 v5; // r9
  __int64 v6; // rdi
  __int64 v7; // rcx
  __int64 v8; // rbx
  unsigned __int64 v9; // rax
  bool v10; // cf
  __int64 v11; // rcx
  char v12; // bl
  __int64 v13; // r15
  __int64 v14; // rcx
  __int64 v15; // rcx
  unsigned __int64 v17; // rdi
  char v18; // al
  unsigned __int8 v19; // r11
  unsigned __int8 v20; // al
  __int64 v21; // rax
  __int64 v22; // rcx
  __int64 v23; // rcx
  __int64 v24; // rax
  __int64 v25; // r14
  unsigned __int64 v26; // rcx
  __int64 v27; // rcx

  v2 = *(_QWORD *)a1;
  if ( *(_QWORD *)a1 )
  {
    v3 = *(_QWORD *)(a1 + 8);
    v4 = *(_QWORD *)(a1 + 16);
    if ( v4 < v3 && *(_BYTE *)(v2 + v4) == 71 )
    {
      v5 = v4 + 1;
      *(_QWORD *)(a1 + 16) = v4 + 1;
      if ( v4 + 1 >= v3 || *(_BYTE *)(v2 + v5) != 95 )
      {
        v17 = 0LL;
        while ( 1 )
        {
          if ( v5 >= v3 )
            goto LABEL_40;
          v18 = *(_BYTE *)(v2 + v5);
          if ( v18 == 95 )
            break;
          v19 = v18 - 48;
          if ( (unsigned __int8)(v18 - 48) >= 0xAu )
          {
            if ( (unsigned __int8)(v18 - 97) >= 0x1Au )
            {
              if ( (unsigned __int8)(v18 - 65) >= 0x1Au )
                goto LABEL_40;
              v20 = v18 - 29;
            }
            else
            {
              v20 = v18 - 87;
            }
            v19 = v20;
          }
          *(_QWORD *)(a1 + 16) = ++v5;
          v21 = 62 * v17;
          if ( is_mul_ok(0x3EuLL, v17) )
          {
            v17 = v19 + v21;
            if ( !__CFADD__(v19, v21) )
              continue;
          }
          goto LABEL_40;
        }
        *(_QWORD *)(a1 + 16) = v5 + 1;
        if ( v17 > 0xFFFFFFFFFFFFFFFDuLL )
        {
LABEL_40:
          v22 = *(_QWORD *)(a1 + 32);
          if ( !v22 || (v12 = 1, !sub_405B80(v22, (unsigned __int16 *)aInvalidSyntax, 0x10uLL)) )
          {
            *(_QWORD *)a1 = 0LL;
            *(_BYTE *)(a1 + 8) = 0;
            return 0;
          }
          return v12;
        }
        v6 = v17 + 2;
        v7 = *(_QWORD *)(a1 + 32);
        if ( v7 )
          goto LABEL_17;
        goto LABEL_7;
      }
      *(_QWORD *)(a1 + 16) = v4 + 2;
      v6 = 1LL;
      v7 = *(_QWORD *)(a1 + 32);
      if ( !v7 )
      {
LABEL_7:
        v8 = 0LL;
        while ( 1 )
        {
          v9 = *(_QWORD *)(a1 + 16);
          if ( v9 < *(_QWORD *)(a1 + 8) && *(_BYTE *)(v2 + v9) == 69 )
            break;
          v10 = v8-- == 0;
          if ( !v10 )
          {
            v11 = *(_QWORD *)(a1 + 32);
            if ( v11 )
            {
              if ( sub_405B80(v11, (unsigned __int16 *)asc_447519, 3uLL) )
                return 1;
            }
          }
          if ( sub_40F100((__int64 *)a1) )
            return 1;
          v2 = *(_QWORD *)a1;
          if ( !*(_QWORD *)a1 )
            return 0;
        }
        *(_QWORD *)(a1 + 16) = v9 + 1;
        return 0;
      }
    }
    else
    {
      v6 = 0LL;
      v7 = *(_QWORD *)(a1 + 32);
      if ( !v7 )
        goto LABEL_7;
    }
LABEL_17:
    if ( !v6 )
      goto LABEL_50;
    v12 = 1;
    if ( !sub_405B80(v7, (unsigned __int16 *)aFor, 4uLL) )
    {
      ++*(_DWORD *)(a1 + 40);
      if ( !sub_40C980(a1, 1uLL) )
      {
        v13 = v6;
        while ( --v13 )
        {
          v14 = *(_QWORD *)(a1 + 32);
          if ( !v14 || !sub_405B80(v14, (unsigned __int16 *)asc_4474F1, 2uLL) )
          {
            ++*(_DWORD *)(a1 + 40);
            if ( !sub_40C980(a1, 1uLL) )
              continue;
          }
          return v12;
        }
        v23 = *(_QWORD *)(a1 + 32);
        if ( !v23 || !sub_405B80(v23, (unsigned __int16 *)asc_4474EF, 2uLL) )
        {
LABEL_50:
          v24 = *(_QWORD *)a1;
          if ( *(_QWORD *)a1 )
          {
            v25 = 0LL;
            while ( 1 )
            {
              v26 = *(_QWORD *)(a1 + 16);
              if ( v26 < *(_QWORD *)(a1 + 8) && *(_BYTE *)(v24 + v26) == 69 )
                break;
              v10 = v25-- == 0;
              if ( !v10 && (v27 = *(_QWORD *)(a1 + 32)) != 0 && sub_405B80(v27, (unsigned __int16 *)asc_447519, 3uLL)
                || sub_40F100((__int64 *)a1) )
              {
                v12 = 1;
                goto LABEL_63;
              }
              v24 = *(_QWORD *)a1;
              if ( !*(_QWORD *)a1 )
                goto LABEL_62;
            }
            *(_QWORD *)(a1 + 16) = v26 + 1;
          }
LABEL_62:
          v12 = 0;
LABEL_63:
          *(_DWORD *)(a1 + 40) -= v6;
        }
      }
    }
    return v12;
  }
  v15 = *(_QWORD *)(a1 + 32);
  if ( v15 )
    return sub_405B80(v15, (unsigned __int16 *)asc_4474E9, 1uLL);
  return 0;
}
// 4474E9: using guessed type char asc_4474E9;

//----- (000000000040F100) ----------------------------------------------------
char __fastcall sub_40F100(__int64 *a1)
{
  char v2; // al
  char v3; // si
  char v4; // bl
  unsigned __int64 v5; // rax
  __int64 v6; // rcx
  _QWORD *v7; // rdx
  __int64 v8; // rcx
  __int64 v9; // rcx
  __int64 v11; // rcx
  char v12; // bl
  __int64 v13; // rcx
  char *v14; // rdx
  unsigned __int64 v15; // r8
  _OWORD v16[2]; // [rsp+20h] [rbp-40h] BYREF
  _OWORD v17[5]; // [rsp+48h] [rbp-18h] BYREF

  v2 = sub_40F320(a1);
  v3 = 1;
  if ( v2 == 2 )
    return v3;
  v4 = v2;
  while ( *a1 )
  {
    v5 = a1[2];
    if ( v5 >= a1[1] || *(_BYTE *)(*a1 + v5) != 112 )
      break;
    a1[2] = v5 + 1;
    v6 = a1[4];
    if ( (v4 & 1) != 0 )
    {
      if ( v6 && sub_405B80(v6, (unsigned __int16 *)asc_4474F1, 2uLL) )
        return v3;
LABEL_13:
      if ( !*a1 )
        goto LABEL_21;
      goto LABEL_14;
    }
    if ( v6 )
    {
      v4 = 1;
      if ( sub_405B80(v6, (unsigned __int16 *)"<&@", 1uLL) )
        return 1;
      goto LABEL_13;
    }
    v4 = 1;
    if ( !*a1 )
    {
LABEL_21:
      v9 = a1[4];
      if ( v9 )
        return sub_405B80(v9, (unsigned __int16 *)asc_4474E9, 1uLL);
      return 0;
    }
LABEL_14:
    sub_40B330((__int64 *)v17, a1);
    if ( !*(_QWORD *)&v17[0] )
    {
      v12 = BYTE8(v17[0]);
      v13 = a1[4];
      if ( BYTE8(v17[0]) )
      {
        if ( v13 )
        {
          v14 = aRecursionLimit;
          v15 = 25LL;
LABEL_32:
          v3 = 1;
          if ( sub_405B80(v13, (unsigned __int16 *)v14, v15) )
            return v3;
        }
      }
      else if ( v13 )
      {
        v14 = aInvalidSyntax;
        v15 = 16LL;
        goto LABEL_32;
      }
      *a1 = 0LL;
      *((_BYTE *)a1 + 8) = v12;
      return 0;
    }
    v16[1] = v17[1];
    v16[0] = v17[0];
    v7 = (_QWORD *)a1[4];
    if ( v7 )
    {
      if ( (unsigned __int8)sub_40B550((unsigned __int8 **)v16, v7) )
        return v3;
      v8 = a1[4];
      if ( v8 )
      {
        if ( sub_405B80(v8, (unsigned __int16 *)asc_447551, 3uLL) )
          return v3;
      }
    }
    if ( (unsigned __int8)sub_40BC10(a1) )
      return v3;
  }
  if ( (v4 & 1) == 0 )
    return 0;
  v11 = a1[4];
  if ( !v11 || !sub_405B80(v11, (unsigned __int16 *)"><&@", 1uLL) )
    return 0;
  return v3;
}
// 40BC10: using guessed type __int64 __fastcall sub_40BC10(_QWORD);
// 4474E9: using guessed type char asc_4474E9;

//----- (000000000040F320) ----------------------------------------------------
__int64 __fastcall sub_40F320(__int64 *a1)
{
  unsigned int v1; // esi
  __int64 v2; // r9
  unsigned __int64 v3; // r10
  unsigned __int64 v4; // r8
  int v5; // eax
  __int64 *v6; // rbx
  unsigned __int64 v7; // r11
  unsigned __int64 v8; // rax
  __int64 result; // rax
  __int64 *v10; // rdx
  __int64 v11; // rcx
  char v12; // al
  __int64 v13; // rax
  __int64 v14; // r14
  unsigned __int64 v15; // rcx
  bool v16; // cf
  __int64 v17; // rcx
  char v18; // al
  unsigned __int64 v19; // rax
  char v20; // dl
  unsigned __int8 v21; // di
  unsigned __int8 v22; // dl
  __int64 v23; // rax
  unsigned __int64 v24; // kr00_8
  unsigned int v25; // edx
  __int64 *v26; // rsi
  __int64 v27; // rax
  char *v28; // rdx
  char v29; // al
  __int128 v30; // [rsp+20h] [rbp-20h]
  __int128 v31; // [rsp+30h] [rbp-10h]

  v2 = *a1;
  if ( !*a1 )
    goto LABEL_9;
  v3 = a1[1];
  v4 = a1[2];
  if ( v4 >= v3 )
    goto LABEL_9;
  v5 = *(unsigned __int8 *)(v2 + v4);
  v6 = a1;
  if ( v5 == 73 )
  {
    a1[2] = v4 + 1;
    if ( !(unsigned __int8)sub_40A960(a1, 0LL) )
    {
      v10 = v6;
      v11 = v6[4];
      if ( !v11 || (v12 = sub_405B80(v11, (unsigned __int16 *)"<&@", 1uLL), v10 = v6, !v12) )
      {
        v13 = *v10;
        LOBYTE(v1) = 1;
        if ( *v10 )
        {
          v14 = 0LL;
          while ( 1 )
          {
            v15 = v10[2];
            if ( v15 < v10[1] && *(_BYTE *)(v13 + v15) == 69 )
              break;
            v16 = v14-- == 0;
            if ( !v16 )
            {
              v17 = v10[4];
              if ( v17 )
              {
                v18 = sub_405B80(v17, (unsigned __int16 *)asc_4474F1, 2uLL);
                v10 = v6;
                if ( v18 )
                  goto LABEL_46;
              }
            }
            if ( sub_40C1E0(v10) )
              goto LABEL_46;
            v10 = v6;
            v13 = *v6;
            if ( !*v6 )
              return v1;
          }
          v10[2] = v15 + 1;
        }
        return v1;
      }
    }
    goto LABEL_46;
  }
  if ( v5 != 66 )
  {
LABEL_9:
    v1 = sub_40A960(a1, 0LL);
    LOBYTE(v1) = 2 * v1;
    return v1;
  }
  v7 = v4 + 1;
  a1[2] = v4 + 1;
  if ( v4 + 1 >= v3 || *(_BYTE *)(v2 + v7) != 95 )
  {
    v19 = 0LL;
    v1 = 62;
    while ( v7 < v3 )
    {
      v20 = *(_BYTE *)(v2 + v7);
      if ( v20 == 95 )
      {
        a1[2] = v7 + 1;
        if ( v19 == -1LL )
          goto LABEL_41;
        v8 = v19 + 1;
        if ( v8 >= v4 )
          goto LABEL_41;
        goto LABEL_38;
      }
      v21 = v20 - 48;
      if ( (unsigned __int8)(v20 - 48) >= 0xAu )
      {
        if ( (unsigned __int8)(v20 - 97) >= 0x1Au )
        {
          if ( (unsigned __int8)(v20 - 65) >= 0x1Au )
            goto LABEL_41;
          v22 = v20 - 29;
        }
        else
        {
          v22 = v20 - 87;
        }
        v21 = v22;
      }
      a1[2] = ++v7;
      v24 = v19;
      v23 = 62 * v19;
      if ( is_mul_ok(0x3EuLL, v24) )
      {
        v16 = __CFADD__(v21, v23);
        v19 = v21 + v23;
        if ( !v16 )
          continue;
      }
      goto LABEL_41;
    }
    goto LABEL_41;
  }
  a1[2] = v4 + 2;
  v8 = 0LL;
  if ( !v4 )
  {
LABEL_41:
    v1 = 0;
LABEL_42:
    v27 = a1[4];
    if ( v27 )
    {
      v28 = aInvalidSyntax;
      if ( (_BYTE)v1 )
        v28 = aRecursionLimit;
      v29 = sub_405B80(v27, (unsigned __int16 *)v28, 9LL * (unsigned __int8)v1 + 16);
      a1 = v6;
      if ( v29 )
      {
LABEL_46:
        LOBYTE(v1) = 2;
        return v1;
      }
    }
    *a1 = 0LL;
    *((_BYTE *)a1 + 8) = v1;
    return 0;
  }
LABEL_38:
  v25 = *((_DWORD *)a1 + 6) + 1;
  LOBYTE(v1) = 1;
  if ( v25 > 0x1F4 )
    goto LABEL_42;
  if ( !a1[4] )
    return 0;
  v31 = *((_OWORD *)a1 + 1);
  v30 = *(_OWORD *)a1;
  a1[2] = v8;
  *((_DWORD *)a1 + 6) = v25;
  v26 = a1;
  result = sub_40F320();
  *(_OWORD *)v26 = v30;
  *((_OWORD *)v26 + 1) = v31;
  return result;
}
// 40F396: variable 'v1' is possibly undefined
// 40A960: using guessed type __int64 __fastcall sub_40A960(_QWORD, _QWORD);

//----- (000000000040F580) ----------------------------------------------------
char __fastcall sub_40F580(_QWORD *a1)
{
  __int64 v1; // r14
  __int64 v3; // rcx
  unsigned __int64 v4; // rdx
  unsigned __int64 v5; // rax
  char v6; // di
  char *v7; // rbx
  __int64 v8; // rcx
  char v9; // cl
  char result; // al
  __int64 v11; // rdi
  char v12; // cl
  unsigned __int64 v13; // r8
  unsigned __int16 *v14; // rbx
  __int64 v15; // r12
  __int64 v16; // rcx
  char v17; // cl
  __int64 v18; // rax
  __int64 v19; // rbx
  unsigned __int64 v20; // rcx
  __int64 v22; // rcx
  __int64 v23; // rcx
  char v24; // cl
  unsigned __int64 v25; // rcx
  __int64 v26; // rcx
  char v27; // cl
  char v28; // bl
  __int64 v29; // rcx
  char *v30; // rdx
  unsigned __int64 v31; // r8
  __int64 v32; // rcx
  char v33; // cl
  __int64 v34; // r13
  __int64 v35; // r15
  unsigned __int64 v36; // rbx
  unsigned __int16 *v37; // r15
  char v38; // cl
  __int64 v39[3]; // [rsp+20h] [rbp-60h] BYREF
  __int128 v40; // [rsp+38h] [rbp-48h]
  __int128 v41; // [rsp+48h] [rbp-38h] BYREF
  __int128 v42; // [rsp+58h] [rbp-28h]
  __int128 v43; // [rsp+68h] [rbp-18h]
  __int64 v44; // [rsp+78h] [rbp-8h]
  __int128 v45; // [rsp+80h] [rbp+0h] BYREF
  _OWORD v46[3]; // [rsp+90h] [rbp+10h] BYREF
  __int64 v47; // [rsp+C0h] [rbp+40h]

  v3 = *a1;
  if ( !v3 )
    goto LABEL_35;
  v4 = a1[1];
  v5 = a1[2];
  if ( v5 < v4 && *(_BYTE *)(v3 + v5) == 85 )
  {
    a1[2] = ++v5;
    v6 = 1;
    if ( v5 >= v4 )
      goto LABEL_11;
  }
  else
  {
    v6 = 0;
    if ( v5 >= v4 )
    {
LABEL_11:
      if ( !v6 )
        goto LABEL_35;
      v7 = 0LL;
LABEL_13:
      v8 = a1[4];
      if ( v8 )
      {
        v9 = sub_405B80(v8, (unsigned __int16 *)aUnsafe, 7uLL);
        result = 1;
        if ( v9 )
          return result;
      }
      if ( !v7 )
      {
LABEL_35:
        v16 = a1[4];
        if ( v16 )
        {
          v17 = sub_405B80(v16, (unsigned __int16 *)aFn, 3uLL);
          result = 1;
          if ( v17 )
            return result;
        }
        v18 = *a1;
        if ( *a1 )
        {
          v19 = 0LL;
          while ( 1 )
          {
            v20 = a1[2];
            if ( v20 < a1[1] && *(_BYTE *)(v18 + v20) == 69 )
              break;
            if ( v19-- != 0 )
            {
              v22 = a1[4];
              if ( v22 )
              {
                if ( sub_405B80(v22, (unsigned __int16 *)asc_4474F1, 2uLL) )
                  return 1;
              }
            }
            if ( (unsigned __int8)sub_40BC10(a1) )
              return 1;
            v18 = *a1;
            if ( !*a1 )
              goto LABEL_46;
          }
          a1[2] = v20 + 1;
          v23 = a1[4];
          if ( !v23 )
          {
LABEL_51:
            if ( v18 )
              goto LABEL_52;
            goto LABEL_55;
          }
        }
        else
        {
LABEL_46:
          v18 = 0LL;
          v23 = a1[4];
          if ( !v23 )
            goto LABEL_51;
        }
        v24 = sub_405B80(v23, (unsigned __int16 *)asc_448BDD, 1uLL);
        result = 1;
        if ( v24 )
          return result;
        v18 = *a1;
        if ( *a1 )
        {
LABEL_52:
          v25 = a1[2];
          if ( v25 < a1[1] && *(_BYTE *)(v18 + v25) == 117 )
          {
            a1[2] = v25 + 1;
            return 0;
          }
        }
LABEL_55:
        v26 = a1[4];
        if ( !v26 )
          return sub_40BC10(a1);
        v27 = sub_405B80(v26, (unsigned __int16 *)asc_44754D, 4uLL);
        result = 1;
        if ( !v27 )
          return sub_40BC10(a1);
        return result;
      }
LABEL_21:
      v11 = a1[4];
      if ( v11 )
      {
        v12 = sub_405B80(a1[4], (unsigned __int16 *)aExtern, 8uLL);
        result = 1;
        if ( v12 )
          return result;
      }
      *(_QWORD *)&v40 = 0LL;
      *((_QWORD *)&v40 + 1) = v1;
      *(_QWORD *)&v41 = v7;
      *((_QWORD *)&v41 + 1) = v1;
      *(_QWORD *)&v42 = 0LL;
      *((_QWORD *)&v42 + 1) = v1;
      *(_QWORD *)&v43 = 0x5F0000005FLL;
      BYTE8(v43) = 1;
      LOWORD(v44) = 1;
      sub_40A570((__int64 *)&v45, (__int64)&v41);
      if ( (v45 & 1) != 0 )
      {
        v13 = *((_QWORD *)&v45 + 1) - v40;
        v14 = (unsigned __int16 *)&v7[v40];
        *(_QWORD *)&v40 = *(_QWORD *)&v46[0];
        if ( !v11 )
        {
LABEL_30:
          v47 = v44;
          v46[2] = v43;
          v46[1] = v42;
          v46[0] = v41;
          v45 = v40;
          if ( BYTE1(v44) )
          {
            v15 = v11;
LABEL_32:
            if ( !v15 || !sub_405B80(v15, (unsigned __int16 *)asc_447548, 2uLL) )
              goto LABEL_35;
            return 1;
          }
          v15 = v11;
          v34 = v11;
          while ( 1 )
          {
            v35 = *(_QWORD *)&v46[0];
            sub_40A570(v39, (__int64)v46);
            if ( (v39[0] & 1) != 0 )
            {
              v36 = v39[1] - v45;
              v37 = (unsigned __int16 *)(v45 + v35);
              *(_QWORD *)&v45 = v39[2];
              if ( !v34 )
                goto LABEL_66;
            }
            else
            {
              if ( BYTE1(v47) )
                goto LABEL_32;
              BYTE1(v47) = 1;
              v36 = *((_QWORD *)&v45 + 1) - v45;
              if ( ((unsigned __int8)v47 | (*((_QWORD *)&v45 + 1) != (_QWORD)v45)) != 1 )
                goto LABEL_32;
              v37 = (unsigned __int16 *)(*(_QWORD *)&v46[0] + v45);
              if ( !v34 )
                goto LABEL_66;
            }
            if ( sub_405B80(v34, (unsigned __int16 *)"-0", 1uLL) )
              return 1;
            if ( !v11 )
            {
              v15 = 0LL;
LABEL_66:
              v34 = 0LL;
              goto LABEL_67;
            }
            v15 = v11;
            v34 = v11;
            if ( sub_405B80(v11, v37, v36) )
              return 1;
LABEL_67:
            if ( BYTE1(v47) )
              goto LABEL_32;
          }
        }
      }
      else
      {
        if ( BYTE1(v44)
          || (BYTE1(v44) = 1,
              v13 = *((_QWORD *)&v40 + 1) - v40,
              ((unsigned __int8)v44 | (*((_QWORD *)&v40 + 1) != (_QWORD)v40)) != 1) )
        {
          sub_407050((__int64)&off_447530);
        }
        v14 = (unsigned __int16 *)(v41 + v40);
        if ( !v11 )
          goto LABEL_30;
      }
      if ( sub_405B80(v11, v14, v13) )
        return 1;
      goto LABEL_30;
    }
  }
  if ( *(_BYTE *)(v3 + v5) != 75 )
    goto LABEL_11;
  a1[2] = v5 + 1;
  if ( v5 + 1 < v4 && *(_BYTE *)(v3 + v5 + 1) == 67 )
  {
    a1[2] = v5 + 2;
    v1 = 1LL;
    v7 = (char *)&unk_44717E;
    goto LABEL_20;
  }
  sub_40B330((__int64 *)&v45, a1);
  v7 = (char *)v45;
  if ( !(_QWORD)v45 )
  {
    v28 = BYTE8(v45);
    v29 = a1[4];
    if ( BYTE8(v45) )
    {
      if ( v29 )
      {
        v30 = aRecursionLimit;
        v31 = 25LL;
        goto LABEL_80;
      }
    }
    else if ( v29 )
    {
      v30 = aInvalidSyntax;
      v31 = 16LL;
LABEL_80:
      v38 = sub_405B80(v29, (unsigned __int16 *)v30, v31);
      result = 1;
      if ( v38 )
        return result;
    }
    *a1 = 0LL;
    *((_BYTE *)a1 + 8) = v28;
    return 0;
  }
  v1 = *((_QWORD *)&v45 + 1);
  if ( *((_QWORD *)&v45 + 1) && !*((_QWORD *)&v46[0] + 1) )
  {
LABEL_20:
    if ( !v6 )
      goto LABEL_21;
    goto LABEL_13;
  }
  v32 = a1[4];
  if ( !v32 || (v33 = sub_405B80(v32, (unsigned __int16 *)aInvalidSyntax, 0x10uLL), result = 1, !v33) )
  {
    *a1 = 0LL;
    *((_BYTE *)a1 + 8) = 0;
    return 0;
  }
  return result;
}
// 40F6A9: variable 'v1' is possibly undefined
// 40BC10: using guessed type __int64 __fastcall sub_40BC10(_QWORD);
// 4472F1: using guessed type char asc_4472F1;
// 447530: using guessed type char *off_447530;
// 448BDD: using guessed type char asc_448BDD;

//----- (000000000040FA50) ----------------------------------------------------
__int64 *__fastcall sub_40FA50(__int64 *a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v3; // r14
  _BYTE *v4; // r13
  unsigned __int64 v5; // r15
  unsigned __int64 v6; // rcx
  unsigned __int64 v7; // r9
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // r11
  unsigned __int64 v10; // r8
  unsigned __int64 v11; // rsi
  unsigned __int64 v12; // rcx
  unsigned __int64 v13; // rdi
  unsigned __int64 v14; // rcx
  unsigned __int64 v15; // r10
  unsigned __int64 v16; // r10
  unsigned __int64 v17; // r11
  unsigned __int64 v18; // r13
  unsigned __int64 v19; // rsi
  unsigned __int64 v20; // r15
  char *v21; // r13
  unsigned __int64 v22; // r15
  bool v23; // cf
  char v24; // si
  char **v26; // rax
  unsigned __int8 *v27; // r8
  int v28; // ecx
  int v29; // edx
  int v30; // r11d
  int v31; // r10d
  __int64 v32; // r12
  __int64 v33; // r15
  unsigned __int64 v34; // rbx
  unsigned __int64 v35; // r15
  unsigned __int8 *v36; // r8
  unsigned __int8 *v37; // r9
  __int64 v38; // rax
  bool v39; // sf
  int v40; // r10d
  unsigned __int8 *v41; // rcx
  int v42; // edx
  int v43; // edx
  int v44; // r11d
  int v45; // eax
  char v46; // al
  __int64 v47; // r14
  char v48; // al
  char v49; // al
  unsigned __int64 v50; // r14
  __int64 v51; // rax
  _BYTE *v52; // rcx
  int v53; // edx
  unsigned __int64 v54; // r8
  unsigned __int64 v55; // r9
  unsigned __int64 v56; // r9
  __int64 *v57; // rax
  unsigned __int64 v58; // rax
  unsigned int v59; // r11d
  __int64 v60; // rax
  unsigned __int64 v61; // kr00_8
  int v62; // edi
  int v63; // edx
  int v64; // r12d
  int v65; // r11d
  unsigned __int8 v66; // si
  int v67; // r11d
  int v68; // r12d
  int v69; // edi
  int v70; // r11d
  unsigned __int8 *v71; // r10
  int v72; // edi
  int v73; // edx
  _BYTE *v74; // rsi
  int v75; // r13d
  unsigned __int64 v76; // rdx
  __int64 v77; // rsi
  __int64 *result; // rax
  unsigned __int64 v79; // rsi
  unsigned __int64 v80; // r9
  __int64 v81; // [rsp+0h] [rbp-80h] BYREF
  __int64 v82; // [rsp+28h] [rbp-58h] BYREF
  unsigned __int64 v83; // [rsp+30h] [rbp-50h]
  unsigned __int64 v84; // [rsp+40h] [rbp-40h]
  __int64 *v85; // [rsp+48h] [rbp-38h]
  _BYTE *v86; // [rsp+50h] [rbp-30h]
  _BYTE *v87; // [rsp+58h] [rbp-28h] BYREF
  unsigned __int64 v88; // [rsp+60h] [rbp-20h]
  unsigned __int64 v89; // [rsp+68h] [rbp-18h]
  unsigned __int64 v90; // [rsp+70h] [rbp-10h] BYREF
  unsigned __int64 v91; // [rsp+78h] [rbp-8h]
  unsigned __int64 v92; // [rsp+80h] [rbp+0h]
  unsigned __int64 v93; // [rsp+90h] [rbp+10h]
  __int64 v94; // [rsp+A0h] [rbp+20h]
  unsigned __int64 v95; // [rsp+A8h] [rbp+28h]
  __int64 v96; // [rsp+B0h] [rbp+30h]
  unsigned __int64 v97; // [rsp+B8h] [rbp+38h]
  __int64 v98; // [rsp+C0h] [rbp+40h]
  unsigned __int64 v99; // [rsp+C8h] [rbp+48h]
  unsigned __int64 v100; // [rsp+D0h] [rbp+50h]

  v3 = a3;
  v4 = (_BYTE *)a2;
  v85 = a1;
  sub_4083C0(&v81 + 11, a2, a3, aLlvm, 6uLL);
  if ( ((unsigned __int8)v87 & 1) != 0 )
  {
    v86 = v4;
    v5 = v93;
    v6 = v97 - 1;
    if ( v93 != -1LL )
    {
      v7 = v92;
      v98 = v97 - 1;
      v8 = v92 + v6;
      if ( v8 < v95 )
      {
        v9 = v91;
        v99 = v90;
        v100 = v97 - v90;
        do
        {
          while ( _bittest64((const __int64 *)&v9, *(unsigned __int8 *)(v94 + v8)) )
          {
            v11 = v5;
            if ( v88 > v5 )
              v11 = v88;
            v12 = v11;
            while ( v12 < v97 )
            {
              v13 = v12;
              if ( v7 + v12 >= v95 )
              {
                v79 = v7 + v11;
                if ( v95 > v79 )
                  v79 = v95;
                sub_4050B0(v79, v95, (__int64)&off_4479B8);
              }
              ++v12;
              if ( *(_BYTE *)(v96 + v13) != *(_BYTE *)(v94 + v7 + v13) )
              {
                v7 = v13 + v7 - v88 + 1;
                goto LABEL_10;
              }
            }
            v14 = v88;
            do
            {
              if ( v5 >= v14 )
                goto LABEL_44;
              if ( --v14 >= v97 )
                goto LABEL_189;
              v15 = v14 + v7;
              if ( v14 + v7 >= v95 )
                goto LABEL_185;
            }
            while ( *(_BYTE *)(v96 + v14) == *(_BYTE *)(v94 + v15) );
            v7 += v99;
            v5 = v100;
            v8 = v7 + v98;
            if ( v7 + v98 >= v95 )
              goto LABEL_42;
          }
          v7 += v97;
LABEL_10:
          v5 = 0LL;
          v8 = v7 + v98;
        }
        while ( v7 + v98 < v95 );
      }
      goto LABEL_42;
    }
    v7 = v92;
    v16 = v92 + v6;
    if ( v92 + v6 >= v95 )
    {
LABEL_42:
      v4 = v86;
      goto LABEL_66;
    }
    v17 = v97 - 1;
    v18 = v91;
    v84 = v90;
    v14 = v88 - 1;
    v98 = v96 + v88 - 1;
    v99 = v88 - 1;
    v100 = v91;
    while ( 1 )
    {
      if ( !_bittest64((const __int64 *)&v18, *(unsigned __int8 *)(v94 + v16)) )
      {
        v7 += v97;
        goto LABEL_29;
      }
      v19 = v88;
      while ( v19 < v97 )
      {
        v20 = v19;
        if ( v7 + v19 >= v95 )
        {
          v80 = v88 + v7;
          if ( v95 > v80 )
            v80 = v95;
          sub_4050B0(v80, v95, (__int64)&off_4479B8);
        }
        ++v19;
        if ( *(_BYTE *)(v96 + v20) != *(_BYTE *)(v94 + v7 + v20) )
        {
          v7 = v20 + v7 - v88 + 1;
          goto LABEL_29;
        }
      }
      if ( v14 >= v97 )
        break;
      v15 = v14 + v7;
      v21 = (char *)v98;
      v22 = v88;
      do
      {
        v23 = v22-- == 0;
        if ( v23 )
          goto LABEL_44;
        if ( v15 >= v95 )
LABEL_185:
          sub_4050B0(v15, v95, (__int64)&off_4479A0);
        v24 = *v21--;
      }
      while ( v24 == *(_BYTE *)(v94 + v15--) );
      v7 += v84;
      v14 = v99;
      v18 = v100;
LABEL_29:
      v16 = v7 + v17;
      if ( v7 + v17 >= v95 )
        goto LABEL_42;
    }
    if ( v88 )
LABEL_189:
      sub_4050B0(v14, v97, (__int64)&off_447988);
LABEL_44:
    v4 = v86;
    v10 = v7 + 6;
    if ( v7 != -6LL )
    {
LABEL_45:
      if ( v10 >= v3 )
      {
        if ( v10 != v3 )
          goto LABEL_47;
      }
      else if ( (char)v4[v10] <= -65 )
      {
LABEL_47:
        v26 = &off_4475B8;
        goto LABEL_196;
      }
    }
  }
  else
  {
    do
      sub_40E480(&v82, (__int64)&v87);
    while ( v82 == 1 );
    if ( v82 )
      goto LABEL_66;
    v7 = v83;
    v10 = v83 + 6;
    if ( v83 != -6LL )
      goto LABEL_45;
  }
  v27 = &v4[v10];
  while ( v27 != &v4[v3] )
  {
    v28 = *v27;
    if ( (v28 & 0x80u) == 0 )
    {
      ++v27;
    }
    else
    {
      v29 = v28 & 0x1F;
      v30 = v27[1] & 0x3F;
      if ( (unsigned __int8)v28 <= 0xDFu )
      {
        v27 += 2;
        v28 = v30 | (v29 << 6);
      }
      else
      {
        v31 = (v30 << 6) | v27[2] & 0x3F;
        if ( (unsigned __int8)v28 < 0xF0u )
        {
          v27 += 3;
          v28 = (v29 << 12) | v31;
        }
        else
        {
          v28 = ((v28 & 7) << 18) | (v31 << 6) | v27[3] & 0x3F;
          if ( v28 == 1114112 )
            break;
          v27 += 4;
        }
      }
    }
    if ( (unsigned int)(v28 - 48) >= 0xA && (unsigned int)(v28 - 64) >= 7 )
      goto LABEL_66;
  }
  if ( !v7 )
  {
    v32 = 2LL;
    goto LABEL_180;
  }
  if ( v7 < v3 )
  {
    if ( (char)v4[v7] > -65 )
    {
      v3 = v7;
      goto LABEL_66;
    }
LABEL_191:
    sub_4079A0(v4, v3, 0LL, v7, (__int64)&off_4475D0);
  }
  if ( v7 != v3 )
    goto LABEL_191;
LABEL_66:
  if ( v3 >= 3 )
  {
    if ( *(_WORD *)v4 ^ 0x5A5F | (unsigned __int8)v4[2] ^ 0x4E )
    {
      if ( *(_WORD *)v4 == 20058 )
      {
        if ( (char)v4[2] <= -65 )
          sub_4079A0(v4, v3, 2uLL, v3, (__int64)&off_447018);
        v10 = 2LL;
        v33 = -2LL;
      }
      else
      {
        v34 = 3LL;
        if ( v3 == 3 )
        {
LABEL_101:
          if ( *(_WORD *)v4 == 21087 )
          {
            v49 = v4[2];
            if ( v49 <= -65 )
              sub_4079A0(v4, v34, 2uLL, v34, (__int64)&off_447248);
            v35 = (unsigned __int64)(v4 + 2);
            v47 = -2LL;
            v32 = 2LL;
            if ( (unsigned __int8)(v49 - 65) > 0x19u )
              goto LABEL_180;
LABEL_114:
            v50 = v34 + v47;
            v51 = 0LL;
            while ( v50 != v51 )
            {
              v39 = *(char *)(v35 + v51++) < 0;
              if ( v39 )
                goto LABEL_180;
            }
            v87 = (_BYTE *)v35;
            v88 = v50;
            v89 = 0LL;
            LODWORD(v90) = 0;
            v91 = 0LL;
            LODWORD(v92) = 0;
            if ( !sub_40A960((__int64)&v87, 0LL) )
            {
              v52 = v87;
              if ( !v87 )
                goto LABEL_180;
              v53 = HIBYTE(v88) << 16;
              v54 = v89;
              v55 = (unsigned __int8)v88 | ((((unsigned __int64)(v53 | (unsigned int)*(unsigned __int16 *)((char *)&v88 + 5)) << 32) | *(unsigned int *)((char *)&v88 + 1)) << 8);
              if ( v89 >= v55 || (unsigned __int8)(v87[v89] - 65) >= 0x1Au )
              {
LABEL_125:
                if ( v54 )
                {
                  if ( v55 <= v54 )
                  {
                    if ( v55 != v54 )
LABEL_128:
                      sub_4079A0(v52, v55, v54, v55, (__int64)&off_4472B8);
                  }
                  else if ( (char)v52[v54] <= -65 )
                  {
                    goto LABEL_128;
                  }
                }
                v41 = &v52[v54];
                v56 = v55 - v54;
                v36 = 0LL;
                if ( v56 )
                  goto LABEL_163;
LABEL_131:
                v56 = 0LL;
LABEL_132:
                v57 = v85;
                v85[1] = (__int64)v36;
                v57[2] = v35;
                v57[3] = v50;
                v57[4] = (__int64)v4;
                v57[5] = v34;
                v57[6] = (__int64)v41;
                v57[7] = v56;
                v32 = 1LL;
                goto LABEL_180;
              }
              v88 = (unsigned __int8)v88 | ((((unsigned __int64)(v53 | (unsigned int)*(unsigned __int16 *)((char *)&v88 + 5)) << 32) | *(unsigned int *)((char *)&v88 + 1)) << 8);
              _mm_storel_ps((double *)&v90, (__m128)v90);
              v91 = 0LL;
              LODWORD(v92) = 0;
              if ( !sub_40A960((__int64)&v87, 0LL) )
              {
                v52 = v87;
                if ( !v87 )
                  goto LABEL_180;
                v54 = v89;
                v55 = (unsigned __int8)v88 | ((((unsigned __int64)((HIBYTE(v88) << 16) | (unsigned int)*(unsigned __int16 *)((char *)&v88 + 5)) << 32) | *(unsigned int *)((char *)&v88 + 1)) << 8);
                goto LABEL_125;
              }
            }
            sub_406F40((__int64)aFmtErrorSShoul, 61LL, (__int64)&v82, (__int64)&unk_446EE8, (__int64)&off_4472A0);
          }
          if ( *v4 != 82 )
          {
            v32 = 2LL;
            if ( v34 == 3 || *(_WORD *)v4 ^ 0x5F5F | (unsigned __int8)v4[2] ^ 0x52 )
              goto LABEL_180;
            v46 = v4[3];
            if ( v46 <= -65 )
              sub_4079A0(v4, v34, 3uLL, v34, (__int64)&off_447218);
            v35 = (unsigned __int64)(v4 + 3);
            v47 = -3LL;
            v32 = 2LL;
            if ( (unsigned __int8)(v46 - 65) > 0x19u )
              goto LABEL_180;
            goto LABEL_114;
          }
LABEL_109:
          v48 = v4[1];
          if ( v48 <= -65 )
            sub_4079A0(v4, v34, 1uLL, v34, (__int64)&off_447230);
          v35 = (unsigned __int64)(v4 + 1);
          v47 = -1LL;
          v32 = 2LL;
          if ( (unsigned __int8)(v48 - 65) > 0x19u )
            goto LABEL_180;
          goto LABEL_114;
        }
        if ( *(_DWORD *)v4 != 1314545503 )
        {
          v34 = v3;
          goto LABEL_101;
        }
        v33 = -4LL;
        v10 = 4LL;
        if ( v3 < 5 )
        {
          v34 = 4LL;
          goto LABEL_81;
        }
        if ( (char)v4[4] <= -65 )
        {
          v26 = &off_447000;
          goto LABEL_196;
        }
      }
    }
    else
    {
      v33 = -3LL;
      v10 = 3LL;
      if ( v3 == 3 )
      {
        v34 = 3LL;
        goto LABEL_81;
      }
      if ( (char)v4[3] <= -65 )
      {
        v26 = &off_447030;
LABEL_196:
        sub_4079A0(v4, v3, v10, v3, (__int64)v26);
      }
    }
    v34 = v3;
    goto LABEL_81;
  }
  v32 = 2LL;
  if ( v3 != 2 )
    goto LABEL_180;
  if ( *(_WORD *)v4 != 20058 )
    goto LABEL_108;
  v33 = -2LL;
  v34 = 2LL;
  v10 = 2LL;
LABEL_81:
  v35 = v34 + v33;
  v36 = &v4[v10];
  v37 = &v36[v35];
  v38 = 0LL;
  while ( v35 != v38 )
  {
    v39 = (v36[v38++] & 0x80u) != 0;
    if ( v39 )
      goto LABEL_100;
  }
  if ( !v35 )
  {
LABEL_100:
    if ( v34 >= 3 )
      goto LABEL_101;
LABEL_108:
    v34 = 2LL;
    v32 = 2LL;
    if ( *v4 != 82 )
      goto LABEL_180;
    goto LABEL_109;
  }
  v40 = *v36;
  if ( (v40 & 0x80u) == 0 )
  {
    v41 = v36 + 1;
LABEL_88:
    v42 = v40;
    goto LABEL_98;
  }
  v43 = v40 & 0x1F;
  v44 = v36[1] & 0x3F;
  if ( (unsigned __int8)v40 <= 0xDFu )
  {
    v41 = v36 + 2;
    v42 = v44 | (v43 << 6);
  }
  else
  {
    v45 = (v44 << 6) | v36[2] & 0x3F;
    if ( (unsigned __int8)v40 >= 0xF0u )
    {
      v41 = v36 + 4;
      v40 = ((v40 & 7) << 18) | (v45 << 6) | v36[3] & 0x3F;
      goto LABEL_88;
    }
    v41 = v36 + 3;
    v42 = (v43 << 12) | v45;
  }
LABEL_98:
  if ( v42 != 69 )
  {
    if ( v42 != 1114112 )
    {
      v50 = 0LL;
      while ( (unsigned int)(v42 - 48) <= 9 )
      {
        v58 = 0LL;
        while ( 1 )
        {
          v59 = v42 - 48;
          if ( (unsigned int)(v42 - 48) >= 0xA )
            break;
          v61 = v58;
          v60 = 10 * v58;
          if ( is_mul_ok(0xAuLL, v61) )
          {
            v23 = __CFADD__(v59, v60);
            v58 = v59 + v60;
            if ( !v23 && v41 != v37 )
            {
              v62 = *v41;
              if ( (v62 & 0x80u) == 0 )
              {
                ++v41;
                v42 = v62;
              }
              else
              {
                v63 = v62 & 0x1F;
                v64 = v41[1] & 0x3F;
                if ( (unsigned __int8)v62 <= 0xDFu )
                {
                  v41 += 2;
                  v42 = v64 | (v63 << 6);
                }
                else
                {
                  v65 = (v64 << 6) | v41[2] & 0x3F;
                  if ( (unsigned __int8)v62 < 0xF0u )
                  {
                    v41 += 3;
                    v42 = (v63 << 12) | v65;
                  }
                  else
                  {
                    v66 = v41[3];
                    v41 += 4;
                    v42 = ((v62 & 7) << 18) | (v65 << 6) | v66 & 0x3F;
                  }
                }
              }
              if ( v42 != 1114112 )
                continue;
            }
          }
          goto LABEL_100;
        }
        if ( v58 )
        {
          while ( v41 != v37 )
          {
            v42 = *v41;
            if ( (v42 & 0x80u) == 0 )
            {
              ++v41;
            }
            else
            {
              v67 = v42 & 0x1F;
              v68 = v41[1] & 0x3F;
              if ( (unsigned __int8)v42 <= 0xDFu )
              {
                v41 += 2;
                v42 = v68 | (v67 << 6);
              }
              else
              {
                v69 = (v68 << 6) | v41[2] & 0x3F;
                if ( (unsigned __int8)v42 < 0xF0u )
                {
                  v41 += 3;
                  v42 = (v67 << 12) | v69;
                }
                else
                {
                  v42 = ((v42 & 7) << 18) | (v69 << 6) | v41[3] & 0x3F;
                  if ( v42 == 1114112 )
                    goto LABEL_100;
                  v41 += 4;
                }
              }
            }
            if ( !--v58 )
              goto LABEL_149;
          }
          goto LABEL_100;
        }
LABEL_149:
        ++v50;
        if ( v42 == 69 )
          goto LABEL_130;
      }
    }
    goto LABEL_100;
  }
  v50 = 0LL;
LABEL_130:
  v56 = v37 - v41;
  if ( !v56 )
    goto LABEL_131;
LABEL_163:
  v32 = 2LL;
  if ( *v41 == 46 )
  {
    LOBYTE(v70) = 46;
    v71 = v41;
LABEL_172:
    ++v71;
    v70 = (unsigned __int8)v70;
    while ( 1 )
    {
      if ( (v70 & 0x1FFFDFu) - 65 >= 0x1A && (unsigned int)(v70 - 48) >= 0xA && (unsigned int)(v70 - 33) >= 0xF )
      {
        v76 = (unsigned int)(v70 - 58);
        if ( (unsigned int)v76 > 0x26 || (v77 = 0x7E0000007FLL, !_bittest64(&v77, v76)) )
        {
          if ( (unsigned int)(v70 - 127) < 0xFFFFFFFC )
            break;
        }
      }
      if ( v71 == &v41[v56] )
        goto LABEL_132;
      LOBYTE(v70) = *v71;
      if ( (*v71 & 0x80u) == 0 )
        goto LABEL_172;
      v72 = v70 & 0x1F;
      v73 = v71[1] & 0x3F;
      if ( (unsigned __int8)v70 <= 0xDFu )
      {
        v71 += 2;
        v70 = v73 | (v72 << 6);
      }
      else
      {
        v74 = v4;
        v75 = (v73 << 6) | v71[2] & 0x3F;
        if ( (unsigned __int8)v70 < 0xF0u )
        {
          v71 += 3;
          v70 = (v72 << 12) | v75;
        }
        else
        {
          v70 = ((v70 & 7) << 18) | (v75 << 6) | v71[3] & 0x3F;
          if ( v70 == 1114112 )
          {
            v4 = v74;
            goto LABEL_132;
          }
          v71 += 4;
        }
        v4 = v74;
      }
    }
  }
LABEL_180:
  result = v85;
  *v85 = v32;
  return result;
}
// 447000: using guessed type char *off_447000;
// 447018: using guessed type char *off_447018;
// 447030: using guessed type char *off_447030;
// 447218: using guessed type char *off_447218;
// 447230: using guessed type char *off_447230;
// 447248: using guessed type char *off_447248;
// 4472A0: using guessed type char *off_4472A0;
// 4472B8: using guessed type char *off_4472B8;
// 4475B8: using guessed type char *off_4475B8;
// 4475D0: using guessed type char *off_4475D0;
// 447988: using guessed type char *off_447988;
// 4479A0: using guessed type char *off_4479A0;
// 4479B8: using guessed type char *off_4479B8;

//----- (0000000000410600) ----------------------------------------------------
__int64 __fastcall sub_410600(char ***a1, __int64 a2)
{
  unsigned __int8 *v2; // r12
  __int64 v3; // r13
  char **v4; // rax
  char *v5; // r15
  unsigned __int8 *v6; // rax
  unsigned __int8 *v7; // rcx
  bool v8; // zf
  int v9; // eax
  unsigned __int64 v10; // rbx
  unsigned __int8 *v11; // r10
  char v12; // r8
  unsigned __int8 *v13; // r14
  int v14; // r11d
  int v15; // esi
  int v16; // edi
  int v17; // esi
  unsigned __int64 v18; // r9
  char v19; // dl
  bool v20; // cf
  __int64 v21; // r10
  unsigned __int64 v22; // rax
  unsigned __int128 v23; // rax
  bool v24; // si
  unsigned int v25; // r11d
  __int64 v26; // rdx
  unsigned int v27; // r10d
  char *v28; // rdx
  unsigned int v29; // r10d
  unsigned int v30; // r8d
  int v31; // r9d
  int v32; // r11d
  int v33; // r10d
  unsigned __int64 v34; // rsi
  char v35; // cl
  unsigned __int64 v36; // rcx
  unsigned __int64 v37; // rbx
  int v38; // eax
  unsigned __int8 *v39; // rax
  unsigned __int64 v40; // r9
  unsigned __int8 *v41; // rcx
  unsigned __int8 *v42; // r8
  int v43; // edx
  unsigned __int64 v44; // rsi
  int v45; // edx
  int v46; // r11d
  int v47; // r10d
  char *v48; // rsi
  unsigned __int64 v49; // r9
  unsigned __int64 v50; // r14
  unsigned __int64 v51; // rbx
  unsigned __int8 *v52; // r12
  int v53; // eax
  unsigned __int8 *v54; // rax
  unsigned __int64 v55; // rax
  char *v56; // rax
  int v57; // ecx
  unsigned __int64 v58; // rcx
  _BYTE *v59; // rax
  unsigned __int8 *v60; // rsi
  unsigned __int8 *v61; // r9
  char v62; // r8
  int v63; // r10d
  int v64; // r11d
  int v65; // edi
  unsigned __int64 v66; // rdx
  unsigned __int8 *v67; // rcx
  unsigned __int64 v68; // r12
  __int64 v69; // rbx
  int v70; // r13d
  char v71; // al
  int v72; // edx
  int v73; // ecx
  int v74; // r8d
  int v75; // edx
  __int64 v76; // r9
  unsigned int v77; // edx
  unsigned int v78; // r11d
  unsigned int v79; // r10d
  __int64 v80; // r9
  unsigned int v81; // r11d
  unsigned int v82; // r10d
  char v83; // al
  int v84; // eax
  char **v86; // rcx
  char **v87; // rax
  __int64 v88; // [rsp+30h] [rbp-50h] BYREF
  unsigned __int64 v89; // [rsp+38h] [rbp-48h]
  unsigned __int64 v90; // [rsp+48h] [rbp-38h]
  __int128 v91; // [rsp+50h] [rbp-30h] BYREF
  __int64 v92; // [rsp+60h] [rbp-20h]
  unsigned __int64 v93; // [rsp+68h] [rbp-18h]
  __int64 v94; // [rsp+70h] [rbp-10h]
  int v95; // [rsp+78h] [rbp-8h]
  unsigned __int8 *v96; // [rsp+80h] [rbp+0h]
  unsigned __int8 *v97; // [rsp+88h] [rbp+8h]
  unsigned int v98; // [rsp+90h] [rbp+10h] BYREF
  int v99; // [rsp+94h] [rbp+14h]
  unsigned __int64 v100; // [rsp+98h] [rbp+18h]
  unsigned __int8 *v101; // [rsp+A0h] [rbp+20h]

  v3 = a2;
  v4 = *a1;
  v5 = **a1;
  if ( !v5 )
  {
    v91 = *(_OWORD *)(v4 + 1);
    v92 = 0LL;
    LODWORD(v93) = 0;
    v94 = a2;
    v95 = 0;
    LOBYTE(a2) = 1;
    LOBYTE(v84) = sub_40A960((__int64)&v91, a2);
    LODWORD(v2) = v84;
    return (unsigned int)v2;
  }
  v101 = (unsigned __int8 *)v4[1];
  v6 = (unsigned __int8 *)v4[2];
  v7 = 0LL;
  v97 = v6;
  while ( 2 )
  {
    LOBYTE(v2) = v7 != v6;
    if ( v7 == v6 )
      return (unsigned int)v2;
    if ( !v101 )
      goto LABEL_197;
    v96 = v7 + 1;
    v9 = (unsigned __int8)*v5;
    v10 = (unsigned __int64)v101;
    v11 = 0LL;
    v12 = *v5;
    if ( *v5 >= 0 )
      goto LABEL_10;
    while ( 1 )
    {
      v14 = v12 & 0x1F;
      v15 = v11[(_QWORD)v5 + 1] & 0x3F;
      if ( (unsigned __int8)v12 <= 0xDFu )
      {
        v17 = v15 | (v14 << 6);
        goto LABEL_19;
      }
      v16 = (v15 << 6) | v11[(_QWORD)v5 + 2] & 0x3F;
      if ( (unsigned __int8)v12 < 0xF0u )
        break;
      v17 = ((v12 & 7) << 18) | (v16 << 6) | v11[(_QWORD)v5 + 3] & 0x3F;
      if ( v17 == 1114112 )
        goto LABEL_197;
LABEL_19:
      v13 = &v11[(_QWORD)v5];
      if ( (unsigned int)(v17 - 48) > 9 )
        goto LABEL_20;
      while ( 1 )
      {
LABEL_11:
        if ( v101 - 1 == v11 )
LABEL_197:
          sub_407050((__int64)&off_447060);
        v12 = v11[(_QWORD)v5 + 1];
        if ( v12 <= -65 )
          sub_4079A0(v13, v10, 1uLL, v10, (__int64)&off_447078);
        --v10;
        ++v11;
        if ( v12 < 0 )
          break;
LABEL_10:
        v13 = &v11[(_QWORD)v5];
        if ( (unsigned int)(unsigned __int8)v12 - 48 > 9 )
          goto LABEL_20;
      }
    }
    v13 = &v11[(_QWORD)v5];
    if ( ((v14 << 12) | (unsigned int)v16) - 48 <= 9 )
      goto LABEL_11;
LABEL_20:
    v18 = (unsigned __int64)&v101[-v10];
    if ( v101 == (unsigned __int8 *)v10 )
    {
      v19 = 0;
      goto LABEL_199;
    }
    if ( v5[v18] <= -65 )
      sub_4079A0(v5, (unsigned __int64)v101, 0LL, v18, (__int64)&off_447090);
    if ( v18 == 1 )
    {
      v19 = 1;
      if ( v9 != 43 )
      {
        v18 = 1LL;
        if ( v9 != 45 )
        {
LABEL_35:
          v26 = 0LL;
          v22 = 0LL;
          while ( 1 )
          {
            v27 = (unsigned __int8)v5[v26] - 48;
            if ( v27 > 9 )
              break;
            v22 = v27 + 10 * v22;
            if ( v18 == ++v26 )
              goto LABEL_38;
          }
LABEL_198:
          v19 = 1;
        }
      }
LABEL_199:
      LOBYTE(v91) = v19;
      sub_406F40((__int64)aCalledResultUn, 43LL, (__int64)&v91, (__int64)&unk_446F28, (__int64)&off_4470A8);
    }
    if ( *v5 == 43 )
    {
      ++v5;
      v20 = v18-- < 0x12;
      if ( v20 )
        goto LABEL_35;
    }
    else if ( v18 < 0x11 )
    {
      goto LABEL_35;
    }
    v21 = 0LL;
    v22 = 0LL;
    while ( v18 != v21 )
    {
      v23 = 0xA * (unsigned __int128)v22;
      v24 = *((_QWORD *)&v23 + 1) != 0LL;
      v25 = (unsigned __int8)v5[v21] - 48;
      if ( v25 > 9 )
        goto LABEL_198;
      v19 = 2;
      if ( !v24 )
      {
        ++v21;
        v20 = __CFADD__(v25, (_QWORD)v23);
        v22 = v25 + (_QWORD)v23;
        if ( !v20 )
          continue;
      }
      goto LABEL_199;
    }
LABEL_38:
    if ( v22 )
    {
      if ( v10 <= v22 )
      {
        if ( v10 != v22 )
LABEL_204:
          sub_4079A0(v13, v10, v22, v10, (__int64)&off_4470C0);
      }
      else if ( (char)v13[v22] <= -65 )
      {
        goto LABEL_204;
      }
    }
    v5 = (char *)&v13[v22];
    if ( v96 != v97 || (*(_DWORD *)(v3 + 36) & 4) == 0 || v12 != 104 || !v22 )
    {
LABEL_62:
      if ( v7 )
      {
        v34 = v22;
        v35 = (*(__int64 (__fastcall **)(_QWORD, const char *, __int64))(*(_QWORD *)(v3 + 56) + 24LL))(
                *(_QWORD *)(v3 + 48),
                "::_$",
                2LL);
        v22 = v34;
        if ( v35 )
          return (unsigned int)v2;
      }
      v99 = (int)v2;
      if ( v22 >= 2 && *(_WORD *)v13 == 9311 )
      {
        if ( (char)v13[1] <= -65 )
        {
          v86 = &off_4470E0;
LABEL_211:
          sub_4079A0(v13, v22, 1uLL, v22, (__int64)v86);
        }
        ++v13;
        v36 = v22 - 1;
      }
      else
      {
        v36 = v22;
      }
      v101 = (unsigned __int8 *)(v10 - v22);
LABEL_68:
      v2 = v13;
      v37 = v36;
      if ( !v36 )
        goto LABEL_74;
      v38 = *v13;
      if ( v38 != 36 )
      {
        if ( v38 == 46 )
        {
          if ( v36 == 1 )
          {
            if ( (*(unsigned __int8 (__fastcall **)(_QWORD, char *, __int64))(*(_QWORD *)(v3 + 56) + 24LL))(
                   *(_QWORD *)(v3 + 48),
                   ".",
                   1LL) )
            {
              goto LABEL_195;
            }
            goto LABEL_186;
          }
          v53 = v13[1];
          if ( (char)v53 <= -65 )
          {
            v87 = &off_4471A0;
            goto LABEL_213;
          }
          if ( (v53 & 0x80u) == 0 )
          {
            if ( v53 == 46 )
              goto LABEL_110;
LABEL_184:
            if ( (*(unsigned __int8 (__fastcall **)(_QWORD, char *, __int64))(*(_QWORD *)(v3 + 56) + 24LL))(
                   *(_QWORD *)(v3 + 48),
                   ".",
                   1LL) )
            {
LABEL_195:
              LOBYTE(v2) = 1;
              return (unsigned int)v2;
            }
            if ( (char)v13[1] < -64 )
            {
              v87 = &off_4471D0;
LABEL_213:
              sub_4079A0(v13, v37, 1uLL, v37, (__int64)v87);
            }
LABEL_186:
            v51 = v37 - 1;
            v52 = v13 + 1;
            goto LABEL_187;
          }
          v73 = v53 & 0x1F;
          v74 = v13[2] & 0x3F;
          if ( (unsigned __int8)v53 <= 0xDFu )
          {
            if ( (v74 | (v73 << 6)) != 0x2E )
              goto LABEL_184;
          }
          else
          {
            v75 = (v74 << 6) | v13[3] & 0x3F;
            if ( (unsigned __int8)v53 < 0xF0u )
            {
              if ( ((v73 << 12) | v75) != 0x2E )
                goto LABEL_184;
            }
            else if ( (((v53 & 7) << 18) | (v75 << 6) | v13[4] & 0x3F) != 0x2E )
            {
              goto LABEL_184;
            }
          }
LABEL_110:
          if ( !(*(unsigned __int8 (__fastcall **)(_QWORD, const char *, __int64))(*(_QWORD *)(v3 + 56) + 24LL))(
                  *(_QWORD *)(v3 + 48),
                  "::_$",
                  2LL) )
          {
            if ( v37 >= 3 && (char)v13[2] < -64 )
              sub_4079A0(v13, v37, 2uLL, v37, (__int64)&off_4471B8);
            v51 = v37 - 2;
            v52 = v13 + 2;
            goto LABEL_187;
          }
          goto LABEL_195;
        }
LABEL_74:
        v39 = &v13[v36];
        v40 = 0LL;
        v41 = v13;
        while ( 1 )
        {
          if ( v41 == v39 )
            goto LABEL_3;
          v44 = v40;
          v40 = *v41;
          if ( (v40 & 0x80u) == 0LL )
          {
            v42 = v41 + 1;
            v43 = *v41;
            if ( (_DWORD)v40 == 36 )
              goto LABEL_86;
          }
          else
          {
            v45 = v40 & 0x1F;
            v46 = v41[1] & 0x3F;
            if ( (unsigned __int8)v40 <= 0xDFu )
            {
              v42 = v41 + 2;
              v43 = v46 | (v45 << 6);
              if ( v43 == 36 )
                goto LABEL_86;
            }
            else
            {
              v47 = (v46 << 6) | v41[2] & 0x3F;
              if ( (unsigned __int8)v40 < 0xF0u )
              {
                v42 = v41 + 3;
                v43 = v47 | (v45 << 12);
                if ( v43 == 36 )
                {
LABEL_86:
                  if ( !v44 )
                  {
                    v44 = 0LL;
                    if ( !(*(unsigned __int8 (__fastcall **)(_QWORD, unsigned __int8 *, _QWORD, unsigned __int64))(*(_QWORD *)(v3 + 56) + 24LL))(
                            *(_QWORD *)(v3 + 48),
                            v13,
                            0LL,
                            v40) )
                      goto LABEL_106;
                    goto LABEL_195;
                  }
                  if ( v44 >= v37 )
                  {
                    if ( v44 != v37 || !v13 )
LABEL_205:
                      sub_4079A0(v13, v37, 0LL, v44, (__int64)&off_4470F8);
                    v44 = v37;
                    if ( !(*(unsigned __int8 (__fastcall **)(_QWORD, unsigned __int8 *, unsigned __int64, unsigned __int64))(*(_QWORD *)(v3 + 56) + 24LL))(
                            *(_QWORD *)(v3 + 48),
                            v13,
                            v37,
                            v40) )
                      goto LABEL_106;
                    goto LABEL_195;
                  }
                  if ( (char)v13[v44] <= -65 )
                    goto LABEL_205;
                  if ( (*(unsigned __int8 (__fastcall **)(_QWORD, unsigned __int8 *, unsigned __int64, unsigned __int64))(*(_QWORD *)(v3 + 56) + 24LL))(
                         *(_QWORD *)(v3 + 48),
                         v13,
                         v44,
                         v40) )
                  {
                    goto LABEL_195;
                  }
                  if ( (char)v13[v44] < -64 )
                    sub_4079A0(v13, v37, v44, v37, (__int64)&off_447110);
LABEL_106:
                  v51 = v37 - v44;
                  v52 = &v13[v44];
LABEL_187:
                  v36 = v51;
                  v13 = v52;
                  goto LABEL_68;
                }
              }
              else
              {
                v42 = v41 + 4;
                v40 = (v47 << 6) | v41[3] & 0x3Fu;
                v43 = v40 | ((v45 & 7) << 18);
                if ( v43 == 36 )
                  goto LABEL_86;
              }
            }
          }
          v40 = (unsigned __int64)&v42[v44 - (_QWORD)v41];
          v41 = v42;
          if ( v43 == 46 )
            goto LABEL_86;
        }
      }
      if ( v36 != 1 && (char)v13[1] <= -65 )
      {
        v87 = &off_447128;
        goto LABEL_213;
      }
      v48 = (char *)(v13 + 1);
      *(_QWORD *)&v91 = v13 + 1;
      *((_QWORD *)&v91 + 1) = v36 - 1;
      v92 = 0LL;
      v93 = v36 - 1;
      LOBYTE(v95) = 1;
      v94 = 0x2400000024LL;
      sub_40A570(&v88, (__int64)&v91);
      if ( !v88 )
        goto LABEL_3;
      if ( v89 == -1LL )
        sub_408380();
      v49 = v89 + 1;
      if ( v37 != 1 && *v48 <= -65 )
LABEL_203:
        sub_4079A0(v13, v37, 1uLL, v49, (__int64)&off_447140);
      if ( v49 >= v37 )
      {
        if ( v49 != v37 )
          goto LABEL_203;
        v100 = v37;
        v54 = v13;
        v50 = v89 + 2;
        if ( v89 == -2LL )
          goto LABEL_123;
      }
      else
      {
        if ( (char)v13[v49] < -64 )
          goto LABEL_203;
        v50 = v89 + 2;
      }
      v55 = v37 - v50;
      if ( v37 <= v50 )
      {
        if ( v37 != v50 )
LABEL_206:
          sub_4079A0(v2, v37, v50, v37, (__int64)&off_447158);
      }
      else if ( (char)v2[v50] < -64 )
      {
        goto LABEL_206;
      }
      v13 = &v2[v50];
      v100 = v55;
      if ( v89 == 1 )
      {
        v57 = (unsigned __int8)*v48;
        v56 = ",(><&@";
        if ( v57 != 67 )
        {
          if ( v57 != 117 )
            goto LABEL_3;
          goto LABEL_137;
        }
      }
      else
      {
        if ( v89 != 2 )
        {
          v54 = v13;
          if ( !v89 )
            goto LABEL_3;
LABEL_123:
          if ( v2[1] != 117 )
            goto LABEL_3;
LABEL_124:
          v13 = v54;
          if ( (char)v2[2] <= -65 )
            sub_4079A0(v2 + 1, v89, 1uLL, v89, (__int64)&off_447180);
LABEL_137:
          v58 = v89 - 1;
          v59 = v2 + 2;
          v90 = v89;
          v60 = (unsigned __int8 *)&v48[v89];
          v61 = v2 + 2;
          while ( 1 )
          {
            v62 = 1;
            if ( v61 == v60 )
              break;
            v63 = *v61;
            if ( (v63 & 0x80u) == 0 )
            {
              ++v61;
            }
            else
            {
              v64 = v63 & 0x1F;
              v65 = v61[1] & 0x3F;
              if ( (unsigned __int8)v63 <= 0xDFu )
              {
                v61 += 2;
                v63 = v65 | (v64 << 6);
              }
              else
              {
                v66 = v58;
                v67 = v2;
                v68 = v37;
                v69 = v3;
                v70 = (v65 << 6) | v61[2] & 0x3F;
                if ( (unsigned __int8)v63 < 0xF0u )
                {
                  v61 += 3;
                  v63 = (v64 << 12) | v70;
                  v3 = v69;
                  v37 = v68;
                  v2 = v67;
                  v58 = v66;
                }
                else
                {
                  v63 = ((v63 & 7) << 18) | (v70 << 6) | v61[3] & 0x3F;
                  v3 = v69;
                  v37 = v68;
                  v2 = v67;
                  v58 = v66;
                  if ( v63 == 1114112 )
                    break;
                  v61 += 4;
                }
              }
            }
            if ( (unsigned int)(v63 - 48) >= 0xA && (unsigned int)(v63 - 97) >= 6 )
            {
              v62 = 0;
              break;
            }
          }
          if ( v90 == 2 )
          {
            v72 = (unsigned __int8)*v59;
            if ( v72 == 43 )
              goto LABEL_3;
            v58 = 1LL;
            if ( v72 == 45 )
              goto LABEL_3;
          }
          else
          {
            if ( v90 == 1 )
              goto LABEL_3;
            if ( *v59 == 43 )
            {
              v59 = v2 + 3;
              v20 = v58 < 0xA;
              v58 = v90 - 2;
              if ( !v20 )
                goto LABEL_170;
            }
            else if ( v58 >= 9 )
            {
LABEL_170:
              v80 = 0LL;
              v77 = 0;
              while ( 1 )
              {
                v81 = (unsigned __int8)v59[v80];
                v82 = v81 - 48;
                if ( v81 >= 0x3A )
                  v82 = ((v81 - 65) & 0xFFFFFFDF) + 10;
                if ( v82 > 0xF || v77 > 0xFFFFFFF )
                  break;
                v77 = v82 | (16 * v77);
                if ( v58 == ++v80 )
                  goto LABEL_176;
              }
LABEL_3:
              v8 = (*(unsigned __int8 (__fastcall **)(_QWORD, unsigned __int8 *, unsigned __int64))(*(_QWORD *)(v3 + 56)
                                                                                                  + 24LL))(
                     *(_QWORD *)(v3 + 48),
                     v2,
                     v37) == 0;
              LODWORD(v2) = v99;
              v6 = v97;
              v7 = v96;
              if ( !v8 )
                return (unsigned int)v2;
              continue;
            }
          }
          v76 = 0LL;
          v77 = 0;
          do
          {
            v78 = (unsigned __int8)v59[v76];
            v79 = v78 - 48;
            if ( v78 >= 0x3A )
              v79 = ((v78 - 65) & 0xFFFFFFDF) + 10;
            if ( v79 > 0xF )
              goto LABEL_3;
            v77 = v79 | (16 * v77);
            ++v76;
          }
          while ( v58 != v76 );
LABEL_176:
          if ( (v77 ^ 0xD800) - 1114112 < 0xFFEF0800 )
            v77 = 1114112;
          if ( (v77 == 1114112) | (unsigned __int8)v62 ^ 1 )
            goto LABEL_3;
          v98 = v77;
          if ( v77 < 0x20 || v77 - 127 < 0x21 )
            goto LABEL_3;
          v83 = sub_408160(&v98, (_QWORD *)v3);
          v36 = v100;
          if ( v83 )
            goto LABEL_195;
          goto LABEL_68;
        }
        v56 = "@";
        if ( *(_WORD *)v48 != 20563 )
        {
          v56 = asc_449A78;
          if ( *(_WORD *)v48 != 20546 )
          {
            v56 = "&@";
            if ( *(_WORD *)v48 != 18002 )
            {
              v56 = "<&@";
              if ( *(_WORD *)v48 != 21580 )
              {
                v56 = "><&@";
                if ( *(_WORD *)v48 != 21575 )
                {
                  v56 = "(><&@";
                  if ( *(_WORD *)v48 != 20556 )
                  {
                    v56 = asc_448BDD;
                    if ( *(_WORD *)v48 != 20562 )
                    {
                      v54 = v13;
                      if ( v2[1] != 117 )
                        goto LABEL_3;
                      goto LABEL_124;
                    }
                  }
                }
              }
            }
          }
        }
      }
      v71 = (*(__int64 (__fastcall **)(_QWORD, char *, __int64))(*(_QWORD *)(v3 + 56) + 24LL))(
              *(_QWORD *)(v3 + 48),
              v56,
              1LL);
      v36 = v100;
      if ( v71 )
        goto LABEL_195;
      goto LABEL_68;
    }
    break;
  }
  if ( v22 != 1 && (char)v13[1] <= -65 )
  {
    v86 = &off_447048;
    goto LABEL_211;
  }
  v28 = (char *)(v13 + 1);
  while ( v28 != v5 )
  {
    v30 = (unsigned __int8)*v28;
    if ( (v30 & 0x80u) == 0 )
    {
      ++v28;
    }
    else
    {
      v31 = v30 & 0x1F;
      v32 = v28[1] & 0x3F;
      if ( (unsigned __int8)v30 <= 0xDFu )
      {
        v28 += 2;
        v30 = v32 | (v31 << 6);
      }
      else
      {
        v33 = (v32 << 6) | v28[2] & 0x3F;
        if ( (unsigned __int8)v30 < 0xF0u )
        {
          v28 += 3;
          v30 = (v31 << 12) | v33;
        }
        else
        {
          v30 = ((v30 & 7) << 18) | (v33 << 6) | v28[3] & 0x3F;
          if ( v30 == 1114112 )
            break;
          v28 += 4;
        }
      }
    }
    v29 = v30 - 48;
    if ( v30 >= 0x3A )
      v29 = ((v30 - 65) & 0xFFFFFFDE) + 10;
    if ( v29 >= 0x10 )
      goto LABEL_62;
  }
  LODWORD(v2) = 0;
  return (unsigned int)v2;
}
// 4109E2: variable 'v2' is possibly undefined
// 41112C: variable 'v84' is possibly undefined
// 447048: using guessed type char *off_447048;
// 447060: using guessed type char *off_447060;
// 447078: using guessed type char *off_447078;
// 447090: using guessed type char *off_447090;
// 4470A8: using guessed type char *off_4470A8;
// 4470C0: using guessed type char *off_4470C0;
// 4470E0: using guessed type char *off_4470E0;
// 4470F8: using guessed type char *off_4470F8;
// 447110: using guessed type char *off_447110;
// 447128: using guessed type char *off_447128;
// 447140: using guessed type char *off_447140;
// 447158: using guessed type char *off_447158;
// 447180: using guessed type char *off_447180;
// 4471A0: using guessed type char *off_4471A0;
// 4471B8: using guessed type char *off_4471B8;
// 4471D0: using guessed type char *off_4471D0;
// 448BDD: using guessed type char asc_448BDD;
// 449A78: using guessed type char asc_449A78;

//----- (0000000000411300) ----------------------------------------------------
__int64 __fastcall sub_411300(__int64 a1, __int64 a2)
{
  return (*(__int64 (__fastcall **)(_QWORD, const char *, __int64))(*(_QWORD *)(a2 + 56) + 24LL))(
           *(_QWORD *)(a2 + 48),
           aSizelimitexhau,
           18LL);
}

//----- (0000000000411330) ----------------------------------------------------
char __fastcall sub_411330(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  bool v3; // cf
  char v4; // al

  v3 = *(_QWORD *)(a1 + 8) < a3;
  *(_QWORD *)(a1 + 8) -= a3;
  v4 = *(_BYTE *)a1 | v3;
  *(_QWORD *)a1 = *(_BYTE *)a1 & 1u | v3;
  if ( (v4 & 1) != 0 )
    return 1;
  else
    return (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 56LL) + 24LL))(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 48LL));
}

//----- (0000000000411370) ----------------------------------------------------
char __fastcall sub_411370(__int64 a1, unsigned int a2)
{
  unsigned __int64 v2; // r8
  bool v3; // cf
  char v4; // dl
  char result; // al
  int v6; // [rsp+2Ch] [rbp-4h] BYREF

  v6 = 0;
  if ( a2 >= 0x80 )
  {
    if ( a2 >= 0x800 )
    {
      if ( a2 >= 0x10000 )
      {
        LOBYTE(v6) = (a2 >> 18) | 0xF0;
        BYTE1(v6) = (a2 >> 12) & 0x3F | 0x80;
        BYTE2(v6) = (a2 >> 6) & 0x3F | 0x80;
        HIBYTE(v6) = a2 & 0x3F | 0x80;
        v2 = 4LL;
      }
      else
      {
        LOBYTE(v6) = (a2 >> 12) | 0xE0;
        BYTE1(v6) = (a2 >> 6) & 0x3F | 0x80;
        BYTE2(v6) = a2 & 0x3F | 0x80;
        v2 = 3LL;
      }
    }
    else
    {
      LOBYTE(v6) = (a2 >> 6) | 0xC0;
      BYTE1(v6) = a2 & 0x3F | 0x80;
      v2 = 2LL;
    }
  }
  else
  {
    LOBYTE(v6) = a2;
    v2 = 1LL;
  }
  v3 = *(_QWORD *)(a1 + 8) < v2;
  *(_QWORD *)(a1 + 8) -= v2;
  v4 = *(_BYTE *)a1 | v3;
  *(_QWORD *)a1 = *(_BYTE *)a1 & 1u | v3;
  result = 1;
  if ( (v4 & 1) == 0 )
    return (*(__int64 (__fastcall **)(_QWORD, int *))(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 56LL) + 24LL))(
             *(_QWORD *)(*(_QWORD *)(a1 + 16) + 48LL),
             &v6);
  return result;
}

//----- (0000000000411450) ----------------------------------------------------
char __fastcall sub_411450(__int64 a1, _QWORD *a2)
{
  return sub_406180(a1, (__int64)&unk_446F80, a2);
}

//----- (0000000000411464) ----------------------------------------------------
void __fastcall __noreturn sub_411464(__int64 a1, __int64 a2)
{
  sub_411474(a1, a2);
}

//----- (0000000000411474) ----------------------------------------------------
void __fastcall __noreturn sub_411474(__int64 a1, __int64 a2)
{
  _BYTE v2[40]; // [rsp+0h] [rbp-40h] BYREF

  *(_QWORD *)&v2[40] = a1;
  *(_QWORD *)&v2[48] = a2;
  *(_QWORD *)&v2[56] = &off_447908;
  sub_4114A0((__int64)&v2[40]);
}
// 447908: using guessed type char *off_447908;

//----- (00000000004114A0) ----------------------------------------------------
void __fastcall __noreturn sub_4114A0(__int64 a1)
{
  sub_4114B0(a1);
}

//----- (00000000004114B0) ----------------------------------------------------
void __fastcall __noreturn sub_4114B0(__int64 a1)
{
  _OWORD v1[4]; // [rsp+0h] [rbp-40h] BYREF

  v1[3] = *(_OWORD *)a1;
  sub_411502((__int64)&v1[3], (__int64)&unk_449620, *(_QWORD *)(a1 + 16), 1, 0);
}

//----- (00000000004114E0) ----------------------------------------------------
__int64 __fastcall sub_4114E0(struct _EXCEPTION_RECORD *a1, void *a2, CONTEXT *a3, __int64 a4)
{
  return sub_43CFD0(a1, a2, a3, a4, (__int64 (__fastcall *)(__int64, __int64, __int64, __int64 *, __int64 *))sub_436B80);
}

//----- (0000000000411502) ----------------------------------------------------
void __fastcall __noreturn sub_411502(__int64 a1, __int64 a2, __int64 a3, char a4, char a5)
{
  _BYTE *v8; // rax
  int v9; // eax
  __int64 v10; // r15
  const char **v11; // rdi
  __int64 v12; // rdx
  __int64 v13; // r12
  unsigned int v14; // ebx
  __int64 (__fastcall *v15)(const char **); // rsi
  __int64 v16; // rax
  __int64 v17; // rdx
  __int64 v18; // rcx
  const char **v19; // rax
  const char *v20; // rax
  __int64 v21; // rcx
  DWORD v22; // ecx
  unsigned __int64 Value; // rax
  const char *v24; // rcx
  bool v25; // zf
  const char *v26; // rdx
  __int64 v27; // rcx
  __int64 v28; // rdi
  __int64 v29; // rdx
  _BYTE *v30; // rax
  _QWORD *v31; // rax
  __int64 v32; // rax
  __int64 v33; // rdx
  _QWORD *v34; // rbx
  _QWORD *v35; // r14
  __int64 v36; // rsi
  signed __int8 v37; // si
  char v38; // si
  __int64 v39; // rt0
  unsigned __int32 v40; // ecx
  int v41; // eax
  char v42; // al
  unsigned int v43; // eax
  signed __int32 v44; // eax
  signed __int32 v45; // eax
  int v46; // edx
  unsigned __int64 v47; // r8
  unsigned __int64 v48; // r13
  unsigned __int64 v49; // r14
  __int64 v50; // r12
  unsigned __int64 v51; // rdi
  WCHAR *v52; // r15
  unsigned __int64 v53; // rbx
  unsigned __int64 v54; // r8
  DWORD EnvironmentVariableW; // esi
  unsigned __int64 v56; // rbx
  char v57; // al
  unsigned __int64 v58; // rdi
  __int64 v59; // r15
  unsigned __int64 v60; // r15
  _QWORD *v61; // r12
  __int64 v62; // rsi
  HANDLE ProcessHeap; // rax
  signed __int8 v64; // al
  __int64 v65; // rax
  __m128i *v66; // rcx
  __int64 v67; // rax
  __int64 v68; // rdx
  __int64 v69; // r8
  _QWORD CompareAddress[128]; // [rsp+30h] [rbp-50h] BYREF
  __int64 v71; // [rsp+430h] [rbp+3B0h] BYREF
  _QWORD v72[2]; // [rsp+438h] [rbp+3B8h] BYREF
  unsigned __int64 v73; // [rsp+448h] [rbp+3C8h]
  _QWORD v74[2]; // [rsp+450h] [rbp+3D0h] BYREF
  _QWORD v75[2]; // [rsp+460h] [rbp+3E0h] BYREF
  __int64 v76; // [rsp+470h] [rbp+3F0h] BYREF
  __int128 v77; // [rsp+478h] [rbp+3F8h] BYREF
  __int64 v78; // [rsp+488h] [rbp+408h]
  __int128 v79; // [rsp+490h] [rbp+410h]
  __int64 v80; // [rsp+4A8h] [rbp+428h]
  __int64 v81; // [rsp+4B0h] [rbp+430h] BYREF
  __int64 *v82; // [rsp+4B8h] [rbp+438h]
  __int64 v83; // [rsp+4C0h] [rbp+440h] BYREF
  __int64 v84; // [rsp+4C8h] [rbp+448h]
  LPCWSTR lpName; // [rsp+4D0h] [rbp+450h]
  __int64 v86; // [rsp+4D8h] [rbp+458h]
  __int64 v87; // [rsp+4E0h] [rbp+460h] BYREF
  __int64 v88; // [rsp+4E8h] [rbp+468h]
  __m128i v89; // [rsp+4F0h] [rbp+470h] BYREF
  _QWORD *v90; // [rsp+500h] [rbp+480h]
  const char **v91; // [rsp+508h] [rbp+488h]
  __int64 v92; // [rsp+510h] [rbp+490h]
  int v93; // [rsp+518h] [rbp+498h] BYREF
  char v94; // [rsp+51Ch] [rbp+49Ch]
  char v95; // [rsp+51Fh] [rbp+49Fh]

  v83 = a1;
  v84 = a2;
  v87 = a3;
  if ( _InterlockedIncrement64(&qword_4500D0) <= 0 )
  {
    LODWORD(v72[0]) = 0;
    BYTE4(v72[0]) = 0;
    *(_QWORD *)&v77 = &v87;
    *((_QWORD *)&v77 + 1) = sub_4121E0;
    v78 = (__int64)&v83;
    CompareAddress[0] = &off_449680;
    CompareAddress[1] = 3LL;
    CompareAddress[4] = 0LL;
    *(_QWORD *)&v79 = sub_406140;
    CompareAddress[2] = &v77;
    CompareAddress[3] = 2LL;
    v65 = sub_412270((__int64)v72, CompareAddress);
    v66 = &v89;
  }
  else
  {
    v8 = sub_412420();
    if ( !v8 )
      goto LABEL_23;
    if ( !v8[8] )
    {
      ++*(_QWORD *)v8;
      v8[8] = 1;
      v9 = dword_4500B0;
      if ( (unsigned int)dword_4500B0 <= 0x3FFFFFFD
        && v9 == _InterlockedCompareExchange(&dword_4500B0, dword_4500B0 + 1, dword_4500B0) )
      {
LABEL_6:
        if ( !qword_4500C0 )
        {
          v10 = v87;
          v11 = (const char **)(*(__int64 (__fastcall **)(__int64))(v84 + 40))(v83);
          v13 = v12;
          LOBYTE(v14) = 3;
          if ( a5 )
            goto LABEL_8;
          v31 = sub_412420();
          if ( !v31 )
            sub_406F40((__int64)aCannotAccessAT, 70LL, (__int64)CompareAddress, (__int64)"", (__int64)&off_448718);
          LOBYTE(v14) = 1;
          if ( *v31 > 1uLL )
            goto LABEL_8;
          LOBYTE(v14) = byte_4500A8 - 1;
          if ( (unsigned __int8)(byte_4500A8 - 1) < 3u )
            goto LABEL_8;
LABEL_32:
          sub_4329C0((__int64)CompareAddress, byte_4487BD, 14LL);
          if ( __OFSUB__(-CompareAddress[0], 1LL) )
          {
            if ( (CompareAddress[1] & 3) == 1 )
            {
              v34 = (_QWORD *)(CompareAddress[1] - 1LL);
              v35 = *(_QWORD **)(CompareAddress[1] - 1LL);
              v36 = *(_QWORD *)(CompareAddress[1] + 7LL);
              if ( *(_QWORD *)v36 )
                (*(void (__fastcall **)(_QWORD *))v36)(v35);
              if ( *(_QWORD *)(v36 + 8) )
                sub_403D80(v35, *(_QWORD *)(v36 + 16));
              sub_403D80(v34, 8uLL);
            }
            LOBYTE(v14) = 2;
            v37 = 3;
            goto LABEL_138;
          }
          v88 = CompareAddress[0];
          v86 = v13;
          v92 = v10;
          v91 = v11;
          v95 = a4;
          v89.m128i_i64[0] = 0LL;
          v89.m128i_i64[1] = 2LL;
          v90 = 0LL;
          lpName = (LPCWSTR)CompareAddress[1];
          v47 = 512LL;
          v48 = 0LL;
          v80 = 2LL;
          v49 = 0LL;
          v50 = 0LL;
          while ( 1 )
          {
            if ( v47 >= 0x201 )
            {
              v54 = v47 - v50;
              if ( v49 - v50 < v54 )
              {
                sub_413290((unsigned __int64 *)&v89, v50, v54, 2LL, 2LL);
                v80 = v89.m128i_i64[1];
                v48 = v89.m128i_i64[0];
              }
              v50 = 0xFFFFFFFFLL;
              if ( v48 < 0xFFFFFFFF )
                v50 = v48;
              v90 = (_QWORD *)v50;
              v49 = v48;
              v51 = v50;
              v52 = (WCHAR *)v80;
              v53 = v50;
            }
            else
            {
              v51 = 512LL;
              v52 = (WCHAR *)CompareAddress;
              v53 = v47;
            }
            SetLastError(0);
            EnvironmentVariableW = GetEnvironmentVariableW(lpName, v52, v53);
            if ( !EnvironmentVariableW )
            {
              if ( GetLastError() )
                break;
            }
            v47 = EnvironmentVariableW;
            if ( v53 == EnvironmentVariableW )
            {
              if ( GetLastError() != 122 )
                sub_405FC0((__int64)"internal error: entered unreachable code", 40LL, (__int64)&off_449FC0);
              v56 = 2 * v53;
              if ( v56 >= 0xFFFFFFFF )
                v56 = 0xFFFFFFFFLL;
              v47 = v56;
            }
            else if ( v53 >= EnvironmentVariableW )
            {
              if ( v51 < EnvironmentVariableW )
                sub_405B00(EnvironmentVariableW, v51, (__int64)&off_449FA8);
              sub_414CB0(&v77, v52, EnvironmentVariableW);
              a4 = v95;
              v13 = v86;
              v59 = *((_QWORD *)&v77 + 1);
              v58 = v77;
              v49 = v78;
              if ( v89.m128i_i64[0] )
                sub_403D80((_QWORD *)v89.m128i_i64[1], 2uLL);
              if ( v58 != 0x8000000000000000uLL )
              {
LABEL_122:
                if ( v88 )
                  sub_403D80(lpName, 2uLL);
                LOBYTE(v14) = 2;
                v37 = 3;
                if ( v58 == 0x8000000000000000uLL )
                  goto LABEL_137;
                if ( v49 == 4 )
                {
                  if ( *(_DWORD *)v59 != 1819047270 )
                    goto LABEL_133;
                  LOBYTE(v14) = 1;
                  v37 = 2;
                }
                else if ( v49 != 1 || *(_BYTE *)v59 != 48 )
                {
LABEL_133:
                  v37 = 1;
                  if ( !v58 )
                  {
                    LOBYTE(v14) = 0;
                    goto LABEL_137;
                  }
                  ProcessHeap = GetProcessHeap();
                  LOBYTE(v14) = 0;
LABEL_136:
                  HeapFree(ProcessHeap, 0, (LPVOID)v59);
LABEL_137:
                  v11 = v91;
                  v10 = v92;
LABEL_138:
                  v64 = _InterlockedCompareExchange8(&byte_4500A8, v37, 0);
                  if ( v64 )
                  {
                    LOBYTE(v14) = 3;
                    if ( (unsigned __int8)v64 < 4u )
                      v14 = 0x2010003u >> (8 * v64);
                  }
LABEL_8:
                  v76 = v10;
                  v15 = *(__int64 (__fastcall **)(const char **))(v13 + 24);
                  v16 = v15(v11);
                  if ( !(v16 ^ 0xB98B1B7157A64178uLL | v17 ^ 0x63EB502CD6CB5D6DLL) )
                  {
                    v18 = 1LL;
                    v19 = v11;
                    goto LABEL_10;
                  }
                  v32 = v15(v11);
                  if ( v32 ^ 0x855AD7BC9E1B7232uLL | v33 ^ 0x3A47F4C020A438C6LL )
                  {
                    v20 = aBoxDynAny;
                    v21 = 12LL;
                  }
                  else
                  {
                    v19 = v11 + 1;
                    v18 = 2LL;
LABEL_10:
                    v20 = *v19;
                    v21 = (__int64)v11[v18];
                  }
                  v74[0] = v20;
                  v74[1] = v21;
                  if ( dword_450120 )
                    v22 = dword_450120 - 1;
                  else
                    v22 = sub_412510((signed __int64)&unk_450108);
                  Value = (unsigned __int64)TlsGetValue(v22);
                  if ( Value < 3 )
                  {
                    v27 = 9LL;
                    v81 = 2LL;
                    v26 = "<unnamed>";
                  }
                  else
                  {
                    if ( (__int64 *)Value == &qword_450038 )
                    {
                      v81 = 0LL;
                      Value = 4LL;
                      v82 = &qword_450038;
                      v24 = aMain_0;
                    }
                    else
                    {
                      v39 = _InterlockedIncrement64((volatile signed __int64 *)(Value - 16));
                      if ( (v39 < 0) ^ __OFSUB__(Value, &qword_450038) | (v39 == 0) )
                        BUG();
                      v81 = 1LL;
                      v82 = (__int64 *)(Value - 16);
                      v24 = *(const char **)(Value + 8);
                      if ( v24 )
                        Value = *(_QWORD *)(Value + 16) - 1LL;
                      else
                        v24 = 0LL;
                    }
                    v25 = v24 == 0LL;
                    v26 = "<unnamed>";
                    if ( v24 )
                      v26 = v24;
                    v27 = 9LL;
                    if ( !v25 )
                      v27 = Value;
                  }
                  v75[0] = v26;
                  v75[1] = v27;
                  v93 = 0;
                  v94 = 0;
                  if ( _InterlockedCompareExchange8(&byte_4500A9, 1, 0) )
                    sub_413070(&byte_4500A9);
                  v38 = (qword_4500D0 & 0x7FFFFFFFFFFFFFFFLL) != 0 && !sub_413120();
                  v11 = (const char **)CompareAddress;
                  memset(CompareAddress, 0, 0x200uLL);
                  v72[0] = CompareAddress;
                  v72[1] = 512LL;
                  v73 = 0LL;
                  v89 = _mm_unpacklo_epi64((__m128i)(unsigned __int64)v75, (__m128i)(unsigned __int64)&v76);
                  v90 = v74;
                  *(_QWORD *)&v77 = sub_413520(v89.m128i_i64, (__int64)v72, sub_4133F0);
                  if ( !(_QWORD)v77 )
                  {
                    sub_4123A0((__int64 *)&v77);
                    if ( v73 < 0x201 )
                    {
                      *(_QWORD *)&v77 = sub_412EF0((unsigned __int8 *)&v93, (unsigned __int8 *)CompareAddress, v73);
                      sub_4123A0((__int64 *)&v77);
                      switch ( (char)v14 )
                      {
                        case 0:
                          goto LABEL_51;
                        case 1:
                          goto LABEL_102;
                        case 2:
                          goto LABEL_103;
                        default:
                          goto LABEL_32;
                      }
                    }
                    sub_405B00(v73, 512LL, (__int64)&off_4494A0);
                  }
                  sub_4123A0((__int64 *)&v77);
                  *(_QWORD *)&v77 = sub_413520(v89.m128i_i64, (__int64)&v93, sub_412270);
                  sub_4123A0((__int64 *)&v77);
                  switch ( (char)v14 )
                  {
                    case 0:
LABEL_51:
                      *(_QWORD *)&v77 = sub_4135B0((__int64)&v93, 0);
                      sub_4123A0((__int64 *)&v77);
                      goto LABEL_105;
                    case 1:
LABEL_102:
                      *(_QWORD *)&v77 = sub_4135B0((__int64)&v93, 1);
                      sub_4123A0((__int64 *)&v77);
                      goto LABEL_105;
                    case 2:
LABEL_103:
                      v57 = byte_43F018;
                      byte_43F018 = 0;
                      if ( v57 )
                      {
                        *(_QWORD *)&v77 = &off_449508;
                        *((_QWORD *)&v77 + 1) = 1LL;
                        v78 = 8LL;
                        v79 = 0LL;
                        v71 = sub_412270((__int64)&v93, &v77);
                        sub_4123A0(&v71);
                      }
LABEL_105:
                      sub_413170(&byte_4500A9, v38);
                      sub_412EC0(&v81);
                      goto LABEL_22;
                    default:
                      goto LABEL_32;
                  }
                }
                if ( !v58 )
                  goto LABEL_137;
                ProcessHeap = GetProcessHeap();
                goto LABEL_136;
              }
LABEL_115:
              if ( (v59 & 3) == 1 )
              {
                v61 = *(_QWORD **)(v59 - 1);
                v62 = *(_QWORD *)(v59 + 7);
                if ( *(_QWORD *)v62 )
                  (*(void (__fastcall **)(_QWORD))v62)(*(_QWORD *)(v59 - 1));
                if ( *(_QWORD *)(v62 + 8) )
                  sub_403D80(v61, *(_QWORD *)(v62 + 16));
                sub_403D80((_QWORD *)(v59 - 1), 8uLL);
                v58 = 0x8000000000000000uLL;
                v13 = v86;
              }
              else
              {
                v58 = 0x8000000000000000uLL;
              }
              goto LABEL_122;
            }
          }
          v60 = (unsigned __int64)GetLastError() << 32;
          if ( v89.m128i_i64[0] )
            sub_403D80((_QWORD *)v89.m128i_i64[1], 2uLL);
          v59 = v60 | 2;
          a4 = v95;
          v13 = v86;
          goto LABEL_115;
        }
        v28 = v87;
        CompareAddress[0] = (*(__int64 (__fastcall **)(__int64))(v84 + 40))(v83);
        CompareAddress[1] = v29;
        CompareAddress[2] = v28;
        LOBYTE(CompareAddress[3]) = a4;
        BYTE1(CompareAddress[3]) = a5;
        (*(void (__fastcall **)(__int64, _QWORD *))(qword_4500C8 + 40))(qword_4500C0, CompareAddress);
LABEL_22:
        sub_4123E0();
        v30 = sub_412420();
        if ( v30 )
        {
          v30[8] = 0;
          if ( a4 )
            sub_412410();
          v89.m128i_i32[0] = 0;
          v89.m128i_i8[4] = 0;
          CompareAddress[0] = &off_449748;
          CompareAddress[1] = 1LL;
          CompareAddress[2] = 8LL;
          *(_OWORD *)&CompareAddress[3] = 0LL;
          *(_QWORD *)&v77 = sub_412270((__int64)&v89, CompareAddress);
          sub_4123A0((__int64 *)&v77);
          __fastfail(7u);
        }
LABEL_23:
        sub_406F40((__int64)aCannotAccessAT, 70LL, (__int64)CompareAddress, (__int64)"", (__int64)&off_448718);
      }
      v40 = dword_4500B0;
      if ( dword_4500B0 == 0x3FFFFFFF )
      {
        v41 = -99;
        do
        {
          _mm_pause();
          v40 = dword_4500B0;
          if ( dword_4500B0 != 0x3FFFFFFF )
            break;
          v25 = v41++ == 0;
        }
        while ( !v25 );
      }
      v42 = 0;
LABEL_61:
      if ( (v42 & 1) != 0 )
      {
        while ( 1 )
        {
          v43 = v40 & 0x3FFFFFFF;
          if ( (v40 & 0x3FFFFFFF) - 1073741822 >= 0xC0000003 && (v40 & 0x40000000) == 0
            || v40 < 0x40000000 && v43 < 0x3FFFFFFE )
          {
            v44 = _InterlockedCompareExchange(&dword_4500B0, v40 + 1, v40);
            if ( v40 == v44 )
              goto LABEL_6;
          }
          else
          {
            if ( v43 == 1073741822 )
              goto LABEL_84;
            if ( (v40 & 0x40000000) != 0 )
              goto LABEL_77;
            v44 = _InterlockedCompareExchange(&dword_4500B0, v40 | 0x40000000, v40);
            if ( v40 == v44 )
              goto LABEL_77;
          }
          v40 = v44;
        }
      }
      while ( 1 )
      {
        if ( (v40 & 0x3FFFFFFF) >= 0x3FFFFFFE || v40 >= 0x40000000 )
        {
          if ( (v40 & 0x3FFFFFFF) == 0x3FFFFFFE )
          {
LABEL_84:
            CompareAddress[0] = &off_44A1B8;
            CompareAddress[1] = 1LL;
            CompareAddress[2] = 8LL;
            *(_OWORD *)&CompareAddress[3] = 0LL;
            sub_405240(CompareAddress, &off_44A1F0);
          }
          if ( (v40 & 0x40000000) != 0
            || (v45 = _InterlockedCompareExchange(&dword_4500B0, v40 | 0x40000000, v40), v40 == v45) )
          {
LABEL_77:
            LODWORD(CompareAddress[0]) = v40 | 0x40000000;
            if ( !WaitOnAddress(&dword_4500B0, CompareAddress, 4uLL, 0xFFFFFFFF) )
              GetLastError();
            v40 = dword_4500B0;
            v42 = 1;
            if ( dword_4500B0 == 0x3FFFFFFF )
            {
              v46 = -99;
              do
              {
                _mm_pause();
                v40 = dword_4500B0;
                if ( dword_4500B0 != 0x3FFFFFFF )
                  break;
                v25 = v46++ == 0;
              }
              while ( !v25 );
            }
            goto LABEL_61;
          }
        }
        else
        {
          v45 = _InterlockedCompareExchange(&dword_4500B0, v40 + 1, v40);
          if ( v40 == v45 )
            goto LABEL_6;
        }
        v40 = v45;
      }
    }
    v67 = (*(__int64 (__fastcall **)(__int64))(a2 + 48))(a1);
    v69 = 1LL;
    if ( v67 )
      v69 = v67;
    else
      v68 = 0LL;
    LODWORD(v75[0]) = 0;
    v89.m128i_i64[0] = v69;
    v89.m128i_i64[1] = v68;
    BYTE4(v75[0]) = 0;
    *(_QWORD *)&v77 = &v87;
    *((_QWORD *)&v77 + 1) = sub_4121E0;
    v78 = (__int64)&v89;
    CompareAddress[0] = &off_4496E8;
    CompareAddress[1] = 3LL;
    CompareAddress[4] = 0LL;
    *(_QWORD *)&v79 = sub_4123C0;
    CompareAddress[2] = &v77;
    CompareAddress[3] = 2LL;
    v65 = sub_412270((__int64)v75, CompareAddress);
    v66 = (__m128i *)v72;
  }
  v66->m128i_i64[0] = v65;
  sub_4123A0(v66->m128i_i64);
  __fastfail(7u);
}
// 4115C8: variable 'v12' is possibly undefined
// 4115FE: variable 'v17' is possibly undefined
// 4116A6: variable 'v29' is possibly undefined
// 411762: variable 'v33' is possibly undefined
// 412055: variable 'v68' is possibly undefined
// 405240: using guessed type void __fastcall __noreturn sub_405240(_QWORD, _QWORD);
// 43F018: using guessed type char byte_43F018;
// 448718: using guessed type char *off_448718;
// 4487BD: using guessed type unsigned __int8[14];
// 4494A0: using guessed type char *off_4494A0;
// 449508: using guessed type char *off_449508;
// 449680: using guessed type char *off_449680;
// 4496E8: using guessed type char *off_4496E8;
// 449748: using guessed type char *off_449748;
// 449FA8: using guessed type char *off_449FA8;
// 449FC0: using guessed type char *off_449FC0;
// 44A1B8: using guessed type char *off_44A1B8;
// 44A1F0: using guessed type char *off_44A1F0;
// 450038: using guessed type __int64 qword_450038;
// 4500A8: using guessed type char byte_4500A8;
// 4500A9: using guessed type char byte_4500A9;
// 4500B0: using guessed type int dword_4500B0;
// 4500C0: using guessed type __int64 qword_4500C0;
// 4500C8: using guessed type __int64 qword_4500C8;
// 4500D0: using guessed type __int64 qword_4500D0;
// 450120: using guessed type int dword_450120;

//----- (00000000004121E0) ----------------------------------------------------
char __fastcall sub_4121E0(__int64 *a1, __int64 a2)
{
  __int64 v2; // rax
  __int64 v3; // rcx
  __int64 v4; // rdx
  _QWORD v6[16]; // [rsp+0h] [rbp-80h] BYREF

  v2 = *a1;
  v3 = *(_QWORD *)(a2 + 48);
  v4 = *(_QWORD *)(a2 + 56);
  v6[10] = v2;
  v6[11] = sub_4123C0;
  v6[12] = v2 + 16;
  v6[13] = sub_4063D0;
  v6[14] = v2 + 20;
  v6[15] = sub_4063D0;
  v6[4] = &unk_448118;
  v6[5] = 3LL;
  v6[8] = 0LL;
  v6[6] = &v6[10];
  v6[7] = 3LL;
  return sub_406180(v3, v4, &v6[4]);
}

//----- (0000000000412270) ----------------------------------------------------
__int64 __fastcall sub_412270(__int64 a1, _QWORD *a2)
{
  char v2; // cl
  __int64 result; // rax
  void *v4; // rsi
  _QWORD *v5; // rbx
  __int64 v6; // r14
  HANDLE ProcessHeap; // rax
  HANDLE v8; // rax
  __int64 v9; // [rsp+0h] [rbp-60h] BYREF
  _QWORD v10[3]; // [rsp+20h] [rbp-40h] BYREF
  __int128 v11; // [rsp+38h] [rbp-28h]
  __int64 v12; // [rsp+50h] [rbp-10h]
  __int64 v13; // [rsp+58h] [rbp-8h]

  v12 = a1;
  v13 = 0LL;
  v2 = sub_406180((__int64)(&v9 + 10), (__int64)&off_448208, a2);
  result = v13;
  if ( v2 )
  {
    if ( !v13 )
    {
      v10[0] = &off_448D98;
      v10[1] = 1LL;
      v10[2] = 8LL;
      v11 = 0LL;
      sub_405240(v10, &off_448DA8);
    }
  }
  else
  {
    if ( (v13 & 3) == 1 )
    {
      v4 = (void *)(v13 - 1);
      v5 = *(_QWORD **)(v13 - 1);
      v6 = *(_QWORD *)(v13 + 7);
      if ( *(_QWORD *)v6 )
        (*(void (__fastcall **)(_QWORD *))v6)(v5);
      if ( *(_QWORD *)(v6 + 8) )
      {
        if ( *(_QWORD *)(v6 + 16) >= 0x11uLL )
          v5 = (_QWORD *)*(v5 - 1);
        ProcessHeap = GetProcessHeap();
        HeapFree(ProcessHeap, 0, v5);
      }
      v8 = GetProcessHeap();
      HeapFree(v8, 0, v4);
    }
    return 0LL;
  }
  return result;
}
// 405240: using guessed type void __fastcall __noreturn sub_405240(_QWORD, _QWORD);
// 448208: using guessed type __int64 (__fastcall *off_448208)();
// 448D98: using guessed type char *off_448D98;
// 448DA8: using guessed type char *off_448DA8;

//----- (00000000004123A0) ----------------------------------------------------
int __fastcall sub_4123A0(__int64 *a1)
{
  __int64 v1; // rcx
  int result; // eax

  v1 = *a1;
  if ( v1 )
    return sub_4131C0(v1);
  return result;
}

//----- (00000000004123C0) ----------------------------------------------------
char __fastcall sub_4123C0(__int64 a1, __int64 a2)
{
  return sub_405B80(a2, *(unsigned __int16 **)a1, *(_QWORD *)(a1 + 8));
}

//----- (00000000004123E0) ----------------------------------------------------
void sub_4123E0()
{
  signed __int32 v0; // edx

  v0 = _InterlockedDecrement(&dword_4500B0);
  if ( __OFSUB__(-(v0 & 0xBFFFFFFF), 1) )
    sub_436870(&dword_4500B0, v0);
}
// 4500B0: using guessed type int dword_4500B0;

//----- (0000000000412410) ----------------------------------------------------
void __noreturn sub_412410()
{
  __fastfail(7u);
}

//----- (0000000000412420) ----------------------------------------------------
LPVOID sub_412420()
{
  DWORD v0; // esi
  LPVOID result; // rax
  bool v2; // zf
  _BYTE *v3; // rax
  void *v4; // rbx
  void *Value; // rdi
  HANDLE ProcessHeap; // rax

  if ( dword_43F070 )
  {
    v0 = dword_43F070 - 1;
    result = TlsGetValue(dword_43F070 - 1);
    v2 = result == (LPVOID)1;
    if ( (unsigned __int64)result > 1 )
      return result;
  }
  else
  {
    v0 = sub_412510((signed __int64)&off_43F058);
    result = TlsGetValue(v0);
    v2 = result == (LPVOID)1;
    if ( (unsigned __int64)result > 1 )
      return result;
  }
  if ( v2 )
    return 0LL;
  v3 = sub_43C4F0(0x18uLL);
  if ( !v3 )
    sub_4040E9(8LL, 24LL);
  *(_QWORD *)v3 = 0LL;
  v3[8] = 0;
  *((_DWORD *)v3 + 4) = v0;
  v4 = v3;
  Value = TlsGetValue(v0);
  TlsSetValue(v0, v4);
  if ( Value )
  {
    ProcessHeap = GetProcessHeap();
    HeapFree(ProcessHeap, 0, Value);
  }
  return v4;
}
// 43F058: using guessed type __int64 (__fastcall *off_43F058)(LPVOID lpMem);
// 43F070: using guessed type int dword_43F070;

//----- (00000000004124E0) ----------------------------------------------------
__int64 __fastcall sub_4124E0(__int64 a1, __int64 a2)
{
  return (*(__int64 (__fastcall **)(_QWORD, const char *, __int64))(*(_QWORD *)(a2 + 56) + 24LL))(
           *(_QWORD *)(a2 + 48),
           aAccesserror,
           11LL);
}

//----- (0000000000412510) ----------------------------------------------------
__int64 __fastcall sub_412510(signed __int64 a1)
{
  DWORD v2; // eax
  DWORD v3; // edi
  signed __int64 v4; // rax
  signed __int64 v5; // rtt
  DWORD v6; // eax
  signed __int32 v7; // eax
  signed __int32 v8; // edi
  __int128 v10; // [rsp+28h] [rbp-38h] BYREF
  __int64 v11; // [rsp+38h] [rbp-28h]
  __int128 v12; // [rsp+40h] [rbp-20h]
  BOOL inited; // [rsp+5Ch] [rbp-4h] BYREF
  WINBOOL fPending; // [rsp+60h] [rbp+0h] BYREF
  DWORD dwTlsIndex[7]; // [rsp+64h] [rbp+4h] BYREF

  if ( !*(_QWORD *)a1 )
  {
    v6 = TlsAlloc();
    dwTlsIndex[0] = v6;
    if ( v6 == -1 )
    {
      *(_QWORD *)&v10 = &off_44A2A8;
      *((_QWORD *)&v10 + 1) = 1LL;
      v11 = 8LL;
      v12 = 0LL;
      sub_4126B2((__int64)dwTlsIndex, &v10);
    }
    v7 = _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 24), v6 + 1, 0);
    if ( !v7 )
      return dwTlsIndex[0];
    v8 = v7;
    TlsFree(dwTlsIndex[0]);
    return (DWORD)(v8 - 1);
  }
  fPending = 0;
  inited = InitOnceBeginInitialize((LPINIT_ONCE)(a1 + 16), 0, &fPending, 0LL);
  if ( !inited )
  {
    *(_QWORD *)&v10 = 0LL;
    sub_41266B((__int64)&inited, &v10);
  }
  if ( !fPending )
  {
    v8 = *(_DWORD *)(a1 + 24);
    return (DWORD)(v8 - 1);
  }
  v2 = TlsAlloc();
  if ( v2 == -1 )
  {
    InitOnceComplete((LPINIT_ONCE)(a1 + 16), 4u, 0LL);
    *(_QWORD *)&v10 = &off_44A2A8;
    *((_QWORD *)&v10 + 1) = 1LL;
    v11 = 8LL;
    v12 = 0LL;
    sub_405240(&v10, &off_44A2B8);
  }
  v3 = v2;
  v4 = qword_4500E0;
  do
  {
    *(_QWORD *)(a1 + 8) = v4;
    v5 = v4;
    v4 = _InterlockedCompareExchange64(&qword_4500E0, a1, v4);
  }
  while ( v5 != v4 );
  *(_DWORD *)(a1 + 24) = v3 + 1;
  InitOnceComplete((LPINIT_ONCE)(a1 + 16), 0, 0LL);
  return v3;
}
// 405240: using guessed type void __fastcall __noreturn sub_405240(_QWORD, _QWORD);
// 44A2A8: using guessed type char *off_44A2A8;
// 44A2B8: using guessed type char *off_44A2B8;
// 4500E0: using guessed type __int64 qword_4500E0;
// 453040: using guessed type __int64 (__fastcall *TlsCallbacks[3])();

//----- (000000000041266B) ----------------------------------------------------
void __fastcall __noreturn sub_41266B(__int64 a1, __int128 *a2)
{
  _QWORD *v2; // r9
  _BYTE v3[32]; // [rsp+0h] [rbp-50h] BYREF

  *(_QWORD *)&v3[72] = a1;
  v2 = &v3[64];
  *v2 = &unk_449BD8;
  sub_405FFE(0, (__int64)&v3[72], (__int64)&unk_447C00, (__int64)v2, (__int64)&unk_447C00, a2, (__int64)&off_44A278);
}
// 44A278: using guessed type char *off_44A278;

//----- (00000000004126B2) ----------------------------------------------------
void __fastcall __noreturn sub_4126B2(__int64 a1, __int128 *a2)
{
  _QWORD *v2; // r9
  _BYTE v3[32]; // [rsp+0h] [rbp-50h] BYREF

  *(_QWORD *)&v3[72] = a1;
  v2 = &v3[64];
  *v2 = &unk_44A2D0;
  sub_405FFE(1, (__int64)&v3[72], (__int64)&unk_447C20, (__int64)v2, (__int64)&unk_447C20, a2, (__int64)&off_44A2D8);
}
// 44A2D8: using guessed type char *off_44A2D8;

//----- (0000000000412700) ----------------------------------------------------
__int64 __fastcall sub_412700(unsigned int **a1, __int64 a2)
{
  unsigned int *v2; // rax
  int v3; // ecx
  __int64 v4; // r8
  __int64 v5; // rcx
  __int64 v6; // r11
  unsigned int v7; // r10d
  bool v8; // cc
  __int64 v9; // rcx
  unsigned int v10; // eax
  __int64 v11; // r9
  unsigned int v12; // r8d
  __int64 v13; // rcx
  char v14; // r10
  unsigned int v15; // eax
  unsigned int v16; // r8d
  char v17; // r10
  _WORD v19[74]; // [rsp+2Ch] [rbp-54h] BYREF

  v2 = *a1;
  v3 = *(_DWORD *)(a2 + 36);
  if ( (v3 & 0x10) != 0 )
  {
    v10 = *v2;
    v11 = 129LL;
    v12 = v10;
    do
    {
      v13 = v11;
      v12 >>= 4;
      v14 = (v10 & 0xF) + 87;
      if ( (v10 & 0xF) < 0xA )
        v14 = (v10 & 0xF) + 48;
      *((_BYTE *)&v19[1] + v11--) = v14;
      v8 = v10 <= 0xF;
      v10 = v12;
    }
    while ( !v8 );
    return sub_405270(a2, 1, (__int64)a0x, 2LL, (__int64)&v19[1] + v13, 129 - v11);
  }
  if ( (v3 & 0x20) != 0 )
  {
    v15 = *v2;
    v11 = 129LL;
    v16 = v15;
    do
    {
      v13 = v11;
      v16 >>= 4;
      v17 = (v15 & 0xF) + 55;
      if ( (v15 & 0xF) < 0xA )
        v17 = (v15 & 0xF) + 48;
      *((_BYTE *)&v19[1] + v11--) = v17;
      v8 = v15 <= 0xF;
      v15 = v16;
    }
    while ( !v8 );
    return sub_405270(a2, 1, (__int64)a0x, 2LL, (__int64)&v19[1] + v13, 129 - v11);
  }
  LODWORD(v4) = *v2;
  v5 = 10LL;
  if ( *v2 < 0x2710 )
  {
    v4 = (unsigned int)v4;
    if ( (unsigned int)v4 <= 0x63 )
      goto LABEL_8;
    goto LABEL_7;
  }
  v6 = 5LL;
  do
  {
    v7 = (unsigned int)v4 / 0x2710;
    v5 = v6 * 2 - 4;
    v19[v6] = a0001020304[(5243 * ((unsigned int)v4 % 0x2710)) >> 19];
    v19[v6 + 1] = a0001020304[(unsigned __int16)((unsigned int)v4 % 0x2710
                                               - 100
                                               * ((unsigned __int16)((5243 * ((unsigned int)v4 % 0x2710)) >> 16) >> 3))];
    v6 -= 2LL;
    v8 = (unsigned int)v4 <= 0x5F5E0FF;
    LODWORD(v4) = (unsigned int)v4 / 0x2710;
  }
  while ( !v8 );
  v4 = v7;
  if ( v7 > 0x63 )
  {
LABEL_7:
    *(_WORD *)((char *)&v19[1] + v5) = a0001020304[(unsigned __int16)v4 % 0x64u];
    v5 -= 2LL;
    v4 = (unsigned int)(5243 * ((unsigned __int16)v4 >> 2)) >> 17;
  }
LABEL_8:
  if ( (unsigned int)v4 >= 0xA )
  {
    *(_WORD *)((char *)&v19[1] + v5) = a0001020304[v4];
    v9 = v5 - 2;
  }
  else
  {
    *((_BYTE *)&v19[1] + v5 + 1) = v4 | 0x30;
    v9 = v5 - 1;
  }
  return sub_405270(a2, 1, 1LL, 0LL, (__int64)&v19[2] + v9, 10 - v9);
}
// 4428DB: using guessed type _WORD a0001020304[100];

//----- (0000000000412930) ----------------------------------------------------
void __fastcall TlsCallback_0(__int64 a1, int a2)
{
  __int64 v2; // rdi
  char v3; // bl
  int v4; // esi
  void (__fastcall *v5)(LPVOID); // r14
  DWORD v6; // esi
  LPVOID Value; // rax
  DWORD v8; // ecx
  LPVOID v9; // rsi
  __int64 v10; // rdi
  char v11; // bl
  int v12; // esi
  void (__fastcall *v13)(LPVOID); // r14
  DWORD v14; // esi
  LPVOID v15; // rax
  DWORD v16; // ecx
  LPVOID v17; // rsi
  __int64 v18; // rdi
  char v19; // bl
  int v20; // esi
  void (__fastcall *v21)(LPVOID); // r14
  DWORD v22; // esi
  LPVOID v23; // rax
  DWORD v24; // ecx
  LPVOID v25; // rsi
  __int64 v26; // rdi
  char v27; // bl
  int v28; // esi
  void (__fastcall *v29)(LPVOID); // r14
  DWORD v30; // esi
  LPVOID v31; // rax
  DWORD v32; // ecx
  LPVOID v33; // rsi
  __int64 v34; // rbx
  int v35; // esi
  void (__fastcall *v36)(LPVOID); // r14
  DWORD v37; // esi
  LPVOID v38; // rax
  LPVOID v39; // rdi
  __int64 *v40; // rax
  __int64 *v41; // rsi
  DWORD v42; // ecx
  __int64 *v43; // rcx
  DWORD v44; // eax
  __int64 *v45; // [rsp+28h] [rbp-8h] BYREF

  if ( a2 == 3 || !a2 )
  {
    v2 = qword_4500E0;
    v3 = 0;
    while ( v2 )
    {
      v4 = *(_DWORD *)(v2 + 24);
      v5 = *(void (__fastcall **)(LPVOID))v2;
      if ( !*(_QWORD *)v2 )
LABEL_50:
        sub_407050((__int64)&off_44A2F0);
      v2 = *(_QWORD *)(v2 + 8);
      if ( v4 )
      {
        v6 = v4 - 1;
        Value = TlsGetValue(v6);
        if ( Value )
        {
          v8 = v6;
          v9 = Value;
          TlsSetValue(v8, 0LL);
          v5(v9);
          v3 = 1;
        }
      }
    }
    if ( (v3 & 1) != 0 )
    {
      v10 = qword_4500E0;
      v11 = 0;
      while ( v10 )
      {
        v12 = *(_DWORD *)(v10 + 24);
        v13 = *(void (__fastcall **)(LPVOID))v10;
        if ( !*(_QWORD *)v10 )
          goto LABEL_50;
        v10 = *(_QWORD *)(v10 + 8);
        if ( v12 )
        {
          v14 = v12 - 1;
          v15 = TlsGetValue(v14);
          if ( v15 )
          {
            v16 = v14;
            v17 = v15;
            TlsSetValue(v16, 0LL);
            v13(v17);
            v11 = 1;
          }
        }
      }
      if ( (v11 & 1) != 0 )
      {
        v18 = qword_4500E0;
        v19 = 0;
        while ( v18 )
        {
          v20 = *(_DWORD *)(v18 + 24);
          v21 = *(void (__fastcall **)(LPVOID))v18;
          if ( !*(_QWORD *)v18 )
            goto LABEL_50;
          v18 = *(_QWORD *)(v18 + 8);
          if ( v20 )
          {
            v22 = v20 - 1;
            v23 = TlsGetValue(v22);
            if ( v23 )
            {
              v24 = v22;
              v25 = v23;
              TlsSetValue(v24, 0LL);
              v21(v25);
              v19 = 1;
            }
          }
        }
        if ( (v19 & 1) != 0 )
        {
          v26 = qword_4500E0;
          v27 = 0;
          while ( v26 )
          {
            v28 = *(_DWORD *)(v26 + 24);
            v29 = *(void (__fastcall **)(LPVOID))v26;
            if ( !*(_QWORD *)v26 )
              goto LABEL_50;
            v26 = *(_QWORD *)(v26 + 8);
            if ( v28 )
            {
              v30 = v28 - 1;
              v31 = TlsGetValue(v30);
              if ( v31 )
              {
                v32 = v30;
                v33 = v31;
                TlsSetValue(v32, 0LL);
                v29(v33);
                v27 = 1;
              }
            }
          }
          if ( (v27 & 1) != 0 )
          {
            v34 = qword_4500E0;
            while ( v34 )
            {
              v35 = *(_DWORD *)(v34 + 24);
              v36 = *(void (__fastcall **)(LPVOID))v34;
              if ( !*(_QWORD *)v34 )
                goto LABEL_50;
              v34 = *(_QWORD *)(v34 + 8);
              if ( v35 )
              {
                v37 = v35 - 1;
                v38 = TlsGetValue(v37);
                if ( v38 )
                {
                  v39 = v38;
                  TlsSetValue(v37, 0LL);
                  v36(v39);
                }
              }
            }
          }
        }
      }
    }
    if ( dword_450120 )
    {
      v40 = (__int64 *)TlsGetValue(dword_450120 - 1);
      if ( (unsigned __int64)v40 < 3 )
        return;
    }
    else
    {
      v44 = sub_412510((signed __int64)&unk_450108);
      v40 = (__int64 *)TlsGetValue(v44);
      if ( (unsigned __int64)v40 < 3 )
        return;
    }
    v41 = v40;
    if ( dword_450120 )
      v42 = dword_450120 - 1;
    else
      v42 = sub_412510((signed __int64)&unk_450108);
    TlsSetValue(v42, (LPVOID)2);
    v43 = &qword_450038;
    if ( v41 != &qword_450038 )
      v43 = v41 - 2;
    v45 = v43;
    if ( v41 != &qword_450038 && !_InterlockedDecrement64(v41 - 2) )
      sub_412BC0((__int64 *)&v45);
  }
}
// 44A2F0: using guessed type char *off_44A2F0;
// 450038: using guessed type __int64 qword_450038;
// 4500E0: using guessed type __int64 qword_4500E0;
// 450120: using guessed type int dword_450120;

//----- (0000000000412BC0) ----------------------------------------------------
void __fastcall sub_412BC0(__int64 *a1)
{
  __int64 v1; // rsi
  _BYTE *v2; // rdi
  bool v3; // zf
  HANDLE ProcessHeap; // rax
  HANDLE v5; // rax

  v1 = *a1;
  v2 = *(_BYTE **)(*a1 + 24);
  if ( v2 )
  {
    v3 = *(_QWORD *)(v1 + 32) == 0LL;
    *v2 = 0;
    if ( !v3 )
    {
      ProcessHeap = GetProcessHeap();
      HeapFree(ProcessHeap, 0, v2);
    }
  }
  if ( v1 != -1 && !_InterlockedDecrement64((volatile signed __int64 *)(v1 + 8)) )
  {
    v5 = GetProcessHeap();
    HeapFree(v5, 0, (LPVOID)v1);
  }
}

//----- (0000000000412C23) ----------------------------------------------------
void __noreturn sub_412C23()
{
  sub_40A540();
}

//----- (0000000000412C40) ----------------------------------------------------
__int64 __fastcall sub_412C40(unsigned int **a1, __int64 a2)
{
  unsigned int *v3; // rcx
  int v4; // edx
  int v5; // ecx
  __int64 v6; // r9
  __int64 v7; // r8
  __int64 v8; // rsi
  unsigned int v9; // r11d
  bool v10; // cc
  __int64 v11; // r8
  unsigned int v12; // ecx
  __int64 v13; // r9
  unsigned int v14; // r8d
  __int64 v15; // rdx
  char v16; // r10
  unsigned int v17; // ecx
  unsigned int v18; // r8d
  char v19; // r10
  _WORD v21[78]; // [rsp+34h] [rbp-4Ch] BYREF

  v3 = *a1;
  v4 = *(_DWORD *)(a2 + 36);
  if ( (v4 & 0x10) != 0 )
  {
    v12 = *v3;
    v13 = 129LL;
    v14 = v12;
    do
    {
      v15 = v13;
      v14 >>= 4;
      v16 = (v12 & 0xF) + 87;
      if ( (v12 & 0xF) < 0xA )
        v16 = (v12 & 0xF) + 48;
      *((_BYTE *)&v21[1] + v13--) = v16;
      v10 = v12 <= 0xF;
      v12 = v14;
    }
    while ( !v10 );
    return sub_405270(a2, 1, (__int64)a0x, 2LL, (__int64)&v21[1] + v15, 129 - v13);
  }
  if ( (v4 & 0x20) != 0 )
  {
    v17 = *v3;
    v13 = 129LL;
    v18 = v17;
    do
    {
      v15 = v13;
      v18 >>= 4;
      v19 = (v17 & 0xF) + 55;
      if ( (v17 & 0xF) < 0xA )
        v19 = (v17 & 0xF) + 48;
      *((_BYTE *)&v21[1] + v13--) = v19;
      v10 = v17 <= 0xF;
      v17 = v18;
    }
    while ( !v10 );
    return sub_405270(a2, 1, (__int64)a0x, 2LL, (__int64)&v21[1] + v15, 129 - v13);
  }
  v5 = *v3;
  LODWORD(v6) = -v5;
  if ( v5 > 0 )
    LODWORD(v6) = v5;
  v7 = 10LL;
  if ( (unsigned int)v6 < 0x2710 )
  {
    v6 = (unsigned int)v6;
    if ( (unsigned int)v6 <= 0x63 )
      goto LABEL_10;
    goto LABEL_9;
  }
  v8 = 5LL;
  do
  {
    v9 = (unsigned int)v6 / 0x2710;
    v7 = v8 * 2 - 4;
    v21[v8] = a0001020304[(5243 * ((unsigned int)v6 % 0x2710)) >> 19];
    v21[v8 + 1] = a0001020304[(unsigned __int16)((unsigned int)v6 % 0x2710
                                               - 100
                                               * ((unsigned __int16)((5243 * ((unsigned int)v6 % 0x2710)) >> 16) >> 3))];
    v8 -= 2LL;
    v10 = (unsigned int)v6 <= 0x5F5E0FF;
    LODWORD(v6) = (unsigned int)v6 / 0x2710;
  }
  while ( !v10 );
  v6 = v9;
  if ( v9 > 0x63 )
  {
LABEL_9:
    *(_WORD *)((char *)&v21[1] + v7) = a0001020304[(unsigned __int16)v6 % 0x64u];
    v7 -= 2LL;
    v6 = (unsigned int)(5243 * ((unsigned __int16)v6 >> 2)) >> 17;
  }
LABEL_10:
  if ( (unsigned int)v6 >= 0xA )
  {
    *(_WORD *)((char *)&v21[1] + v7) = a0001020304[v6];
    v11 = v7 - 2;
  }
  else
  {
    *((_BYTE *)&v21[1] + v7 + 1) = v6 | 0x30;
    v11 = v7 - 1;
  }
  return sub_405270(a2, v5 >= 0, 1LL, 0LL, (__int64)&v21[2] + v11, 10 - v11);
}
// 4428DB: using guessed type _WORD a0001020304[100];

//----- (0000000000412E70) ----------------------------------------------------
__int64 (__fastcall *__fastcall sub_412E70(_DWORD *lpMem))()
{
  DWORD v2; // edi
  HANDLE ProcessHeap; // rax

  v2 = lpMem[4];
  TlsSetValue(v2, (LPVOID)1);
  ProcessHeap = GetProcessHeap();
  HeapFree(ProcessHeap, 0, lpMem);
  TlsSetValue(v2, 0LL);
  return TlsCallbacks[0];
}
// 453040: using guessed type __int64 (__fastcall *TlsCallbacks[3])();

//----- (0000000000412EC0) ----------------------------------------------------
void __fastcall sub_412EC0(_QWORD *a1)
{
  if ( *a1 != 2LL && *a1 && !_InterlockedDecrement64((volatile signed __int64 *)a1[1]) )
    sub_412BC0(a1 + 1);
}

//----- (0000000000412EF0) ----------------------------------------------------
char **__fastcall sub_412EF0(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // rsi
  __int64 v6; // rax
  unsigned __int64 v7; // rdx
  void *v8; // r14
  _QWORD *v9; // r15
  __int64 v10; // r12
  HANDLE ProcessHeap; // rax
  HANDLE v12; // rax

  if ( a3 )
  {
    v3 = a3;
    do
    {
      v6 = sub_435C30(0xFFFFFFF4, a2, v3, a1);
      if ( v6 )
      {
        switch ( v7 & 3 )
        {
          case 0uLL:
            if ( *(_BYTE *)(v7 + 16) == 35 )
              break;
            return (char **)v7;
          case 1uLL:
            if ( *(_BYTE *)(v7 + 15) != 35 )
              return (char **)v7;
            if ( (v6 & 1) != 0 )
            {
              v8 = (void *)(v7 - 1);
              v9 = *(_QWORD **)(v7 - 1);
              v10 = *(_QWORD *)(v7 + 7);
              if ( *(_QWORD *)v10 )
                (*(void (__fastcall **)(_QWORD))v10)(*(_QWORD *)(v7 - 1));
              if ( *(_QWORD *)(v10 + 8) )
              {
                if ( *(_QWORD *)(v10 + 16) >= 0x11uLL )
                  v9 = (_QWORD *)*(v9 - 1);
                ProcessHeap = GetProcessHeap();
                HeapFree(ProcessHeap, 0, v9);
              }
              v12 = GetProcessHeap();
              HeapFree(v12, 0, v8);
            }
            break;
          case 2uLL:
            return (char **)v7;
          case 3uLL:
            if ( HIDWORD(v7) != 35 )
              return (char **)v7;
            break;
        }
      }
      else
      {
        if ( !v7 )
          return &off_448D10;
        if ( v3 < v7 )
          sub_4050A0(v7, v3, (__int64)&off_448D28);
        a2 += v7;
        v3 -= v7;
      }
    }
    while ( v3 );
  }
  return 0LL;
}
// 412F20: variable 'v7' is possibly undefined
// 448D10: using guessed type char *off_448D10;
// 448D28: using guessed type char *off_448D28;

//----- (0000000000413070) ----------------------------------------------------
signed __int8 __fastcall sub_413070(signed __int8 *Address)
{
  signed __int8 result; // al
  int v3; // ecx
  bool v4; // zf
  int v5; // ecx
  char CompareAddress[17]; // [rsp+2Fh] [rbp-1h] BYREF

  result = *Address;
  if ( *Address == 1 )
  {
    v3 = -99;
    do
    {
      _mm_pause();
      result = *Address;
      if ( *Address != 1 )
        break;
      v4 = v3++ == 0;
    }
    while ( !v4 );
  }
  if ( result || (result = _InterlockedCompareExchange8(Address, 1, 0)) != 0 )
  {
    while ( 1 )
    {
      if ( result != 2 )
      {
        result = *Address;
        *Address = 2;
        if ( !result )
          break;
      }
      CompareAddress[0] = 2;
      if ( !WaitOnAddress(Address, CompareAddress, 1uLL, 0xFFFFFFFF) )
        GetLastError();
      result = *Address;
      if ( *Address == 1 )
      {
        v5 = -99;
        do
        {
          _mm_pause();
          result = *Address;
          if ( *Address != 1 )
            break;
          v4 = v5++ == 0;
        }
        while ( !v4 );
      }
    }
  }
  return result;
}

//----- (0000000000413120) ----------------------------------------------------
bool sub_413120()
{
  _QWORD *v0; // rax
  char v2; // [rsp+2Fh] [rbp-1h] BYREF

  v0 = sub_412420();
  if ( !v0 )
    sub_406F40((__int64)aCannotAccessAT, 70LL, (__int64)&v2, (__int64)"", (__int64)&off_448718);
  return *v0 == 0LL;
}
// 448718: using guessed type char *off_448718;

//----- (0000000000413170) ----------------------------------------------------
void __fastcall sub_413170(_BYTE *a1, char a2)
{
  char v2; // al
  _BYTE *v3; // rsi
  bool v4; // al

  if ( (a2 & 1) == 0 )
  {
    if ( 2 * qword_4500D0 )
    {
      v3 = a1;
      v4 = sub_413120();
      a1 = v3;
      if ( !v4 )
        v3[1] = 1;
    }
  }
  v2 = *a1;
  *a1 = 0;
  if ( v2 == 2 )
    WakeByAddressSingle(a1);
}
// 4500D0: using guessed type __int64 qword_4500D0;

//----- (00000000004131C0) ----------------------------------------------------
int __fastcall sub_4131C0(__int64 a1)
{
  int result; // eax
  void *v2; // rsi
  _QWORD *v3; // rdi
  __int64 v4; // r14
  HANDLE ProcessHeap; // rax
  HANDLE v6; // rax

  result = a1 & 3;
  if ( result == 1 )
  {
    v2 = (void *)(a1 - 1);
    v3 = *(_QWORD **)(a1 - 1);
    v4 = *(_QWORD *)(a1 + 7);
    if ( *(_QWORD *)v4 )
      (*(void (__fastcall **)(_QWORD))v4)(*(_QWORD *)(a1 - 1));
    if ( *(_QWORD *)(v4 + 8) )
    {
      if ( *(_QWORD *)(v4 + 16) >= 0x11uLL )
        v3 = (_QWORD *)*(v3 - 1);
      ProcessHeap = GetProcessHeap();
      HeapFree(ProcessHeap, 0, v3);
    }
    v6 = GetProcessHeap();
    return HeapFree(v6, 0, v2);
  }
  return result;
}

//----- (0000000000413270) ----------------------------------------------------
int __fastcall sub_413270(__int64 a1)
{
  __int64 v1; // rcx
  int result; // eax

  v1 = *(_QWORD *)(a1 + 8);
  if ( v1 )
    return sub_4131C0(v1);
  return result;
}

//----- (0000000000413290) ----------------------------------------------------
__int64 __fastcall sub_413290(unsigned __int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  unsigned __int128 v5; // rax
  unsigned __int64 v6; // rsi
  unsigned __int64 v8; // r8
  __int64 v9; // rcx
  __int64 v10; // rcx
  __int64 result; // rax
  _QWORD v12[3]; // [rsp+20h] [rbp-30h] BYREF
  __int64 v13; // [rsp+38h] [rbp-18h] BYREF
  __int64 v14; // [rsp+40h] [rbp-10h]
  __int64 v15; // [rsp+48h] [rbp-8h]

  *((_QWORD *)&v5 + 1) = a2;
  v6 = a3 + *((_QWORD *)&v5 + 1);
  if ( __CFADD__(a3, *((_QWORD *)&v5 + 1)) )
    goto LABEL_13;
  v8 = *a1;
  if ( 2 * *a1 > v6 )
    v6 = 2 * *a1;
  if ( 4 * (unsigned __int64)(a4 == 1) + 4 > v6 )
    v6 = 4LL * (a4 == 1) + 4;
  v9 = 0LL;
  v5 = v6 * (unsigned __int128)((a5 + a4 - 1) & (unsigned __int64)-a5);
  if ( !is_mul_ok(v6, (a5 + a4 - 1) & -a5) )
LABEL_13:
    sub_40408F(0LL, *((__int64 *)&v5 + 1), (__int64)&off_447E80);
  if ( (unsigned __int64)v5 > 0x8000000000000000uLL - a5 )
LABEL_15:
    sub_40408F(v9, *((__int64 *)&v5 + 1), (__int64)&off_447E80);
  if ( v8 )
  {
    v12[0] = a1[1];
    v12[2] = a4 * v8;
    v10 = a5;
  }
  else
  {
    v10 = 0LL;
  }
  v12[1] = v10;
  sub_413370(&v13, (void *)a5, v5, (__int64)v12);
  if ( (_DWORD)v13 == 1 )
  {
    v9 = v14;
    *((_QWORD *)&v5 + 1) = v15;
    goto LABEL_15;
  }
  result = v14;
  a1[1] = v14;
  *a1 = v6;
  return result;
}
// 447E80: using guessed type char *off_447E80;

//----- (0000000000413370) ----------------------------------------------------
LPVOID __fastcall sub_413370(_QWORD *a1, void *a2, SIZE_T a3, __int64 a4)
{
  LPVOID v5; // rbx
  void *v7; // r14
  HANDLE ProcessHeap; // rax
  LPVOID result; // rax
  __int64 v10; // rcx

  v5 = a2;
  if ( *(_QWORD *)(a4 + 8) && *(_QWORD *)(a4 + 16) )
  {
    v7 = *(void **)a4;
    ProcessHeap = GetProcessHeap();
    result = HeapReAlloc(ProcessHeap, 0, v7, a3);
  }
  else if ( a3 )
  {
    result = sub_43C4F0(a3);
  }
  else
  {
    result = a2;
  }
  v10 = 0LL;
  if ( result )
    v5 = result;
  LOBYTE(v10) = result == 0LL;
  a1[1] = v5;
  a1[2] = a3;
  *a1 = v10;
  return result;
}

//----- (00000000004133F0) ----------------------------------------------------
__int64 __fastcall sub_4133F0(__int64 a1, _QWORD *a2)
{
  char v2; // cl
  __int64 result; // rax
  void *v4; // rsi
  _QWORD *v5; // rbx
  __int64 v6; // r14
  HANDLE ProcessHeap; // rax
  HANDLE v8; // rax
  __int64 v9; // [rsp+0h] [rbp-60h] BYREF
  _QWORD v10[3]; // [rsp+20h] [rbp-40h] BYREF
  __int128 v11; // [rsp+38h] [rbp-28h]
  __int64 v12; // [rsp+50h] [rbp-10h]
  __int64 v13; // [rsp+58h] [rbp-8h]

  v12 = a1;
  v13 = 0LL;
  v2 = sub_406180((__int64)(&v9 + 10), (__int64)&off_4481A8, a2);
  result = v13;
  if ( v2 )
  {
    if ( !v13 )
    {
      v10[0] = &off_448D98;
      v10[1] = 1LL;
      v10[2] = 8LL;
      v11 = 0LL;
      sub_405240(v10, &off_448DA8);
    }
  }
  else
  {
    if ( (v13 & 3) == 1 )
    {
      v4 = (void *)(v13 - 1);
      v5 = *(_QWORD **)(v13 - 1);
      v6 = *(_QWORD *)(v13 + 7);
      if ( *(_QWORD *)v6 )
        (*(void (__fastcall **)(_QWORD *))v6)(v5);
      if ( *(_QWORD *)(v6 + 8) )
      {
        if ( *(_QWORD *)(v6 + 16) >= 0x11uLL )
          v5 = (_QWORD *)*(v5 - 1);
        ProcessHeap = GetProcessHeap();
        HeapFree(ProcessHeap, 0, v5);
      }
      v8 = GetProcessHeap();
      HeapFree(v8, 0, v4);
    }
    return 0LL;
  }
  return result;
}
// 405240: using guessed type void __fastcall __noreturn sub_405240(_QWORD, _QWORD);
// 4481A8: using guessed type __int64 (__fastcall *off_4481A8)();
// 448D98: using guessed type char *off_448D98;
// 448DA8: using guessed type char *off_448DA8;

//----- (0000000000413520) ----------------------------------------------------
__int64 __fastcall sub_413520(__int64 *a1, __int64 a2, __int64 (__fastcall *a3)(__int64, _QWORD *))
{
  __int64 v4; // rdx
  __int64 v5; // r9
  __int64 v6; // rcx
  _QWORD v8[16]; // [rsp+0h] [rbp-80h] BYREF

  v4 = *a1;
  v5 = a1[1];
  v6 = a1[2];
  v8[10] = v4;
  v8[11] = sub_4123C0;
  v8[12] = v5;
  v8[13] = sub_4121E0;
  v8[14] = v6;
  v8[15] = sub_4123C0;
  v8[4] = &off_449530;
  v8[5] = 4LL;
  v8[8] = 0LL;
  v8[6] = &v8[10];
  v8[7] = 3LL;
  return a3(a2, &v8[4]);
}
// 449530: using guessed type char *off_449530;

//----- (00000000004135B0) ----------------------------------------------------
__int64 __fastcall sub_4135B0(__int64 a1, char a2)
{
  _QWORD v3[13]; // [rsp+0h] [rbp-70h] BYREF
  char v4; // [rsp+6Fh] [rbp-1h]

  v4 = a2;
  v3[11] = (char *)&v3[13] + 7;
  v3[12] = sub_413610;
  v3[5] = &unk_448868;
  v3[6] = 1LL;
  v3[9] = 0LL;
  v3[7] = &v3[11];
  v3[8] = 1LL;
  return sub_412270(a1, &v3[5]);
}

//----- (0000000000413610) ----------------------------------------------------
char __fastcall sub_413610(_BYTE *a1, __int64 a2)
{
  __int64 v2; // r8
  char *v3; // r15
  char *v4; // r12
  __int64 v5; // rsi
  unsigned __int64 v6; // rdi
  WCHAR *p_Buffer; // rbx
  unsigned __int64 i; // r14
  unsigned __int64 v9; // r8
  DWORD CurrentDirectoryW; // eax
  DWORD LastError; // ecx
  unsigned __int64 v12; // r14
  unsigned __int64 v13; // r14
  __int64 v14; // rsi
  void *v15; // rdi
  HANDLE v16; // rax
  char v17; // cl
  unsigned __int64 v18; // rsi
  void *v19; // rdi
  HANDLE ProcessHeap; // rax
  _QWORD *v21; // rbx
  __int64 v22; // r15
  HANDLE v23; // rax
  HANDLE v24; // rax
  DWORD64 Rip; // r15
  struct _RUNTIME_FUNCTION *v26; // rax
  unsigned __int64 v27; // rdi
  volatile signed __int64 **v28; // rsi
  LPVOID v29; // rax
  HANDLE Toolhelp32Snapshot; // rax
  __int64 v31; // rdx
  unsigned __int64 v32; // r8
  void *v33; // r14
  __int64 v34; // rax
  __int64 v35; // r8
  void *v36; // r12
  HANDLE v37; // rbx
  LPCVOID v38; // r13
  unsigned __int64 v39; // rax
  unsigned __int64 v40; // rdx
  unsigned __int64 v41; // rdx
  HANDLE v42; // rax
  _QWORD *v43; // rax
  __int64 modBaseSize; // rdx
  char *v45; // rcx
  __int64 v46; // rax
  __int128 v47; // xmm0
  __int128 v48; // xmm1
  __int128 v49; // xmm2
  __int64 v50; // rdx
  __int64 v51; // r12
  __int64 v52; // r13
  void **v53; // rbx
  void *v54; // r14
  HANDLE v55; // rax
  void *v56; // r14
  HANDLE v57; // rax
  HANDLE v58; // rax
  DWORD64 v59; // rbx
  DWORD64 v60; // rsi
  void *v61; // rsi
  HANDLE v62; // rax
  void *v64; // rsi
  HANDLE v65; // rax
  int HandlerData; // [rsp+28h] [rbp-58h]
  int ContextPointers; // [rsp+38h] [rbp-48h]
  CONTEXT Buffer; // [rsp+40h] [rbp-40h] BYREF
  MODULEENTRY32W me; // [rsp+518h] [rbp+498h] BYREF
  __int128 v70; // [rsp+950h] [rbp+8D0h]
  _QWORD v71[4]; // [rsp+968h] [rbp+8E8h] BYREF
  char v72; // [rsp+988h] [rbp+908h]
  unsigned __int64 v73[2]; // [rsp+990h] [rbp+910h] BYREF
  __int128 v74; // [rsp+9A0h] [rbp+920h]
  __m256 v75; // [rsp+9B0h] [rbp+930h]
  unsigned __int64 v76; // [rsp+9D8h] [rbp+958h] BYREF
  DWORD64 v77; // [rsp+9E0h] [rbp+960h]
  DWORD64 Rsp; // [rsp+9E8h] [rbp+968h]
  __int128 v79; // [rsp+9F0h] [rbp+970h] BYREF
  __int128 v80; // [rsp+A00h] [rbp+980h]
  HANDLE hObject[2]; // [rsp+A10h] [rbp+990h] BYREF
  LPCVOID lpBaseAddress; // [rsp+A20h] [rbp+9A0h]
  unsigned __int64 v83; // [rsp+A28h] [rbp+9A8h]
  __int128 v84; // [rsp+A30h] [rbp+9B0h]
  __int64 v85; // [rsp+A40h] [rbp+9C0h]
  __int64 v86; // [rsp+A48h] [rbp+9C8h] BYREF
  BYTE *modBaseAddr; // [rsp+A50h] [rbp+9D0h]
  _QWORD *v88; // [rsp+A58h] [rbp+9D8h]
  __int128 v89; // [rsp+A60h] [rbp+9E0h] BYREF
  char *v90; // [rsp+A70h] [rbp+9F0h]
  __int64 *v91; // [rsp+A78h] [rbp+9F8h]
  char *v92; // [rsp+A80h] [rbp+A00h]
  _QWORD *v93; // [rsp+A88h] [rbp+A08h]
  char *v94; // [rsp+A90h] [rbp+A10h]
  unsigned __int64 *v95; // [rsp+A98h] [rbp+A18h]
  unsigned __int64 v96; // [rsp+AA8h] [rbp+A28h] BYREF
  LPVOID v97; // [rsp+AB0h] [rbp+A30h]
  __int128 v98; // [rsp+AB8h] [rbp+A38h]
  char v99; // [rsp+AC8h] [rbp+A48h]
  __int64 v100; // [rsp+AD0h] [rbp+A50h]
  __int64 v101; // [rsp+AD8h] [rbp+A58h]
  void *v102; // [rsp+AE0h] [rbp+A60h]
  __int128 v103; // [rsp+AE8h] [rbp+A68h] BYREF
  __int64 v104; // [rsp+AF8h] [rbp+A78h]
  LPVOID lpMem[2]; // [rsp+B00h] [rbp+A80h] BYREF
  __int128 v106; // [rsp+B10h] [rbp+A90h]
  __int128 v107; // [rsp+B20h] [rbp+AA0h]
  __int128 v108; // [rsp+B30h] [rbp+AB0h]
  __int64 v109; // [rsp+B40h] [rbp+AC0h]
  PRUNTIME_FUNCTION FunctionEntry; // [rsp+B48h] [rbp+AC8h]
  unsigned __int64 ImageBase; // [rsp+B50h] [rbp+AD0h] BYREF
  LPVOID v112; // [rsp+B58h] [rbp+AD8h]
  char v113; // [rsp+B62h] [rbp+AE2h] BYREF
  char v114; // [rsp+B63h] [rbp+AE3h]
  char v115; // [rsp+B64h] [rbp+AE4h] BYREF
  char v116; // [rsp+B65h] [rbp+AE5h] BYREF
  char v117; // [rsp+B66h] [rbp+AE6h] BYREF
  char v118; // [rsp+B67h] [rbp+AE7h] BYREF

  v109 = a2;
  LOBYTE(v112) = *a1;
  v118 = (char)v112;
  lpMem[0] = 0LL;
  lpMem[1] = (LPVOID)2;
  *(_QWORD *)&v106 = 0LL;
  v2 = 512LL;
  FunctionEntry = (PRUNTIME_FUNCTION)2;
  v3 = 0LL;
  v4 = 0LL;
  v5 = 0LL;
LABEL_4:
  while ( 2 )
  {
    v6 = 512LL;
    p_Buffer = (WCHAR *)&Buffer;
    for ( i = v2; ; i = v5 )
    {
      SetLastError(0);
      CurrentDirectoryW = GetCurrentDirectoryW(i, p_Buffer);
      if ( !CurrentDirectoryW )
      {
        LastError = GetLastError();
        CurrentDirectoryW = 0;
        if ( LastError )
        {
          v18 = (unsigned __int64)GetLastError() << 32;
          if ( lpMem[0] )
          {
            v19 = lpMem[1];
            ProcessHeap = GetProcessHeap();
            HeapFree(ProcessHeap, 0, v19);
          }
          v14 = v18 | 2;
          v13 = 0x8000000000000000uLL;
          goto LABEL_26;
        }
      }
      v2 = CurrentDirectoryW;
      if ( i != CurrentDirectoryW )
        break;
      if ( GetLastError() != 122 )
        sub_405FC0((__int64)"internal error: entered unreachable code", 40LL, (__int64)&off_449FC0);
      v12 = 2 * i;
      if ( v12 >= 0xFFFFFFFF )
        v12 = 0xFFFFFFFFLL;
      v2 = v12;
      if ( v12 < 0x201 )
        goto LABEL_4;
LABEL_5:
      v9 = v2 - v5;
      if ( (unsigned __int64)&v4[-v5] < v9 )
      {
        sub_413290((unsigned __int64 *)lpMem, v5, v9, 2LL, 2LL);
        v3 = (char *)lpMem[0];
        FunctionEntry = (PRUNTIME_FUNCTION)lpMem[1];
      }
      v5 = 0xFFFFFFFFLL;
      if ( (unsigned __int64)v3 < 0xFFFFFFFF )
        v5 = (__int64)v3;
      *(_QWORD *)&v106 = v5;
      v4 = v3;
      v6 = v5;
      p_Buffer = (WCHAR *)FunctionEntry;
    }
    if ( i < CurrentDirectoryW )
    {
      if ( CurrentDirectoryW < 0x201uLL )
        continue;
      goto LABEL_5;
    }
    break;
  }
  if ( v6 < CurrentDirectoryW )
    sub_405B00(CurrentDirectoryW, v6, (__int64)&off_449FA8);
  sub_414CB0(&me, p_Buffer, CurrentDirectoryW);
  v13 = *(_QWORD *)&me.dwSize;
  v14 = *(_QWORD *)&me.th32ProcessID;
  v89 = *(_OWORD *)&me.ProccntUsage;
  if ( lpMem[0] )
  {
    v15 = lpMem[1];
    v16 = GetProcessHeap();
    HeapFree(v16, 0, v15);
  }
  if ( v13 != 0x8000000000000000uLL )
  {
    v70 = v89;
    v17 = (char)v112;
    goto LABEL_34;
  }
LABEL_26:
  v17 = (char)v112;
  if ( (v14 & 3) == 1 )
  {
    v21 = *(_QWORD **)(v14 - 1);
    v22 = *(_QWORD *)(v14 + 7);
    if ( *(_QWORD *)v22 )
      (*(void (__fastcall **)(_QWORD))v22)(*(_QWORD *)(v14 - 1));
    if ( *(_QWORD *)(v22 + 8) )
    {
      if ( *(_QWORD *)(v22 + 16) >= 0x11uLL )
        v21 = (_QWORD *)*(v21 - 1);
      v23 = GetProcessHeap();
      HeapFree(v23, 0, v21);
    }
    v24 = GetProcessHeap();
    HeapFree(v24, 0, (LPVOID)(v14 - 1));
    v17 = v118;
  }
LABEL_34:
  v99 = v17;
  v96 = v13;
  v97 = (LPVOID)v14;
  v98 = v70;
  if ( (*(unsigned __int8 (__fastcall **)(_QWORD, const char *, __int64))(*(_QWORD *)(v109 + 56) + 24LL))(
         *(_QWORD *)(v109 + 48),
         aStackBacktrace,
         17LL) )
  {
    goto LABEL_111;
  }
  v71[0] = v109;
  v71[3] = 0LL;
  v72 = v118;
  v71[1] = &v96;
  v71[2] = &off_449118;
  v117 = 0;
  v86 = 0LL;
  v113 = 1;
  v114 = v118;
  v115 = v118;
  memset(&Buffer, 0, sizeof(Buffer));
  RtlCaptureContext(&Buffer);
  Rip = Buffer.Rip;
  ImageBase = 0LL;
  v26 = RtlLookupFunctionEntry(Buffer.Rip, &ImageBase, 0LL);
  if ( v26 )
  {
    v27 = 0LL;
    while ( 1 )
    {
      FunctionEntry = v26;
      v76 = ImageBase;
      v77 = Rip;
      Rsp = Buffer.Rsp;
      if ( v27 >= 0x65 && v118 == 0 )
        break;
      v28 = 0LL;
      if ( Rip )
        v28 = (volatile signed __int64 **)(Rip - 1);
      v116 = 0;
      *(_QWORD *)&v89 = &v116;
      *((_QWORD *)&v89 + 1) = &v118;
      v90 = &v115;
      v91 = &v86;
      v92 = &v113;
      v93 = v71;
      v94 = &v117;
      v95 = &v76;
      v73[0] = (unsigned __int64)&v89;
      v73[1] = (unsigned __int64)&unk_449758;
      if ( (_QWORD)xmmword_43F028 == 0x8000000000000000uLL )
      {
        v29 = sub_43C4F0(0x8C0uLL);
        if ( !v29 )
          sub_4040E9(8LL, 2240LL);
        *(_QWORD *)&v84 = 4LL;
        *((_QWORD *)&v84 + 1) = v29;
        v85 = 0LL;
        *(_QWORD *)&v103 = 0LL;
        *((_QWORD *)&v103 + 1) = 8LL;
        v104 = 0LL;
        Toolhelp32Snapshot = CreateToolhelp32Snapshot(8u, 0);
        if ( Toolhelp32Snapshot != (HANDLE)-1LL )
        {
          v33 = Toolhelp32Snapshot;
          memset(&me, 0, sizeof(me));
          me.dwSize = 1080;
          if ( Module32FirstW(v33, &me) )
          {
            v100 = 8LL;
            v112 = 0LL;
            do
            {
              v34 = 520LL;
              v35 = 0LL;
              while ( me.szExePath[v35] )
              {
                if ( !me.szExePath[v35 + 1] )
                {
                  ++v35;
                  break;
                }
                if ( !me.szExePath[v35 + 2] )
                {
                  v35 += 2LL;
                  break;
                }
                if ( !me.szExePath[v35 + 3] )
                {
                  v35 += 3LL;
                  break;
                }
                if ( !me.szExePath[v35 + 4] )
                {
                  v35 += 4LL;
                  break;
                }
                v35 += 5LL;
                v34 -= 10LL;
                if ( !v34 )
                {
                  v35 = 260LL;
                  break;
                }
              }
              sub_414CB0(&v79, me.szExePath, v35);
              v36 = (void *)*((_QWORD *)&v79 + 1);
              sub_4151C0(hObject, *((unsigned __int8 **)&v79 + 1), v80);
              if ( ((__int64)hObject[0] & 1) != 0 )
              {
                v37 = hObject[1];
                v38 = lpBaseAddress;
                if ( v83 >= 0x40 && *(_WORD *)lpBaseAddress == 23117 )
                {
                  v39 = *((unsigned int *)lpBaseAddress + 15);
                  if ( v83 >= v39
                    && v83 - v39 >= 0x88
                    && *(_DWORD *)((char *)lpBaseAddress + v39) == 17744
                    && *(_WORD *)((char *)lpBaseAddress + v39 + 24) == 523 )
                  {
                    v40 = *(unsigned __int16 *)((char *)lpBaseAddress + v39 + 20);
                    if ( v40 >= 0x70 )
                    {
                      v41 = v40 - 112;
                      if ( v83 - (v39 + 136) >= v41
                        && 8 * (unsigned __int64)*(unsigned int *)((char *)lpBaseAddress + v39 + 132) <= v41 )
                      {
                        v101 = *(_QWORD *)((char *)lpBaseAddress + v39 + 48);
                        modBaseAddr = me.modBaseAddr;
                        v102 = (void *)v79;
                        v43 = sub_43C4F0(0x10uLL);
                        if ( !v43 )
                          sub_4040E9(8LL, 16LL);
                        modBaseSize = me.modBaseSize;
                        *v43 = v101;
                        v88 = v43;
                        v43[1] = modBaseSize;
                        *(_OWORD *)hObject = v80;
                        UnmapViewOfFile(v38);
                        CloseHandle(v37);
                        if ( v102 != (void *)0x8000000000000000LL )
                        {
                          lpMem[0] = v102;
                          lpMem[1] = v36;
                          v106 = *(_OWORD *)hObject;
                          *(_QWORD *)&v107 = 1LL;
                          *((_QWORD *)&v107 + 1) = v88;
                          *(_QWORD *)&v108 = 1LL;
                          *((_QWORD *)&v108 + 1) = &modBaseAddr[-v101];
                          if ( v112 == (LPVOID)v103 )
                          {
                            sub_415470((__int64 *)&v103, (__int64)&off_44A4D8);
                            v100 = *((_QWORD *)&v103 + 1);
                          }
                          v45 = (char *)v112;
                          v46 = (_QWORD)v112 << 6;
                          v47 = *(_OWORD *)lpMem;
                          v48 = v106;
                          v49 = v107;
                          v50 = v100;
                          *(_OWORD *)(v100 + v46 + 48) = v108;
                          *(_OWORD *)(v50 + v46 + 32) = v49;
                          *(_OWORD *)(v50 + v46 + 16) = v48;
                          *(_OWORD *)(v50 + v46) = v47;
                          v112 = v45 + 1;
                          v104 = (__int64)(v45 + 1);
                        }
                        continue;
                      }
                    }
                  }
                }
                UnmapViewOfFile(lpBaseAddress);
                CloseHandle(v37);
              }
              if ( (_QWORD)v79 )
              {
                v42 = GetProcessHeap();
                HeapFree(v42, 0, v36);
              }
            }
            while ( Module32NextW(v33, &me) );
          }
          CloseHandle(v33);
        }
        v74 = v103;
        *(_QWORD *)v75.m256_f32 = v104;
        *(_QWORD *)&v75.m256_f32[6] = v85;
        *(_OWORD *)&v75.m256_f32[2] = v84;
        v51 = xmmword_43F028;
        if ( (_QWORD)xmmword_43F028 != 0x8000000000000000uLL )
        {
          v112 = (LPVOID)*((_QWORD *)&xmmword_43F028 + 1);
          v52 = *(_QWORD *)ymmword_43F038.m256_f32;
          if ( *(_QWORD *)ymmword_43F038.m256_f32 )
          {
            v53 = (void **)((char *)v112 + 40);
            do
            {
              if ( *(v53 - 5) )
              {
                v54 = *(v53 - 4);
                v55 = GetProcessHeap();
                HeapFree(v55, 0, v54);
              }
              if ( *(v53 - 1) )
              {
                v56 = *v53;
                v57 = GetProcessHeap();
                HeapFree(v57, 0, v56);
              }
              v53 += 8;
              --v52;
            }
            while ( v52 );
          }
          if ( v51 )
          {
            v58 = GetProcessHeap();
            HeapFree(v58, 0, v112);
          }
          sub_415650(&ymmword_43F038.m256_f32[2], v31, v32);
        }
        ymmword_43F038 = v75;
        xmmword_43F028 = v74;
      }
      sub_415720(v28, v73);
      if ( !v116 && v115 == 1 )
      {
        v89 = (unsigned __int64)v71;
        *(_QWORD *)&me.dwSize = 3LL;
        lpMem[0] = (LPVOID)2;
        v117 = sub_414350((__int64)&v89, v77, (__int128 *)&me, (__int64)lpMem, 0, HandlerData, 0, ContextPointers);
        ++*(_QWORD *)(v89 + 24);
      }
      if ( !v117 )
      {
        v59 = Buffer.Rsp;
        lpMem[0] = 0LL;
        *(_QWORD *)&me.dwSize = 0LL;
        RtlVirtualUnwind(0, ImageBase, Rip, FunctionEntry, &Buffer, lpMem, (PULONG64)&me.dwSize, 0LL);
        v60 = Buffer.Rip;
        if ( Buffer.Rip )
        {
          if ( Buffer.Rip != Rip || Buffer.Rsp != v59 )
          {
            ++v27;
            ImageBase = 0LL;
            v26 = RtlLookupFunctionEntry(Buffer.Rip, &ImageBase, 0LL);
            Rip = v60;
            if ( v26 )
              continue;
          }
        }
      }
      break;
    }
  }
  if ( v117
    || !v114
    && (*(unsigned __int8 (__fastcall **)(_QWORD, const char *, __int64))(*(_QWORD *)(v109 + 56) + 24LL))(
         *(_QWORD *)(v109 + 48),
         aNoteSomeDetail,
         88LL) )
  {
LABEL_111:
    if ( 2 * v96 )
    {
      v61 = v97;
      v62 = GetProcessHeap();
      HeapFree(v62, 0, v61);
    }
    return 1;
  }
  else
  {
    if ( 2 * v96 )
    {
      v64 = v97;
      v65 = GetProcessHeap();
      HeapFree(v65, 0, v64);
    }
    return 0;
  }
}
// 413FD2: variable 'v31' is possibly undefined
// 413FD2: variable 'v32' is possibly undefined
// 41408B: variable 'HandlerData' is possibly undefined
// 41408B: variable 'ContextPointers' is possibly undefined
// 43F028: using guessed type __int128 xmmword_43F028;
// 43F038: using guessed type __m256 ymmword_43F038;
// 449118: using guessed type __int64 (__fastcall *off_449118)();
// 449FA8: using guessed type char *off_449FA8;
// 449FC0: using guessed type char *off_449FC0;
// 44A4D8: using guessed type char *off_44A4D8;

//----- (0000000000414350) ----------------------------------------------------
char __fastcall sub_414350(
        __int64 a1,
        __int64 a2,
        __int128 *a3,
        __int64 a4,
        unsigned __int8 a5,
        int a6,
        char a7,
        int a8)
{
  _BYTE *v8; // rbx
  __int64 v9; // rsi
  char result; // al
  __int64 v13; // rdi
  __int64 v14; // rax
  __int64 v15; // rax
  __int128 v16; // xmm0
  __int128 v17; // xmm1
  __int128 v18; // xmm2
  __int64 v19; // rax
  __int128 v20; // xmm0
  __int128 v21; // xmm1
  __int128 v22; // xmm2
  __int64 v23; // rax
  __int64 v24; // rax
  __int64 v25; // rcx
  __int64 v26; // rax
  __int64 v27; // rax
  __int64 v28; // rax
  char v29; // cl
  bool v30; // zf
  __int64 v31; // [rsp+28h] [rbp-58h] BYREF
  _QWORD v32[2]; // [rsp+30h] [rbp-50h] BYREF
  __m256i *v33; // [rsp+40h] [rbp-40h] BYREF
  __int64 v34; // [rsp+48h] [rbp-38h]
  _QWORD *v35; // [rsp+50h] [rbp-30h]
  __int64 v36; // [rsp+58h] [rbp-28h]
  __int64 *v37; // [rsp+60h] [rbp-20h]
  __int64 v38; // [rsp+68h] [rbp-18h]
  __m256i v39; // [rsp+70h] [rbp-10h] BYREF
  __int128 v40; // [rsp+90h] [rbp+10h]
  __int128 v41; // [rsp+A0h] [rbp+20h]
  __int128 v42; // [rsp+B0h] [rbp+30h]
  __int64 v43; // [rsp+C0h] [rbp+40h] BYREF
  __int64 v44; // [rsp+C8h] [rbp+48h]
  __int64 v45; // [rsp+D0h] [rbp+50h]
  __int64 v46; // [rsp+D8h] [rbp+58h]
  __m256i *v47; // [rsp+E0h] [rbp+60h]
  __int64 v48; // [rsp+E8h] [rbp+68h]
  char v49; // [rsp+F0h] [rbp+70h]

  v8 = *(_BYTE **)a1;
  v9 = *(_QWORD *)(a1 + 8);
  v31 = a2;
  if ( !a2 && !v8[32] )
    goto LABEL_3;
  v13 = a1;
  v14 = *(_QWORD *)v8;
  if ( v9 )
  {
    if ( (*(unsigned __int8 (__fastcall **)(_QWORD, const char *, __int64))(*(_QWORD *)(v14 + 56) + 24LL))(
           *(_QWORD *)(v14 + 48),
           asc_449818,
           6LL) )
    {
      return 1;
    }
    if ( v8[32] != 1 )
      goto LABEL_12;
    v15 = *(_QWORD *)v8;
    v33 = (__m256i *)&unk_448868;
    v34 = (__int64)sub_4123C0;
    v35 = 0LL;
    v36 = 21LL;
    v39.m256i_i64[0] = 2LL;
    v39.m256i_i64[2] = 1LL;
    v39.m256i_i64[3] = 1LL;
    *(_QWORD *)&v40 = 0LL;
    *((_QWORD *)&v40 + 1) = 32LL;
    LOBYTE(v41) = 3;
    v43 = (__int64)&unk_448868;
    v44 = 1LL;
    v47 = &v39;
    v48 = 1LL;
    v45 = (__int64)&v33;
    goto LABEL_11;
  }
  v33 = (__m256i *)(v8 + 24);
  v34 = (__int64)sub_405120;
  v39.m256i_i64[0] = 2LL;
  v39.m256i_i64[2] = 0LL;
  v39.m256i_i64[3] = 4LL;
  *(_QWORD *)&v40 = 0LL;
  *((_QWORD *)&v40 + 1) = 32LL;
  LOBYTE(v41) = 3;
  v43 = (__int64)&unk_4497D0;
  v44 = 2LL;
  v47 = &v39;
  v48 = 1LL;
  v45 = (__int64)&v33;
  v46 = 1LL;
  if ( sub_406180(*(_QWORD *)(v14 + 48), *(_QWORD *)(v14 + 56), &v43) )
    return 1;
  if ( v8[32] == 1 )
  {
    v15 = *(_QWORD *)v8;
    v33 = (__m256i *)&v31;
    v34 = (__int64)sub_414920;
    v35 = 0LL;
    v36 = 18LL;
    v39.m256i_i64[0] = 2LL;
    v39.m256i_i64[2] = 1LL;
    v39.m256i_i64[3] = 1LL;
    *(_QWORD *)&v40 = 0LL;
    *((_QWORD *)&v40 + 1) = 32LL;
    LOBYTE(v41) = 3;
    v43 = (__int64)&unk_4497F8;
    v44 = 2LL;
    v47 = &v39;
    v48 = 1LL;
    v45 = (__int64)&v33;
LABEL_11:
    v46 = 2LL;
    if ( sub_406180(*(_QWORD *)(v15 + 48), *(_QWORD *)(v15 + 56), &v43) )
      return 1;
  }
LABEL_12:
  if ( *(_DWORD *)a3 != 3 )
  {
    if ( v8[32] )
    {
      v42 = a3[4];
      v16 = *a3;
      v17 = a3[1];
      v18 = a3[2];
      v41 = a3[3];
      v40 = v18;
      *(_OWORD *)&v39.m256i_u64[2] = v17;
      *(_OWORD *)v39.m256i_i8 = v16;
      v19 = *(_QWORD *)v8;
      v33 = &v39;
      v34 = (__int64)sub_414A10;
      v43 = (__int64)&unk_448868;
      v44 = 1LL;
      v47 = 0LL;
      v45 = (__int64)&v33;
      v46 = 1LL;
      if ( sub_406180(*(_QWORD *)(v19 + 48), *(_QWORD *)(v19 + 56), &v43) )
        return 1;
      goto LABEL_19;
    }
    v42 = a3[4];
    v20 = *a3;
    v21 = a3[1];
    v22 = a3[2];
    v41 = a3[3];
    v40 = v22;
    *(_OWORD *)&v39.m256i_u64[2] = v21;
    *(_OWORD *)v39.m256i_i8 = v20;
    v23 = *(_QWORD *)v8;
    v32[0] = &v39;
    v32[1] = sub_414A10;
    v43 = 2LL;
    v45 = 2LL;
    v47 = 0LL;
    v48 = 0x400000020LL;
    v49 = 3;
    v33 = (__m256i *)&unk_448868;
    v34 = 1LL;
    v37 = &v43;
    v38 = 1LL;
    v35 = v32;
    v36 = 1LL;
    if ( !sub_406180(*(_QWORD *)(v23 + 48), *(_QWORD *)(v23 + 56), &v33) )
      goto LABEL_19;
    return 1;
  }
  if ( (*(unsigned __int8 (__fastcall **)(_QWORD, const char *, __int64))(*(_QWORD *)(*(_QWORD *)v8 + 56LL) + 24LL))(
         *(_QWORD *)(*(_QWORD *)v8 + 48LL),
         aUnknown,
         9LL) )
  {
    return 1;
  }
LABEL_19:
  if ( (*(unsigned __int8 (__fastcall **)(_QWORD, const char *, __int64))(*(_QWORD *)(*(_QWORD *)v8 + 56LL) + 24LL))(
         *(_QWORD *)(*(_QWORD *)v8 + 48LL),
         "\n",
         1LL) )
  {
    return 1;
  }
  a1 = v13;
  if ( ((*(_DWORD *)a4 != 2) & a5) != 1 )
    goto LABEL_3;
  LODWORD(v32[0]) = a6;
  if ( v8[32] == 1 )
  {
    v24 = *(_QWORD *)v8;
    v33 = (__m256i *)&unk_448868;
    v34 = (__int64)sub_4123C0;
    v35 = 0LL;
    v36 = 18LL;
    v39.m256i_i64[0] = 2LL;
    v39.m256i_i64[2] = 1LL;
    v39.m256i_i64[3] = 1LL;
    *(_QWORD *)&v40 = 0LL;
    *((_QWORD *)&v40 + 1) = 32LL;
    LOBYTE(v41) = 3;
    v43 = (__int64)&unk_448868;
    v44 = 1LL;
    v47 = &v39;
    v48 = 1LL;
    v45 = (__int64)&v33;
    v46 = 2LL;
    if ( sub_406180(*(_QWORD *)(v24 + 48), *(_QWORD *)(v24 + 56), &v43) )
      return 1;
  }
  if ( (*(unsigned __int8 (__fastcall **)(_QWORD, const char *, __int64))(*(_QWORD *)(*(_QWORD *)v8 + 56LL) + 24LL))(
         *(_QWORD *)(*(_QWORD *)v8 + 48LL),
         aAt,
         16LL) )
  {
    return 1;
  }
  v25 = *((_QWORD *)v8 + 1);
  v26 = *((_QWORD *)v8 + 2);
  v39.m256i_i64[0] = *(_QWORD *)v8;
  *(_OWORD *)&v39.m256i_u64[1] = *(_OWORD *)a4;
  v39.m256i_i64[3] = *(_QWORD *)(a4 + 16);
  if ( (*(unsigned __int8 (__fastcall **)(__int64, __int64, unsigned __int64 *))(v26 + 32))(
         v25,
         v39.m256i_i64[0],
         &v39.m256i_u64[1]) )
  {
    return 1;
  }
  v27 = *(_QWORD *)v8;
  v43 = (__int64)v32;
  v44 = (__int64)sub_4063D0;
  v39.m256i_i64[0] = (__int64)&off_449830;
  v39.m256i_i64[1] = 1LL;
  *(_QWORD *)&v40 = 0LL;
  v39.m256i_i64[2] = (__int64)&v43;
  v39.m256i_i64[3] = 1LL;
  if ( sub_406180(*(_QWORD *)(v27 + 48), *(_QWORD *)(v27 + 56), &v39) )
    return 1;
  if ( (a7 & 1) != 0 )
  {
    LODWORD(v33) = a8;
    v28 = *(_QWORD *)v8;
    v43 = (__int64)&v33;
    v44 = (__int64)sub_4063D0;
    v39.m256i_i64[0] = (__int64)&off_449830;
    v39.m256i_i64[1] = 1LL;
    *(_QWORD *)&v40 = 0LL;
    v39.m256i_i64[2] = (__int64)&v43;
    v39.m256i_i64[3] = 1LL;
    if ( sub_406180(*(_QWORD *)(v28 + 48), *(_QWORD *)(v28 + 56), &v39) )
      return 1;
  }
  v29 = (*(__int64 (__fastcall **)(_QWORD, const char *, __int64))(*(_QWORD *)(*(_QWORD *)v8 + 56LL) + 24LL))(
          *(_QWORD *)(*(_QWORD *)v8 + 48LL),
          "\n",
          1LL);
  result = 1;
  v30 = v29 == 0;
  a1 = v13;
  if ( v30 )
  {
LABEL_3:
    *(_QWORD *)(a1 + 8) = v9 + 1;
    return 0;
  }
  return result;
}
// 44952F: using guessed type char asc_44952F;
// 449830: using guessed type __int16 (*off_449830)[4];

//----- (0000000000414920) ----------------------------------------------------
__int64 __fastcall sub_414920(unsigned __int64 *a1, __m128i *a2)
{
  unsigned __int64 v3; // rax
  __m128i v4; // xmm6
  int v5; // edi
  int v6; // ecx
  __int64 v7; // r8
  unsigned __int64 v8; // rdx
  __int64 v9; // rcx
  char v10; // r9
  bool v11; // cf
  __int64 result; // rax
  _BYTE v13[130]; // [rsp+2Eh] [rbp-52h] BYREF

  v3 = *a1;
  v4 = _mm_loadu_si128(a2);
  v5 = a2[2].m128i_i32[1];
  v6 = v5;
  if ( (v5 & 4) != 0 )
  {
    v6 = v5 | 8;
    if ( !v4.m128i_i64[0] )
    {
      a2->m128i_i64[0] = 1LL;
      a2->m128i_i64[1] = 18LL;
    }
  }
  a2[2].m128i_i32[1] = v6 | 4;
  v7 = 129LL;
  v8 = v3;
  do
  {
    v9 = v7;
    v8 >>= 4;
    v10 = (v3 & 0xF) + 87;
    if ( (v3 & 0xF) < 0xA )
      v10 = (v3 & 0xF) + 48;
    v13[v7--] = v10;
    v11 = v3 < 0x10;
    v3 = v8;
  }
  while ( !v11 );
  result = sub_405270((__int64)a2, 1, (__int64)a0x, 2LL, (__int64)&v13[v9], 129 - v7);
  *a2 = v4;
  a2[2].m128i_i32[1] = v5;
  return result;
}

//----- (0000000000414A10) ----------------------------------------------------
char __fastcall sub_414A10(_QWORD *a1, __int64 a2)
{
  unsigned __int64 v3; // rdi
  __int64 v4; // rbx
  __int64 v5; // r12
  char v6; // r15
  __int64 v7; // r13
  unsigned __int64 v8; // r12
  _QWORD *v9; // rbx
  bool v10; // zf
  char v11; // al
  char v12; // cl
  __int64 v13; // rdi
  __int64 (__fastcall *v14)(__int64, _QWORD, _QWORD); // rsi
  char v15; // cl
  char result; // al
  _QWORD v17[2]; // [rsp+30h] [rbp-50h] BYREF
  _QWORD *v18; // [rsp+40h] [rbp-40h] BYREF
  __int64 v19; // [rsp+48h] [rbp-38h]
  _QWORD *v20; // [rsp+50h] [rbp-30h]
  __int64 v21; // [rsp+58h] [rbp-28h]
  __int64 *v22; // [rsp+60h] [rbp-20h]
  __int64 v23; // [rsp+68h] [rbp-18h]
  _QWORD v24[3]; // [rsp+70h] [rbp-10h] BYREF
  __int64 v25; // [rsp+88h] [rbp+8h] BYREF
  __int64 v26; // [rsp+90h] [rbp+10h]
  unsigned __int64 v27; // [rsp+98h] [rbp+18h]
  __int64 v28; // [rsp+A0h] [rbp+20h]
  __int64 v29; // [rsp+A8h] [rbp+28h]
  __int64 v30; // [rsp+B0h] [rbp+30h]
  char v31; // [rsp+B8h] [rbp+38h]
  _QWORD v32[8]; // [rsp+C0h] [rbp+40h] BYREF

  if ( *a1 != 2LL )
  {
    if ( (*a1 & 1) == 0 )
    {
      v9 = a1;
      v13 = *(_QWORD *)(a2 + 48);
      v14 = *(__int64 (__fastcall **)(__int64, _QWORD, _QWORD))(*(_QWORD *)(a2 + 56) + 24LL);
      v15 = v14(v13, a1[4], a1[5]);
      result = 1;
      if ( v15 )
        return result;
      return v14(v13, v9[6], v9[7]);
    }
    v9 = a1;
    v10 = (*(_BYTE *)(a2 + 36) & 4) == 0;
    v32[0] = a1 + 1;
    v24[0] = 0LL;
    v24[1] = 1000000LL;
    v24[2] = a2;
    if ( v10 )
    {
      v18 = v32;
      v19 = (__int64)sub_410600;
      v25 = (__int64)&unk_448868;
      v26 = 1LL;
      v29 = 0LL;
      v27 = (unsigned __int64)&v18;
      v28 = 1LL;
      v11 = sub_406180((__int64)v24, (__int64)&unk_446F80, &v25);
      v12 = v24[0];
      if ( (v24[0] & (unsigned __int8)v11) == 0 )
        goto LABEL_13;
    }
    else
    {
      v17[0] = v32;
      v17[1] = sub_410600;
      v25 = 2LL;
      v27 = 2LL;
      v29 = 0LL;
      v30 = 0x400000020LL;
      v31 = 3;
      v18 = &unk_448868;
      v19 = 1LL;
      v22 = &v25;
      v23 = 1LL;
      v20 = v17;
      v21 = 1LL;
      v11 = sub_406180((__int64)v24, (__int64)&unk_446F80, &v18);
      v12 = v24[0];
      if ( (v24[0] & (unsigned __int8)v11) == 0 )
      {
LABEL_13:
        if ( !v11 )
        {
          if ( (v12 & 1) != 0 )
            sub_406F40((__int64)aFmtErrorFromSi, 55LL, (__int64)&v25, (__int64)&unk_446EC8, (__int64)&off_447638);
          goto LABEL_20;
        }
        return 1;
      }
    }
    if ( !(*(unsigned __int8 (__fastcall **)(_QWORD, const char *, __int64))(*(_QWORD *)(a2 + 56) + 24LL))(
            *(_QWORD *)(a2 + 48),
            aSizeLimitReach,
            20LL) )
    {
LABEL_20:
      v13 = *(_QWORD *)(a2 + 48);
      v14 = *(__int64 (__fastcall **)(__int64, _QWORD, _QWORD))(*(_QWORD *)(a2 + 56) + 24LL);
      return v14(v13, v9[6], v9[7]);
    }
    return 1;
  }
  v3 = a1[9];
  if ( v3 )
  {
    v4 = a1[8];
    while ( 1 )
    {
      sub_406850((__int64)&v25, v4, v3);
      if ( (v25 & 1) == 0 )
        break;
      v5 = v26;
      v6 = v27;
      v7 = BYTE1(v27);
      if ( sub_405B80(a2, word_449310, 3uLL) )
        return 1;
      if ( (v6 & 1) != 0 )
      {
        v8 = v7 + v5;
        if ( v3 < v8 )
          sub_4050A0(v8, v3, (__int64)&off_4497B8);
        v4 += v8;
        v3 -= v8;
        if ( v3 )
          continue;
      }
      return 0;
    }
    if ( sub_405B80(a2, (unsigned __int16 *)v26, v27) )
      return 1;
  }
  return 0;
}
// 447638: using guessed type char *off_447638;
// 449310: using guessed type unsigned __int16 word_449310[4];
// 4497B8: using guessed type char *off_4497B8;

//----- (0000000000414CB0) ----------------------------------------------------
_OWORD *__fastcall sub_414CB0(_OWORD *a1, unsigned __int16 *a2, __int64 a3)
{
  __int64 v6; // rcx
  unsigned __int16 *v7; // rdi
  char *v8; // r14
  __m128i v9; // xmm6
  __m128i v10; // xmm7
  unsigned int i; // r12d
  char v12; // si
  size_t v13; // r12
  unsigned __int16 v14; // ax
  unsigned __int16 v15; // ax
  unsigned __int16 v16; // cx
  __int128 v17; // xmm0
  _OWORD *result; // rax
  _OWORD *v19; // [rsp+30h] [rbp-50h]
  LPVOID lpMem[2]; // [rsp+38h] [rbp-48h] BYREF
  __int128 v21; // [rsp+48h] [rbp-38h]
  unsigned __int16 v22; // [rsp+5Ah] [rbp-26h]
  int Src; // [rsp+5Ch] [rbp-24h] BYREF

  if ( a3 < 0 )
    sub_4040B0((__int64)&off_449250);
  if ( a3 )
  {
    v6 = (__int64)sub_43C4F0(a3);
    if ( !v6 )
      sub_4040E9(1LL, a3);
  }
  else
  {
    v6 = 1LL;
  }
  v19 = a1;
  lpMem[0] = (LPVOID)a3;
  lpMem[1] = (LPVOID)v6;
  *(_QWORD *)&v21 = 0LL;
  BYTE8(v21) = 1;
  v7 = &a2[a3];
  v8 = 0LL;
  v9 = _mm_cvtsi32_si128(0x3F3F3F07u);
  v10 = _mm_cvtsi32_si128(0x808080F0);
LABEL_7:
  if ( a2 == v7 )
    goto LABEL_47;
  for ( i = *a2++; ; i = v22 )
  {
    if ( (i & 0xF800) != 0xD800 )
    {
      Src = 0;
      if ( (unsigned __int16)i >= 0x80u )
      {
        if ( (unsigned __int16)i >= 0x800u )
        {
          LOBYTE(Src) = ((unsigned __int16)i >> 12) | 0xE0;
          BYTE1(Src) = ((unsigned __int16)i >> 6) & 0x3F | 0x80;
          BYTE2(Src) = i & 0x3F | 0x80;
          v13 = 3LL;
          if ( (LPVOID)((char *)lpMem[0] - (char *)v8) >= (LPVOID)3 )
            goto LABEL_24;
        }
        else
        {
          LOBYTE(Src) = (i >> 6) | 0xC0;
          BYTE1(Src) = i & 0x3F | 0x80;
          v13 = 2LL;
          if ( (LPVOID)((char *)lpMem[0] - (char *)v8) >= (LPVOID)2 )
            goto LABEL_24;
        }
      }
      else
      {
        LOBYTE(Src) = i;
        v13 = 1LL;
        if ( lpMem[0] != v8 )
          goto LABEL_24;
      }
      goto LABEL_46;
    }
    if ( (unsigned __int16)i > 0xDBFFu )
    {
      v12 = 0;
      goto LABEL_42;
    }
    if ( a2 != v7 )
      break;
LABEL_39:
    v12 = 0;
    a2 = v7;
LABEL_42:
    BYTE8(v21) = 0;
    if ( (LPVOID)((char *)lpMem[0] - (char *)v8) <= (LPVOID)2 )
    {
      sub_413290((unsigned __int64 *)lpMem, (__int64)v8, 3LL, 1LL, 1LL);
      v8 = (char *)v21;
    }
    v6 = (__int64)lpMem[1];
    *((_BYTE *)lpMem[1] + (unsigned __int64)v8) = -19;
    v8[v6 + 1] = (i >> 6) & 0x3F | 0x80;
    v8[v6 + 2] = i & 0x3F | 0x80;
    v8 += 3;
    *(_QWORD *)&v21 = v8;
    if ( (v12 & 1) == 0 )
      goto LABEL_7;
  }
  v14 = *a2++;
  v12 = 1;
  if ( (unsigned __int16)(v14 + 0x2000) < 0xFC00u )
  {
    v22 = v14;
    goto LABEL_42;
  }
  Src = _mm_cvtsi128_si32(
          _mm_or_si128(
            _mm_and_si128(
              _mm_cvtsi32_si128(((unsigned int)(((v14 & 0x3C0) << 16) | ((unsigned __int16)i << 26)) >> 6) & 0xFF0000 | ((((unsigned __int64)(i & 0x3FF) << 26) + 0x100000000LL) >> 34) | ((unsigned __int8)((((unsigned __int64)(i & 0x3FF) << 26) + 0x100000000LL) >> 28) << 8) | (v14 << 24)),
              v9),
            v10));
  v13 = 4LL;
  if ( (LPVOID)((char *)lpMem[0] - (char *)v8) >= (LPVOID)4 )
    goto LABEL_24;
LABEL_46:
  sub_413290((unsigned __int64 *)lpMem, (__int64)v8, v13, 1LL, 1LL);
  v6 = (__int64)lpMem[1];
  v8 = (char *)v21;
LABEL_24:
  while ( 1 )
  {
    memcpy(&v8[v6], &Src, v13);
    v8 += v13;
    *(_QWORD *)&v21 = v8;
    if ( a2 == v7 )
      break;
    i = *a2;
    v15 = *a2;
    if ( (*a2 & 0xF800) == 0xD800 )
    {
      if ( (unsigned __int16)i > 0xDBFFu )
      {
        v12 = 0;
        ++a2;
        goto LABEL_42;
      }
      if ( a2 + 1 == v7 )
        goto LABEL_39;
      v16 = a2[1];
      a2 += 2;
      if ( (unsigned __int16)(v16 + 0x2000) < 0xFC00u )
      {
        v12 = 1;
        v22 = v16;
        goto LABEL_42;
      }
      Src = _mm_cvtsi128_si32(
              _mm_or_si128(
                _mm_and_si128(
                  _mm_cvtsi32_si128(((((unsigned __int64)(v15 & 0x3FF) << 26) + 0x100000000LL) >> 34) | ((unsigned __int8)((((unsigned __int64)(v15 & 0x3FF) << 26) + 0x100000000LL) >> 28) << 8) | ((unsigned int)(((v16 & 0x3C0) << 16) | (v15 << 26)) >> 6) & 0xFF0000 | (v16 << 24)),
                  v9),
                v10));
      v13 = 4LL;
    }
    else
    {
      Src = 0;
      if ( (unsigned __int16)i >= 0x80u )
      {
        if ( (unsigned __int16)i >= 0x800u )
        {
          LOBYTE(Src) = ((unsigned __int16)i >> 12) | 0xE0;
          BYTE1(Src) = ((unsigned __int16)i >> 6) & 0x3F | 0x80;
          BYTE2(Src) = i & 0x3F | 0x80;
          v13 = 3LL;
        }
        else
        {
          LOBYTE(Src) = (i >> 6) | 0xC0;
          BYTE1(Src) = i & 0x3F | 0x80;
          v13 = 2LL;
        }
      }
      else
      {
        LOBYTE(Src) = i;
        v13 = 1LL;
      }
      ++a2;
    }
    if ( (char *)lpMem[0] - (char *)v8 < v13 )
    {
      sub_413290((unsigned __int64 *)lpMem, (__int64)v8, v13, 1LL, 1LL);
      v8 = (char *)v21;
    }
    v6 = (__int64)lpMem[1];
  }
LABEL_47:
  v17 = *(_OWORD *)lpMem;
  result = v19;
  v19[1] = v21;
  *v19 = v17;
  return result;
}
// 449250: using guessed type char *off_449250;

//----- (00000000004151C0) ----------------------------------------------------
int __fastcall sub_4151C0(_QWORD *a1, unsigned __int8 *a2, __int64 a3)
{
  __int64 v4; // rax
  __int64 v5; // rdx
  void *v6; // rsi
  int result; // eax
  void *v8; // rsi
  _QWORD *v9; // rbx
  __int64 v10; // r14
  HANDLE ProcessHeap; // rax
  HANDLE v12; // rax
  void *v13; // rbx
  _QWORD *v14; // r14
  __int64 v15; // r15
  HANDLE v16; // rax
  HANDLE v17; // rax
  SIZE_T v18; // r12
  HANDLE CurrentProcess; // rax
  HANDLE v20; // rbx
  HANDLE FileMappingA; // rax
  void *v22; // r14
  LPVOID v23; // r15
  __int64 v24; // [rsp+0h] [rbp-80h] BYREF
  HANDLE TargetHandle; // [rsp+38h] [rbp-48h] BYREF
  __int128 v26; // [rsp+40h] [rbp-40h]
  int v27; // [rsp+50h] [rbp-30h]
  __int64 v28; // [rsp+54h] [rbp-2Ch]
  __int16 v29; // [rsp+5Ch] [rbp-24h]
  SIZE_T dwNumberOfBytesToMap; // [rsp+70h] [rbp-10h]

  LODWORD(TargetHandle) = 0;
  v26 = 0LL;
  v27 = 7;
  v28 = 0x100000000LL;
  v29 = 0;
  v4 = sub_432610(a2, a3, (__int64)(&v24 + 7));
  v6 = (void *)v5;
  if ( v4 )
  {
    result = v5 & 3;
    if ( result == 1 )
    {
      v8 = (void *)(v5 - 1);
      v9 = *(_QWORD **)(v5 - 1);
      v10 = *(_QWORD *)(v5 + 7);
      if ( *(_QWORD *)v10 )
        (*(void (__fastcall **)(_QWORD *))v10)(v9);
      if ( *(_QWORD *)(v10 + 8) )
      {
        if ( *(_QWORD *)(v10 + 16) >= 0x11uLL )
          v9 = (_QWORD *)*(v9 - 1);
        ProcessHeap = GetProcessHeap();
        HeapFree(ProcessHeap, 0, v9);
      }
      v12 = GetProcessHeap();
      result = HeapFree(v12, 0, v8);
    }
    *a1 = 0LL;
    return result;
  }
  sub_4328B0((__int64)&TargetHandle, (void *)v5);
  if ( (_DWORD)TargetHandle != 2 )
  {
    v18 = dwNumberOfBytesToMap;
    if ( v6 )
    {
      TargetHandle = 0LL;
      CurrentProcess = GetCurrentProcess();
      if ( !DuplicateHandle(CurrentProcess, v6, CurrentProcess, &TargetHandle, 0, 0, 2u) )
      {
        GetLastError();
        *a1 = 0LL;
        return CloseHandle(v6);
      }
      v20 = TargetHandle;
    }
    else
    {
      v20 = 0LL;
    }
    FileMappingA = CreateFileMappingA(v20, 0LL, 2u, 0, 0, 0LL);
    if ( FileMappingA && (v22 = FileMappingA, v23 = MapViewOfFile(FileMappingA, 4u, 0, 0, v18), CloseHandle(v22), v23) )
    {
      a1[1] = v20;
      a1[2] = v23;
      a1[3] = v18;
      *a1 = 1LL;
    }
    else
    {
      *a1 = 0LL;
      CloseHandle(v20);
    }
    return CloseHandle(v6);
  }
  if ( (v26 & 3) == 1 )
  {
    v13 = (void *)(v26 - 1);
    v14 = *(_QWORD **)(v26 - 1);
    v15 = *(_QWORD *)(v26 + 7);
    if ( *(_QWORD *)v15 )
      (*(void (__fastcall **)(_QWORD *))v15)(v14);
    if ( *(_QWORD *)(v15 + 8) )
    {
      if ( *(_QWORD *)(v15 + 16) >= 0x11uLL )
        v14 = (_QWORD *)*(v14 - 1);
      v16 = GetProcessHeap();
      HeapFree(v16, 0, v14);
    }
    v17 = GetProcessHeap();
    HeapFree(v17, 0, v13);
  }
  *a1 = 0LL;
  return CloseHandle(v6);
}
// 415215: variable 'v5' is possibly undefined

//----- (0000000000415470) ----------------------------------------------------
__int64 __fastcall sub_415470(__int64 *a1, __int64 a2)
{
  __int64 v2; // rsi
  __int64 v3; // rax
  unsigned __int64 v5; // rdx
  __int64 v6; // rbx
  __int64 v7; // rcx
  __int64 v8; // rax
  __int64 result; // rax
  _QWORD v10[3]; // [rsp+28h] [rbp-28h] BYREF
  __int64 v11; // [rsp+40h] [rbp-10h] BYREF
  __int64 v12; // [rsp+48h] [rbp-8h]
  __int64 v13; // [rsp+50h] [rbp+0h]

  v2 = a2;
  v3 = *a1;
  if ( *a1 == -1 )
    goto LABEL_13;
  v5 = v3 + 1;
  if ( 2 * v3 > (unsigned __int64)(v3 + 1) )
    v5 = 2 * v3;
  v6 = 4LL;
  if ( v5 >= 5 )
    v6 = v5;
  v7 = 0LL;
  a2 = v5 >> 58;
  if ( a2 )
LABEL_13:
    sub_40408F(0LL, a2, v2);
  if ( (unsigned __int64)(v6 << 6) > 0x7FFFFFFFFFFFFFF8LL )
LABEL_15:
    sub_40408F(v7, a2, v2);
  if ( v3 )
  {
    v10[0] = a1[1];
    v10[2] = v3 << 6;
    v8 = 8LL;
  }
  else
  {
    v8 = 0LL;
  }
  v10[1] = v8;
  sub_413370(&v11, (void *)8, v6 << 6, (__int64)v10);
  if ( (_DWORD)v11 == 1 )
  {
    v7 = v12;
    a2 = v13;
    goto LABEL_15;
  }
  result = v12;
  a1[1] = v12;
  *a1 = v6;
  return result;
}

//----- (0000000000415540) ----------------------------------------------------
void __fastcall sub_415540(_QWORD *a1)
{
  void *v2; // rdi
  HANDLE ProcessHeap; // rax
  void *v4; // rsi
  HANDLE v5; // rax

  if ( *a1 )
  {
    v2 = (void *)a1[1];
    ProcessHeap = GetProcessHeap();
    HeapFree(ProcessHeap, 0, v2);
  }
  if ( a1[4] )
  {
    v4 = (void *)a1[5];
    v5 = GetProcessHeap();
    HeapFree(v5, 0, v4);
  }
}

//----- (00000000004155A0) ----------------------------------------------------
void __fastcall sub_4155A0(_QWORD *a1)
{
  void **v2; // rsi
  __int64 v3; // r14
  void **v4; // r15
  void *v5; // rbx
  HANDLE ProcessHeap; // rax
  void *v7; // rbx
  HANDLE v8; // rax
  HANDLE v9; // rax

  v2 = (void **)a1[1];
  v3 = a1[2];
  if ( v3 )
  {
    v4 = v2 + 5;
    do
    {
      if ( *(v4 - 5) )
      {
        v5 = *(v4 - 4);
        ProcessHeap = GetProcessHeap();
        HeapFree(ProcessHeap, 0, v5);
      }
      if ( *(v4 - 1) )
      {
        v7 = *v4;
        v8 = GetProcessHeap();
        HeapFree(v8, 0, v7);
      }
      v4 += 8;
      --v3;
    }
    while ( v3 );
  }
  if ( *a1 )
  {
    v9 = GetProcessHeap();
    HeapFree(v9, 0, v2);
  }
}

//----- (0000000000415650) ----------------------------------------------------
void __fastcall sub_415650(_QWORD *a1, __int64 a2, unsigned __int64 a3)
{
  void *v4; // rsi
  __int64 v5; // r15
  __int64 v6; // rcx
  __int64 i; // r15
  __int64 v8; // r14
  HANDLE ProcessHeap; // rax

  v4 = (void *)a1[1];
  v5 = a1[2];
  v6 = (__int64)v4 + 8;
  for ( i = v5 + 1; i != 1; --i )
  {
    v8 = v6 + 560;
    sub_4230A0(v6, a2, a3);
    v6 = v8;
  }
  if ( *a1 )
  {
    ProcessHeap = GetProcessHeap();
    HeapFree(ProcessHeap, 0, v4);
  }
}
// 415690: variable 'a2' is possibly undefined
// 415690: variable 'a3' is possibly undefined

//----- (0000000000415720) ----------------------------------------------------
void __fastcall sub_415720(volatile signed __int64 **a1, unsigned __int64 *a2)
{
  volatile signed __int64 **v2; // r14
  unsigned __int64 v3; // r15
  _QWORD *v4; // r8
  _QWORD *v5; // r10
  __int64 v6; // r9
  __int64 v7; // r12
  __int64 v8; // r9
  _QWORD *v9; // r11
  unsigned __int64 v10; // rsi
  char *v11; // rdi
  volatile signed __int64 **v12; // r13
  __int64 v13; // r8
  __int64 v14; // rbx
  __int128 v15; // rcx
  char *v16; // r14
  unsigned __int64 v17; // rax
  unsigned __int64 v18; // rcx
  unsigned __int64 v19; // rcx
  unsigned __int64 v20; // rcx
  _QWORD *v21; // r10
  bool v22; // dl
  unsigned __int64 v23; // rcx
  unsigned __int64 v24; // r11
  unsigned __int64 v25; // r8
  unsigned __int64 v26; // r9
  unsigned __int64 v27; // rdx
  char *v28; // r8
  __int64 v29; // rax
  unsigned __int64 v30; // rsi
  unsigned __int64 v31; // r9
  __int64 v32; // rdx
  volatile signed __int64 **v33; // r14
  unsigned __int64 v34; // rdx
  unsigned int v35; // eax
  char *v36; // rdi
  volatile signed __int64 *v37; // rbx
  __int64 v38; // rcx
  __int64 v39; // r9
  unsigned __int64 v40; // r8
  unsigned __int64 v41; // rcx
  volatile signed __int64 **v42; // rsi
  __int64 v43; // rcx
  volatile signed __int64 *v44; // r12
  __int64 v45; // rcx
  __int128 *v46; // rdx
  volatile signed __int64 *v47; // r8
  unsigned __int64 v48; // rcx
  volatile signed __int64 *v49; // rdx
  char v50; // r13
  __int64 v51; // r14
  volatile signed __int64 **v52; // r15
  char *v53; // r9
  __int64 v54; // rdx
  unsigned __int64 v55; // r8
  _QWORD *v56; // rax
  _QWORD *v57; // rcx
  int v58; // edx
  _QWORD *v59; // r8
  __int64 v60; // rcx
  char v61; // dl
  __int64 v62; // r8
  char *v63; // r9
  _QWORD *v64; // rbx
  volatile signed __int64 **v65; // rdi
  unsigned int v66; // ecx
  __int128 v67; // rax
  unsigned __int64 v68; // r14
  unsigned __int64 v69; // r8
  unsigned __int64 v70; // rsi
  unsigned __int64 v71; // rdi
  HANDLE v72; // rax
  unsigned int v73; // r13d
  unsigned __int64 v74; // rbx
  unsigned __int64 *v75; // r12
  unsigned __int64 *v76; // r14
  char v77; // si
  __int64 v78; // rbx
  void *v79; // rax
  bool v80; // r12
  __int64 v81; // r15
  bool v82; // zf
  __int128 v83; // kr30_16
  HANDLE v84; // rax
  _OWORD *v85; // r15
  __int128 v86; // xmm0
  __int64 *v87; // rax
  __int64 v88; // rax
  unsigned __int64 *v89; // rcx
  HANDLE v90; // rax
  unsigned __int64 v91; // rdi
  unsigned __int64 *v92; // r15
  int v93; // eax
  __int64 v94; // r12
  unsigned __int64 *v95; // rbx
  __int64 v96; // r14
  unsigned __int64 v97; // rcx
  bool v98; // si
  bool v99; // di
  __int64 v100; // r15
  bool v101; // zf
  __int64 *v102; // rax
  HANDLE v103; // rax
  unsigned __int64 v104; // rsi
  unsigned __int64 *v105; // rdx
  HANDLE v106; // rax
  _OWORD *v107; // r15
  __int128 v108; // xmm0
  __int64 v109; // rcx
  unsigned __int64 *v110; // rax
  HANDLE v111; // rdx
  HANDLE v112; // rax
  unsigned __int64 v113; // rax
  __int64 v114; // rdx
  unsigned __int64 v115; // rcx
  unsigned __int64 v116; // r8
  unsigned __int64 v117; // rdi
  __int64 v118; // rsi
  __int64 v119; // rax
  unsigned __int64 v120; // rax
  unsigned __int64 *v121; // rdx
  __int64 v122; // r8
  unsigned __int64 *v123; // rcx
  unsigned __int64 v124; // rax
  void *v125; // rdx
  unsigned __int64 v126; // rcx
  void *v127; // rcx
  unsigned __int64 v128; // rax
  unsigned __int64 v129; // rdx
  __int64 v130; // r8
  unsigned __int64 v131; // rcx
  unsigned __int64 v132; // rax
  _QWORD *v133; // rdx
  void *v134; // rcx
  _QWORD *v135; // rcx
  unsigned __int64 v136; // rax
  unsigned __int64 v137; // rdx
  __int64 v138; // r8
  unsigned __int64 v139; // rcx
  unsigned __int64 v140; // rax
  __int64 v141; // rdx
  void *v142; // rcx
  __int64 v143; // rcx
  unsigned __int64 v144; // rax
  __int64 v145; // rdx
  __int64 v146; // r8
  __int64 v147; // rcx
  unsigned __int64 v148; // rax
  void *v149; // rdx
  unsigned __int64 v150; // rcx
  void *v151; // rcx
  unsigned __int64 v152; // rax
  __int64 *v153; // rdx
  __int64 v154; // r8
  __int64 *v155; // rcx
  unsigned __int64 v156; // rax
  unsigned int *v157; // rdx
  __int64 v158; // rcx
  unsigned int *v159; // rcx
  unsigned __int64 v160; // rax
  unsigned __int64 v161; // rdx
  __int64 v162; // rdi
  unsigned __int64 v163; // rcx
  unsigned __int64 v164; // rsi
  __int64 v165; // rdx
  __int64 v166; // r13
  unsigned __int64 v167; // rax
  __int64 v168; // rdx
  __int64 v169; // rcx
  char *v170; // rax
  char *v171; // r13
  unsigned __int64 v172; // rcx
  __int64 v173; // rdi
  __int64 v174; // rsi
  unsigned __int64 v175; // r13
  char *v176; // rax
  unsigned __int64 v177; // rdx
  unsigned __int64 v178; // r8
  __int64 v179; // r13
  unsigned __int64 *v180; // rdx
  __int64 v181; // rcx
  unsigned __int64 v182; // rdi
  unsigned __int8 *v183; // r13
  unsigned int v184; // edx
  int v185; // ecx
  unsigned __int64 v186; // rdx
  unsigned __int64 v187; // rcx
  __int64 v188; // rdi
  __int64 v189; // r13
  __int64 v190; // rax
  void *v191; // rsi
  char *v192; // rdi
  char *v193; // rcx
  char *v194; // r15
  HANDLE v195; // rax
  void *v196; // rsi
  HANDLE v197; // rax
  void *v198; // rsi
  HANDLE v199; // rax
  volatile signed __int64 *v200; // r13
  LPVOID v201; // rdi
  void *v202; // rsi
  HANDLE v203; // rax
  void *v204; // rsi
  HANDLE ProcessHeap; // rax
  unsigned __int64 v206; // rsi
  __int64 v207; // r10
  __int64 v208; // r11
  unsigned __int64 v209; // rax
  int v210; // ecx
  char v211; // di
  bool v212; // cf
  void *v213; // rsi
  HANDLE v214; // rax
  void *v215; // rsi
  HANDLE v216; // rax
  void *v217; // rsi
  HANDLE v218; // rax
  void *v219; // rsi
  HANDLE v220; // rax
  __int64 v221; // rcx
  __int64 v222; // rcx
  __int64 v223; // r10
  char v224; // r11
  __int64 v225; // r9
  __int64 v226; // rdi
  int v227; // ecx
  int v228; // eax
  unsigned __int64 v229; // rax
  unsigned __int64 v230; // rcx
  unsigned __int64 v231; // rax
  int v232; // ecx
  __int64 v233; // rax
  unsigned __int64 v234; // rcx
  unsigned __int64 v235; // rax
  __int128 v236; // rt0
  unsigned __int64 v237; // rax
  unsigned __int64 v238; // rcx
  unsigned __int64 v239; // rax
  int v240; // eax
  __int128 v241; // rt0
  __int128 v242; // rt0
  unsigned __int64 v243; // rax
  unsigned __int64 v244; // rax
  unsigned __int64 v245; // rcx
  __int64 v246; // rax
  unsigned __int64 v247; // r8
  unsigned __int64 v248; // rcx
  unsigned __int64 v249; // r11
  __int64 v250; // rcx
  unsigned __int64 *v251; // r8
  _QWORD *v252; // rcx
  unsigned __int64 v253; // rdi
  unsigned __int64 v254; // r13
  unsigned __int16 *v255; // rdi
  __int64 v256; // rax
  __int64 v257; // rcx
  int v258; // r8d
  __int64 v259; // rax
  __int128 v260; // rt0
  __int64 v261; // r13
  __int64 v262; // r13
  __int128 v263; // rt0
  __int64 v264; // rcx
  int v265; // r8d
  __int64 v266; // r13
  unsigned int *v267; // rax
  unsigned __int64 v268; // r8
  __int64 v269; // rcx
  unsigned __int64 v270; // r13
  __int64 v271; // rdi
  char *v272; // rax
  __int128 v273; // xmm6
  unsigned int *v274; // rax
  __int64 v275; // rcx
  __int64 v276; // r13
  unsigned __int64 v277; // rdi
  char *v278; // rax
  __int64 v279; // rcx
  __int64 v280; // rdx
  unsigned __int64 v281; // rdi
  __int64 v282; // rsi
  __int64 v283; // rax
  __int64 v284; // rcx
  void *v285; // r13
  HANDLE v286; // rax
  __int64 v287; // rdx
  __int64 v288; // rax
  void *v289; // r15
  char *v290; // rdi
  char *v291; // rcx
  char *v292; // r12
  void *v293; // rsi
  HANDLE v294; // rax
  void *v295; // rsi
  HANDLE v296; // rax
  void *v297; // rsi
  HANDLE v298; // rax
  void *v299; // rsi
  HANDLE v300; // rax
  HANDLE v301; // rax
  HANDLE v302; // rax
  void *v303; // rdi
  HANDLE v304; // rax
  __m128 v305; // xmm6
  __int64 v306; // rdx
  unsigned __int64 *v307; // rdi
  HANDLE v308; // rax
  __int64 v309; // rdi
  HANDLE v310; // rax
  HANDLE v311; // rax
  __int64 v312; // rdi
  HANDLE v313; // rax
  HANDLE v314; // rax
  __int64 v315; // rdi
  __int64 v316; // rbx
  __int64 v317; // rdx
  unsigned __int64 v318; // r8
  __int64 v319; // rdx
  unsigned __int64 v320; // rax
  unsigned __int64 *v321; // rdx
  unsigned __int64 *v322; // rcx
  __int64 v323; // rcx
  char *v324; // rdx
  unsigned __int64 v325; // rax
  unsigned __int64 v326; // rdx
  unsigned __int64 v327; // rcx
  unsigned __int64 v328; // rax
  unsigned __int64 v329; // rdx
  unsigned __int64 v330; // rcx
  void *v331; // rcx
  unsigned __int64 v332; // rax
  void *v333; // rdx
  void *v334; // rcx
  unsigned __int64 v335; // rax
  unsigned __int64 v336; // rdx
  unsigned __int64 v337; // rcx
  _QWORD *v338; // rcx
  unsigned __int64 v339; // rax
  void *v340; // rdx
  void *v341; // rcx
  unsigned __int64 v342; // rax
  __int64 v343; // rdx
  __int64 v344; // rcx
  __int64 v345; // rcx
  unsigned __int64 v346; // rax
  unsigned __int64 v347; // rdx
  unsigned __int64 v348; // rcx
  unsigned __int64 v349; // rax
  __int64 *v350; // rdx
  __int64 *v351; // rcx
  void *v352; // rcx
  unsigned __int64 v353; // rax
  __int64 v354; // rdx
  bool v355; // zf
  __int64 v356; // rax
  __int64 v357; // r13
  __int64 v358; // rdx
  unsigned __int64 v359; // r8
  unsigned __int64 v360; // r8
  void *v361; // rsi
  HANDLE v362; // rax
  void *v363; // r13
  HANDLE v364; // rax
  unsigned __int64 v365; // rdi
  _QWORD *v366; // rsi
  unsigned __int64 *v367; // rcx
  __int64 v368; // r13
  __int64 v369; // r8
  __int64 v370; // rax
  unsigned __int64 *v371; // r9
  unsigned __int64 *v372; // r10
  unsigned __int64 *v373; // rdx
  unsigned __int64 v374; // r8
  unsigned __int64 v375; // r9
  __int64 v376; // r11
  __int64 v377; // r10
  unsigned __int64 *v378; // rcx
  char *v379; // rsi
  char *v380; // r8
  __int64 v381; // rax
  unsigned __int64 *v382; // r9
  unsigned __int64 *v383; // r10
  char *v384; // rdx
  unsigned __int64 v385; // r8
  unsigned __int64 v386; // r9
  __int64 v387; // r11
  __int64 v388; // r10
  _OWORD Src[35]; // [rsp+28h] [rbp-58h] BYREF
  _BYTE v390[552]; // [rsp+258h] [rbp+1D8h] BYREF
  __int128 v391; // [rsp+480h] [rbp+400h] BYREF
  __int128 v392; // [rsp+490h] [rbp+410h]
  __int128 v393; // [rsp+4A0h] [rbp+420h]
  __int128 v394; // [rsp+4B0h] [rbp+430h]
  __int128 v395; // [rsp+4C0h] [rbp+440h]
  __int128 v396; // [rsp+4D0h] [rbp+450h]
  __int128 v397; // [rsp+4E0h] [rbp+460h]
  __int128 v398; // [rsp+4F0h] [rbp+470h]
  __int128 v399; // [rsp+500h] [rbp+480h]
  __int128 v400; // [rsp+510h] [rbp+490h]
  __int128 v401; // [rsp+520h] [rbp+4A0h]
  _BYTE v402[87]; // [rsp+530h] [rbp+4B0h]
  __int128 v403[27]; // [rsp+590h] [rbp+510h] BYREF
  __int128 v404; // [rsp+740h] [rbp+6C0h]
  __int128 v405; // [rsp+750h] [rbp+6D0h]
  __int128 v406; // [rsp+760h] [rbp+6E0h]
  unsigned __int64 *v407; // [rsp+770h] [rbp+6F0h]
  __int128 v408; // [rsp+780h] [rbp+700h]
  _QWORD *v409; // [rsp+790h] [rbp+710h]
  _BYTE v410[23]; // [rsp+7A0h] [rbp+720h]
  __int128 v411; // [rsp+7B8h] [rbp+738h] BYREF
  __int128 v412; // [rsp+7C8h] [rbp+748h]
  __int128 v413; // [rsp+7D8h] [rbp+758h]
  __int128 v414; // [rsp+7E8h] [rbp+768h] BYREF
  __int128 v415; // [rsp+7F8h] [rbp+778h]
  __int128 v416; // [rsp+808h] [rbp+788h]
  unsigned __int64 *v417; // [rsp+818h] [rbp+798h]
  __int64 v418; // [rsp+820h] [rbp+7A0h]
  unsigned __int64 v419; // [rsp+828h] [rbp+7A8h]
  __int64 v420; // [rsp+830h] [rbp+7B0h]
  __int64 v421; // [rsp+838h] [rbp+7B8h]
  __int128 v422; // [rsp+840h] [rbp+7C0h] BYREF
  __int128 v423; // [rsp+850h] [rbp+7D0h]
  __int64 v424; // [rsp+860h] [rbp+7E0h]
  signed __int64 v425; // [rsp+868h] [rbp+7E8h] BYREF
  unsigned __int64 v426; // [rsp+870h] [rbp+7F0h]
  __int64 v427; // [rsp+878h] [rbp+7F8h]
  __int128 v428[35]; // [rsp+880h] [rbp+800h] BYREF
  LPVOID v429[2]; // [rsp+AB0h] [rbp+A30h] BYREF
  __int128 v430; // [rsp+AC0h] [rbp+A40h]
  __int128 v431; // [rsp+AD0h] [rbp+A50h]
  __int128 v432; // [rsp+AE0h] [rbp+A60h]
  __int128 v433; // [rsp+AF0h] [rbp+A70h]
  __int64 v434; // [rsp+B00h] [rbp+A80h]
  unsigned __int64 *v435; // [rsp+B10h] [rbp+A90h]
  __int64 v436; // [rsp+B18h] [rbp+A98h]
  _BYTE v437[56]; // [rsp+B20h] [rbp+AA0h] BYREF
  __int128 v438; // [rsp+B58h] [rbp+AD8h]
  __int128 v439; // [rsp+B68h] [rbp+AE8h]
  int v440; // [rsp+B80h] [rbp+B00h]
  int v441; // [rsp+B84h] [rbp+B04h]
  __int128 v442; // [rsp+B88h] [rbp+B08h] BYREF
  unsigned __int64 *v443; // [rsp+B98h] [rbp+B18h]
  _BYTE v444[56]; // [rsp+BA0h] [rbp+B20h] BYREF
  __int128 v445; // [rsp+BD8h] [rbp+B58h]
  __int64 v446; // [rsp+BE8h] [rbp+B68h]
  unsigned __int64 *v447; // [rsp+BF8h] [rbp+B78h] BYREF
  LPVOID v448; // [rsp+C00h] [rbp+B80h]
  unsigned __int64 *v449; // [rsp+C08h] [rbp+B88h]
  unsigned int v450; // [rsp+C14h] [rbp+B94h]
  char *v451; // [rsp+C18h] [rbp+B98h] BYREF
  unsigned __int64 v452; // [rsp+C20h] [rbp+BA0h]
  __m256i v453; // [rsp+C28h] [rbp+BA8h] BYREF
  __int16 v454; // [rsp+C4Ah] [rbp+BCAh]
  int v455; // [rsp+C4Ch] [rbp+BCCh]
  unsigned __int64 v456; // [rsp+C50h] [rbp+BD0h]
  unsigned __int64 v457; // [rsp+C58h] [rbp+BD8h]
  LPVOID v458[2]; // [rsp+C60h] [rbp+BE0h] BYREF
  _QWORD *v459; // [rsp+C70h] [rbp+BF0h]
  char *v460; // [rsp+C80h] [rbp+C00h]
  unsigned __int64 v461; // [rsp+C88h] [rbp+C08h]
  char *v462; // [rsp+C90h] [rbp+C10h]
  unsigned __int64 v463; // [rsp+C98h] [rbp+C18h] BYREF
  LPVOID v464; // [rsp+CA0h] [rbp+C20h]
  unsigned __int64 v465; // [rsp+CA8h] [rbp+C28h]
  volatile signed __int64 **v466; // [rsp+CB0h] [rbp+C30h]
  unsigned __int64 v467; // [rsp+CB8h] [rbp+C38h]
  HANDLE hObject; // [rsp+CC0h] [rbp+C40h]
  _QWORD *v469; // [rsp+CC8h] [rbp+C48h]
  __int64 *v470; // [rsp+CD0h] [rbp+C50h]
  __int64 v471; // [rsp+CD8h] [rbp+C58h]
  unsigned __int64 v472; // [rsp+CE0h] [rbp+C60h]
  unsigned __int64 v473; // [rsp+CE8h] [rbp+C68h]
  unsigned __int64 v474; // [rsp+CF0h] [rbp+C70h]
  unsigned __int64 v475; // [rsp+CF8h] [rbp+C78h]
  LPVOID lpMem; // [rsp+D00h] [rbp+C80h]
  __int64 v477; // [rsp+D08h] [rbp+C88h]
  signed __int64 v478; // [rsp+D10h] [rbp+C90h]
  LPVOID v479; // [rsp+D18h] [rbp+C98h]
  LPVOID v480; // [rsp+D20h] [rbp+CA0h]
  unsigned __int64 v481; // [rsp+D28h] [rbp+CA8h]
  LPVOID v482; // [rsp+D30h] [rbp+CB0h]
  unsigned __int64 v483; // [rsp+D38h] [rbp+CB8h]
  unsigned __int64 v484; // [rsp+D40h] [rbp+CC0h]
  unsigned __int64 *v485; // [rsp+D48h] [rbp+CC8h]

  v435 = a2;
  if ( !(_QWORD)xmmword_43F038 )
    return;
  v2 = a1;
  v3 = 0LL;
  v4 = (_QWORD *)*((_QWORD *)&xmmword_43F028 + 1);
LABEL_3:
  v5 = (_QWORD *)v4[5];
  v6 = v4[6];
  v7 = v4[7];
  v4 += 8;
  v8 = 16 * v6;
  do
  {
    if ( !v8 )
    {
      ++v3;
      if ( v4 == (_QWORD *)(*((_QWORD *)&xmmword_43F028 + 1) + ((_QWORD)xmmword_43F038 << 6)) )
        return;
      goto LABEL_3;
    }
    v9 = v5;
    v5 += 2;
    v10 = v7 + *v9;
    v8 -= 16LL;
  }
  while ( v10 > (unsigned __int64)a1 || v9[1] + v10 <= (unsigned __int64)a1 );
  v11 = (char *)*(&::Src + 1);
  if ( *(&::Src + 1) )
  {
    v12 = (volatile signed __int64 **)::Src;
    v13 = 0LL;
    v14 = 0LL;
    do
    {
      if ( *(_QWORD *)((char *)::Src + v13) == v3 )
      {
        if ( v14 )
        {
          memcpy(Src, (char *)::Src + 560 * v14, sizeof(Src));
          memmove((char *)::Src + 560 * v14, (char *)::Src + 560 * v14 + 560, 560 * ((_QWORD)*(&::Src + 1) + ~v14));
          *(&::Src + 1) = v11 - 1;
          if ( v11 - 1 == *((char **)&xmmword_43F038 + 1) )
            sub_422FC0((__int64)&off_44A3D8, v32);
          v12 = (volatile signed __int64 **)::Src;
          memmove((char *)::Src + 560, ::Src, 560LL * (_QWORD)(v11 - 1));
          memcpy(v12, Src, 0x230uLL);
          *(&::Src + 1) = v11;
        }
        goto LABEL_35;
      }
      ++v14;
      v13 += 560LL;
    }
    while ( 560LL * (_QWORD)*(&::Src + 1) != v13 );
  }
  if ( (unsigned __int64)xmmword_43F038 <= v3 )
    sub_4050B0(v3, xmmword_43F038, &off_44A3F0);
  sub_4151C0(
    v428,
    *(unsigned __int8 **)(*((_QWORD *)&xmmword_43F028 + 1) + (v3 << 6) + 8),
    *(_QWORD *)(*((_QWORD *)&xmmword_43F028 + 1) + (v3 << 6) + 16));
  if ( (v428[0] & 1) != 0 )
  {
    v466 = v2;
    hObject = (HANDLE)*((_QWORD *)&v428[0] + 1);
    *((_QWORD *)&v15 + 1) = *((_QWORD *)&v428[1] + 1);
    v16 = *(char **)&v428[1];
    *(_QWORD *)&v411 = 0LL;
    *((_QWORD *)&v411 + 1) = 8LL;
    v412 = 0LL;
    v413 = 8uLL;
    if ( *((_QWORD *)&v428[1] + 1) < 0x40uLL )
      goto LABEL_238;
    if ( **(_WORD **)&v428[1] != 23117 )
      goto LABEL_238;
    v17 = *(unsigned int *)(*(_QWORD *)&v428[1] + 60LL);
    if ( *((_QWORD *)&v428[1] + 1) < v17 || *((_QWORD *)&v428[1] + 1) - v17 < 0x88 )
      goto LABEL_238;
    if ( *(_DWORD *)(*(_QWORD *)&v428[1] + v17) != 17744 )
      goto LABEL_238;
    if ( *(_WORD *)(*(_QWORD *)&v428[1] + v17 + 24) != 523 )
      goto LABEL_238;
    v18 = *(unsigned __int16 *)(*(_QWORD *)&v428[1] + v17 + 20);
    if ( v18 < 0x70 )
      goto LABEL_238;
    v19 = v18 - 112;
    if ( *((_QWORD *)&v428[1] + 1) - (v17 + 136) < v19 )
      goto LABEL_238;
    if ( 8 * (unsigned __int64)*(unsigned int *)(*(_QWORD *)&v428[1] + v17 + 132) > v19 )
      goto LABEL_238;
    v20 = v17 + 136 + v19;
    v21 = (_QWORD *)*(unsigned __int16 *)(*(_QWORD *)&v428[1] + v17 + 6);
    v22 = *((_QWORD *)&v428[1] + 1) < v20
       || *((_QWORD *)&v428[1] + 1) - v20 < 5 * (unsigned __int64)(unsigned int)(8 * (_DWORD)v21);
    v23 = *(_QWORD *)&v428[1] + v20;
    if ( v22 )
      goto LABEL_238;
    v24 = v23;
    v25 = *(unsigned int *)(*(_QWORD *)&v428[1] + v17 + 12);
    if ( *(_DWORD *)(*(_QWORD *)&v428[1] + v17 + 12) )
    {
      if ( *((_QWORD *)&v428[1] + 1) < v25 )
        goto LABEL_238;
      v26 = *(unsigned int *)(*(_QWORD *)&v428[1] + v17 + 16);
      if ( *((_QWORD *)&v428[1] + 1) - v25 < 18 * v26 )
        goto LABEL_238;
      v27 = v25 + 18 * v26;
      if ( *((_QWORD *)&v428[1] + 1) - v27 < 4 )
        goto LABEL_238;
      v471 = v25 + 18 * v26;
      v475 = *(unsigned int *)(*(_QWORD *)&v428[1] + v27);
      v480 = *(LPVOID *)(*(_QWORD *)&v428[1] + v17 + 48);
      *(_QWORD *)&v428[0] = 0LL;
      *((_QWORD *)&v428[0] + 1) = 8LL;
      *(_QWORD *)&v428[1] = 0LL;
      v474 = v26;
      if ( v26 )
      {
        v28 = &v16[v25];
        v29 = 8LL;
        v485 = 0LL;
        v30 = 0LL;
        v31 = v474;
        v478 = (signed __int64)v21;
        v472 = v23;
        v479 = v28;
        do
        {
          v182 = (unsigned __int8)v28[18 * v30 + 17];
          if ( (*(_WORD *)&v28[18 * v30 + 14] & 0x30) == 0x20 )
          {
            v183 = (unsigned __int8 *)&v28[18 * v30];
            v184 = *((unsigned __int16 *)v183 + 6);
            v185 = (__int16)v184;
            if ( v184 < 0xFEFF )
              v185 = *((unsigned __int16 *)v183 + 6);
            if ( v185 > 0 )
            {
              v484 = (unsigned __int8)v28[18 * v30 + 17];
              v186 = (unsigned int)v185 - 1LL;
              v187 = v24 + 40 * v186;
              if ( v186 >= (unsigned __int64)v21 || !v187 )
              {
                if ( *(_QWORD *)&v428[0] )
                {
                  v204 = (void *)*((_QWORD *)&v428[0] + 1);
LABEL_237:
                  ProcessHeap = GetProcessHeap();
                  HeapFree(ProcessHeap, 0, v204);
                }
LABEL_238:
                sub_419960(&v411);
                UnmapViewOfFile(v16);
                CloseHandle(hObject);
                return;
              }
              v482 = &v28[18 * v30];
              v188 = *((unsigned int *)v183 + 2);
              v189 = *(unsigned int *)(v187 + 12);
              if ( v485 == *(unsigned __int64 **)&v428[0] )
              {
                sub_419B60((__int64 *)v428, (__int64)&off_44A460);
                v29 = *((_QWORD *)&v428[0] + 1);
              }
              v180 = v485;
              v181 = 16LL * (_QWORD)v485;
              *(_QWORD *)(v29 + v181) = (char *)v480 + v188 + v189;
              *(_QWORD *)(v29 + v181 + 8) = v482;
              v485 = (unsigned __int64 *)((char *)v180 + 1);
              *(_QWORD *)&v428[1] = (char *)v180 + 1;
              v21 = (_QWORD *)v478;
              v24 = v472;
              v28 = (char *)v479;
              v31 = v474;
              v182 = v484;
            }
          }
          v30 += v182 + 1;
        }
        while ( v30 < v31 );
        if ( (unsigned __int64)v485 >= 2 )
        {
          v365 = v24;
          v366 = v21;
          v367 = (unsigned __int64 *)*((_QWORD *)&v428[0] + 1);
          if ( (unsigned __int64)v485 >= 0x15 )
          {
            sub_419A30(*((__int64 *)&v428[0] + 1), (unsigned __int64)v485);
            v21 = v366;
            v24 = v365;
          }
          else
          {
            v368 = *((_QWORD *)&v428[0] + 1) + 16LL * (_QWORD)v485;
            v369 = *((_QWORD *)&v428[0] + 1) + 16LL;
            v370 = 16LL;
            v371 = (unsigned __int64 *)*((_QWORD *)&v428[0] + 1);
            do
            {
              v373 = (unsigned __int64 *)v369;
              v374 = v371[2];
              if ( v374 < *v371 )
              {
                v375 = v371[3];
                v376 = v370;
                do
                {
                  *(_OWORD *)((char *)v367 + v376) = *(_OWORD *)((char *)v367 + v376 - 16);
                  if ( v376 == 16 )
                  {
                    v372 = v367;
                    goto LABEL_561;
                  }
                  v377 = v376 - 16;
                  v212 = v374 < *(unsigned __int64 *)((char *)v367 + v376 - 32);
                  v376 -= 16LL;
                }
                while ( v212 );
                v372 = (unsigned __int64 *)((char *)v367 + v377);
LABEL_561:
                *v372 = v374;
                v372[1] = v375;
              }
              v369 = (__int64)(v373 + 2);
              v370 += 16LL;
              v371 = v373;
              v21 = v366;
              v24 = v365;
            }
            while ( v373 + 2 != (unsigned __int64 *)v368 );
          }
        }
      }
      v119 = *(_QWORD *)&v428[0];
      v403[0] = *(__int128 *)((char *)v428 + 8);
      v118 = v471;
      if ( __OFSUB__(-*(_QWORD *)&v428[0], 1LL) )
        goto LABEL_238;
      v117 = v471 + v475;
      *(_QWORD *)&v15 = v16;
    }
    else
    {
      *((_QWORD *)&v428[0] + 1) = 8LL;
      *(_QWORD *)&v428[1] = 0LL;
      v403[0] = 8uLL;
      v117 = 0LL;
      v118 = 0LL;
      *(_QWORD *)&v15 = 0LL;
      v119 = 0LL;
    }
    *(_OWORD *)&v437[8] = v403[0];
    *(_QWORD *)v437 = v119;
    *(_QWORD *)&v437[24] = v16;
    *(_QWORD *)&v437[32] = *((_QWORD *)&v15 + 1);
    *(_QWORD *)&v437[40] = v24;
    *(_QWORD *)&v437[48] = v21;
    v438 = v15;
    *(_QWORD *)&v439 = v118;
    *((_QWORD *)&v439 + 1) = v117;
    v429[0] = (LPVOID)0x8000000000000000LL;
    v120 = sub_419C30(v437, aDebugAbbrev, 0xDuLL);
    v485 = v121;
    v122 = v120;
    v484 = 1LL;
    if ( !v120 )
      v122 = 1LL;
    v469 = (_QWORD *)v122;
    v123 = v485;
    if ( !v120 )
      v123 = 0LL;
    v485 = v123;
    v124 = sub_419C30(v437, aDebugAddr, 0xBuLL);
    v482 = v125;
    v126 = v484;
    if ( v124 )
      v126 = v124;
    v484 = v126;
    v127 = v482;
    if ( !v124 )
      v127 = 0LL;
    v482 = v127;
    v128 = sub_419C30(v437, aDebugAranges, 0xEuLL);
    v474 = v129;
    v130 = v128;
    v480 = (LPVOID)1;
    if ( !v128 )
      v130 = 1LL;
    v467 = v130;
    v131 = v474;
    if ( !v128 )
      v131 = 0LL;
    v474 = v131;
    v132 = sub_419C30(v437, aDebugInfo, 0xBuLL);
    v478 = (signed __int64)v133;
    v134 = v480;
    if ( v132 )
      v134 = (void *)v132;
    v480 = v134;
    v135 = (_QWORD *)v478;
    if ( !v132 )
      v135 = 0LL;
    v478 = (signed __int64)v135;
    v136 = sub_419C30(v437, aDebugLine, 0xBuLL);
    v472 = v137;
    v138 = v136;
    v479 = (LPVOID)1;
    if ( !v136 )
      v138 = 1LL;
    v461 = v138;
    v139 = v472;
    if ( !v136 )
      v139 = 0LL;
    v472 = v139;
    v140 = sub_419C30(v437, aDebugLineStr, 0xFuLL);
    v471 = v141;
    v142 = v479;
    if ( v140 )
      v142 = (void *)v140;
    v479 = v142;
    v143 = v471;
    if ( !v140 )
      v143 = 0LL;
    v471 = v143;
    v144 = sub_419C30(v437, aDebugStr, 0xAuLL);
    v475 = v145;
    v146 = v144;
    v483 = 1LL;
    if ( !v144 )
      v146 = 1LL;
    v462 = (char *)v146;
    v147 = v475;
    if ( !v144 )
      v147 = 0LL;
    v475 = v147;
    v148 = sub_419C30(v437, aDebugStrOffset, 0x12uLL);
    lpMem = v149;
    v150 = v483;
    if ( v148 )
      v150 = v148;
    v483 = v150;
    v151 = lpMem;
    if ( !v148 )
      v151 = 0LL;
    lpMem = v151;
    v152 = sub_419C30(v437, aDebugTypes, 0xCuLL);
    v470 = v153;
    v154 = v152;
    v477 = 1LL;
    if ( !v152 )
      v154 = 1LL;
    v452 = v154;
    v155 = v470;
    if ( !v152 )
      v155 = 0LL;
    v470 = v155;
    v156 = sub_419C30(v437, aDebugLoc, 0xAuLL);
    v481 = (unsigned __int64)v157;
    v158 = v477;
    if ( v156 )
      v158 = v156;
    v477 = v158;
    v159 = (unsigned int *)v481;
    if ( !v156 )
      v159 = 0LL;
    v481 = (unsigned __int64)v159;
    v160 = sub_419C30(v437, aDebugLoclists, 0xFuLL);
    v473 = v161;
    v162 = 1LL;
    if ( v160 )
      v162 = v160;
    v163 = v473;
    if ( !v160 )
      v163 = 0LL;
    v473 = v163;
    v164 = sub_419C30(v437, aDebugRanges, 0xDuLL);
    v166 = v165;
    v167 = sub_419C30(v437, aDebugRnglists, 0xFuLL);
    if ( !v164 )
      v166 = 0LL;
    v169 = 1LL;
    if ( !v164 )
      v164 = 1LL;
    if ( v167 )
      v169 = v167;
    else
      v168 = 0LL;
    v428[14] = 0LL;
    *(_QWORD *)&v428[1] = v469;
    *((_QWORD *)&v428[1] + 1) = v485;
    *(_QWORD *)&v428[2] = v484;
    *((_QWORD *)&v428[2] + 1) = v482;
    *(_QWORD *)&v428[3] = v467;
    *((_QWORD *)&v428[3] + 1) = v474;
    *(_QWORD *)&v428[4] = v480;
    *((_QWORD *)&v428[4] + 1) = v478;
    *(_QWORD *)&v428[5] = v461;
    *((_QWORD *)&v428[5] + 1) = v472;
    *(_QWORD *)&v428[6] = v479;
    *((_QWORD *)&v428[6] + 1) = v471;
    *(_QWORD *)&v428[7] = v462;
    *((_QWORD *)&v428[7] + 1) = v475;
    *(_QWORD *)&v428[8] = v483;
    *((_QWORD *)&v428[8] + 1) = lpMem;
    *(_QWORD *)&v428[9] = v452;
    *((_QWORD *)&v428[9] + 1) = v470;
    *(_QWORD *)&v428[10] = v477;
    *((_QWORD *)&v428[10] + 1) = v481;
    *(_QWORD *)&v428[11] = v162;
    *((_QWORD *)&v428[11] + 1) = v473;
    *(_QWORD *)&v428[12] = v164;
    *((_QWORD *)&v428[12] + 1) = v166;
    *(_QWORD *)&v428[13] = v169;
    *((_QWORD *)&v428[13] + 1) = v168;
    *((_QWORD *)&v428[15] + 1) = 0LL;
    LOBYTE(v428[16]) = 0;
    *(_QWORD *)&v428[0] = 1LL;
    *((_QWORD *)&v428[0] + 1) = 1LL;
    v170 = (char *)sub_43C4F0(0x108uLL);
    if ( !v170 )
      sub_4040E9(8LL, 264LL);
    v171 = v170;
    memcpy(v170, v428, 0x108uLL);
    v451 = v171;
    v447 = 0LL;
    v448 = (LPVOID)8;
    v449 = 0LL;
    v172 = *((_QWORD *)v171 + 7);
    v478 = *((_QWORD *)v171 + 6);
    v425 = v478;
    v426 = v172;
    v427 = 0LL;
    v474 = v172;
    v480 = v171;
    if ( v172 )
    {
      v173 = 8LL;
      v485 = 0LL;
      v482 = (LPVOID)8;
      v174 = 0LL;
      v175 = v474;
      do
      {
        sub_419ED0((__int64)v428, (unsigned __int64 *)&v425, v174);
        if ( BYTE9(v428[2]) == 3 )
          goto LABEL_227;
        v484 = *(_QWORD *)&v428[1];
        v174 = v427 + v175 - v426;
        v179 = *(_QWORD *)&v428[2];
        v427 = v174;
        if ( v485 == v447 )
        {
          sub_419B60((__int64 *)&v447, (__int64)&off_448278);
          v482 = v448;
        }
        v176 = (char *)v482;
        *(_QWORD *)((char *)v482 + v173 - 8) = v179;
        *(_QWORD *)&v176[v173] = v484;
        v485 = (unsigned __int64 *)((char *)v485 + 1);
        v449 = v485;
        v175 = v426;
        v173 += 16LL;
      }
      while ( v426 );
      v171 = (char *)v480;
      if ( (unsigned __int64)v485 >= 2 )
      {
        v378 = (unsigned __int64 *)v448;
        if ( (unsigned __int64)v485 >= 0x15 )
        {
          sub_41A180((__m128i *)v448, (unsigned __int64)v485);
          v171 = (char *)v480;
        }
        else
        {
          v379 = (char *)v448 + 16 * (_QWORD)v485;
          v380 = (char *)v448 + 16;
          v381 = 16LL;
          v382 = (unsigned __int64 *)v448;
          v171 = (char *)v480;
          do
          {
            v384 = v380;
            v385 = v382[2];
            if ( v385 < *v382 )
            {
              v386 = v382[3];
              v387 = v381;
              do
              {
                *(_OWORD *)((char *)v378 + v387) = *(_OWORD *)((char *)v378 + v387 - 16);
                if ( v387 == 16 )
                {
                  v383 = v378;
                  goto LABEL_571;
                }
                v388 = v387 - 16;
                v212 = v385 < *(unsigned __int64 *)((char *)v378 + v387 - 32);
                v387 -= 16LL;
              }
              while ( v212 );
              v383 = (unsigned __int64 *)((char *)v378 + v388);
LABEL_571:
              *v383 = v385;
              v383[1] = v386;
            }
            v380 = v384 + 16;
            v381 += 16LL;
            v382 = (unsigned __int64 *)v384;
          }
          while ( v384 + 16 != v379 );
        }
      }
    }
    v463 = 0LL;
    v464 = (LPVOID)8;
    v465 = 0LL;
    v458[0] = 0LL;
    v458[1] = (LPVOID)8;
    v459 = 0LL;
    v442 = *((_OWORD *)v171 + 4);
    v443 = 0LL;
    sub_41A2B0((__int64)v428, (unsigned __int64 *)&v442);
    v190 = *(_QWORD *)&v428[0];
    if ( *(_QWORD *)&v428[0] == 3LL )
      goto LABEL_220;
    v485 = (unsigned __int64 *)(v171 + 16);
    v471 = *((_QWORD *)v171 + 26);
    v472 = *((_QWORD *)v171 + 27);
    LOBYTE(v475) = v171[256];
    v479 = (LPVOID)*((_QWORD *)v171 + 4);
    v482 = (LPVOID)*((_QWORD *)v171 + 5);
    while ( 1 )
    {
      v206 = *((_QWORD *)&v428[0] + 1);
      *(_QWORD *)&v403[3] = *((_QWORD *)&v428[4] + 1);
      v403[2] = *(__int128 *)((char *)&v428[3] + 8);
      v403[1] = *(__int128 *)((char *)&v428[2] + 8);
      v403[0] = *(__int128 *)((char *)&v428[1] + 8);
      v392 = *(__int128 *)((char *)&v428[1] + 8);
      v422 = *(__int128 *)((char *)&v428[2] + 8);
      v423 = *(__int128 *)((char *)&v428[3] + 8);
      v177 = *((_QWORD *)&v428[4] + 1);
      v424 = *((_QWORD *)&v428[4] + 1);
      if ( v190 == 2 )
        break;
      if ( v190 )
        goto LABEL_241;
      if ( (*(_QWORD *)&v428[1] | 4LL) == 5 )
        goto LABEL_241;
      v484 = (unsigned __int64)v459;
      *(_QWORD *)v444 = 0LL;
      *(_QWORD *)&v444[8] = *((_QWORD *)&v428[0] + 1);
      *(_QWORD *)&v444[16] = *(_QWORD *)&v428[1];
      *(_OWORD *)&v444[24] = v392;
      v446 = v424;
      v445 = v423;
      *(_OWORD *)&v444[40] = v422;
      sub_41A8B0((unsigned __int64)v428, v485, (unsigned __int64)v444);
      if ( LODWORD(v428[0]) == 2 )
      {
LABEL_241:
        sub_41A2B0((__int64)v428, (unsigned __int64 *)&v442);
        v190 = *(_QWORD *)&v428[0];
        if ( *(_QWORD *)&v428[0] == 3LL )
          goto LABEL_220;
      }
      else
      {
        memcpy(v403, v428, 0x1A8uLL);
        v177 = *((_QWORD *)&v403[21] + 1);
        v178 = *((_QWORD *)&v403[2] + 1);
        *(_OWORD *)v444 = *(__int128 *)((char *)&v403[2] + 8);
        *(_QWORD *)&v444[16] = v403;
        *(_QWORD *)&v444[24] = *((_QWORD *)&v403[21] + 1) + 16LL;
        *(_QWORD *)&v444[32] = 0LL;
        if ( !*(_QWORD *)&v403[3] )
          goto LABEL_451;
        v207 = *(_QWORD *)&v403[3] - 1LL;
        v208 = *((_QWORD *)&v403[2] + 1) + 1LL;
        v209 = 0LL;
        v210 = 0;
        while ( 1 )
        {
          v211 = *(_BYTE *)(v208 - 1);
          if ( v210 == 63 && (unsigned __int8)v211 >= 2u )
          {
            *(_QWORD *)v444 = v208;
            goto LABEL_451;
          }
          v209 |= (unsigned __int64)(*(_BYTE *)(v208 - 1) & 0x7F) << v210;
          if ( v211 >= 0 )
            break;
          v210 += 7;
          ++v208;
          v212 = v207-- != 0;
          if ( !v212 )
          {
            v178 = *(_QWORD *)&v403[3] + *((_QWORD *)&v403[2] + 1);
            *(_QWORD *)v444 = *(_QWORD *)&v403[3] + *((_QWORD *)&v403[2] + 1);
            goto LABEL_451;
          }
        }
        *(_QWORD *)v444 = v208;
        *(_QWORD *)&v444[8] = v207;
        if ( !v209 )
        {
          if ( !_InterlockedDecrement64(*((volatile signed __int64 **)&v403[21] + 1)) )
            sub_41D140(*((LPVOID *)&v403[21] + 1), v177, v178);
          if ( LODWORD(v403[6]) != 47 )
          {
            if ( *(_QWORD *)&v403[10] )
            {
              v213 = (void *)*((_QWORD *)&v403[10] + 1);
              v214 = GetProcessHeap();
              HeapFree(v214, 0, v213);
            }
            if ( *((_QWORD *)&v403[11] + 1) )
            {
              v215 = *(void **)&v403[12];
              v216 = GetProcessHeap();
              HeapFree(v216, 0, v215);
            }
            if ( *(_QWORD *)&v403[13] )
            {
              v217 = (void *)*((_QWORD *)&v403[13] + 1);
              v218 = GetProcessHeap();
              HeapFree(v218, 0, v217);
            }
            if ( *((_QWORD *)&v403[14] + 1) )
            {
              v219 = *(void **)&v403[15];
              v220 = GetProcessHeap();
              HeapFree(v220, 0, v219);
            }
          }
          goto LABEL_241;
        }
        if ( v209 - 1 >= *(_QWORD *)(*((_QWORD *)&v403[21] + 1) + 32LL) )
        {
          v222 = *(_QWORD *)(*((_QWORD *)&v403[21] + 1) + 40LL);
          if ( !v222 )
            goto LABEL_451;
          v177 = *(_QWORD *)(*((_QWORD *)&v403[21] + 1) + 48LL);
LABEL_269:
          v223 = 8 * (unsigned int)*(unsigned __int16 *)(v222 + 1330);
          v178 = -1LL;
          do
          {
            if ( !v223 )
            {
              v178 = *(unsigned __int16 *)(v222 + 1330);
LABEL_277:
              v212 = v177-- == 0;
              if ( v212 )
                goto LABEL_451;
              v222 = *(_QWORD *)(v222 + 8 * v178 + 1336);
              goto LABEL_269;
            }
            v224 = *(_QWORD *)(v222 + 8 * v178 + 1248) != v209;
            if ( *(_QWORD *)(v222 + 8 * v178 + 1248) > v209 )
              v224 = -1;
            ++v178;
            v223 -= 8LL;
          }
          while ( v224 == 1 );
          if ( v224 )
            goto LABEL_277;
          v221 = 112 * v178 + v222;
        }
        else
        {
          v221 = *(_QWORD *)(*((_QWORD *)&v403[21] + 1) + 24LL) + 112 * (v209 - 1);
        }
        if ( *(_BYTE *)(v221 + 106) == 1 )
          *(_QWORD *)&v444[32] = 1LL;
        lpMem = (LPVOID)sub_409E2D(v221);
        v483 = v177;
        if ( v177 )
        {
          v419 = v472 - *(_QWORD *)&v403[26];
          v440 = WORD4(v403[4]) & 0xFF00;
          v441 = HIWORD(DWORD2(v403[4]));
          v225 = 0LL;
          if ( DWORD2(v403[4]) < 0x50000 )
            v225 = *(_QWORD *)&v403[26];
          v452 = *(_QWORD *)&v403[26];
          v436 = *(_QWORD *)&v403[26] + v471;
          v226 = 0LL;
          if ( (v475 & 1) == 0 )
            v225 = 0LL;
          v418 = v225;
          v420 = BYTE9(v403[4]);
          v467 = (unsigned __int64)v482 - *(_QWORD *)&v403[25];
          v462 = *(char **)&v403[25];
          v460 = (char *)v479 + *(_QWORD *)&v403[25];
          v450 = DWORD2(v403[4]);
          v481 = BYTE8(v403[4]);
          v483 *= 16LL;
          LODWORD(v470) = 0;
          LODWORD(v473) = 0;
          LODWORD(v469) = 0;
          v455 = 0;
          LODWORD(v477) = 0;
          while ( 1 )
          {
            v391 = *(_OWORD *)((char *)lpMem + v226);
            sub_41D2E0(
              (__int64)v428,
              (unsigned __int64 *)v444,
              *(_DWORD *)(*(_QWORD *)&v444[16] + 72LL),
              (__int64)&v391);
            if ( *(_QWORD *)&v428[0] == 46LL )
              break;
            *(_OWORD *)&v453.m256i_u64[1] = *(__int128 *)((char *)v428 + 8);
            v453.m256i_i64[0] = *(_QWORD *)&v428[0];
            v453.m256i_i64[3] = *((_QWORD *)&v428[1] + 1);
            if ( WORD4(v428[1]) > 0x12u )
            {
              if ( WORD4(v428[1]) == 19 )
              {
                sub_421680((__int64)v428, v453.m256i_i64);
                if ( *(_QWORD *)&v428[0] == 38LL )
                  v454 = WORD4(v428[0]);
                v227 = (int)v470;
                if ( LODWORD(v428[0]) == 38 )
                  v227 = 1;
                LODWORD(v470) = v227;
              }
              else if ( WORD4(v428[1]) == 85 )
              {
                sub_421680((__int64)v428, v453.m256i_i64);
                v232 = v428[0];
                if ( *(_QWORD *)&v428[0] == 22LL )
                {
                  LOBYTE(v232) = 1;
                  LODWORD(v477) = v232;
                  v461 = v418 + *((_QWORD *)&v428[0] + 1);
                }
                else if ( LODWORD(v428[0]) == 24 )
                {
                  if ( v472 < v452 )
                    break;
                  v233 = v420 * *((_QWORD *)&v428[0] + 1);
                  v234 = v419 - v420 * *((_QWORD *)&v428[0] + 1);
                  if ( v419 < v420 * *((_QWORD *)&v428[0] + 1) )
                    break;
                  if ( v440 == 2048 )
                  {
                    if ( v234 <= 7 )
                      break;
                    v177 = *(unsigned __int16 *)(v436 + v233 + 4);
                    v178 = (unsigned __int64)((unsigned int)v177 | (*(unsigned __int8 *)(v436 + v233 + 6) << 16)) << 40;
                    *(_QWORD *)&v236 = v178 | ((unsigned __int64)*(unsigned int *)(v436 + v233) << 8);
                    *((_QWORD *)&v236 + 1) = *(unsigned __int8 *)(v436 + v233 + 7);
                    v235 = v236 >> 8;
                  }
                  else
                  {
                    if ( v234 <= 3 )
                      break;
                    v235 = *(unsigned int *)(v436 + v233);
                  }
                  v461 = v235;
                  v240 = v452;
                  v461 += v452;
                  LOBYTE(v240) = 1;
                  LODWORD(v477) = v240;
                }
                else
                {
                  LODWORD(v477) = 0;
                }
              }
            }
            else if ( WORD4(v428[1]) == 17 )
            {
              sub_421680((__int64)v428, v453.m256i_i64);
              if ( *(_QWORD *)&v428[0] )
              {
                if ( LODWORD(v428[0]) == 12 )
                {
                  if ( v482 < v462 )
                    break;
                  v237 = v481 * *((_QWORD *)&v428[0] + 1);
                  v238 = v467 - v481 * *((_QWORD *)&v428[0] + 1);
                  if ( v467 < v481 * *((_QWORD *)&v428[0] + 1) )
                    break;
                  v177 = (unsigned int)(v481 - 1);
                  switch ( (int)v481 )
                  {
                    case 1:
                      if ( v467 == v237 )
                        goto LABEL_451;
                      v239 = (unsigned __int8)v460[v237];
                      break;
                    case 2:
                      if ( v238 <= 1 )
                        goto LABEL_451;
                      v239 = *(unsigned __int16 *)&v460[v237];
                      break;
                    case 4:
                      if ( v238 <= 3 )
                        goto LABEL_451;
                      v239 = *(unsigned int *)&v460[v237];
                      break;
                    case 8:
                      if ( v238 < 8 )
                        goto LABEL_451;
                      v177 = *(unsigned __int16 *)&v460[v237 + 4];
                      v178 = (unsigned __int64)((unsigned int)v177 | ((unsigned __int8)v460[v237 + 6] << 16)) << 40;
                      *(_QWORD *)&v241 = v178 | ((unsigned __int64)*(unsigned int *)&v460[v237] << 8);
                      *((_QWORD *)&v241 + 1) = (unsigned __int8)v460[v237 + 7];
                      v239 = v241 >> 8;
                      break;
                    default:
                      goto LABEL_451;
                  }
                  v456 = v239;
                  LOBYTE(v239) = 1;
                  LODWORD(v473) = v239;
                }
              }
              else
              {
                LODWORD(v473) = 1;
                v456 = *((_QWORD *)&v428[0] + 1);
              }
            }
            else if ( WORD4(v428[1]) == 18 )
            {
              sub_421680((__int64)v428, v453.m256i_i64);
              v228 = v428[0];
              if ( *(_QWORD *)&v428[0] )
              {
                if ( LODWORD(v428[0]) == 7 )
                {
                  LOBYTE(v228) = 1;
                  v455 = v228;
                  v421 = *((_QWORD *)&v428[0] + 1);
                }
                else if ( LODWORD(v428[0]) == 12 )
                {
                  if ( v482 < v462 )
                    break;
                  v229 = v481 * *((_QWORD *)&v428[0] + 1);
                  v230 = v467 - v481 * *((_QWORD *)&v428[0] + 1);
                  if ( v467 < v481 * *((_QWORD *)&v428[0] + 1) )
                    break;
                  v177 = (unsigned int)(v481 - 1);
                  switch ( (int)v481 )
                  {
                    case 1:
                      if ( v467 == v229 )
                        goto LABEL_451;
                      v231 = (unsigned __int8)v460[v229];
                      break;
                    case 2:
                      if ( v230 <= 1 )
                        goto LABEL_451;
                      v231 = *(unsigned __int16 *)&v460[v229];
                      break;
                    case 4:
                      if ( v230 <= 3 )
                        goto LABEL_451;
                      v231 = *(unsigned int *)&v460[v229];
                      break;
                    case 8:
                      if ( v230 < 8 )
                        goto LABEL_451;
                      v177 = *(unsigned __int16 *)&v460[v229 + 4];
                      v178 = (unsigned __int64)((unsigned int)v177 | ((unsigned __int8)v460[v229 + 6] << 16)) << 40;
                      *(_QWORD *)&v242 = v178 | ((unsigned __int64)*(unsigned int *)&v460[v229] << 8);
                      *((_QWORD *)&v242 + 1) = (unsigned __int8)v460[v229 + 7];
                      v231 = v242 >> 8;
                      break;
                    default:
                      goto LABEL_451;
                  }
                  v457 = v231;
                  LOBYTE(v231) = 1;
                  LODWORD(v469) = v231;
                }
              }
              else
              {
                LODWORD(v469) = 1;
                v457 = *((_QWORD *)&v428[0] + 1);
              }
            }
            v226 += 16LL;
            if ( v483 == v226 )
            {
              if ( (v477 & 1) == 0 )
                goto LABEL_350;
              v243 = *((_QWORD *)v480 + 2 * (unsigned int)(v450 >= 0x50000) + 25);
              v212 = v243 < v461;
              v244 = v243 - v461;
              if ( v212 )
                break;
              v245 = v461 + *((_QWORD *)v480 + 2 * (unsigned int)(v450 >= 0x50000) + 24);
              BYTE4(v428[3]) = v450 >= 0x50000;
              *(_QWORD *)&v428[0] = v479;
              *((_QWORD *)&v428[0] + 1) = v482;
              *(_QWORD *)&v428[1] = *(_QWORD *)&v403[24];
              *((_QWORD *)&v428[1] + 1) = v462;
              *(_QWORD *)&v428[2] = v245;
              *((_QWORD *)&v428[2] + 1) = v244;
              LOWORD(v428[3]) = v450;
              WORD1(v428[3]) = v441;
              sub_41E760(&v453, (unsigned __int8 **)v428);
              v246 = v453.m256i_i64[0];
              if ( v453.m256i_i64[0] == 2 )
              {
LABEL_348:
                if ( v453.m256i_i8[8] != 75 )
                  break;
                v481 = ((unsigned __int32)v453.m256i_i32[2] >> 8) & 1;
              }
              else
              {
                v481 = 0LL;
                while ( v246 == 1 )
                {
                  v483 = v453.m256i_u64[2];
                  v276 = v453.m256i_i64[1];
                  if ( v453.m256i_i64[1] < (unsigned __int64)v453.m256i_i64[2] )
                  {
                    v277 = v465;
                    if ( v465 == v463 )
                      sub_41F5E0((__int64 *)&v463, (__int64)&off_4482D8);
                    v274 = (unsigned int *)v464;
                    v275 = 8 * v277;
                    *(_QWORD *)((char *)v464 + v275 * 4) = v276;
                    *(_QWORD *)&v274[v275 + 2] = v483;
                    *(_QWORD *)&v274[v275 + 4] = v484;
                    *(_QWORD *)&v274[v275 + 6] = 0LL;
                    v465 = v277 + 1;
                    LOBYTE(v274) = 1;
                    v481 = (unsigned __int64)v274;
                  }
                  sub_41E760(&v453, (unsigned __int8 **)v428);
                  v246 = v453.m256i_i64[0];
                  if ( v453.m256i_i64[0] == 2 )
                    goto LABEL_348;
                }
              }
              goto LABEL_411;
            }
          }
LABEL_451:
          if ( !_InterlockedDecrement64(*((volatile signed __int64 **)&v403[21] + 1)) )
            sub_41D140(*((LPVOID *)&v403[21] + 1), v177, v178);
          if ( LODWORD(v403[6]) != 47 )
          {
            if ( *(_QWORD *)&v403[10] )
            {
              v293 = (void *)*((_QWORD *)&v403[10] + 1);
              v294 = GetProcessHeap();
              HeapFree(v294, 0, v293);
            }
            if ( *((_QWORD *)&v403[11] + 1) )
            {
              v295 = *(void **)&v403[12];
              v296 = GetProcessHeap();
              HeapFree(v296, 0, v295);
            }
            if ( *(_QWORD *)&v403[13] )
            {
              v297 = (void *)*((_QWORD *)&v403[13] + 1);
              v298 = GetProcessHeap();
              HeapFree(v298, 0, v297);
            }
            if ( *((_QWORD *)&v403[14] + 1) )
            {
              v299 = *(void **)&v403[15];
              v300 = GetProcessHeap();
              HeapFree(v300, 0, v299);
            }
          }
LABEL_220:
          v191 = v458[1];
          v192 = (char *)v459 + 1;
          v193 = (char *)v458[1];
          while ( v192 != (char *)1 )
          {
            v194 = v193 + 536;
            --v192;
            sub_41F780((__int64)v193, v177, v178);
            v193 = v194;
          }
          if ( v458[0] )
          {
            v195 = GetProcessHeap();
            HeapFree(v195, 0, v191);
          }
          if ( v463 )
          {
            v196 = v464;
            v197 = GetProcessHeap();
            HeapFree(v197, 0, v196);
          }
LABEL_227:
          if ( v447 )
          {
            v198 = v448;
            v199 = GetProcessHeap();
            HeapFree(v199, 0, v198);
          }
          v200 = (volatile signed __int64 *)v451;
LABEL_230:
          if ( !_InterlockedDecrement64(v200) )
            sub_422320((__int64 *)&v451, v177, v178);
          v201 = v429[0];
LABEL_233:
          if ( 2LL * (_QWORD)v201 )
          {
            v202 = v429[1];
            v203 = GetProcessHeap();
            HeapFree(v203, 0, v202);
          }
          goto LABEL_235;
        }
        LODWORD(v470) = 0;
        LODWORD(v473) = 0;
        LODWORD(v469) = 0;
        v455 = 0;
LABEL_350:
        if ( v449 )
        {
          if ( v449 == (unsigned __int64 *)1 )
          {
            v247 = 0LL;
          }
          else
          {
            v248 = (unsigned __int64)v449;
            v177 = 0LL;
            do
            {
              v249 = (v248 >> 1) + v177;
              if ( *((_QWORD *)v448 + 2 * v249) > v206 )
                v249 = v177;
              v248 -= v248 >> 1;
              v247 = v249;
              v177 = v249;
            }
            while ( v248 > 1 );
          }
          v250 = 16 * v247;
          if ( *((_QWORD *)v448 + 2 * v247) == v206 )
          {
            v251 = (unsigned __int64 *)(v247 + 1);
            v252 = (char *)v448 + v250 - 16;
            while ( v251 != (unsigned __int64 *)1 )
            {
              v251 = (unsigned __int64 *)((char *)v251 - 1);
              v177 = (unsigned __int64)(v252 - 2);
              v82 = *v252 == v206;
              v252 -= 2;
              if ( !v82 )
                goto LABEL_369;
            }
            v251 = 0LL;
LABEL_369:
            if ( v251 == v449 )
            {
LABEL_410:
              v481 = 0LL;
            }
            else
            {
              v462 = (char *)v448 + 16 * (_QWORD)v449;
              v467 = (unsigned __int64)v448 + 16 * (_QWORD)v251;
              v481 = 0LL;
              do
              {
                if ( *(_QWORD *)v467 != v206 )
                  break;
                v178 = *(_QWORD *)(v467 + 8);
                if ( v474 < v178 )
                  goto LABEL_451;
                v453.m256i_i64[0] = v178 + v478;
                v453.m256i_i64[1] = v474 - v178;
                sub_419ED0((__int64)v428, (unsigned __int64 *)&v453, v178);
                if ( BYTE9(v428[2]) == 3 )
                  goto LABEL_451;
                v483 = *((_QWORD *)&v428[0] + 1);
                if ( *((_QWORD *)&v428[0] + 1) )
                {
                  v255 = *(unsigned __int16 **)&v428[0];
                  v469 = (_QWORD *)BYTE8(v428[2]);
                  lpMem = (LPVOID)BYTE12(v428[2]);
                  v473 = (unsigned __int8)(BYTE12(v428[2]) + 2 * BYTE8(v428[2]));
                  while ( v483 >= v473 )
                  {
                    switch ( (int)lpMem )
                    {
                      case 0:
                        v256 = (__int64)lpMem;
                        break;
                      case 1:
                        if ( !v483 )
                          goto LABEL_451;
                        --v483;
                        v256 = *(unsigned __int8 *)v255;
                        v255 = (unsigned __int16 *)((char *)v255 + 1);
                        break;
                      case 2:
                        if ( v483 <= 1 )
                          goto LABEL_451;
                        v483 -= 2LL;
                        v256 = *v255++;
                        break;
                      case 4:
                        if ( v483 <= 3 )
                          goto LABEL_451;
                        v483 -= 4LL;
                        v256 = *(unsigned int *)v255;
                        v255 += 2;
                        break;
                      case 8:
                        if ( v483 < 8 )
                          goto LABEL_451;
                        v483 -= 8LL;
                        v257 = *((unsigned __int8 *)v255 + 7);
                        v177 = v255[2];
                        v258 = *((unsigned __int8 *)v255 + 6);
                        v259 = *(unsigned int *)v255;
                        v255 += 4;
                        v178 = (unsigned __int64)((unsigned int)v177 | (v258 << 16)) << 40;
                        *(_QWORD *)&v260 = v178 | (v259 << 8);
                        *((_QWORD *)&v260 + 1) = v257;
                        v256 = v260 >> 8;
                        break;
                      default:
                        goto LABEL_451;
                    }
                    switch ( (int)v469 )
                    {
                      case 1:
                        if ( v483 < 2 )
                          goto LABEL_451;
                        v477 = *(unsigned __int8 *)v255;
                        v483 -= 2LL;
                        v261 = *((unsigned __int8 *)v255++ + 1);
                        break;
                      case 2:
                        if ( v483 < 4 )
                          goto LABEL_451;
                        v477 = *v255;
                        v483 -= 4LL;
                        v261 = v255[1];
                        v255 += 2;
                        break;
                      case 4:
                        if ( v483 < 4 || (v483 & 0xFFFFFFFFFFFFFFFCuLL) == 4 )
                          goto LABEL_451;
                        v477 = *(unsigned int *)v255;
                        v261 = *((unsigned int *)v255 + 1);
                        v483 -= 8LL;
                        v255 += 4;
                        break;
                      case 8:
                        if ( v483 < 8 || (v483 & 0xFFFFFFFFFFFFFFF8uLL) == 8 )
                          goto LABEL_451;
                        v262 = *((unsigned int *)v255 + 2);
                        *(_QWORD *)&v263 = ((unsigned __int64)(v255[2] | (*((unsigned __int8 *)v255 + 6) << 16)) << 40) | ((unsigned __int64)*(unsigned int *)v255 << 8);
                        *((_QWORD *)&v263 + 1) = *((unsigned __int8 *)v255 + 7);
                        v477 = v263 >> 8;
                        v483 -= 16LL;
                        v264 = *((unsigned __int8 *)v255 + 15);
                        v177 = v255[6];
                        v265 = *((unsigned __int8 *)v255 + 14);
                        v255 += 8;
                        v178 = (unsigned __int64)((unsigned int)v177 | (v265 << 16)) << 40;
                        *(_QWORD *)&v263 = v178 | (v262 << 8);
                        *((_QWORD *)&v263 + 1) = v264;
                        v261 = v263 >> 8;
                        break;
                      default:
                        goto LABEL_451;
                    }
                    if ( v261 | v477 | v256 )
                    {
                      if ( v261 )
                      {
                        v481 = v465;
                        if ( v465 == v463 )
                          sub_41F5E0((__int64 *)&v463, (__int64)&off_448290);
                        v266 = v477 + v261;
                        v267 = (unsigned int *)v464;
                        v268 = v481;
                        v269 = 8 * v481;
                        *(_QWORD *)((char *)v464 + v269 * 4) = v477;
                        *(_QWORD *)&v267[v269 + 2] = v266;
                        v177 = v484;
                        *(_QWORD *)&v267[v269 + 4] = v484;
                        *(_QWORD *)&v267[v269 + 6] = 0LL;
                        v178 = v268 + 1;
                        v465 = v178;
                        LOBYTE(v267) = 1;
                        v481 = (unsigned __int64)v267;
                      }
                      if ( !v483 )
                        break;
                    }
                  }
                }
                v467 += 16LL;
              }
              while ( (char *)v467 != v462 );
            }
LABEL_411:
            *(_QWORD *)v444 = 0LL;
            if ( (v481 & 1) == 0 && *(_QWORD *)&v403[6] != 47LL )
            {
              sub_41F880((__int64)v428, (__int64 *)&v403[6]);
              sub_41FD50(v453.m256i_i64, (__int64)v403, (__int64)v428, v485);
              *(_QWORD *)v444 = 1LL;
              *(__m256i *)&v444[8] = v453;
              if ( v453.m256i_i64[0] )
              {
                v483 = *(_QWORD *)&v444[32];
                if ( *(_QWORD *)&v444[32] )
                {
                  lpMem = *(LPVOID *)&v444[24];
                  v270 = v465;
                  v477 = 32 * v465;
                  v483 *= 32LL;
                  v271 = 0LL;
                  do
                  {
                    v273 = *(_OWORD *)((char *)lpMem + v271 + 16);
                    if ( v270 == v463 )
                      sub_41F5E0((__int64 *)&v463, (__int64)&off_4482A8);
                    v272 = (char *)v464 + v477;
                    *(_OWORD *)&v272[v271] = v273;
                    *(_QWORD *)&v272[v271 + 16] = v484;
                    *(_QWORD *)&v272[v271 + 24] = 0LL;
                    v465 = ++v270;
                    v271 += 32LL;
                  }
                  while ( v483 != v271 );
                }
              }
            }
            goto LABEL_428;
          }
        }
        if ( (v473 & 1) == 0 )
          goto LABEL_410;
        if ( ((unsigned __int8)v469 & 1) != 0 )
        {
          if ( v456 >= v457 )
            goto LABEL_410;
          v253 = v465;
          if ( v465 == v463 )
            sub_41F5E0((__int64 *)&v463, (__int64)&off_4482D8);
          v254 = v457;
        }
        else
        {
          if ( (v455 & 1) == 0 )
            goto LABEL_410;
          v254 = v421 + v456;
          if ( v456 >= v421 + v456 )
            goto LABEL_410;
          v253 = v465;
          if ( v465 == v463 )
            sub_41F5E0((__int64 *)&v463, (__int64)&off_4482D8);
        }
        v278 = (char *)v464;
        v279 = 32 * v253;
        *(_QWORD *)((char *)v464 + v279) = v456;
        *(_QWORD *)&v278[v279 + 8] = v254;
        *(_QWORD *)&v278[v279 + 16] = v484;
        *(_QWORD *)&v278[v279 + 24] = 0LL;
        v465 = v253 + 1;
        *(_QWORD *)v444 = 0LL;
LABEL_428:
        memcpy(v428, v403, 0x1A8uLL);
        v428[27] = *(_OWORD *)v444;
        v428[28] = *(_OWORD *)&v444[16];
        v428[29] = *(unsigned __int64 *)&v444[32];
        *((_QWORD *)&v428[26] + 1) = v206;
        LOWORD(v428[33]) = (_WORD)v470;
        WORD1(v428[33]) = v454;
        LOBYTE(v428[32]) = 76;
        if ( (LPVOID)v484 == v458[0] )
          sub_41F6B0((unsigned __int64 *)v458, v280);
        v281 = v484;
        memcpy((char *)v458[1] + 536 * v484, v428, 0x218uLL);
        v459 = (_QWORD *)(v281 + 1);
        sub_41A2B0((__int64)v428, (unsigned __int64 *)&v442);
        v190 = *(_QWORD *)&v428[0];
        if ( *(_QWORD *)&v428[0] == 3LL )
          goto LABEL_220;
      }
    }
    v282 = (__int64)v464;
    v484 = v465;
    if ( v465 >= 2 )
    {
      if ( v484 >= 0x15 )
        sub_421E50((__int128 *)v464, v484);
      else
        sub_421F80((__int64)v464, v484);
      goto LABEL_437;
    }
    if ( v484 )
    {
LABEL_437:
      v283 = 32 * v484;
      v284 = 0LL;
      v177 = 0LL;
      do
      {
        v178 = *(_QWORD *)(v282 + v284 + 8);
        if ( v177 <= v178 )
          v177 = *(_QWORD *)(v282 + v284 + 8);
        *(_QWORD *)(v282 + v284 + 24) = v177;
        v284 += 32LL;
      }
      while ( v283 != v284 );
    }
    v474 = v463;
    v408 = *(_OWORD *)v458;
    v409 = v459;
    if ( v447 )
    {
      v285 = v448;
      v286 = GetProcessHeap();
      HeapFree(v286, 0, v285);
    }
    v200 = (volatile signed __int64 *)v451;
    if ( v474 == 0x8000000000000000uLL )
      goto LABEL_230;
    v459 = v409;
    *(_OWORD *)v458 = v408;
    v482 = (LPVOID)*((_QWORD *)v451 + 28);
    if ( !v482 )
    {
      *(_QWORD *)&v442 = 0LL;
      *((_QWORD *)&v442 + 1) = 8LL;
      v480 = (LPVOID)8;
      v472 = 0LL;
      v485 = 0LL;
      goto LABEL_469;
    }
    v453.m256i_i64[0] = 0LL;
    *(_OWORD *)&v453.m256i_u64[1] = 8uLL;
    v422 = *((_OWORD *)v482 + 4);
    *(_QWORD *)&v423 = 0LL;
    sub_41A2B0((__int64)v428, (unsigned __int64 *)&v422);
    v288 = *(_QWORD *)&v428[0];
    if ( *(_QWORD *)&v428[0] == 3LL )
    {
LABEL_446:
      sub_422100(&v453, v287, v178);
      goto LABEL_447;
    }
    v482 = (char *)v482 + 16;
    v480 = (LPVOID)8;
    v485 = 0LL;
    while ( 2 )
    {
      v305 = *(__m128 *)((char *)v428 + 8);
      *(_OWORD *)v444 = *(__int128 *)((char *)&v428[1] + 8);
      *(_OWORD *)&v444[16] = *(__int128 *)((char *)&v428[2] + 8);
      *(_OWORD *)&v444[32] = *(__int128 *)((char *)&v428[3] + 8);
      *(_QWORD *)&v444[48] = *((_QWORD *)&v428[4] + 1);
      if ( !v288 )
      {
        *(_QWORD *)&v428[0] = 0LL;
        *((_QWORD *)&v428[4] + 1) = *(_QWORD *)&v444[48];
        *(__int128 *)((char *)&v428[3] + 8) = *(_OWORD *)&v444[32];
        *(__int128 *)((char *)&v428[2] + 8) = *(_OWORD *)&v444[16];
        *(__int128 *)((char *)&v428[1] + 8) = *(_OWORD *)v444;
        sub_41A8B0((unsigned __int64)v403, (unsigned __int64 *)v482, (unsigned __int64)v428);
        if ( LODWORD(v403[0]) != 2 )
        {
          memcpy(v428, v403, 0x1A8uLL);
          _mm_storel_ps((double *)&v428[26] + 1, v305);
          if ( v485 == (unsigned __int64 *)v453.m256i_i64[0] )
          {
            sub_4221F0((unsigned __int64 *)&v453, v306);
            v480 = (LPVOID)v453.m256i_i64[1];
          }
          v307 = v485;
          memcpy((char *)v480 + 432 * (_QWORD)v485, v428, 0x1B0uLL);
          v485 = (unsigned __int64 *)((char *)v307 + 1);
          v453.m256i_i64[2] = (__int64)v307 + 1;
        }
LABEL_475:
        sub_41A2B0((__int64)v428, (unsigned __int64 *)&v422);
        v288 = *(_QWORD *)&v428[0];
        if ( *(_QWORD *)&v428[0] == 3LL )
          goto LABEL_446;
        continue;
      }
      break;
    }
    if ( v288 != 2 )
      goto LABEL_475;
    v177 = v453.m256i_i64[0];
    v472 = v453.m256i_i64[0];
    if ( v453.m256i_i64[0] == 0x8000000000000000uLL )
    {
LABEL_447:
      v289 = v458[1];
      v290 = (char *)v459 + 1;
      v291 = (char *)v458[1];
      while ( v290 != (char *)1 )
      {
        v292 = v291 + 536;
        --v290;
        sub_41F780((__int64)v291, v177, v178);
        v291 = v292;
      }
      if ( v458[0] )
      {
        v301 = GetProcessHeap();
        HeapFree(v301, 0, v289);
      }
      if ( v474 )
      {
        v302 = GetProcessHeap();
        HeapFree(v302, 0, (LPVOID)v282);
      }
      goto LABEL_230;
    }
    *(_QWORD *)&v442 = v472;
    *((_QWORD *)&v442 + 1) = v480;
LABEL_469:
    v443 = v485;
    *(_QWORD *)&v428[0] = v200;
    v479 = (LPVOID)v282;
    if ( v474 > v484 )
    {
      if ( v484 )
      {
        v303 = (void *)(32 * v484);
        v304 = GetProcessHeap();
        v482 = v303;
        v479 = HeapReAlloc(v304, 0, (LPVOID)v282, (SIZE_T)v303);
        if ( !v479 )
          sub_4040E9(8LL, (__int64)v482);
      }
      else
      {
        v308 = GetProcessHeap();
        HeapFree(v308, 0, (LPVOID)v282);
        v479 = (LPVOID)8;
      }
    }
    v482 = v458[1];
    v478 = (signed __int64)v459;
    if ( v458[0] > v459 )
    {
      if ( v478 )
      {
        v309 = 536 * v478;
        v310 = GetProcessHeap();
        v482 = HeapReAlloc(v310, 0, v482, v309);
        if ( !v482 )
          sub_4040E9(8LL, v309);
      }
      else
      {
        v311 = GetProcessHeap();
        HeapFree(v311, 0, v482);
        v482 = (LPVOID)8;
      }
    }
    if ( v472 > (unsigned __int64)v485 )
    {
      if ( v485 )
      {
        v312 = 432LL * (_QWORD)v485;
        v313 = GetProcessHeap();
        v480 = HeapReAlloc(v313, 0, v480, v312);
        if ( !v480 )
          sub_4040E9(8LL, v312);
      }
      else
      {
        v314 = GetProcessHeap();
        HeapFree(v314, 0, v480);
        v480 = (LPVOID)8;
      }
    }
    v201 = v429[0];
    if ( !v200 )
      goto LABEL_233;
    *(_QWORD *)&v414 = v200;
    *((_QWORD *)&v414 + 1) = v479;
    *(_QWORD *)&v415 = v484;
    *((_QWORD *)&v415 + 1) = v482;
    *(_QWORD *)&v416 = v478;
    *((_QWORD *)&v416 + 1) = v480;
    v417 = v485;
    if ( v429[0] == (LPVOID)0x8000000000000000LL )
    {
      LOBYTE(v485) = 22;
      goto LABEL_497;
    }
    v320 = sub_419C30(v429, aDebugCuIndex, 0xFuLL);
    v485 = v321;
    v322 = v321;
    if ( !v320 )
      v322 = 0LL;
    v485 = v322;
    v323 = 1LL;
    if ( v320 )
      v323 = v320;
    v481 = v323;
    v452 = sub_419C30(v429, aDebugTuIndex, 0xFuLL);
    v462 = v324;
    v325 = sub_419C30(v429, aDebugAbbrevDwo, 0x11uLL);
    v484 = v326;
    v327 = v326;
    if ( !v325 )
      v327 = 0LL;
    v484 = v327;
    v482 = (LPVOID)1;
    if ( !v325 )
      v325 = 1LL;
    v473 = v325;
    v328 = sub_419C30(v429, aDebugInfoDwo, 0xFuLL);
    v474 = v329;
    v330 = v329;
    if ( !v328 )
      v330 = 0LL;
    v474 = v330;
    v331 = v482;
    if ( v328 )
      v331 = (void *)v328;
    v482 = v331;
    v332 = sub_419C30(v429, aDebugLineDwo, 0xFuLL);
    v480 = v333;
    v334 = v333;
    if ( !v332 )
      v334 = 0LL;
    v480 = v334;
    v478 = 1LL;
    if ( !v332 )
      v332 = 1LL;
    v469 = (_QWORD *)v332;
    v335 = sub_419C30(v429, aDebugStrDwo, 0xEuLL);
    v472 = v336;
    v337 = v336;
    if ( !v335 )
      v337 = 0LL;
    v472 = v337;
    v338 = (_QWORD *)v478;
    if ( v335 )
      v338 = (_QWORD *)v335;
    v478 = (signed __int64)v338;
    v339 = sub_419C30(v429, aDebugStrOffset_0, 0x16uLL);
    v479 = v340;
    v341 = v340;
    if ( !v339 )
      v341 = 0LL;
    v479 = v341;
    v471 = 1LL;
    if ( !v339 )
      v339 = 1LL;
    v467 = v339;
    v342 = sub_419C30(v429, aDebugLocDwo, 0xEuLL);
    v475 = v343;
    v344 = v343;
    if ( !v342 )
      v344 = 0LL;
    v475 = v344;
    v345 = v471;
    if ( v342 )
      v345 = v342;
    v471 = v345;
    v346 = sub_419C30(v429, aDebugLoclistsD, 0x13uLL);
    v483 = v347;
    v348 = v347;
    if ( !v346 )
      v348 = 0LL;
    v483 = v348;
    lpMem = (LPVOID)1;
    if ( !v346 )
      v346 = 1LL;
    v461 = v346;
    v349 = sub_419C30(v429, aDebugRnglistsD, 0x13uLL);
    v470 = v350;
    v351 = v350;
    if ( !v349 )
      v351 = 0LL;
    v470 = v351;
    v352 = lpMem;
    if ( v349 )
      v352 = (void *)v349;
    lpMem = v352;
    v353 = sub_419C30(v429, aDebugTypesDwo, 0x10uLL);
    v477 = v354;
    v282 = v353;
    v355 = v353 == 0;
    v356 = v354;
    if ( v355 )
      v356 = v282;
    v477 = v356;
    v357 = 1LL;
    if ( v355 )
      v282 = 1LL;
    sub_422480((__int64)v428, (unsigned int *)v481, (unsigned __int64)v485);
    LOBYTE(v485) = v428[0];
    if ( LOBYTE(v428[0]) == 22 )
      goto LABEL_552;
    if ( v452 )
      v357 = v452;
    v360 = (unsigned __int64)v462;
    if ( !v452 )
      v360 = 0LL;
    *(_QWORD *)&v444[15] = *(_QWORD *)&v428[1];
    *(_OWORD *)v444 = *(__int128 *)((char *)v428 + 1);
    v403[0] = *(__int128 *)((char *)&v428[1] + 8);
    v403[1] = *(__int128 *)((char *)&v428[2] + 8);
    v403[2] = *(__int128 *)((char *)&v428[3] + 8);
    v403[3] = *(__int128 *)((char *)&v428[4] + 8);
    sub_422480((__int64)v428, (unsigned int *)v357, v360);
    LOBYTE(v481) = v428[0];
    if ( LOBYTE(v428[0]) == 22 )
    {
LABEL_552:
      if ( v201 )
      {
        v361 = v429[1];
        v362 = GetProcessHeap();
        HeapFree(v362, 0, v361);
      }
      sub_422E90((__int64)&v414, v358, v359);
LABEL_235:
      if ( *(_QWORD *)v437 )
      {
        v204 = *(void **)&v437[8];
        goto LABEL_237;
      }
      goto LABEL_238;
    }
    *(_QWORD *)&v410[15] = *(_QWORD *)&v428[1];
    *(_OWORD *)v410 = *(__int128 *)((char *)v428 + 1);
    v393 = *(__int128 *)((char *)&v428[1] + 8);
    v394 = *(__int128 *)((char *)&v428[2] + 8);
    v395 = *(__int128 *)((char *)&v428[3] + 8);
    v396 = *(__int128 *)((char *)&v428[4] + 8);
    *(_OWORD *)v402 = *(_OWORD *)v444;
    *(_QWORD *)&v402[15] = *(_QWORD *)&v444[15];
    *(_OWORD *)&v402[71] = v403[3];
    *(_OWORD *)&v402[55] = v403[2];
    *(_OWORD *)&v402[39] = v403[1];
    *(_OWORD *)&v402[23] = v403[0];
    if ( v201 )
    {
      v363 = v429[1];
      v364 = GetProcessHeap();
      HeapFree(v364, 0, v363);
    }
LABEL_497:
    v407 = v417;
    v406 = v416;
    v405 = v415;
    v404 = v414;
    v397 = *(_OWORD *)&v437[8];
    v398 = *(_OWORD *)&v437[24];
    v399 = *(_OWORD *)&v437[40];
    v400 = v438;
    v401 = v439;
    if ( *(_QWORD *)v437 == 0x8000000000000000uLL )
      goto LABEL_238;
    *(_OWORD *)&v390[72] = v401;
    *(_OWORD *)&v390[56] = v400;
    *(_OWORD *)&v390[40] = v399;
    *(_OWORD *)&v390[24] = v398;
    *(_OWORD *)&v390[8] = v397;
    *(_OWORD *)&v390[153] = *(_OWORD *)&v402[64];
    *(_QWORD *)&v390[168] = *(_QWORD *)&v402[79];
    *(_OWORD *)&v390[89] = *(_OWORD *)v402;
    *(_OWORD *)&v390[105] = *(_OWORD *)&v402[16];
    *(_OWORD *)&v390[121] = *(_OWORD *)&v402[32];
    *(_OWORD *)&v390[137] = *(_OWORD *)&v402[48];
    *(_QWORD *)&v390[192] = *(_QWORD *)&v410[15];
    *(_OWORD *)&v390[177] = *(_OWORD *)v410;
    *(_OWORD *)&v390[200] = v393;
    *(_OWORD *)&v390[216] = v394;
    *(_OWORD *)&v390[232] = v395;
    *(_OWORD *)&v390[248] = v396;
    *(_QWORD *)&v390[472] = v407;
    *(_OWORD *)&v390[424] = v404;
    *(_OWORD *)&v390[440] = v405;
    *(_OWORD *)&v390[456] = v406;
    *(_OWORD *)&v390[536] = v413;
    *(_OWORD *)&v390[520] = v412;
    *(_OWORD *)&v390[504] = v411;
    *(_QWORD *)v390 = *(_QWORD *)v437;
    v390[88] = (_BYTE)v485;
    v390[176] = v481;
    *(_QWORD *)&v390[264] = v473;
    *(_QWORD *)&v390[272] = v484;
    *(_QWORD *)&v390[280] = v482;
    *(_QWORD *)&v390[288] = v474;
    *(_QWORD *)&v390[296] = v469;
    *(_QWORD *)&v390[304] = v480;
    *(_QWORD *)&v390[312] = v478;
    *(_QWORD *)&v390[320] = v472;
    *(_QWORD *)&v390[328] = v467;
    *(_QWORD *)&v390[336] = v479;
    *(_QWORD *)&v390[344] = v471;
    *(_QWORD *)&v390[352] = v475;
    *(_QWORD *)&v390[360] = v461;
    *(_QWORD *)&v390[368] = v483;
    *(_QWORD *)&v390[376] = lpMem;
    *(_QWORD *)&v390[384] = v470;
    *(_QWORD *)&v390[392] = v282;
    *(_QWORD *)&v390[400] = v477;
    *(_QWORD *)&v390[408] = 1LL;
    *(_QWORD *)&v390[416] = 0LL;
    *(_QWORD *)&v390[480] = hObject;
    *(_QWORD *)&v390[488] = v16;
    *(_QWORD *)&v390[496] = *((_QWORD *)&v15 + 1);
    v315 = (__int64)*(&::Src + 1);
    v316 = *((_QWORD *)&xmmword_43F038 + 1);
    if ( *(&::Src + 1) == (void *)4 )
    {
      *(&::Src + 1) = (void *)3;
      memcpy(v428, (char *)::Src + 1680, sizeof(v428));
      v315 = 3LL;
      if ( *((_QWORD *)&v428[0] + 1) != 0x8000000000000000uLL )
      {
        sub_4230A0((__int64)v428 + 8, v317, v318);
        v315 = (__int64)*(&::Src + 1);
        v316 = *((_QWORD *)&xmmword_43F038 + 1);
      }
    }
    memcpy((char *)v428 + 8, v390, 0x228uLL);
    *(_QWORD *)&v428[0] = v3;
    if ( v315 == v316 )
      sub_422FC0((__int64)&off_44A408, v319);
    v12 = (volatile signed __int64 **)::Src;
    if ( v315 )
      memmove((char *)::Src + 560, ::Src, 560 * v315);
    memcpy(v12, v428, 0x230uLL);
    *(&::Src + 1) = (void *)(v315 + 1);
    v2 = v466;
LABEL_35:
    v33 = (volatile signed __int64 **)((char *)v2 - v7);
    v34 = (unsigned __int64)v12[56];
    v35 = 3;
    v466 = v33;
    v478 = (signed __int64)v12;
    if ( v34 )
    {
      v36 = (char *)v33 + 1;
      v37 = v12[55];
      if ( v34 == 1 )
      {
        v38 = 0LL;
      }
      else
      {
        v39 = 0LL;
        v40 = v34;
        do
        {
          v38 = (v40 >> 1) + v39;
          if ( v37[4 * v38] > (unsigned __int64)v36 )
            v38 = v39;
          v40 -= v40 >> 1;
          v39 = v38;
        }
        while ( v40 > 1 );
      }
      if ( (char *)v37[4 * v38] == v36 )
        v41 = v38 + 1;
      else
        v41 = (v37[4 * v38] < (unsigned __int64)v36) + v38;
      if ( v41 > v34 )
        sub_405B00(v41, v34, (__int64)&off_4482F0);
      if ( v41 )
      {
        v42 = v12 + 54;
        v43 = 4 * v41;
        v44 = &v37[v43 - 4];
        v45 = -(v43 * 8);
        v46 = v428;
        v47 = 0LL;
        while ( 1 )
        {
          if ( *((_QWORD *)v44 + 3) <= (unsigned __int64)v33 )
          {
            v50 = 1;
            goto LABEL_55;
          }
          if ( *((_QWORD *)v44 + 1) > (unsigned __int64)v33 && (unsigned __int64)v36 > *v44 )
            break;
          v44 -= 4;
          v45 += 32LL;
          if ( !v45 )
            goto LABEL_69;
        }
        v48 = *((_QWORD *)v44 + 2);
        v49 = v12[58];
        if ( v48 >= (unsigned __int64)v49 )
          sub_4050B0(v48, v49, &off_448308);
        *(_QWORD *)&v428[0] = &v12[57][67 * v48];
        v46 = Src;
        v50 = 0;
        v47 = v44;
LABEL_55:
        *(_QWORD *)v46 = v47;
        v51 = *(_QWORD *)&v428[0];
        if ( *(_QWORD *)&v428[0] )
        {
          v52 = v466;
          sub_423160(v428, *(__int64 *)&v428[0], v466, v42);
          *(_QWORD *)v390 = v52;
          *(_QWORD *)&v390[8] = v51;
          *(_QWORD *)&v390[16] = v42;
          *(_QWORD *)&v390[24] = v42;
          *(_QWORD *)&v390[32] = v52;
          *(_QWORD *)&v390[40] = v36;
          *(_QWORD *)&v390[48] = v37;
          *(_QWORD *)&v390[56] = v44;
          *(_QWORD *)&v390[64] = v36;
          *(_QWORD *)&v390[72] = v52;
          v390[80] = v50;
          sub_423680((__int64)Src, v428, (__int64)v390, v53);
          if ( LOBYTE(Src[11]) != 2 )
          {
            while ( 1 )
            {
              *(_OWORD *)&v437[32] = Src[2];
              *(_OWORD *)&v437[16] = Src[1];
              *(_OWORD *)v437 = Src[0];
              memcpy(v390, &Src[3], 0x88uLL);
              if ( !_InterlockedDecrement64(*(volatile signed __int64 **)&Src[0]) )
                sub_422320((__int64 *)v437, v54, v55);
              v56 = *(_QWORD **)v390;
              v57 = *(_QWORD **)&v390[16];
              v58 = *(unsigned __int8 *)(*(_QWORD *)v390 + 512LL);
              if ( v58 != 75 )
                break;
              v59 = *(_QWORD **)(*(_QWORD *)v390 + 520LL);
              if ( !v59 )
                goto LABEL_64;
              v60 = *v59 + 16LL;
              v61 = 2;
              v56 = v59 + 1;
LABEL_65:
              v62 = 0LL;
LABEL_67:
              *(_QWORD *)&v428[0] = v62;
              *((_QWORD *)&v428[0] + 1) = v60;
              LOBYTE(v428[1]) = v61;
              DWORD1(v428[1]) = *(_DWORD *)((char *)v429 + 3);
              *(_DWORD *)((char *)&v428[1] + 1) = v429[0];
              *((_QWORD *)&v428[1] + 1) = v56;
              sub_423B70((unsigned __int64)v403 + 8, (__int64 *)&v390[24], (__int64)v428);
              *(_QWORD *)&v403[0] = 0LL;
              v434 = *(_QWORD *)&v390[128];
              v433 = *(_OWORD *)&v390[112];
              v432 = *(_OWORD *)&v390[96];
              v431 = *(_OWORD *)&v390[80];
              v430 = *(_OWORD *)&v390[64];
              *(_OWORD *)v429 = *(_OWORD *)&v390[48];
              sub_423680((__int64)v428, v403, (__int64)v429, v63);
              memcpy(Src, v428, 0xB8uLL);
              if ( LOBYTE(Src[11]) == 2 )
                goto LABEL_68;
            }
            if ( v58 != 76 )
            {
              v60 = *(_QWORD *)(*(_QWORD *)v390 + 512LL);
              v61 = *(_BYTE *)(*(_QWORD *)v390 + 520LL);
              *(_DWORD *)((char *)v429 + 3) = *(_DWORD *)(*(_QWORD *)v390 + 524LL);
              v56 = (_QWORD *)*(unsigned int *)(*(_QWORD *)v390 + 521LL);
              LODWORD(v429[0]) = *(_DWORD *)(*(_QWORD *)v390 + 521LL);
              v62 = 1LL;
              goto LABEL_67;
            }
            *(_BYTE *)(*(_QWORD *)v390 + 512LL) = 75;
            v56[65] = 0LL;
LABEL_64:
            v60 = *v57 + 16LL;
            v61 = 0;
            goto LABEL_65;
          }
LABEL_68:
          v35 = Src[0];
        }
      }
    }
LABEL_69:
    v64 = (_QWORD *)(v478 + 8);
    v65 = v466;
    if ( v35 == 5 )
    {
LABEL_141:
      v113 = sub_4259C0(v64, (unsigned __int64)v65);
      if ( v113 )
      {
        v115 = *v435;
        v116 = v435[1];
        LODWORD(v428[0]) = 3;
        *((_QWORD *)&v428[0] + 1) = v113;
        *(_QWORD *)&v428[1] = v114;
        (*(void (__fastcall **)(unsigned __int64, __int128 *))(v116 + 32))(v115, v428);
      }
      return;
    }
    lpMem = (LPVOID)*((_QWORD *)&Src[3] + 1);
    v471 = *((_QWORD *)&Src[4] + 1);
    v66 = v35 - 3;
    *((_QWORD *)&v67 + 1) = 2LL;
    if ( v35 - 3 < 2 )
      *((_QWORD *)&v67 + 1) = v66;
    if ( DWORD2(v67) )
    {
      v484 = *((_QWORD *)&Src[1] + 1);
      v485 = *(unsigned __int64 **)&Src[1];
      v469 = (_QWORD *)*((_QWORD *)&Src[2] + 1);
      v68 = *(_QWORD *)&Src[2];
      v483 = *(_QWORD *)&Src[4];
      v470 = (__int64 *)(*(_QWORD *)&Src[2] + 96LL);
      v473 = *(_QWORD *)&Src[2] + 440LL;
      v69 = (unsigned __int64)v435;
      v474 = *v435;
      v70 = v435[1];
      v475 = *(_QWORD *)&Src[2];
      v477 = *(_QWORD *)&Src[3];
      v478 += 8LL;
      v472 = *(_QWORD *)&Src[5];
      if ( DWORD2(v67) == 1 )
      {
        v479 = (LPVOID)DWORD1(Src[0]);
        v482 = (LPVOID)HIDWORD(Src[0]);
        v71 = *((_QWORD *)&Src[0] + 1);
        if ( v471 != 0 && v66 >= 2 )
        {
          v72 = GetProcessHeap();
          HeapFree(v72, 0, lpMem);
        }
        hObject = HANDLE_FLAG_PROTECT_FROM_CLOSE;
        v73 = 3;
        v74 = v68;
        v75 = (unsigned __int64 *)v484;
        v76 = v485;
        goto LABEL_77;
      }
      v71 = v35 | ((unsigned __int64)DWORD1(Src[0]) << 32);
      v76 = (unsigned __int64 *)*((_QWORD *)&Src[0] + 1);
      if ( v483 == *(_QWORD *)&Src[5] )
      {
        *(_QWORD *)&v67 = *(_QWORD *)(*(_QWORD *)&Src[3] + 40LL);
        if ( (_QWORD)v67 )
          *((_QWORD *)&v67 + 1) = *(_QWORD *)(*(_QWORD *)&Src[3] + 48LL);
        hObject = (HANDLE)DWORD2(Src[0]);
        v482 = (LPVOID)HIDWORD(Src[0]);
        v479 = (LPVOID)DWORD1(Src[0]);
        if ( v471 )
        {
          v83 = v67;
          v84 = GetProcessHeap();
          HeapFree(v84, 0, lpMem);
          v67 = v83;
        }
        v73 = 3;
        v74 = v484;
        v75 = v485;
        if ( (_QWORD)v67 )
          goto LABEL_102;
        goto LABEL_77;
      }
      v78 = *(_QWORD *)(*(_QWORD *)&Src[5] - 8LL);
      v73 = 0;
      v479 = (LPVOID)*(unsigned int *)(v78 + 40);
      LOBYTE(v480) = (_DWORD)v479 != 0;
      v79 = (void *)*(unsigned int *)(v78 + 44);
      hObject = 0LL;
      v482 = v79;
      v80 = (_DWORD)v79 != 0;
      if ( *(_DWORD *)v78 != 1 || *(_DWORD *)v470 == 47 )
        goto LABEL_99;
      v481 = *(_QWORD *)(v78 + 8);
      if ( (*(_BYTE *)(v475 + 432) & 1) == 0 )
      {
        sub_41F880((__int64)v428, v470);
        v81 = v475;
        sub_41FD50((__int64 *)Src, v475, (__int64)v428, v469);
        v82 = *(_QWORD *)(v81 + 432) == 0LL;
        if ( *(_QWORD *)(v81 + 432) )
        {
          sub_4215A0((__int64)Src);
        }
        else
        {
          v85 = (_OWORD *)v473;
          if ( !v82 )
            sub_4215A0(v473);
          *(_QWORD *)(v475 + 432) = 1LL;
          v86 = Src[0];
          v85[1] = Src[1];
          *v85 = v86;
        }
      }
      v87 = (__int64 *)v473;
      if ( *(_QWORD *)v473 )
      {
LABEL_95:
        if ( v481 < v87[1] )
        {
          v88 = *v87;
          v89 = *(unsigned __int64 **)(v88 + 24 * v481 + 8);
          v69 = *(_QWORD *)(v88 + 24 * v481 + 16);
LABEL_100:
          v472 -= 8LL;
          LOBYTE(v73) = (_BYTE)v480;
          v90 = hObject;
          LOBYTE(v90) = v80;
          hObject = v90;
          *(_QWORD *)&v67 = *(_QWORD *)(v78 + 24);
          if ( (_QWORD)v67 )
          {
            *((_QWORD *)&v67 + 1) = *(_QWORD *)(v78 + 32);
            v74 = v484;
            v75 = v485;
            v485 = v89;
            v484 = v69;
            goto LABEL_102;
          }
          v74 = v484;
          v75 = v485;
          v485 = v89;
          v484 = v69;
LABEL_77:
          *(_QWORD *)&v67 = sub_4259C0((_QWORD *)v478, (unsigned __int64)v466);
LABEL_102:
          *(_QWORD *)&v428[0] = v71;
          *((_QWORD *)&v428[0] + 1) = v76;
          *(_QWORD *)&v428[1] = v75;
          *((_QWORD *)&v428[1] + 1) = v74;
          *(_QWORD *)&v428[2] = v466;
          *(__int128 *)((char *)&v428[2] + 8) = v67;
          v480 = *(LPVOID *)(v70 + 32);
          ((void (__fastcall *)(unsigned __int64, __int128 *))v480)(v474, v428);
          while ( 1 )
          {
            v66 = v73 - 3;
            v93 = 2;
            if ( v73 - 3 < 2 )
              v93 = v73 - 3;
            v65 = v466;
            if ( v93 == 1 )
              break;
            if ( v93 != 2 )
            {
              v77 = 1;
              v64 = (_QWORD *)v478;
              goto LABEL_138;
            }
            v94 = v73 | ((_QWORD)v479 << 32);
            v95 = (unsigned __int64 *)((unsigned int)hObject | ((_QWORD)v482 << 32));
            if ( v483 != v472 )
            {
              v96 = *(_QWORD *)(v472 - 8);
              v97 = *(unsigned int *)(v96 + 44);
              v73 = 0;
              v479 = (LPVOID)*(unsigned int *)(v96 + 40);
              v98 = (_DWORD)v479 != 0;
              hObject = 0LL;
              v482 = (LPVOID)v97;
              v99 = (_DWORD)v97 != 0;
              if ( (*(_BYTE *)v96 & 1) == 0 || *(_DWORD *)v470 == 47 )
                goto LABEL_134;
              v481 = *(_QWORD *)(v96 + 8);
              if ( (*(_BYTE *)(v475 + 432) & 1) != 0 )
                goto LABEL_115;
              sub_41F880((__int64)v428, v470);
              v100 = v475;
              sub_41FD50((__int64 *)Src, v475, (__int64)v428, v469);
              v101 = *(_QWORD *)(v100 + 432) == 0LL;
              if ( *(_QWORD *)(v100 + 432) )
              {
                sub_4215A0((__int64)Src);
LABEL_115:
                v102 = (__int64 *)v473;
                if ( !*(_QWORD *)v473 )
                {
LABEL_116:
                  if ( *(_BYTE *)(v475 + 448) != 75 )
                  {
                    v77 = 1;
                    goto LABEL_146;
                  }
                  v102 = *(__int64 **)(v475 + 456);
                  if ( !v102 )
                  {
LABEL_134:
                    v110 = 0LL;
                    goto LABEL_135;
                  }
                }
              }
              else
              {
                v107 = (_OWORD *)v473;
                if ( !v101 )
                  sub_4215A0(v473);
                *(_QWORD *)(v475 + 432) = 1LL;
                v108 = Src[0];
                v107[1] = Src[1];
                *v107 = v108;
                v102 = (__int64 *)v473;
                if ( !*(_QWORD *)v473 )
                  goto LABEL_116;
              }
              if ( v481 >= v102[1] )
                goto LABEL_134;
              v109 = *v102;
              v110 = *(unsigned __int64 **)(*v102 + 24 * v481 + 8);
              v97 = *(_QWORD *)(v109 + 24 * v481 + 16);
LABEL_135:
              v472 -= 8LL;
              LOBYTE(v73) = v98;
              v111 = hObject;
              LOBYTE(v111) = v99;
              hObject = v111;
              v104 = *(_QWORD *)(v96 + 24);
              if ( v104 )
              {
                v76 = *(unsigned __int64 **)(v96 + 32);
                v91 = v484;
                v92 = v485;
                v485 = v110;
                v484 = v97;
                goto LABEL_104;
              }
              v91 = v484;
              v92 = v485;
              v485 = v110;
              v484 = v97;
LABEL_122:
              v104 = sub_4259C0((_QWORD *)v478, (unsigned __int64)v466);
              v76 = v105;
              goto LABEL_104;
            }
            v104 = *(_QWORD *)(v477 + 40);
            if ( v104 )
              v76 = *(unsigned __int64 **)(v477 + 48);
            if ( v471 )
            {
              v106 = GetProcessHeap();
              HeapFree(v106, 0, lpMem);
            }
            v73 = 3;
            v91 = v484;
            v92 = v485;
            if ( !v104 )
              goto LABEL_122;
LABEL_104:
            *(_QWORD *)&v428[0] = v94;
            *((_QWORD *)&v428[0] + 1) = v95;
            *(_QWORD *)&v428[1] = v92;
            *((_QWORD *)&v428[1] + 1) = v91;
            *(_QWORD *)&v428[2] = v466;
            *((_QWORD *)&v428[2] + 1) = v104;
            *(_QWORD *)&v428[3] = v76;
            ((void (__fastcall *)(unsigned __int64, __int128 *))v480)(v474, v428);
          }
          if ( v471 != 0 && v66 >= 2 )
          {
            v103 = GetProcessHeap();
            HeapFree(v103, 0, lpMem);
          }
          v94 = (unsigned int)hObject | ((_QWORD)v482 << 32);
          hObject = HANDLE_FLAG_PROTECT_FROM_CLOSE;
          v73 = 3;
          v91 = v475;
          v92 = (unsigned __int64 *)v484;
          v95 = v485;
          goto LABEL_122;
        }
LABEL_99:
        v89 = 0LL;
        goto LABEL_100;
      }
      if ( *(_BYTE *)(v475 + 448) == 75 )
      {
        v87 = *(__int64 **)(v475 + 456);
        if ( !v87 )
          goto LABEL_99;
        goto LABEL_95;
      }
      v77 = 0;
LABEL_146:
      v65 = v466;
      v64 = (_QWORD *)v478;
      if ( !v471 )
        goto LABEL_140;
    }
    else
    {
      v77 = 0;
LABEL_138:
      if ( v471 == 0 || v66 < 2 )
      {
LABEL_140:
        if ( v77 )
          return;
        goto LABEL_141;
      }
    }
    v112 = GetProcessHeap();
    HeapFree(v112, 0, lpMem);
    goto LABEL_140;
  }
}
// 415A8C: variable 'v32' is possibly undefined
// 415C69: variable 'v53' is possibly undefined
// 415CFA: variable 'v54' is possibly undefined
// 415CFA: variable 'v55' is possibly undefined
// 415E25: variable 'v63' is possibly undefined
// 4161C9: variable 'v69' is possibly undefined
// 4161FA: variable 'v67' is possibly undefined
// 41623E: variable 'v97' is possibly undefined
// 41646C: variable 'v105' is possibly undefined
// 4165ED: variable 'v114' is possibly undefined
// 41670C: variable 'v121' is possibly undefined
// 416760: variable 'v125' is possibly undefined
// 4167A7: variable 'v129' is possibly undefined
// 4167FB: variable 'v133' is possibly undefined
// 416842: variable 'v137' is possibly undefined
// 416896: variable 'v141' is possibly undefined
// 4168DD: variable 'v145' is possibly undefined
// 416931: variable 'v149' is possibly undefined
// 416978: variable 'v153' is possibly undefined
// 4169CC: variable 'v157' is possibly undefined
// 416A13: variable 'v161' is possibly undefined
// 416A54: variable 'v165' is possibly undefined
// 416BD7: variable 'v168' is possibly undefined
// 416F63: variable 'v177' is possibly undefined
// 416F63: variable 'v178' is possibly undefined
// 418305: variable 'v280' is possibly undefined
// 41850E: variable 'v287' is possibly undefined
// 418860: variable 'v306' is possibly undefined
// 418E29: variable 'v317' is possibly undefined
// 418E29: variable 'v318' is possibly undefined
// 418E6B: variable 'v319' is possibly undefined
// 418ED6: variable 'v321' is possibly undefined
// 418F22: variable 'v324' is possibly undefined
// 418F42: variable 'v326' is possibly undefined
// 418F93: variable 'v329' is possibly undefined
// 418FDA: variable 'v333' is possibly undefined
// 41902B: variable 'v336' is possibly undefined
// 419072: variable 'v340' is possibly undefined
// 4190C3: variable 'v343' is possibly undefined
// 41910A: variable 'v347' is possibly undefined
// 41915B: variable 'v350' is possibly undefined
// 4191A2: variable 'v354' is possibly undefined
// 4192AC: variable 'v358' is possibly undefined
// 4192AC: variable 'v359' is possibly undefined
// 4050B0: using guessed type void __fastcall __noreturn sub_4050B0(_QWORD, _QWORD, _QWORD);
// 43F028: using guessed type __int128 xmmword_43F028;
// 43F038: using guessed type __int128 xmmword_43F038;
// 448278: using guessed type char *off_448278;
// 448290: using guessed type char *off_448290;
// 4482A8: using guessed type char *off_4482A8;
// 4482D8: using guessed type char *off_4482D8;
// 4482F0: using guessed type char *off_4482F0;
// 448308: using guessed type char *off_448308;
// 44A3D8: using guessed type char *off_44A3D8;
// 44A3F0: using guessed type char *off_44A3F0;
// 44A408: using guessed type char *off_44A408;
// 44A460: using guessed type char *off_44A460;

//----- (0000000000419960) ----------------------------------------------------
void __fastcall sub_419960(_QWORD *a1)
{
  void **v2; // rdi
  __int64 v3; // r14
  void **v4; // r15
  void *v5; // rbx
  HANDLE ProcessHeap; // rax
  HANDLE v7; // rax
  LPCVOID *v8; // rdi
  __int64 v9; // r14
  LPCVOID *v10; // r15
  void *v11; // rbx
  HANDLE v12; // rax

  v2 = (void **)a1[1];
  v3 = a1[2];
  if ( v3 )
  {
    v4 = v2 + 1;
    do
    {
      if ( *(v4 - 1) )
      {
        v5 = *v4;
        ProcessHeap = GetProcessHeap();
        HeapFree(ProcessHeap, 0, v5);
      }
      v4 += 3;
      --v3;
    }
    while ( v3 );
  }
  if ( *a1 )
  {
    v7 = GetProcessHeap();
    HeapFree(v7, 0, v2);
  }
  v8 = (LPCVOID *)a1[4];
  v9 = a1[5];
  if ( v9 )
  {
    v10 = v8 + 1;
    do
    {
      v11 = (void *)*(v10 - 1);
      UnmapViewOfFile(*v10);
      CloseHandle(v11);
      v10 += 3;
      --v9;
    }
    while ( v9 );
  }
  if ( a1[3] )
  {
    v12 = GetProcessHeap();
    HeapFree(v12, 0, v8);
  }
}

//----- (0000000000419A30) ----------------------------------------------------
void __fastcall sub_419A30(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // r8
  unsigned __int64 *v3; // r10
  __int64 v4; // r9
  unsigned __int64 v5; // r11
  unsigned __int64 v6; // rsi
  unsigned __int64 v7; // rsi
  __int128 *v8; // r9
  __int64 v9; // rax
  __int64 v10; // r11
  __int128 *v11; // rdi
  __int64 v12; // r10
  __int128 v13; // xmm0
  __int64 v14; // r11
  __int128 v15; // xmm0
  __int64 v16; // r11
  __int64 v17; // rdx
  __int128 v18; // xmm0
  unsigned __int64 v19; // r9

  v2 = *(_QWORD *)(a1 + 16);
  v3 = (unsigned __int64 *)(a1 + 32);
  v4 = 2LL;
  v5 = v2;
  if ( v2 >= *(_QWORD *)a1 )
  {
    while ( 1 )
    {
      v7 = v5;
      v5 = *v3;
      if ( *v3 < v7 )
        break;
      ++v4;
      v3 += 2;
      if ( a2 == v4 )
        goto LABEL_9;
    }
  }
  else
  {
    while ( 1 )
    {
      v6 = v5;
      v5 = *v3;
      if ( *v3 >= v6 )
        break;
      ++v4;
      v3 += 2;
      if ( a2 == v4 )
        goto LABEL_9;
    }
  }
  if ( v4 == a2 )
  {
LABEL_9:
    if ( v2 < *(_QWORD *)a1 )
    {
      v8 = (__int128 *)(16 * a2 + a1 - 16);
      v9 = a1 + 16 * a2;
      v10 = 0LL;
      v11 = (__int128 *)a1;
      do
      {
        v12 = v10;
        v13 = *v11;
        *v11 = *v8;
        *v8 = v13;
        v14 = 16 * (v10 ^ 0xFFFFFFFFFFFFFFELL);
        v15 = v11[1];
        v11[1] = *(_OWORD *)(v9 + v14);
        *(_OWORD *)(v9 + v14) = v15;
        v10 = v12 + 2;
        v11 += 2;
        v8 -= 2;
      }
      while ( ((a2 >> 1) & 0xFFFFFFFFFFFFFFFEuLL) != v12 + 2 );
      if ( (a2 & 2) != 0 )
      {
        v16 = 16 * v10;
        v17 = 16 * (-3 - v12);
        v18 = *(_OWORD *)(a1 + v16);
        *(_OWORD *)(a1 + v16) = *(_OWORD *)(v9 + v17);
        *(_OWORD *)(v9 + v17) = v18;
      }
    }
  }
  else
  {
    _BitScanReverse64(&v19, a2 | 1);
    sub_431C80((__int128 *)a1, a2, 0LL, (2 * (v19 ^ 0x3F)) ^ 0x7E);
  }
}

//----- (0000000000419B60) ----------------------------------------------------
__int64 __fastcall sub_419B60(__int64 *a1, __int64 a2)
{
  __int64 v2; // rsi
  __int64 v3; // rax
  unsigned __int64 v5; // rdx
  __int64 v6; // rbx
  __int64 v7; // rcx
  __int64 v8; // rax
  __int64 result; // rax
  _QWORD v10[3]; // [rsp+28h] [rbp-28h] BYREF
  __int64 v11; // [rsp+40h] [rbp-10h] BYREF
  __int64 v12; // [rsp+48h] [rbp-8h]
  __int64 v13; // [rsp+50h] [rbp+0h]

  v2 = a2;
  v3 = *a1;
  if ( *a1 == -1 )
    goto LABEL_13;
  v5 = v3 + 1;
  if ( 2 * v3 > (unsigned __int64)(v3 + 1) )
    v5 = 2 * v3;
  v6 = 4LL;
  if ( v5 >= 5 )
    v6 = v5;
  v7 = 0LL;
  a2 = v5 >> 60;
  if ( a2 )
LABEL_13:
    sub_40408F(0LL, a2, v2);
  if ( (unsigned __int64)(16 * v6) > 0x7FFFFFFFFFFFFFF8LL )
LABEL_15:
    sub_40408F(v7, a2, v2);
  if ( v3 )
  {
    v10[0] = a1[1];
    v10[2] = 16 * v3;
    v8 = 8LL;
  }
  else
  {
    v8 = 0LL;
  }
  v10[1] = v8;
  sub_413370(&v11, (void *)8, 16 * v6, (__int64)v10);
  if ( (_DWORD)v11 == 1 )
  {
    v7 = v12;
    a2 = v13;
    goto LABEL_15;
  }
  result = v12;
  a1[1] = v12;
  *a1 = v6;
  return result;
}

//----- (0000000000419C30) ----------------------------------------------------
unsigned __int64 __fastcall sub_419C30(_QWORD *a1, const void *a2, size_t a3)
{
  __int64 v3; // rax
  unsigned __int64 v4; // rdi
  __int64 v5; // rdx
  __int64 v7; // r15
  __int64 v8; // rbx
  unsigned __int64 v9; // r12
  unsigned __int64 v10; // rsi
  const void *v11; // r12
  __int64 v12; // rdx
  __int64 v13; // rdx
  __int64 v14; // rcx
  unsigned __int64 v15; // rax
  unsigned __int64 v16; // rcx
  unsigned int v17; // r8d
  unsigned __int64 v18; // r15
  __int64 v20; // rsi
  __int64 v21; // r14
  __int64 v22; // rdx
  __int64 v23; // [rsp+20h] [rbp-40h]
  unsigned __int64 v25; // [rsp+30h] [rbp-30h]
  __int64 v26; // [rsp+38h] [rbp-28h]
  const __m128i *v27; // [rsp+40h] [rbp-20h]
  unsigned __int64 v29; // [rsp+50h] [rbp-10h]
  __int64 v30; // [rsp+58h] [rbp-8h] BYREF
  char v31; // [rsp+60h] [rbp+0h]
  unsigned int v32; // [rsp+64h] [rbp+4h]

  v3 = a1[6];
  if ( !v3 )
    return 0LL;
  v4 = a1[5];
  v5 = a1[7];
  if ( v5 )
  {
    v25 = a1[8];
    v23 = a1[9];
    v26 = a1[7];
    v29 = a1[10];
    v27 = (const __m128i *)(v5 + v29);
    v7 = -(__int64)v4;
    v8 = 40 * v3;
    while ( 1 )
    {
      sub_40A210((__int64)&v30, (_BYTE *)v4);
      if ( !v30 )
      {
        if ( (v31 & 1) != 0 )
        {
          v9 = v23 + v32;
          if ( __CFADD__(v23, v32) )
            goto LABEL_4;
          v10 = v29 - v9;
          if ( v29 < v9 )
            goto LABEL_4;
          if ( v29 > v25 )
            goto LABEL_4;
          v11 = (const void *)(v26 + v9);
          if ( !off_43F010(0, (unsigned __int64)v11, v27) || v12 - (__int64)v11 > v10 || v12 - (_QWORD)v11 != a3 )
            goto LABEL_4;
        }
        else if ( off_43F010(0, v4, (const __m128i *)(v4 + 8)) )
        {
          v14 = v7 + v13;
          if ( (unsigned __int64)(v7 + v13) >= 9 )
            goto LABEL_37;
          v11 = (const void *)v4;
          if ( v14 != a3 )
            goto LABEL_4;
        }
        else
        {
          v11 = (const void *)v4;
          if ( a3 != 8 )
            goto LABEL_4;
        }
        if ( !memcmp(v11, a2, a3) )
        {
          v15 = a1[4];
          v16 = *(unsigned int *)(v4 + 20);
          v17 = *(_DWORD *)(v4 + 16);
          if ( *(_DWORD *)(v4 + 8) < v17 )
            v17 = *(_DWORD *)(v4 + 8);
          v18 = v16 + a1[3];
          if ( v15 - v16 < v17 )
            v18 = 0LL;
          if ( v15 < v16 )
            return 0LL;
          return v18;
        }
      }
LABEL_4:
      v4 += 40LL;
      v7 -= 40LL;
      v8 -= 40LL;
      if ( !v8 )
        return 0LL;
    }
  }
  v20 = -(__int64)v4;
  v21 = 40 * v3;
  v18 = 0LL;
  do
  {
    sub_40A210((__int64)&v30, (_BYTE *)v4);
    if ( !v30 && (v31 & 1) == 0 && off_43F010(0, v4, (const __m128i *)(v4 + 8)) )
    {
      v14 = v20 + v22;
      if ( (unsigned __int64)(v20 + v22) >= 9 )
LABEL_37:
        sub_405B00(v14, 8LL, (__int64)&off_446E08);
    }
    v4 += 40LL;
    v20 -= 40LL;
    v21 -= 40LL;
  }
  while ( v21 );
  return v18;
}
// 419D15: variable 'v12' is possibly undefined
// 419D41: variable 'v13' is possibly undefined
// 419E40: variable 'v22' is possibly undefined
// 43F010: using guessed type _BOOL8 (__fastcall *off_43F010)(unsigned __int8 a1, unsigned __int64 a2, const __m128i *a3);
// 446E08: using guessed type char *off_446E08;

//----- (0000000000419E60) ----------------------------------------------------
unsigned __int64 __fastcall sub_419E60(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  volatile signed __int64 *v4; // rax

  v4 = *(volatile signed __int64 **)(a1 + 224);
  if ( v4 && !_InterlockedDecrement64(v4) )
    sub_422320((__int64 *)(a1 + 224), a2, a3);
  return sub_42B180((__int64 *)(a1 + 232), a2, a3);
}
// 419E9E: variable 'a2' is possibly undefined
// 419E9E: variable 'a3' is possibly undefined

//----- (0000000000419ED0) ----------------------------------------------------
char __fastcall sub_419ED0(__int64 a1, unsigned __int64 *a2, __int64 a3)
{
  unsigned __int64 v3; // r9
  unsigned __int64 v4; // rsi
  unsigned __int64 v5; // rdi
  unsigned int *v6; // r11
  unsigned __int64 v7; // rax
  __int64 v8; // rax
  char v9; // r10
  unsigned __int64 v10; // r9
  bool v11; // cf
  unsigned __int64 v12; // rdi
  unsigned __int64 v13; // rsi
  __int128 v14; // rt0
  unsigned __int16 v15; // dx
  unsigned __int64 v16; // rsi
  unsigned __int64 v17; // rdi
  char *v18; // rsi
  __int64 v19; // rbx
  __int128 v20; // rt0
  char v21; // r11
  char v22; // r14
  unsigned __int8 v23; // r15
  unsigned __int64 v24; // rdi
  char v25; // al
  bool v26; // zf
  unsigned __int64 v27; // rdi

  v3 = *a2;
  v4 = a2[1];
  if ( v4 < 4 )
  {
    v8 = 19LL;
    goto LABEL_6;
  }
  v5 = v4 - 4;
  v6 = (unsigned int *)(v3 + 4);
  *a2 = v3 + 4;
  a2[1] = v4 - 4;
  v7 = *(unsigned int *)v3;
  if ( *(_DWORD *)v3 >> 4 != 0xFFFFFFF )
  {
    v9 = 4;
    v10 = *(unsigned int *)v3;
    v11 = v5 < v7;
    v12 = v5 - v7;
    if ( !v11 )
      goto LABEL_12;
    goto LABEL_9;
  }
  if ( (_DWORD)v7 == -1 )
  {
    if ( v5 < 8 )
    {
      v8 = 19LL;
      v3 += 4LL;
      goto LABEL_6;
    }
    v13 = v4 - 12;
    v6 = (unsigned int *)(v3 + 12);
    *a2 = v3 + 12;
    a2[1] = v13;
    *(_QWORD *)&v14 = ((unsigned __int64)(*(unsigned __int16 *)(v3 + 8) | (*(unsigned __int8 *)(v3 + 10) << 16)) << 40) | ((unsigned __int64)*(unsigned int *)(v3 + 4) << 8);
    *((_QWORD *)&v14 + 1) = *(unsigned __int8 *)(v3 + 11);
    v10 = v14 >> 8;
    v9 = 8;
    v12 = v13 - v10;
    if ( v13 >= v10 )
    {
LABEL_12:
      *a2 = (unsigned __int64)v6 + v10;
      a2[1] = v12;
      if ( v10 <= 1 )
      {
        LOBYTE(v7) = 0;
        *(_WORD *)a1 = 19;
        *(_WORD *)(a1 + 2) = 0;
        *(_DWORD *)(a1 + 4) = 0;
        *(_QWORD *)(a1 + 8) = v6;
        goto LABEL_7;
      }
      v15 = *(_WORD *)v6;
      if ( (*(_WORD *)v6 & 0xFFFE) != 2 )
      {
        LOBYTE(v7) = *(_WORD *)v6;
        *(_BYTE *)a1 = 17;
        *(_QWORD *)(a1 + 8) = v15;
        goto LABEL_7;
      }
      v16 = v10 - 2;
      if ( (unsigned int)v7 < 0xFFFFFFF0 )
      {
        if ( v16 > 3 )
        {
          v17 = v10 - 6;
          v19 = *(unsigned int *)((char *)v6 + 2);
          v18 = (char *)v6 + 6;
LABEL_22:
          if ( v17 )
          {
            if ( v17 != 1 )
            {
              v21 = *v18;
              LOBYTE(v7) = (unsigned int)v7 >= 0xFFFFFFF0;
              if ( *v18 < 0 || (v22 = v18[1], v23 = v22 + 2 * v21, __CFADD__(v22, 2 * v21)) || !(v22 + 2 * v21) )
              {
                *(_BYTE *)a1 = 48;
                goto LABEL_7;
              }
              v24 = v17 - 2;
              v18 += 2;
              v25 = (unsigned __int8)(v9 + 8 * v7 + 8) % v23;
              v26 = v25 == 0;
              LOBYTE(v7) = v23 - v25;
              if ( v26 )
                LOBYTE(v7) = 0;
              v11 = v24 < (unsigned __int8)v7;
              v27 = v24 - (unsigned __int8)v7;
              if ( !v11 )
              {
                *(_QWORD *)a1 = &v18[(unsigned __int8)v7];
                *(_QWORD *)(a1 + 8) = v27;
                *(_QWORD *)(a1 + 16) = a3;
                *(_QWORD *)(a1 + 24) = v10;
                *(_QWORD *)(a1 + 32) = v19;
                *(_BYTE *)(a1 + 40) = v21;
                *(_BYTE *)(a1 + 41) = v9;
                *(_WORD *)(a1 + 42) = v15;
                *(_BYTE *)(a1 + 44) = v22;
                return v7;
              }
              *(_BYTE *)a1 = 19;
              goto LABEL_26;
            }
            ++v18;
          }
          *(_WORD *)a1 = 19;
          *(_WORD *)(a1 + 6) = 0;
          *(_DWORD *)(a1 + 2) = 0;
LABEL_26:
          *(_QWORD *)(a1 + 8) = v18;
          goto LABEL_7;
        }
      }
      else if ( v16 > 7 )
      {
        v17 = v10 - 10;
        v18 = (char *)v6 + 10;
        *(_QWORD *)&v20 = ((unsigned __int64)(*((unsigned __int16 *)v6 + 3) | (*((unsigned __int8 *)v6 + 8) << 16)) << 40) | ((unsigned __int64)*(unsigned int *)((char *)v6 + 2) << 8);
        *((_QWORD *)&v20 + 1) = *((unsigned __int8 *)v6 + 9);
        v19 = v20 >> 8;
        goto LABEL_22;
      }
      *(_BYTE *)a1 = 19;
      *(_BYTE *)(a1 + 7) = 0;
      *(_WORD *)(a1 + 5) = 0;
      *(_DWORD *)(a1 + 1) = 0;
      *(_QWORD *)(a1 + 8) = (char *)v6 + 2;
      goto LABEL_7;
    }
LABEL_9:
    *(_QWORD *)a1 = 19LL;
    *(_QWORD *)(a1 + 8) = v6;
    goto LABEL_7;
  }
  v8 = 16LL;
LABEL_6:
  *(_QWORD *)a1 = v8;
  *(_BYTE *)(a1 + 8) = v3;
  v7 = HIBYTE(v3);
  *(_BYTE *)(a1 + 15) = HIBYTE(v3);
  *(_WORD *)(a1 + 13) = HIDWORD(v3) >> 8;
  *(_DWORD *)(a1 + 9) = v3 >> 8;
LABEL_7:
  *(_BYTE *)(a1 + 41) = 3;
  return v7;
}

//----- (000000000041A180) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_41A180(__m128i *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // r8
  size_t v3; // rsi
  __m128i *v6; // rax
  __m128i *v7; // rdi
  HANDLE ProcessHeap; // rax
  __m128i v9[258]; // [rsp+28h] [rbp-58h] BYREF

  v2 = 500000LL;
  if ( a2 < 0x7A120 )
    v2 = a2;
  if ( a2 >> 1 > v2 )
    v2 = a2 >> 1;
  v3 = 48LL;
  if ( v2 >= 0x31 )
    v3 = v2;
  if ( v2 >= 0x101 )
  {
    if ( a2 >> 61 || 16 * v3 >= 0x7FFFFFFFFFFFFFF9LL )
      sub_4040B0((__int64)&off_447D68);
    v6 = (__m128i *)sub_43C4F0(16 * v3);
    if ( !v6 )
      sub_4040E9(8LL, 16 * v3);
    v7 = v6;
    sub_430620(a1, a2, v6, v3, a2 < 0x41);
    ProcessHeap = GetProcessHeap();
    HeapFree(ProcessHeap, 0, v7);
  }
  else
  {
    sub_430620(a1, a2, v9, 0x100uLL, a2 < 0x41);
  }
}
// 41A1F9: positive sp value 1028 has been found
// 447D68: using guessed type char *off_447D68;

//----- (000000000041A2B0) ----------------------------------------------------
void __fastcall sub_41A2B0(__int64 a1, unsigned __int64 *a2)
{
  unsigned __int64 v2; // r8
  unsigned int *v3; // r11
  unsigned int *v4; // r9
  unsigned __int64 v5; // r10
  unsigned __int64 v6; // rax
  unsigned __int64 v7; // r13
  unsigned __int64 v8; // r9
  unsigned __int64 v9; // r8
  unsigned __int64 v10; // r10
  unsigned __int64 v11; // r11
  __int64 v12; // r12
  char v13; // bl
  unsigned __int64 v14; // r11
  bool v15; // cf
  __int128 v16; // rt0
  unsigned __int64 v17; // r14
  unsigned __int16 v18; // si
  unsigned __int64 v19; // rdi
  unsigned __int64 v20; // r15
  __int64 v21; // r14
  __int128 v22; // rt0
  unsigned __int16 v23; // bx
  unsigned __int64 v24; // rsi
  char v25; // di
  unsigned int *v26; // r15
  char v27; // r13
  unsigned __int64 v28; // rdi
  int v29; // r15d
  unsigned __int64 v30; // rdi
  int v31; // r12d
  int v32; // r15d
  __int64 v33; // r14
  unsigned __int64 v34; // r14
  __int128 v35; // rt0
  __int128 v36; // rt0
  unsigned __int64 v37; // r12
  __int64 v38; // r13
  int v39; // edi
  __int64 v40; // r14
  unsigned __int64 v41; // r14
  __int128 v42; // rt0
  __int64 v43; // rdi
  int v44; // r12d
  int v45; // r13d
  __int64 v46; // r15
  __int128 v47; // rt0
  __int64 v48; // rdi
  int v49; // r12d
  int v50; // r13d
  __int64 v51; // r15
  __int128 v52; // rt0
  __int128 v53; // rt0
  unsigned __int64 v54; // r12
  __int64 v55; // r13
  int v56; // edi
  __int64 v57; // r14
  unsigned __int64 v58; // r14
  __int128 v59; // rt0
  __int64 v60; // [rsp+10h] [rbp-20h]
  __int64 v61; // [rsp+18h] [rbp-18h]
  unsigned __int64 v62; // [rsp+18h] [rbp-18h]
  unsigned __int64 v63; // [rsp+18h] [rbp-18h]
  char v64; // [rsp+20h] [rbp-10h]
  int v65; // [rsp+20h] [rbp-10h]
  unsigned __int64 v66; // [rsp+20h] [rbp-10h]
  int v67; // [rsp+20h] [rbp-10h]
  int v68; // [rsp+20h] [rbp-10h]
  char v69; // [rsp+2Fh] [rbp-1h]

  v2 = a2[1];
  if ( !v2 )
  {
    *(_QWORD *)a1 = 2LL;
    return;
  }
  v3 = (unsigned int *)*a2;
  if ( v2 < 4 )
  {
    v8 = 19LL;
    v6 = *a2;
    goto LABEL_8;
  }
  v4 = (unsigned int *)a2[2];
  v5 = v2 - 4;
  v6 = (unsigned __int64)(v3 + 1);
  v7 = *v3;
  if ( *v3 >> 4 != 0xFFFFFFF )
  {
    v13 = 4;
    v14 = *v3;
    v15 = v5 < v7;
    v10 = v5 - v7;
    if ( v15 )
    {
LABEL_10:
      v9 = v6 >> 8;
      v8 = 19LL;
      LOWORD(v10) = 0;
      v12 = 0LL;
      goto LABEL_32;
    }
LABEL_13:
    *a2 = v6 + v14;
    a2[1] = v10;
    if ( v14 <= 1 )
    {
      LOWORD(v10) = 0;
      v9 = v6 >> 8;
      v8 = 19LL;
      v12 = 0LL;
      goto LABEL_32;
    }
    v17 = v14 - 2;
    v18 = *(_WORD *)v6;
    if ( (unsigned __int16)(*(_WORD *)v6 - 2) < 3u )
    {
      if ( (unsigned int)v7 < 0xFFFFFFF0 )
      {
        if ( v17 > 3 )
        {
          v19 = v14 - 6;
          v21 = *(unsigned int *)(v6 + 2);
          v20 = v6 + 6;
          goto LABEL_26;
        }
      }
      else if ( v17 > 7 )
      {
        v19 = v14 - 10;
        v20 = v6 + 10;
        *(_QWORD *)&v22 = ((unsigned __int64)(*(unsigned __int16 *)(v6 + 6) | (*(unsigned __int8 *)(v6 + 8) << 16)) << 40) | ((unsigned __int64)*(unsigned int *)(v6 + 2) << 8);
        *((_QWORD *)&v22 + 1) = *(unsigned __int8 *)(v6 + 9);
        v21 = v22 >> 8;
LABEL_26:
        if ( v19 )
        {
          v64 = v13;
          v23 = *(_WORD *)v6;
          v24 = v19 - 1;
          v25 = *(_BYTE *)v20;
          v26 = (unsigned int *)(v20 + 1);
          v12 = 0LL;
          v6 = (unsigned __int64)v26;
          v27 = v25;
          v28 = v24;
          v18 = v23;
          v13 = v64;
LABEL_28:
          a2[2] = (unsigned __int64)v4 + v2 - v10;
          *(_QWORD *)a1 = 0LL;
          *(_QWORD *)(a1 + 8) = v4;
          *(_QWORD *)(a1 + 16) = v12;
          *(_QWORD *)(a1 + 24) = v26;
          *(_QWORD *)(a1 + 32) = v61;
          *(_QWORD *)(a1 + 40) = v6;
          *(_QWORD *)(a1 + 48) = v28;
          *(_QWORD *)(a1 + 56) = v14;
          *(_QWORD *)(a1 + 64) = v21;
          *(_BYTE *)(a1 + 72) = v27;
          *(_BYTE *)(a1 + 73) = v13;
          *(_WORD *)(a1 + 74) = v18;
          return;
        }
        v9 = v20 >> 8;
        v8 = 19LL;
        LOWORD(v10) = 0;
        v12 = 0LL;
        LOBYTE(v6) = v20;
LABEL_32:
        v11 = 0LL;
        goto LABEL_33;
      }
LABEL_29:
      v9 = (v6 + 2) >> 8;
      v8 = 19LL;
      LOWORD(v10) = 0;
      v12 = 0LL;
      LOBYTE(v6) = v6 + 2;
      goto LABEL_32;
    }
    if ( v18 != 5 )
    {
      LOBYTE(v6) = *(_WORD *)v6;
      v9 = HIBYTE(v18);
      v8 = 17LL;
      v12 = 0LL;
      goto LABEL_32;
    }
    if ( v14 == 2 )
      goto LABEL_29;
    if ( v14 == 3 )
    {
      v6 += 3LL;
      goto LABEL_10;
    }
    v29 = *(unsigned __int8 *)(v6 + 2);
    v30 = v14 - 4;
    if ( (unsigned int)v7 < 0xFFFFFFF0 )
    {
      if ( v30 > 3 )
      {
        v69 = *(_BYTE *)(v6 + 3);
        v28 = v14 - 8;
        v21 = *(unsigned int *)(v6 + 4);
        v6 += 8LL;
        goto LABEL_39;
      }
    }
    else if ( v30 > 7 )
    {
      v69 = *(_BYTE *)(v6 + 3);
      v28 = v14 - 12;
      v61 = *(unsigned __int8 *)(v6 + 11);
      v31 = *(unsigned __int16 *)(v6 + 8);
      v65 = *(unsigned __int8 *)(v6 + 2);
      v32 = *(unsigned __int8 *)(v6 + 10);
      v33 = *(unsigned int *)(v6 + 4);
      v6 += 12LL;
      v34 = ((unsigned __int64)(v31 | (unsigned int)(v32 << 16)) << 40) | (v33 << 8);
      v29 = v65;
      *(_QWORD *)&v35 = v34;
      *((_QWORD *)&v35 + 1) = v61;
      v21 = v35 >> 8;
LABEL_39:
      v12 = 0LL;
      v26 = (unsigned int *)(unsigned int)(v29 - 1);
      v66 = v28;
      switch ( (int)v26 )
      {
        case 0:
          goto LABEL_48;
        case 1:
          if ( v28 <= 7 )
            goto LABEL_10;
          v62 = v28 - 8;
          *(_QWORD *)&v36 = ((unsigned __int64)(*(unsigned __int16 *)(v6 + 4) | (*(unsigned __int8 *)(v6 + 6) << 16)) << 40) | ((unsigned __int64)*(unsigned int *)v6 << 8);
          *((_QWORD *)&v36 + 1) = *(unsigned __int8 *)(v6 + 7);
          v26 = (unsigned int *)(v36 >> 8);
          v60 = v21;
          if ( (unsigned int)v7 < 0xFFFFFFF0 )
          {
            if ( v62 <= 3 )
              goto LABEL_64;
            v28 -= 12LL;
            v61 = *(unsigned int *)(v6 + 8);
            v6 += 12LL;
          }
          else
          {
            if ( v62 <= 7 )
              goto LABEL_64;
            v37 = v28 - 16;
            v38 = *(unsigned __int8 *)(v6 + 15);
            v67 = *(unsigned __int16 *)(v6 + 12);
            v39 = *(unsigned __int8 *)(v6 + 14);
            v40 = *(unsigned int *)(v6 + 8);
            v6 += 16LL;
            v41 = ((unsigned __int64)(unsigned int)(v67 + (v39 << 16)) << 40) | (v40 << 8);
            v28 = v37;
            *(_QWORD *)&v42 = v41;
            *((_QWORD *)&v42 + 1) = v38;
            v61 = v42 >> 8;
          }
          v12 = 1LL;
          goto LABEL_63;
        case 2:
          v12 = 2LL;
LABEL_48:
          v27 = v69;
          goto LABEL_28;
        case 3:
          if ( v28 <= 7 )
            goto LABEL_10;
          v48 = *(unsigned __int8 *)(v6 + 7);
          v49 = *(unsigned __int16 *)(v6 + 4);
          v50 = *(unsigned __int8 *)(v6 + 6);
          v51 = *(unsigned int *)v6;
          v6 += 8LL;
          *(_QWORD *)&v52 = ((unsigned __int64)(v49 | (unsigned int)(v50 << 16)) << 40) | (v51 << 8);
          *((_QWORD *)&v52 + 1) = v48;
          v26 = (unsigned int *)(v52 >> 8);
          v28 = v66 - 8;
          v12 = 3LL;
          goto LABEL_51;
        case 4:
          if ( v28 <= 7 )
            goto LABEL_10;
          v43 = *(unsigned __int8 *)(v6 + 7);
          v44 = *(unsigned __int16 *)(v6 + 4);
          v45 = *(unsigned __int8 *)(v6 + 6);
          v46 = *(unsigned int *)v6;
          v6 += 8LL;
          *(_QWORD *)&v47 = ((unsigned __int64)(v44 | (unsigned int)(v45 << 16)) << 40) | (v46 << 8);
          *((_QWORD *)&v47 + 1) = v43;
          v26 = (unsigned int *)(v47 >> 8);
          v28 = v66 - 8;
          v12 = 4LL;
LABEL_51:
          v27 = v69;
          goto LABEL_28;
        case 5:
          if ( v28 <= 7 )
            goto LABEL_10;
          v63 = v28 - 8;
          *(_QWORD *)&v53 = ((unsigned __int64)(*(unsigned __int16 *)(v6 + 4) | (*(unsigned __int8 *)(v6 + 6) << 16)) << 40) | ((unsigned __int64)*(unsigned int *)v6 << 8);
          *((_QWORD *)&v53 + 1) = *(unsigned __int8 *)(v6 + 7);
          v26 = (unsigned int *)(v53 >> 8);
          v60 = v21;
          if ( (unsigned int)v7 < 0xFFFFFFF0 )
          {
            if ( v63 > 3 )
            {
              v28 -= 12LL;
              v61 = *(unsigned int *)(v6 + 8);
              v6 += 12LL;
LABEL_62:
              v12 = 5LL;
LABEL_63:
              v27 = v69;
              v21 = v60;
              goto LABEL_28;
            }
          }
          else if ( v63 > 7 )
          {
            v54 = v28 - 16;
            v55 = *(unsigned __int8 *)(v6 + 15);
            v68 = *(unsigned __int16 *)(v6 + 12);
            v56 = *(unsigned __int8 *)(v6 + 14);
            v57 = *(unsigned int *)(v6 + 8);
            v6 += 16LL;
            v58 = ((unsigned __int64)(unsigned int)(v68 + (v56 << 16)) << 40) | (v57 << 8);
            v28 = v54;
            *(_QWORD *)&v59 = v58;
            *((_QWORD *)&v59 + 1) = v55;
            v61 = v59 >> 8;
            goto LABEL_62;
          }
LABEL_64:
          v6 += 8LL;
          goto LABEL_10;
        default:
          v8 = 63LL;
          v9 = 0LL;
          LOBYTE(v6) = 0;
          goto LABEL_32;
      }
    }
    v6 += 4LL;
    goto LABEL_10;
  }
  if ( (_DWORD)v7 == -1 )
  {
    if ( v5 < 8 )
    {
      v8 = 19LL;
      goto LABEL_8;
    }
    v6 = (unsigned __int64)(v3 + 3);
    *(_QWORD *)&v16 = ((unsigned __int64)(*((unsigned __int16 *)v3 + 4) | (*((unsigned __int8 *)v3 + 10) << 16)) << 40) | ((unsigned __int64)v3[1] << 8);
    *((_QWORD *)&v16 + 1) = *((unsigned __int8 *)v3 + 11);
    v14 = v16 >> 8;
    v13 = 8;
    v10 = v2 - 12 - v14;
    if ( v2 - 12 < v14 )
      goto LABEL_10;
    goto LABEL_13;
  }
  v8 = 16LL;
LABEL_8:
  v9 = v6 >> 8;
  v10 = v8 >> 16;
  v11 = (v8 >> 16) & 0xFFFFFFFFFFFF0000uLL;
  v12 = (unsigned __int16)v8 & 0xFF00;
  v8 = (unsigned __int8)v8;
LABEL_33:
  *a2 = 1LL;
  a2[1] = 0LL;
  *(_QWORD *)(a1 + 8) = v8 | v12 | ((v11 | (unsigned __int16)v10) << 16);
  *(_QWORD *)(a1 + 16) = (v9 << 8) | (unsigned __int8)v6;
  *(_QWORD *)a1 = 3LL;
}
// 41A4F7: variable 'v61' is possibly undefined

//----- (000000000041A8B0) ----------------------------------------------------
int __fastcall sub_41A8B0(unsigned __int64 a1, unsigned __int64 *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // r14
  unsigned __int64 v5; // rax
  unsigned __int64 v6; // rcx
  unsigned __int64 v7; // r12
  unsigned __int64 v8; // r13
  unsigned __int64 v9; // rdx
  __int64 v10; // r11
  __int64 v11; // r9
  char v12; // si
  bool v13; // cf
  unsigned __int64 *v14; // rax
  bool v15; // of
  __int64 v16; // rt0
  char v17; // di
  unsigned __int64 v18; // rbx
  unsigned __int64 v19; // rdi
  char *v20; // r12
  unsigned __int64 v21; // r13
  __int64 v22; // r15
  int v23; // ecx
  unsigned __int64 v24; // rax
  char *v25; // rdx
  unsigned __int64 v26; // rdi
  unsigned __int64 v27; // r10
  unsigned __int64 v28; // r12
  _BYTE *v29; // r13
  int v30; // r9d
  unsigned __int8 *v31; // r13
  unsigned __int64 v32; // r12
  __int64 v33; // rsi
  unsigned __int8 *v34; // rcx
  unsigned __int16 v35; // ax
  unsigned __int16 v36; // cx
  int v37; // edx
  int v38; // ecx
  unsigned __int64 v39; // r9
  __int64 v40; // rsi
  int v41; // r10d
  __int64 v42; // r11
  __int64 v43; // rdi
  __int64 v44; // rax
  __int64 v45; // rcx
  _OWORD *v46; // rax
  __int128 v47; // xmm0
  __int128 v48; // xmm1
  __int128 v49; // xmm2
  _QWORD *v50; // rax
  __int64 v51; // rcx
  __int16 v52; // ax
  unsigned __int16 v53; // dx
  unsigned __int64 v54; // rcx
  __int64 v55; // rsi
  unsigned __int64 v56; // rdi
  void *v57; // r15
  HANDLE ProcessHeap; // rax
  void **v59; // r15
  __int64 v60; // rsi
  void **v61; // r13
  void *v62; // r12
  HANDLE v63; // rax
  __int64 v64; // rax
  unsigned __int64 v65; // rdi
  __int64 v66; // rdx
  __int64 v67; // rsi
  _OWORD *v68; // rax
  __int128 v69; // xmm0
  __int128 v70; // xmm1
  __int128 v71; // xmm2
  HANDLE v72; // rax
  char *v73; // rax
  __int64 v74; // rcx
  unsigned __int64 v75; // r8
  __int64 i; // rax
  __int64 v77; // rax
  void *v78; // r13
  HANDLE v79; // rax
  __int64 v80; // r8
  __int64 v81; // rax
  __int128 v82; // xmm0
  unsigned __int8 v83; // dl
  __int64 v84; // r11
  __int64 v85; // r10
  __int64 v86; // r11
  unsigned __int64 v87; // rdx
  unsigned __int64 v88; // r8
  unsigned __int8 v89; // al
  _QWORD *v90; // rsi
  __m256i *v91; // r14
  __int64 v92; // r9
  _QWORD *v93; // rax
  void *v94; // rsi
  HANDLE v95; // rax
  void *v96; // rsi
  HANDLE v97; // rax
  void *v98; // rsi
  HANDLE v99; // rax
  void *v100; // rsi
  HANDLE v101; // rax
  unsigned __int64 v102; // rbx
  __int64 v103; // r13
  __int64 v104; // rbx
  __int64 v105; // r13
  __int64 v106; // rax
  __int64 v107; // r13
  __int64 v108; // r12
  __int64 v109; // rcx
  unsigned __int64 *v110; // rdi
  __int64 v111; // rax
  __int64 v112; // rbx
  __int64 v113; // rax
  __int64 v114; // rcx
  unsigned __int64 v115; // rdx
  __int64 v116; // rax
  unsigned __int64 v117; // rdx
  char v118; // si
  unsigned __int16 *v119; // rax
  unsigned __int64 v120; // rcx
  __int64 v121; // r11
  unsigned __int64 v122; // r13
  unsigned __int64 v123; // rdi
  __int64 v124; // rsi
  unsigned __int64 v125; // rdi
  void *v126; // r15
  HANDLE v127; // rax
  void *v128; // r15
  HANDLE v129; // rax
  void *v130; // r15
  HANDLE v131; // rax
  void *v132; // r15
  HANDLE v133; // rax
  void *v134; // r8
  unsigned __int8 *v135; // rax
  unsigned __int64 v136; // r8
  unsigned __int64 v137; // rcx
  unsigned __int64 v138; // r9
  __int64 v139; // rcx
  char v140; // r9
  unsigned __int64 v141; // rdi
  __int64 v142; // rax
  __int128 v143; // rt0
  __int64 v144; // rsi
  __int128 v145; // rt0
  unsigned __int64 v146; // r11
  unsigned __int8 *v147; // rcx
  unsigned __int64 v148; // r10
  __int128 v149; // rt0
  unsigned __int8 *v150; // rax
  unsigned __int64 v151; // rcx
  char *v152; // rax
  __int64 v153; // rcx
  char *v154; // rsi
  __int64 v155; // r12
  __int64 v156; // rax
  unsigned __int64 *v157; // rax
  char *v158; // rsi
  __int64 v159; // rax
  char v160; // r12
  void *v161; // rsi
  HANDLE v162; // rax
  HANDLE v163; // rax
  void *v164; // rsi
  HANDLE v165; // rax
  HANDLE v166; // rax
  __int64 v167; // r15
  char *v168; // rcx
  __int128 v169; // xmm1
  unsigned __int64 v170; // rax
  char *v171; // rcx
  __int64 v172; // r9
  __int64 v173; // r15
  char *v174; // rdx
  __int64 v175; // rax
  __int128 v176; // xmm1
  __int64 v178; // [rsp+30h] [rbp-50h] BYREF
  __int128 v179; // [rsp+38h] [rbp-48h]
  __int64 v180; // [rsp+48h] [rbp-38h] BYREF
  __int128 v181; // [rsp+50h] [rbp-30h]
  __int128 v182; // [rsp+60h] [rbp-20h]
  __int128 v183; // [rsp+70h] [rbp-10h]
  __int128 v184; // [rsp+80h] [rbp+0h]
  __int128 v185; // [rsp+90h] [rbp+10h]
  __int64 v186; // [rsp+A0h] [rbp+20h]
  unsigned __int64 v187; // [rsp+A8h] [rbp+28h]
  __int64 v188; // [rsp+B0h] [rbp+30h]
  char *v189; // [rsp+B8h] [rbp+38h]
  __int128 v190; // [rsp+C0h] [rbp+40h]
  char *v191; // [rsp+D0h] [rbp+50h]
  _OWORD Src[27]; // [rsp+E0h] [rbp+60h] BYREF
  __m256i v193; // [rsp+290h] [rbp+210h] BYREF
  __int128 v194; // [rsp+2B0h] [rbp+230h]
  __int128 v195; // [rsp+2C0h] [rbp+240h]
  __int64 v196; // [rsp+2D0h] [rbp+250h]
  int v197; // [rsp+2DAh] [rbp+25Ah]
  __int16 v198; // [rsp+2DEh] [rbp+25Eh]
  __int128 v199; // [rsp+2E0h] [rbp+260h]
  __int64 v200; // [rsp+2F0h] [rbp+270h]
  __int64 v201; // [rsp+300h] [rbp+280h]
  unsigned __int64 v202; // [rsp+308h] [rbp+288h]
  __int64 v203; // [rsp+310h] [rbp+290h]
  unsigned int v204; // [rsp+31Ch] [rbp+29Ch]
  unsigned __int64 v205; // [rsp+320h] [rbp+2A0h]
  unsigned __int16 *v206; // [rsp+328h] [rbp+2A8h]
  _BYTE v207[48]; // [rsp+330h] [rbp+2B0h] BYREF
  __int128 v208; // [rsp+360h] [rbp+2E0h]
  __int64 v209; // [rsp+370h] [rbp+2F0h]
  LPVOID v210[2]; // [rsp+380h] [rbp+300h] BYREF
  _BYTE v211[24]; // [rsp+390h] [rbp+310h]
  char *v212; // [rsp+3A8h] [rbp+328h]
  __m256i v213; // [rsp+3B0h] [rbp+330h] BYREF
  __int128 v214; // [rsp+3D0h] [rbp+350h]
  __int128 v215; // [rsp+3E0h] [rbp+360h]
  __int64 v216; // [rsp+3F0h] [rbp+370h]
  unsigned __int8 *v217; // [rsp+400h] [rbp+380h]
  int v218; // [rsp+408h] [rbp+388h]
  __int16 v219; // [rsp+40Ch] [rbp+38Ch]
  __int64 v220; // [rsp+410h] [rbp+390h]
  char *v221; // [rsp+418h] [rbp+398h]
  __int64 v222; // [rsp+420h] [rbp+3A0h]
  __int64 v223; // [rsp+428h] [rbp+3A8h]
  unsigned __int64 v224; // [rsp+430h] [rbp+3B0h]
  __int64 v225; // [rsp+438h] [rbp+3B8h]
  LPVOID v226[2]; // [rsp+440h] [rbp+3C0h] BYREF
  char *v227; // [rsp+450h] [rbp+3D0h]
  __int64 v228; // [rsp+458h] [rbp+3D8h]
  _BYTE v229[96]; // [rsp+460h] [rbp+3E0h] BYREF
  LPVOID v230; // [rsp+4C8h] [rbp+448h]
  LPVOID v231[2]; // [rsp+4D0h] [rbp+450h] BYREF
  __int64 v232; // [rsp+4E0h] [rbp+460h]
  __int64 v233; // [rsp+4E8h] [rbp+468h]
  char *v234; // [rsp+4F0h] [rbp+470h]
  unsigned __int64 *v235; // [rsp+4F8h] [rbp+478h]
  __int64 v236; // [rsp+500h] [rbp+480h]
  __int64 v237; // [rsp+508h] [rbp+488h]
  char *v238; // [rsp+510h] [rbp+490h] BYREF
  unsigned __int64 v239; // [rsp+518h] [rbp+498h]
  unsigned __int8 v240; // [rsp+524h] [rbp+4A4h]
  char v241; // [rsp+525h] [rbp+4A5h]
  char v242; // [rsp+526h] [rbp+4A6h]
  bool v243; // [rsp+527h] [rbp+4A7h]
  char *v244; // [rsp+528h] [rbp+4A8h]
  LPVOID v245; // [rsp+530h] [rbp+4B0h]
  char v246; // [rsp+53Dh] [rbp+4BDh]
  __int16 v247; // [rsp+53Eh] [rbp+4BEh]

  v5 = *(_QWORD *)(a3 + 64);
  v6 = a2[27];
  v7 = *a2;
  v8 = a2[1];
  v235 = a2;
  v236 = a3;
  if ( v6 )
  {
    v9 = a2[28];
    while ( 1 )
    {
      v10 = 8 * (unsigned int)*(unsigned __int16 *)(v6 + 274);
      v11 = -1LL;
      do
      {
        if ( !v10 )
        {
          v11 = *(unsigned __int16 *)(v6 + 274);
          goto LABEL_11;
        }
        v12 = *(_QWORD *)(v6 + 8 * v11 + 192) != v5;
        if ( *(_QWORD *)(v6 + 8 * v11 + 192) > v5 )
          v12 = -1;
        ++v11;
        v10 -= 8LL;
      }
      while ( v12 == 1 );
      if ( !v12 )
      {
        v14 = (unsigned __int64 *)(v6 + 16 * v11);
        v15 = __OFSUB__(*(_BYTE *)v14, 75);
        if ( *(_BYTE *)v14 != 75 )
        {
          v19 = *v14;
          v3 = v14[1];
          v18 = *v14;
          goto LABEL_133;
        }
        v3 = v14[1];
        v16 = _InterlockedIncrement64((volatile signed __int64 *)v3);
        if ( (v16 < 0) ^ v15 | (v16 == 0) )
          BUG();
        goto LABEL_135;
      }
LABEL_11:
      v13 = v9-- == 0;
      if ( v13 )
        break;
      v6 = *(_QWORD *)(v6 + 8 * v11 + 280);
    }
  }
  if ( v8 < v5 )
  {
    v17 = 19;
    v18 = 0LL;
    v3 = v7;
    goto LABEL_132;
  }
  v20 = (char *)(v5 + v7);
  v210[0] = 0LL;
  v210[1] = (LPVOID)8;
  v212 = 0LL;
  *(_OWORD *)v211 = 0LL;
  v21 = v8 - v5;
  v221 = (char *)a1;
  if ( !v21 )
    goto LABEL_92;
  v18 = 0LL;
  while ( 2 )
  {
    v22 = 0LL;
    v23 = 0;
    v24 = v21;
    v25 = v20;
    while ( 1 )
    {
      a3 = (unsigned __int8)*v25;
      LOBYTE(v26) = 6;
      if ( v23 == 63 && (unsigned __int8)a3 >= 2u )
        goto LABEL_91;
      v27 = (a3 & 0x7F) << v23;
      a3 = v24 - 1;
      v3 = (unsigned __int64)(v25 + 1);
      v22 |= v27;
      if ( *v25 >= 0 )
        break;
      v23 += 7;
      --v24;
      ++v25;
      if ( !a3 )
      {
        v20 += v21;
        goto LABEL_92;
      }
    }
    if ( !v22 )
    {
      v17 = (char)v210[1];
      v3 = *(_QWORD *)v211;
      *(_OWORD *)v226 = *(_OWORD *)&v211[8];
      v227 = v212;
      if ( __OFSUB__(-(__int64)v210[0], 1LL) )
      {
        v18 = (unsigned __int64)v210[1] & 0xFFFFFFFFFFFFFF00uLL;
        goto LABEL_131;
      }
      *((_QWORD *)&Src[3] + 1) = v227;
      *(_OWORD *)((char *)&Src[2] + 8) = *(_OWORD *)v226;
      *(_QWORD *)&Src[0] = 1LL;
      *((_QWORD *)&Src[0] + 1) = 1LL;
      Src[1] = *(_OWORD *)v210;
      *(_QWORD *)&Src[2] = *(_QWORD *)v211;
      v68 = sub_43C4F0(0x40uLL);
      a1 = (unsigned __int64)v221;
      if ( !v68 )
        sub_4040E9(8LL, 64LL);
      v3 = (unsigned __int64)v68;
      v69 = Src[0];
      v70 = Src[1];
      v71 = Src[2];
      v68[3] = Src[3];
      v68[2] = v71;
      v68[1] = v70;
      *v68 = v69;
      LOBYTE(v19) = 75;
      goto LABEL_134;
    }
    if ( v24 == 1 )
    {
      LOBYTE(v26) = 19;
      LODWORD(v18) = 0;
      v54 = 0LL;
      goto LABEL_100;
    }
    v28 = v24 - 2;
    v29 = v25 + 2;
    v30 = v25[1] & 0x7F;
    if ( v25[1] < 0 )
    {
      if ( v24 == 2 )
        goto LABEL_107;
      v28 = v24 - 3;
      v29 = v25 + 3;
      a3 = (unsigned __int8)(v25[2] & 0x7F) << 7;
      v30 = a3 | v25[1] & 0x7F;
      if ( v25[2] < 0 )
      {
        if ( v24 == 3 )
          goto LABEL_107;
        if ( (unsigned __int8)*v29 > 3u )
        {
LABEL_91:
          v54 = 0LL;
          goto LABEL_100;
        }
        v30 = ((unsigned __int8)*v29 << 14) | (unsigned __int16)v30;
        v29 = v25 + 4;
        v28 = v24 - 4;
      }
    }
    if ( !(_WORD)v30 )
    {
      LOBYTE(v26) = 8;
      v54 = 0LL;
      goto LABEL_100;
    }
    if ( !v28 )
    {
LABEL_107:
      LOBYTE(v26) = 19;
      LODWORD(v18) = 0;
      v54 = 0LL;
      v3 = (unsigned __int64)v29;
      goto LABEL_100;
    }
    if ( *v29 >= 2u )
    {
      LOBYTE(v26) = 10;
      v54 = 0LL;
      goto LABEL_100;
    }
    LOBYTE(v222) = *v29;
    LODWORD(v237) = v30;
    v31 = v29 + 1;
    v32 = v28 - 1;
    *(_QWORD *)&v229[32] = 0LL;
    *(_DWORD *)&v229[40] = 0;
    *(_QWORD *)&v229[48] = 0LL;
    *(_DWORD *)&v229[56] = 0;
    *(_QWORD *)&v229[64] = 0LL;
    *(_DWORD *)&v229[72] = 0;
    *(_QWORD *)&v229[80] = 0LL;
    *(_DWORD *)&v229[88] = 0;
    memset(v229, 0, 28);
    v33 = 0LL;
    while ( 1 )
    {
      if ( !v32 )
      {
LABEL_94:
        v64 = 19LL;
        v65 = 0LL;
        v66 = 0LL;
        v67 = 0LL;
        v3 = (unsigned __int64)v31;
        goto LABEL_95;
      }
      a3 = v32 - 1;
      v34 = v31 + 1;
      v35 = *v31 & 0x7F;
      if ( (*v31 & 0x80u) != 0 )
      {
        if ( v32 == 1 )
          goto LABEL_106;
        a3 = v32 - 2;
        v34 = v31 + 2;
        v35 |= (v31[1] & 0x7F) << 7;
        if ( (v31[1] & 0x80u) != 0 )
        {
          if ( v32 == 2 )
            goto LABEL_106;
          v36 = *v34;
          if ( v36 > 3u )
            goto LABEL_114;
          v35 |= v36 << 14;
          v34 = v31 + 3;
          a3 = v32 - 3;
        }
      }
      if ( !v35 )
        break;
      if ( !a3 )
        goto LABEL_106;
      v32 = a3 - 1;
      v31 = v34 + 1;
      v37 = *v34 & 0x7F;
      if ( (*v34 & 0x80u) != 0 )
      {
        if ( a3 == 1 )
          goto LABEL_94;
        v32 = a3 - 2;
        v31 = v34 + 2;
        v37 = ((v34[1] & 0x7F) << 7) | *v34 & 0x7F;
        if ( (v34[1] & 0x80u) != 0 )
        {
          if ( a3 == 2 )
            goto LABEL_94;
          if ( *v31 > 3u )
            goto LABEL_114;
          a3 -= 3LL;
          v37 = (*v31 << 14) | (unsigned __int16)v37;
          v31 = v34 + 3;
          v32 = a3;
        }
      }
      if ( (_WORD)v37 != 33 )
      {
        v33 = (unsigned __int16)v37;
        if ( (_WORD)v37 )
        {
          v33 = 0LL;
          goto LABEL_69;
        }
        v64 = 9LL;
LABEL_115:
        v65 = v33 & 0xFFFFFFFF00000000uLL;
        v66 = (unsigned int)v33 & 0xFFFF0000;
        v67 = (unsigned __int16)v33 & 0xFF00;
LABEL_95:
        v55 = v64 | v67;
        v56 = v66 | v65;
        if ( *(_QWORD *)v229 && *(_QWORD *)&v229[8] )
        {
          v57 = *(void **)&v229[16];
          ProcessHeap = GetProcessHeap();
          HeapFree(ProcessHeap, 0, v57);
        }
        v26 = v55 | v56;
LABEL_99:
        v54 = v26 & 0xFFFFFFFF00000000uLL;
        LODWORD(v18) = v26;
        goto LABEL_100;
      }
      v38 = 0;
      a3 = (unsigned __int64)v31;
      v39 = v32;
      v40 = 0LL;
      do
      {
        v13 = v39-- == 0;
        if ( v13 )
        {
          v31 += v32;
          goto LABEL_94;
        }
        v41 = *(unsigned __int8 *)a3;
        if ( v38 == 63 && v41 != 127 && *(_BYTE *)a3 )
        {
          v64 = 7LL;
          v65 = 0LL;
          v66 = 0LL;
          v67 = 0LL;
          goto LABEL_95;
        }
        ++a3;
        v40 |= (unsigned __int64)(v41 & 0x7F) << v38;
        v38 += 7;
      }
      while ( (v41 & 0x80u) != 0 );
      v42 = -1LL << v38;
      if ( (unsigned __int8)v41 < 0x40u )
        v42 = 0LL;
      if ( v38 >= 64 )
        v42 = 0LL;
      v33 = v42 | v40;
      v31 = (unsigned __int8 *)a3;
      v32 = v39;
LABEL_69:
      v3 = (unsigned int)(v37 << 16) | v35 | v3 & 0xFFFFFFFF00000000uLL;
      if ( *(_QWORD *)v229 )
      {
        v43 = *(_QWORD *)&v229[24];
        if ( *(_QWORD *)&v229[24] == *(_QWORD *)&v229[8] )
          sub_409700((unsigned __int64 *)&v229[8], (__int64)&off_446D50);
        v44 = *(_QWORD *)&v229[16];
        v45 = 16 * v43;
        *(_QWORD *)(*(_QWORD *)&v229[16] + v45) = v33;
        *(_QWORD *)(v44 + v45 + 8) = v3;
        *(_QWORD *)&v229[24] = v43 + 1;
      }
      else if ( *(_QWORD *)&v229[8] == 5LL )
      {
        v46 = sub_43C4F0(0x50uLL);
        if ( !v46 )
          sub_4040E9(8LL, 80LL);
        v46[4] = *(_OWORD *)&v229[80];
        v47 = *(_OWORD *)&v229[16];
        v48 = *(_OWORD *)&v229[32];
        v49 = *(_OWORD *)&v229[48];
        v46[3] = *(_OWORD *)&v229[64];
        v46[2] = v49;
        v46[1] = v48;
        *v46 = v47;
        v231[0] = (LPVOID)5;
        v231[1] = v46;
        v232 = 5LL;
        sub_409700((unsigned __int64 *)v231, (__int64)&off_446D20);
        v50 = v231[1];
        *((_QWORD *)v231[1] + 10) = v33;
        v50[11] = v3;
        v232 = 6LL;
        sub_408F07(v229);
        *(_QWORD *)v229 = 1LL;
        *(_QWORD *)&v229[24] = v232;
        *(_OWORD *)&v229[8] = *(_OWORD *)v231;
      }
      else
      {
        if ( *(_QWORD *)&v229[8] >= 5uLL )
          sub_4050B0(*(_QWORD *)&v229[8], 5LL, &off_446D38);
        v51 = 16LL * *(_QWORD *)&v229[8];
        *(_QWORD *)&v229[v51 + 16] = v33;
        *(_QWORD *)&v229[v51 + 24] = v3;
        ++*(_QWORD *)&v229[8];
      }
    }
    if ( !a3 )
    {
LABEL_106:
      v64 = 19LL;
      v65 = 0LL;
      v66 = 0LL;
      v67 = 0LL;
      v3 = (unsigned __int64)v34;
      goto LABEL_95;
    }
    v21 = a3 - 1;
    v20 = (char *)(v34 + 1);
    v52 = *v34 & 0x7F;
    if ( (*v34 & 0x80u) == 0 )
      goto LABEL_85;
    if ( a3 == 1 )
      goto LABEL_295;
    v21 = a3 - 2;
    v20 = (char *)(v34 + 2);
    v52 |= (v34[1] & 0x7F) << 7;
    if ( (v34[1] & 0x80u) == 0 )
      goto LABEL_85;
    if ( a3 == 2 )
    {
LABEL_295:
      v64 = 19LL;
      v65 = 0LL;
      v66 = 0LL;
      v67 = 0LL;
      v3 = (unsigned __int64)v20;
      goto LABEL_95;
    }
    v53 = (unsigned __int8)*v20;
    if ( v53 > 3u )
    {
LABEL_114:
      v64 = 6LL;
      v33 = 0LL;
      goto LABEL_115;
    }
    a3 -= 3LL;
    v52 |= v53 << 14;
    v20 = (char *)(v34 + 3);
    v21 = a3;
LABEL_85:
    if ( v52 )
    {
      v64 = 13LL;
      goto LABEL_115;
    }
    v26 = *(_QWORD *)&v229[8];
    v3 = *(_QWORD *)&v229[16];
    v213 = *(__m256i *)&v229[24];
    v214 = *(_OWORD *)&v229[56];
    v215 = *(_OWORD *)&v229[72];
    v216 = *(_QWORD *)&v229[88];
    if ( *(_QWORD *)v229 == 2LL )
      goto LABEL_99;
    v196 = v216;
    v195 = v215;
    v194 = v214;
    v193 = v213;
    if ( *(_QWORD *)v229 == 3LL )
      goto LABEL_99;
    v209 = v196;
    v208 = v195;
    *(_OWORD *)&v207[32] = v194;
    *(__m256i *)v207 = v193;
    LODWORD(v199) = v190;
    BYTE4(v199) = BYTE4(v190);
    Src[0] = *(_OWORD *)v229;
    *(_QWORD *)&Src[1] = *(_QWORD *)&v229[16];
    *((_QWORD *)&Src[5] + 1) = v196;
    *(_OWORD *)((char *)&Src[4] + 8) = v195;
    *(_OWORD *)((char *)&Src[3] + 8) = v194;
    *(__m256i *)((char *)&Src[1] + 8) = v193;
    *(_QWORD *)&Src[6] = v22;
    WORD4(Src[6]) = v237;
    BYTE10(Src[6]) = v222;
    HIBYTE(Src[6]) = BYTE4(v190);
    *(_DWORD *)((char *)&Src[6] + 11) = v190;
    if ( sub_40974D((unsigned __int64 *)v210, (__int64 *)Src) )
    {
      v17 = 14;
      v59 = (void **)v210[1];
      v60 = *(_QWORD *)v211;
      if ( *(_QWORD *)v211 )
        goto LABEL_101;
    }
    else
    {
      if ( v21 )
        continue;
LABEL_92:
      LOBYTE(v26) = 19;
      LODWORD(v18) = 0;
      v54 = 0LL;
      v3 = (unsigned __int64)v20;
LABEL_100:
      v18 = v54 | (unsigned int)v18 & 0xFFFFFF00;
      v17 = v18 | v26;
      v59 = (void **)v210[1];
      v60 = *(_QWORD *)v211;
      if ( *(_QWORD *)v211 )
      {
LABEL_101:
        v61 = v59 + 2;
        do
        {
          if ( *(v61 - 2) && *(v61 - 1) )
          {
            v62 = *v61;
            v63 = GetProcessHeap();
            HeapFree(v63, 0, v62);
          }
          v61 += 14;
          --v60;
        }
        while ( v60 );
      }
    }
    break;
  }
  if ( v210[0] )
  {
    v72 = GetProcessHeap();
    HeapFree(v72, 0, v59);
  }
  if ( *(_QWORD *)&v211[8] )
  {
    v73 = v212;
    *(_QWORD *)&v229[8] = 0LL;
    *(_QWORD *)&v229[16] = *(_QWORD *)&v211[8];
    *(_QWORD *)&v229[24] = *(_QWORD *)&v211[16];
    *(_QWORD *)&v229[40] = 0LL;
    *(_QWORD *)&v229[48] = *(_QWORD *)&v211[8];
    *(_QWORD *)&v229[56] = *(_QWORD *)&v211[16];
    v74 = 1LL;
  }
  else
  {
    v74 = 0LL;
    v73 = 0LL;
  }
  *(_QWORD *)v229 = v74;
  *(_QWORD *)&v229[32] = v74;
  *(_QWORD *)&v229[64] = v73;
  sub_42EC30((unsigned __int64 *)&v213, (__int64)v229, a3);
  for ( i = v213.m256i_i64[0]; v213.m256i_i64[0]; i = v213.m256i_i64[0] )
  {
    if ( *(_QWORD *)(i + 112 * v213.m256i_i64[2]) )
    {
      v77 = 112 * v213.m256i_i64[2] + i;
      if ( *(_QWORD *)(v77 + 8) )
      {
        v78 = *(void **)(v77 + 16);
        v79 = GetProcessHeap();
        HeapFree(v79, 0, v78);
      }
    }
    sub_42EC30((unsigned __int64 *)&v213, (__int64)v229, v75);
  }
LABEL_131:
  a1 = (unsigned __int64)v221;
LABEL_132:
  LOBYTE(v19) = v18 | v17;
LABEL_133:
  v18 >>= 8;
LABEL_134:
  if ( (_BYTE)v19 != 75 )
  {
    *(_BYTE *)(a1 + 8) = v19;
    *(_DWORD *)(a1 + 9) = v18;
    v93 = (_QWORD *)HIWORD(v18);
    *(_BYTE *)(a1 + 15) = BYTE6(v18);
    *(_WORD *)(a1 + 13) = WORD2(v18);
    *(_QWORD *)(a1 + 16) = v3;
    *(_QWORD *)a1 = 2LL;
    return (int)v93;
  }
LABEL_135:
  v80 = *(_QWORD *)(v236 + 16);
  v81 = *(_QWORD *)(v236 + 24);
  *(_QWORD *)&Src[4] = *(_QWORD *)(v236 + 64);
  v82 = *(_OWORD *)(v236 + 32);
  Src[3] = *(_OWORD *)(v236 + 48);
  Src[2] = v82;
  v83 = *((_BYTE *)v235 + 240);
  Src[0] = *(_OWORD *)v236;
  *(_QWORD *)&Src[1] = v80;
  *((_QWORD *)&Src[1] + 1) = v81;
  v84 = 8 * (unsigned int)((*(_QWORD *)(v236 + 72) & 0xFF00) == 2048);
  v85 = v84 + 8;
  v86 = v84 + 12;
  if ( (v83 & ((unsigned int)*(_QWORD *)(v236 + 72) >= 0x50000)) == 0 )
  {
    v85 = 0LL;
    v86 = 0LL;
  }
  *((_QWORD *)&Src[4] + 1) = *(_QWORD *)(v236 + 72);
  *((_QWORD *)&Src[21] + 1) = v3;
  *(_QWORD *)&Src[22] = 0LL;
  *(_QWORD *)&Src[23] = 0LL;
  *(_QWORD *)&Src[24] = 0LL;
  *((_QWORD *)&Src[24] + 1) = v85;
  *(_QWORD *)&Src[25] = 0LL;
  *((_QWORD *)&Src[25] + 1) = v86;
  *(_QWORD *)&Src[26] = v86;
  *(_QWORD *)&Src[6] = 47LL;
  *(_QWORD *)&Src[5] = (unsigned __int64)(v80 - 3) < 2;
  *((_QWORD *)&Src[5] + 1) = v81;
  *(_OWORD *)v229 = *(_OWORD *)((char *)&Src[2] + 8);
  *(_QWORD *)&v229[16] = Src;
  *(_QWORD *)&v229[24] = v3 + 16;
  *(_QWORD *)&v229[32] = 0LL;
  *(_QWORD *)&v229[88] = 0LL;
  sub_42AD40(v213.m256i_i64, (__int64)v229);
  v89 = v213.m256i_i8[0];
  if ( v213.m256i_i8[0] != 75 )
  {
LABEL_142:
    v92 = v213.m256i_i64[1];
    v88 = (unsigned __int64)*(unsigned int *)((char *)v213.m256i_u32 + 2) << 16;
    v87 = v88 | ((unsigned __int64)v213.m256i_u16[3] << 48);
    *(_QWORD *)(a1 + 8) = v87 | (v213.m256i_u8[1] << 8) | (unsigned __int64)v89;
    *(_QWORD *)(a1 + 16) = v92;
    goto LABEL_143;
  }
  v90 = &v229[32];
  v91 = (__m256i *)v229;
  while ( v213.m256i_i8[1] == 1 )
  {
    if ( *(_QWORD *)&v229[32] )
      goto LABEL_157;
    sub_42AD40(v213.m256i_i64, (__int64)v229);
    v89 = v213.m256i_i8[0];
    if ( v213.m256i_i8[0] != 75 )
      goto LABEL_142;
  }
  if ( !*(_QWORD *)&v229[32] )
  {
    *(_BYTE *)(a1 + 8) = 66;
    *(_QWORD *)(a1 + 16) = 0LL;
    goto LABEL_143;
  }
LABEL_157:
  if ( (**(_BYTE **)&v229[48] & 1) != 0 )
  {
    v102 = *(_QWORD *)(*(_QWORD *)&v229[48] + 24LL);
    v103 = *(_QWORD *)(*(_QWORD *)&v229[48] + 16LL);
  }
  else
  {
    v102 = *(_QWORD *)(*(_QWORD *)&v229[48] + 8LL);
    if ( v102 >= 6 )
      sub_405B00(*(_QWORD *)(*(_QWORD *)&v229[48] + 8LL), 5LL, (__int64)&off_446D68);
    v103 = *(_QWORD *)&v229[48] + 16LL;
  }
  *(_OWORD *)v213.m256i_i8 = *(_OWORD *)&v229[32];
  v213.m256i_i64[2] = v103;
  v213.m256i_i64[3] = v102;
  *(_QWORD *)&v214 = &v229[32];
  if ( v102 )
  {
    v221 = (char *)a1;
    v220 = *(_QWORD *)&Src[5];
    v104 = v102 - 1;
    v105 = v103 + 16;
    v223 = 46LL;
    v236 = 0LL;
    v91 = &v193;
    v237 = 46LL;
    v222 = 46LL;
    do
    {
      *(_OWORD *)v207 = *(_OWORD *)(v105 - 16);
      sub_41D2E0((__int64)&v193, (unsigned __int64 *)&v213, *(_DWORD *)(*(_QWORD *)(v214 + 24) + 72LL), (__int64)v207);
      if ( v193.m256i_i64[0] == 46 )
      {
        v185 = *(_OWORD *)&v193.m256i_u64[1];
        v93 = v221;
        *(_OWORD *)(v221 + 8) = *(_OWORD *)&v193.m256i_u64[1];
        *v93 = 2LL;
        LODWORD(v93) = DWORD2(Src[21]);
        if ( !_InterlockedDecrement64(*((volatile signed __int64 **)&Src[21] + 1)) )
          goto LABEL_144;
        goto LABEL_145;
      }
      v213.m256i_i64[2] = v105;
      v213.m256i_i64[3] = v104;
      v185 = *(_OWORD *)&v193.m256i_u64[1];
      if ( v193.m256i_u16[12] <= 0x71u )
      {
        switch ( v193.m256i_i16[12] )
        {
          case 3:
            sub_421680((__int64)v207, v193.m256i_i64);
            v223 = *(_QWORD *)v207;
            v184 = *(_OWORD *)&v207[8];
            break;
          case 0x10:
            sub_421680((__int64)v207, v193.m256i_i64);
            if ( *(_QWORD *)v207 == 16LL )
              v224 = *(_QWORD *)&v207[8];
            v106 = v236;
            if ( *(_DWORD *)v207 == 16 )
              v106 = 1LL;
            v236 = v106;
            break;
          case 0x11:
            sub_421680((__int64)v207, v193.m256i_i64);
            v201 = *(_QWORD *)&v207[8];
            v222 = *(_QWORD *)v207;
            break;
          case 0x1B:
            sub_421680((__int64)v207, v193.m256i_i64);
            v237 = *(_QWORD *)v207;
            v183 = *(_OWORD *)&v207[8];
            break;
          default:
            break;
        }
      }
      else if ( v193.m256i_u16[12] > 0x2130u )
      {
        switch ( v193.m256i_u16[12] )
        {
          case 0x2131u:
            if ( !v220 )
            {
              sub_421680((__int64)v207, v193.m256i_i64);
              if ( *(_DWORD *)v207 == 45 )
              {
                *(_QWORD *)&Src[5] = 1LL;
                *((_QWORD *)&Src[5] + 1) = *(_QWORD *)&v207[8];
                v220 = 1LL;
              }
              else
              {
                v220 = 0LL;
              }
            }
            break;
          case 0x2132u:
LABEL_182:
            sub_421680((__int64)v207, v193.m256i_i64);
            if ( *(_DWORD *)v207 == 23 )
              *(_QWORD *)&Src[26] = *(_QWORD *)&v207[8];
            break;
          case 0x2133u:
LABEL_180:
            sub_421680((__int64)v207, v193.m256i_i64);
            if ( *(_DWORD *)v207 == 11 )
              *(_QWORD *)&Src[25] = *(_QWORD *)&v207[8];
            break;
        }
      }
      else
      {
        switch ( v193.m256i_i16[12] )
        {
          case 0x72:
            sub_421680((__int64)v207, v193.m256i_i64);
            if ( *(_DWORD *)v207 == 28 )
              *((_QWORD *)&Src[24] + 1) = *(_QWORD *)&v207[8];
            break;
          case 0x73:
            goto LABEL_180;
          case 0x74:
            goto LABEL_182;
          case 0x8C:
            sub_421680((__int64)v207, v193.m256i_i64);
            if ( *(_DWORD *)v207 == 18 )
              *((_QWORD *)&Src[25] + 1) = *(_QWORD *)&v207[8];
            break;
          default:
            break;
        }
      }
      v105 += 16LL;
      v13 = v104-- != 0;
    }
    while ( v13 );
    v90 = (_QWORD *)v214;
    a1 = (unsigned __int64)v221;
    v107 = v222;
    v108 = v236;
    v109 = v223;
    v110 = v235;
    if ( (*(_BYTE *)(v214 + 40) & 1) == 0 )
      goto LABEL_193;
  }
  else
  {
    v107 = 46LL;
    v108 = 0LL;
    v237 = 46LL;
    v109 = 46LL;
    v110 = v235;
    if ( (v229[72] & 1) == 0 )
    {
LABEL_193:
      v111 = v213.m256i_i64[0] - *v90;
      v90[5] = 1LL;
      v90[6] = v111;
    }
  }
  v185 = *(_OWORD *)v210;
  if ( v109 != 46 )
  {
    v180 = v109;
    v181 = v184;
    sub_427DD0((__int64 *)v229, v110, BYTE9(Src[4]), *((__int64 *)&Src[24] + 1), &v180);
    v113 = v237;
    if ( v229[0] )
      v112 = 0LL;
    else
      v112 = *(_QWORD *)&v229[8];
    v91 = *(__m256i **)&v229[16];
    *(_QWORD *)&Src[22] = v112;
    *((_QWORD *)&Src[22] + 1) = *(_QWORD *)&v229[16];
    if ( v237 == 46 )
      goto LABEL_211;
LABEL_196:
    v178 = v113;
    v179 = v183;
    sub_427DD0((__int64 *)v229, v110, BYTE9(Src[4]), *((__int64 *)&Src[24] + 1), &v178);
    v113 = *(_QWORD *)&v229[16];
    if ( v229[0] )
      v114 = 0LL;
    else
      v114 = *(_QWORD *)&v229[8];
    v88 = v224;
    *(_QWORD *)&Src[23] = v114;
    *((_QWORD *)&Src[23] + 1) = *(_QWORD *)&v229[16];
    if ( v108 )
    {
      v108 = v110[8];
      v115 = v110[9];
      v13 = v115 < v224;
      v87 = v115 - v224;
      if ( !v13 )
        goto LABEL_213;
      goto LABEL_208;
    }
LABEL_217:
    v124 = 47LL;
    LODWORD(v236) = v113;
    v237 = v113;
    if ( LODWORD(Src[6]) == 47 )
      goto LABEL_226;
LABEL_218:
    v125 = a1;
    if ( *(_QWORD *)&Src[10] )
    {
      v126 = (void *)*((_QWORD *)&Src[10] + 1);
      v127 = GetProcessHeap();
      HeapFree(v127, 0, v126);
    }
    if ( *((_QWORD *)&Src[11] + 1) )
    {
      v128 = *(void **)&Src[12];
      v129 = GetProcessHeap();
      HeapFree(v129, 0, v128);
    }
    if ( *(_QWORD *)&Src[13] )
    {
      v130 = (void *)*((_QWORD *)&Src[13] + 1);
      v131 = GetProcessHeap();
      HeapFree(v131, 0, v130);
    }
    a1 = v125;
    v88 = v224;
    if ( *((_QWORD *)&Src[14] + 1) )
    {
      v132 = *(void **)&Src[15];
      v133 = GetProcessHeap();
      v134 = v132;
      a1 = v125;
      HeapFree(v133, 0, v134);
      v88 = v224;
    }
    goto LABEL_226;
  }
  v112 = 0LL;
  v113 = v237;
  *(_QWORD *)&Src[22] = 0LL;
  *((_QWORD *)&Src[22] + 1) = v91;
  if ( v237 != 46 )
    goto LABEL_196;
LABEL_211:
  *(_QWORD *)&Src[23] = 0LL;
  v88 = v224;
  if ( !v108 )
    goto LABEL_217;
  v114 = 0LL;
  v108 = v110[8];
  v117 = v110[9];
  v13 = v117 < v224;
  v87 = v117 - v224;
  if ( v13 )
  {
LABEL_208:
    v116 = 19LL;
    goto LABEL_249;
  }
LABEL_213:
  v108 += v88;
  if ( v87 < 4 )
  {
    v122 = a1;
    *(_DWORD *)v229 = 0;
    v229[6] = 0;
    *(_WORD *)&v229[4] = 0;
    v123 = 19LL;
LABEL_234:
    LODWORD(v112) = (unsigned int)v123 >> 8;
    LODWORD(v91) = WORD1(v123);
    a1 = HIDWORD(v123);
    goto LABEL_248;
  }
  v223 = v114;
  v220 = v113;
  v118 = BYTE8(Src[4]);
  v88 = v87 - 4;
  v119 = (unsigned __int16 *)(v108 + 4);
  v120 = *(unsigned int *)v108;
  if ( *(_DWORD *)v108 >> 4 != 0xFFFFFFF )
  {
    v140 = 4;
    v141 = *(unsigned int *)v108;
    if ( v88 >= v120 )
      goto LABEL_243;
    goto LABEL_236;
  }
  v121 = v107;
  v122 = a1;
  if ( (_DWORD)v120 != -1 )
  {
    v123 = 16LL;
    goto LABEL_234;
  }
  if ( v88 < 8 )
  {
    v123 = 19LL;
    v108 += 4LL;
    goto LABEL_234;
  }
  v87 -= 12LL;
  v119 = (unsigned __int16 *)(v108 + 12);
  *(_QWORD *)&v143 = ((unsigned __int64)(*(unsigned __int16 *)(v108 + 8) | (*(unsigned __int8 *)(v108 + 10) << 16)) << 40) | ((unsigned __int64)*(unsigned int *)(v108 + 4) << 8);
  *((_QWORD *)&v143 + 1) = *(unsigned __int8 *)(v108 + 11);
  v141 = v143 >> 8;
  v140 = 8;
  v88 = v87;
  v107 = v121;
  if ( v87 < v141 )
  {
LABEL_236:
    v122 = a1;
    goto LABEL_237;
  }
LABEL_243:
  v239 = v141;
  if ( v141 <= 1 )
  {
    v122 = a1;
    *(_WORD *)v229 = 0;
    *(_DWORD *)&v229[2] = 0;
    LOWORD(v91) = 0;
    LOBYTE(v123) = 19;
    a1 = 0LL;
    goto LABEL_247;
  }
  v88 = *v119;
  v87 = (unsigned int)*v119 - 6;
  if ( (unsigned __int16)(*v119 - 6) < 0xFFFCu )
  {
    v122 = a1;
    v108 = (unsigned __int16)v88;
    LOBYTE(v123) = 17;
    goto LABEL_248;
  }
  v87 = v141 - 2;
  v108 = (__int64)(v119 + 1);
  if ( (unsigned __int16)v88 <= 4u )
    goto LABEL_268;
  if ( v141 == 2 )
    goto LABEL_275;
  if ( v141 == 3 )
  {
    v122 = a1;
    v119 = (unsigned __int16 *)((char *)v119 + 3);
    goto LABEL_237;
  }
  v118 = *((_BYTE *)v119 + 2);
  v239 = v141 - 4;
  if ( *((_BYTE *)v119 + 3) )
  {
    v122 = a1;
    LOBYTE(v123) = 65;
    goto LABEL_248;
  }
  v87 = v141 - 4;
  v108 = (__int64)(v119 + 2);
LABEL_268:
  if ( (unsigned int)v120 >= 0xFFFFFFF0 )
  {
    if ( v87 > 7 )
    {
      v238 = (char *)(v108 + 8);
      v146 = v87 - 8;
      v147 = (unsigned __int8 *)(v108 + 8);
      v87 = (unsigned __int64)(*(unsigned __int16 *)(v108 + 4) | (*(unsigned __int8 *)(v108 + 6) << 16)) << 40;
      *(_QWORD *)&v149 = v87 | ((unsigned __int64)*(unsigned int *)v108 << 8);
      *((_QWORD *)&v149 + 1) = *(unsigned __int8 *)(v108 + 7);
      v148 = v149 >> 8;
      goto LABEL_273;
    }
LABEL_275:
    v122 = a1;
LABEL_276:
    LOBYTE(v123) = 19;
    a1 = 0LL;
    LOWORD(v91) = 0;
    LOBYTE(v112) = 0;
LABEL_248:
    v116 = (((a1 << 24) | ((unsigned __int16)v91 << 8) | (unsigned __int8)v112) << 8) | (unsigned __int8)v123;
    a1 = v122;
LABEL_249:
    *(_QWORD *)(a1 + 8) = v116;
    *(_QWORD *)(a1 + 16) = v108;
LABEL_143:
    *(_QWORD *)a1 = 2LL;
    LODWORD(v93) = DWORD2(Src[21]);
    if ( !_InterlockedDecrement64(*((volatile signed __int64 **)&Src[21] + 1)) )
LABEL_144:
      LODWORD(v93) = sub_41D140(*((LPVOID *)&Src[21] + 1), v87, v88);
LABEL_145:
    if ( LODWORD(Src[6]) != 47 )
    {
      if ( *(_QWORD *)&Src[10] )
      {
        v94 = (void *)*((_QWORD *)&Src[10] + 1);
        v95 = GetProcessHeap();
        LODWORD(v93) = HeapFree(v95, 0, v94);
      }
      if ( *((_QWORD *)&Src[11] + 1) )
      {
        v96 = *(void **)&Src[12];
        v97 = GetProcessHeap();
        LODWORD(v93) = HeapFree(v97, 0, v96);
      }
      if ( *(_QWORD *)&Src[13] )
      {
        v98 = (void *)*((_QWORD *)&Src[13] + 1);
        v99 = GetProcessHeap();
        LODWORD(v93) = HeapFree(v99, 0, v98);
      }
      if ( *((_QWORD *)&Src[14] + 1) )
      {
        v100 = *(void **)&Src[15];
        v101 = GetProcessHeap();
        LODWORD(v93) = HeapFree(v101, 0, v100);
      }
    }
    return (int)v93;
  }
  if ( v87 <= 3 )
    goto LABEL_275;
  v87 -= 4LL;
  v146 = v87;
  v147 = (unsigned __int8 *)(v108 + 4);
  v238 = (char *)(v108 + 4);
  v148 = *(unsigned int *)v108;
LABEL_273:
  v186 = v146 - v148;
  if ( v146 < v148 )
  {
    v122 = a1;
    LOBYTE(v123) = 19;
LABEL_292:
    v108 = (__int64)v147;
    goto LABEL_248;
  }
  v222 = v107;
  v122 = a1;
  if ( !v148 )
  {
    LOBYTE(v123) = 19;
    a1 = 0LL;
    LOWORD(v91) = 0;
    LOBYTE(v112) = 0;
    goto LABEL_292;
  }
  v150 = v147;
  v151 = v148 - 1;
  v239 = v148 - 1;
  v87 = *v150;
  if ( !(_BYTE)v87 )
  {
    LOBYTE(v123) = 26;
    goto LABEL_248;
  }
  v240 = *v150;
  v205 = v148;
  v187 = v141;
  HIBYTE(v247) = v140;
  LOBYTE(v247) = v118;
  v217 = v150;
  v119 = (unsigned __int16 *)(v150 + 1);
  v246 = 1;
  LODWORD(v236) = v88;
  if ( (unsigned __int16)v88 >= 4u )
  {
    if ( v148 != 1 )
    {
      v151 = v205 - 2;
      v239 = v205 - 2;
      v246 = v217[1];
      if ( !v246 )
      {
        LOBYTE(v123) = 27;
        goto LABEL_248;
      }
      v119 = (unsigned __int16 *)(v217 + 2);
      goto LABEL_283;
    }
LABEL_237:
    LOBYTE(v123) = 19;
    a1 = 0LL;
    LOWORD(v91) = 0;
LABEL_247:
    LOBYTE(v112) = 0;
    v108 = (__int64)v119;
    goto LABEL_248;
  }
LABEL_283:
  if ( !v151 )
    goto LABEL_237;
  v108 = (__int64)v119 + 1;
  v238 = (char *)v119 + 1;
  if ( v151 == 1 )
    goto LABEL_276;
  v87 = *(unsigned __int8 *)v119;
  v88 = v151 - 2;
  v239 = v151 - 2;
  if ( v151 == 2 )
  {
    ++v119;
    goto LABEL_237;
  }
  v241 = *((_BYTE *)v119 + 1);
  v108 = (__int64)v119 + 3;
  v238 = (char *)v119 + 3;
  v88 = *((unsigned __int8 *)v119 + 2);
  v242 = v88;
  if ( !(_BYTE)v88 )
  {
    LOBYTE(v123) = 28;
    goto LABEL_248;
  }
  v243 = (_BYTE)v87 != 0;
  if ( v151 == 3 )
    goto LABEL_276;
  v87 = v151 - 4;
  v239 = v151 - 4;
  v88 = *((unsigned __int8 *)v119 + 3);
  v237 = v88;
  if ( !(_BYTE)v88 )
  {
    LOBYTE(v123) = 29;
    goto LABEL_248;
  }
  v206 = v119 + 2;
  v88 = (unsigned int)(v237 - 1);
  v202 = (unsigned __int8)(v237 - 1);
  v13 = v87 < v202;
  v87 -= v202;
  if ( v13 )
  {
    LOBYTE(v123) = 19;
    a1 = 0LL;
    LOWORD(v91) = 0;
    LOBYTE(v112) = 0;
    v108 = (__int64)v206;
    goto LABEL_248;
  }
  v88 = (unsigned __int64)v206;
  v108 = (__int64)v206 + v202;
  v238 = (char *)v206 + v202;
  v239 = v87;
  v226[0] = 0LL;
  v226[1] = (LPVOID)8;
  v227 = 0LL;
  if ( (unsigned __int16)v236 > 4u )
  {
    sub_42F0D0((__int64)v229, (__int64)&v238);
    v230 = *(LPVOID *)&v229[8];
    v225 = *(_QWORD *)v229;
    v157 = (unsigned __int64 *)-*(_QWORD *)v229;
    v108 = *(_QWORD *)&v229[16];
    if ( __OFSUB__(-*(_QWORD *)v229, 1LL) )
    {
      LOBYTE(v123) = (_BYTE)v230;
      LODWORD(v112) = (unsigned int)v230 >> 8;
      LODWORD(v91) = (unsigned int)v230 >> 16;
      a1 = (unsigned __int64)v230 >> 32;
      LOBYTE(v157) = 1;
      v235 = v157;
    }
    else
    {
      sub_42F450((__int64)v229, (__int64 *)&v238);
      LOBYTE(v123) = v229[0];
      if ( v229[0] == 75 )
      {
        v234 = *(char **)&v229[8];
        if ( !*(_QWORD *)&v229[8] )
        {
          v231[0] = 0LL;
          v231[1] = (LPVOID)8;
          v232 = 0LL;
          v223 = 0LL;
          goto LABEL_331;
        }
        LODWORD(v228) = (unsigned __int8)v247 + (HIBYTE(v247) << 8) + 327680;
        v233 = 8LL;
        a1 = 16LL;
        v223 = 0LL;
        v158 = 0LL;
        while ( 1 )
        {
          sub_42F500((__int64)v229, (unsigned __int64 *)&v238, v228, (__int64)v230, v108);
          v123 = *(_QWORD *)&v229[8];
          v244 = *(char **)&v229[16];
          v245 = *(LPVOID *)v229;
          if ( *(_QWORD *)v229 == 46LL )
            break;
          if ( v158 == v226[0] )
          {
            sub_426260((unsigned __int64 *)v226, (__int64)&off_447EE0);
            v233 = (__int64)v226[1];
          }
          ++v158;
          v159 = v233;
          *(_QWORD *)(v233 + a1 - 16) = v245;
          *(_QWORD *)(v159 + a1 - 8) = v123;
          *(_QWORD *)(v159 + a1) = v244;
          v227 = v158;
          a1 += 24LL;
          if ( v234 == v158 )
            goto LABEL_328;
        }
        LODWORD(v112) = *(_DWORD *)&v229[8] >> 8;
        LODWORD(v91) = HIWORD(*(_DWORD *)&v229[8]);
        a1 = HIDWORD(*(_QWORD *)&v229[8]);
LABEL_335:
        v235 = 0LL;
LABEL_337:
        v108 = (__int64)v244;
      }
      else
      {
        LOBYTE(v112) = v229[1];
        LODWORD(v91) = *(_DWORD *)&v229[1] >> 8;
        a1 = (*(unsigned int *)&v229[1] | ((unsigned __int64)((v229[7] << 16) | (unsigned int)*(unsigned __int16 *)&v229[5]) << 32)) >> 24;
        v108 = *(_QWORD *)&v229[8];
        v235 = 0LL;
      }
    }
LABEL_338:
    if ( v226[0] )
    {
      v164 = v226[1];
      v165 = GetProcessHeap();
      HeapFree(v165, 0, v164);
    }
    if ( !((v225 == 0) | (unsigned __int8)v235) )
    {
      v166 = GetProcessHeap();
      HeapFree(v166, 0, v230);
    }
    goto LABEL_248;
  }
  if ( !v87 )
  {
LABEL_321:
    LODWORD(v112) = (unsigned int)a1 >> 8;
    LODWORD(v91) = WORD1(a1);
    a1 >>= 32;
    v230 = (LPVOID)2;
    LOBYTE(v123) = 19;
    v225 = 0LL;
    v235 = 0LL;
    goto LABEL_338;
  }
  v152 = (char *)v119 + v151;
  v153 = 8LL;
  v225 = 0LL;
  v154 = 0LL;
  while ( 1 )
  {
    a1 = v141;
    v141 = v108;
    v155 = 0LL;
    while ( *(_BYTE *)(v141 + v155) )
    {
      v88 = v141 + v155++ + 1;
      if ( (char *)v88 == v152 )
      {
        v108 = v141;
        goto LABEL_321;
      }
    }
    v87 += ~v155;
    v238 = (char *)(v141 + v155 + 1);
    v239 = v87;
    if ( !v155 )
      break;
    if ( v154 == v226[0] )
    {
      sub_426260((unsigned __int64 *)v226, (__int64)&off_447EF8);
      v153 = (__int64)v226[1];
    }
    v156 = 3LL * (_QWORD)v154;
    *(_QWORD *)(v153 + 8 * v156) = 31LL;
    *(_QWORD *)(v153 + 8 * v156 + 8) = v141;
    *(_QWORD *)(v153 + 8 * v156 + 16) = v155;
    v227 = ++v154;
    v108 = (__int64)v238;
    v87 = v239;
    v152 = &v238[v239];
    a1 = v141;
    if ( !v239 )
      goto LABEL_321;
  }
  v230 = (LPVOID)2;
  v108 = 0LL;
LABEL_328:
  v231[0] = 0LL;
  v231[1] = (LPVOID)8;
  v232 = 0LL;
  if ( (unsigned __int16)v236 < 5u )
  {
    if ( v112 )
    {
      v182 = 0LL;
      v124 = 31LL;
    }
    else
    {
      v124 = 46LL;
    }
    v244 = v238;
    v170 = v239;
    if ( v239 )
    {
      v171 = &v244[v239];
      v228 = 8LL;
      v233 = 0LL;
      v234 = 0LL;
      while ( 1 )
      {
        a1 = (unsigned __int64)v245;
        v245 = v244;
        v172 = 0LL;
        while ( 1 )
        {
          v87 = (unsigned __int64)v245 + v172 + 1;
          if ( !*((_BYTE *)v245 + v172) )
            break;
          ++v172;
          if ( (char *)v87 == v171 )
          {
            v244 = (char *)v245;
            goto LABEL_363;
          }
        }
        v238 = (char *)v245 + v172 + 1;
        v239 = ~v172 + v170;
        if ( !v172 )
        {
          v245 = (LPVOID)2;
          v244 = 0LL;
          goto LABEL_369;
        }
        sub_42F890((__int64)v229, (__int64 *)&v238, (__int64)v245, v172);
        v123 = *(_QWORD *)&v229[8];
        v173 = *(_QWORD *)v229;
        v244 = *(char **)&v229[16];
        if ( *(_QWORD *)v229 == 46LL )
          break;
        *(_QWORD *)&v194 = *(_QWORD *)&v229[56];
        v193 = *(__m256i *)&v229[24];
        if ( v234 == v231[0] )
        {
          sub_415470((__int64 *)v231, (__int64)&off_447F28);
          v228 = (__int64)v231[1];
        }
        v174 = v234;
        v175 = (_QWORD)v234 << 6;
        v88 = v228;
        *(_QWORD *)(v228 + v175) = v173;
        *(_QWORD *)(v88 + v175 + 8) = v123;
        *(_QWORD *)(v88 + v175 + 16) = v244;
        v176 = *(_OWORD *)&v193.m256i_u64[2];
        *(_OWORD *)(v88 + v175 + 24) = *(_OWORD *)v193.m256i_i8;
        *(_OWORD *)(v88 + v175 + 40) = v176;
        *(_QWORD *)(v88 + v175 + 56) = v194;
        v234 = v174 + 1;
        v232 = (__int64)(v174 + 1);
        v87 = (unsigned __int64)v238;
        v170 = v239;
        v244 = v238;
        v171 = &v238[v239];
        a1 = (unsigned __int64)v245;
        if ( !v239 )
          goto LABEL_363;
      }
      LODWORD(v112) = *(_DWORD *)&v229[8] >> 8;
      LODWORD(v91) = HIWORD(*(_DWORD *)&v229[8]);
      a1 = HIDWORD(*(_QWORD *)&v229[8]);
      v245 = (LPVOID)2;
      v233 = 0LL;
      v160 = 0;
      if ( !v231[0] )
        goto LABEL_334;
    }
    else
    {
LABEL_363:
      LODWORD(v112) = (unsigned int)a1 >> 8;
      LODWORD(v91) = WORD1(a1);
      a1 >>= 32;
      v245 = (LPVOID)2;
      LOBYTE(v123) = 19;
      v233 = 0LL;
      v160 = 0;
      if ( !v231[0] )
        goto LABEL_334;
    }
LABEL_333:
    v161 = v231[1];
    v162 = GetProcessHeap();
    HeapFree(v162, 0, v161);
    goto LABEL_334;
  }
LABEL_331:
  sub_42F0D0((__int64)v229, (__int64)&v238);
  v245 = *(LPVOID *)&v229[8];
  v233 = *(_QWORD *)v229;
  v244 = *(char **)&v229[16];
  if ( __OFSUB__(-*(_QWORD *)v229, 1LL) )
  {
    LOBYTE(v123) = (_BYTE)v245;
    LODWORD(v112) = (unsigned int)v245 >> 8;
    LODWORD(v91) = (unsigned int)v245 >> 16;
    a1 = (unsigned __int64)v245 >> 32;
    v160 = 1;
    if ( !v231[0] )
      goto LABEL_334;
    goto LABEL_333;
  }
  sub_42F450((__int64)v229, (__int64 *)&v238);
  LOBYTE(v123) = v229[0];
  if ( v229[0] != 75 )
  {
    LOBYTE(v112) = v229[1];
    LODWORD(v91) = *(_DWORD *)&v229[1] >> 8;
    a1 = (*(unsigned int *)&v229[1] | ((unsigned __int64)((v229[7] << 16) | (unsigned int)*(unsigned __int16 *)&v229[5]) << 32)) >> 24;
    v244 = *(char **)&v229[8];
    v160 = 0;
    if ( !v231[0] )
      goto LABEL_334;
    goto LABEL_333;
  }
  v124 = 46LL;
  v189 = *(char **)&v229[8];
  if ( *(_QWORD *)&v229[8] )
  {
    v204 = (unsigned __int8)v247 + (HIBYTE(v247) << 8) + 327680;
    v203 = 8LL;
    v167 = 24LL;
    v234 = 0LL;
    while ( 1 )
    {
      sub_42F5F0((__int64)v229, (unsigned __int64 *)&v238, v204, (__int64)v245, (__int64)v244);
      v123 = *(_QWORD *)&v229[8];
      v228 = *(_QWORD *)&v229[16];
      v188 = *(_QWORD *)v229;
      if ( *(_QWORD *)v229 == 46LL )
        break;
      *(_QWORD *)&v214 = *(_QWORD *)&v229[56];
      v213 = *(__m256i *)&v229[24];
      if ( v234 == v231[0] )
      {
        sub_415470((__int64 *)v231, (__int64)&off_447F10);
        v203 = (__int64)v231[1];
      }
      v168 = v234 + 1;
      v87 = v203;
      *(_QWORD *)(v203 + v167 - 24) = v188;
      *(_QWORD *)(v87 + v167 - 16) = v123;
      *(_QWORD *)(v87 + v167 - 8) = v228;
      v169 = *(_OWORD *)&v213.m256i_u64[2];
      *(_OWORD *)(v87 + v167) = *(_OWORD *)v213.m256i_i8;
      *(_OWORD *)(v87 + v167 + 16) = v169;
      *(_QWORD *)(v87 + v167 + 32) = v214;
      v232 = (__int64)v168;
      v167 += 64LL;
      v234 = v168;
      if ( v189 == v168 )
        goto LABEL_369;
    }
    LODWORD(v112) = *(_DWORD *)&v229[8] >> 8;
    LODWORD(v91) = HIWORD(*(_DWORD *)&v229[8]);
    a1 = HIDWORD(*(_QWORD *)&v229[8]);
    v160 = 0;
    v244 = (char *)v228;
    if ( v231[0] )
      goto LABEL_333;
LABEL_334:
    if ( (unsigned __int8)v160 | (v233 == 0) )
      goto LABEL_335;
    v163 = GetProcessHeap();
    v235 = 0LL;
    HeapFree(v163, 0, v245);
    goto LABEL_337;
  }
LABEL_369:
  v217 += v205;
  v191 = v227;
  v190 = *(_OWORD *)v226;
  v199 = *(_OWORD *)v231;
  v200 = v232;
  *(_OWORD *)&v207[24] = v182;
  memset(v207, 0, 24);
  *(_QWORD *)v211 = 0LL;
  *(_OWORD *)&v211[8] = v182;
  *(_OWORD *)v210 = 0LL;
  v219 = v198;
  v218 = v197;
  a1 = v122;
  v107 = v222;
  v88 = v224;
  if ( LODWORD(Src[6]) != 47 )
    goto LABEL_218;
LABEL_226:
  *(_QWORD *)&Src[6] = v124;
  *((_QWORD *)&Src[6] + 1) = v112;
  *(_QWORD *)&Src[7] = v91;
  *((_QWORD *)&Src[9] + 1) = *(_QWORD *)&v211[16];
  *(_OWORD *)((char *)&Src[8] + 8) = *(_OWORD *)v211;
  *(_OWORD *)((char *)&Src[7] + 8) = *(_OWORD *)v210;
  *(_QWORD *)&Src[10] = v225;
  *((_QWORD *)&Src[10] + 1) = v230;
  *(_QWORD *)&Src[11] = v108;
  *((_QWORD *)&Src[12] + 1) = v191;
  *(_OWORD *)((char *)&Src[11] + 8) = v190;
  *(_QWORD *)&Src[13] = v233;
  *((_QWORD *)&Src[13] + 1) = v245;
  *(_QWORD *)&Src[14] = v244;
  *((_QWORD *)&Src[15] + 1) = v200;
  *(_OWORD *)((char *)&Src[14] + 8) = v199;
  *(_QWORD *)&Src[16] = v206;
  *((_QWORD *)&Src[16] + 1) = v202;
  *(_QWORD *)&Src[17] = v217;
  *((_QWORD *)&Src[17] + 1) = v186;
  *(_QWORD *)&Src[18] = v88;
  *((_QWORD *)&Src[18] + 1) = v187;
  *(_QWORD *)&Src[19] = v205;
  *((_QWORD *)&Src[19] + 1) = v223;
  *(_QWORD *)&Src[20] = v220;
  WORD4(Src[20]) = v247;
  WORD5(Src[20]) = v236;
  BYTE12(Src[20]) = v243;
  BYTE13(Src[20]) = v240;
  BYTE14(Src[20]) = v246;
  HIBYTE(Src[20]) = v241;
  LOBYTE(Src[21]) = v242;
  BYTE1(Src[21]) = v237;
  WORD3(Src[21]) = v219;
  *(_DWORD *)((char *)&Src[21] + 2) = v218;
  if ( v107 != 46 )
  {
    if ( v107 )
    {
      if ( v107 == 12 )
      {
        v135 = (unsigned __int8 *)v235[2];
        v136 = v235[3];
        v13 = v136 < *(_QWORD *)&Src[25];
        v88 = v136 - *(_QWORD *)&Src[25];
        if ( v13
          || (LOBYTE(v87) = BYTE8(Src[4]),
              v135 += *(_QWORD *)&Src[25],
              v137 = BYTE8(Src[4]) * v201,
              v138 = v88 - v137,
              v88 < v137) )
        {
          v139 = 19LL;
        }
        else
        {
          v144 = BYTE8(Src[4]) * v201;
          v139 = 23LL;
          v135 += v144;
          switch ( BYTE8(Src[4]) )
          {
            case 1:
              if ( v88 == v144 )
                goto LABEL_264;
              v142 = *v135;
              goto LABEL_239;
            case 2:
              if ( v138 <= 1 )
                goto LABEL_264;
              v142 = *(unsigned __int16 *)v135;
              goto LABEL_239;
            case 4:
              if ( v138 <= 3 )
                goto LABEL_264;
              v142 = *(unsigned int *)v135;
              goto LABEL_239;
            case 8:
              if ( v138 > 7 )
              {
                *(_QWORD *)&v145 = ((unsigned __int64)(*((unsigned __int16 *)v135 + 2) | (v135[6] << 16)) << 40) | ((unsigned __int64)*(unsigned int *)v135 << 8);
                *((_QWORD *)&v145 + 1) = v135[7];
                v142 = v145 >> 8;
                goto LABEL_239;
              }
LABEL_264:
              v139 = 19LL;
              LOBYTE(v87) = 0;
              break;
            default:
              break;
          }
        }
        v87 = v139 | ((unsigned __int8)v87 << 8);
        *(_QWORD *)(a1 + 8) = v87;
        *(_QWORD *)(a1 + 16) = v135;
        goto LABEL_143;
      }
    }
    else
    {
      v142 = v201;
LABEL_239:
      *(_QWORD *)&Src[24] = v142;
    }
  }
  LODWORD(v93) = (unsigned int)memcpy((void *)a1, Src, 0x1A8uLL);
  return (int)v93;
}
// 41B377: variable 'a3' is possibly undefined
// 41B3A6: variable 'v75' is possibly undefined
// 41B4A3: variable 'v3' is possibly undefined
// 41B609: variable 'v87' is possibly undefined
// 41B609: variable 'v88' is possibly undefined
// 4050B0: using guessed type void __fastcall __noreturn sub_4050B0(_QWORD, _QWORD, _QWORD);
// 446D20: using guessed type char *off_446D20;
// 446D38: using guessed type char *off_446D38;
// 446D50: using guessed type char *off_446D50;
// 446D68: using guessed type char *off_446D68;
// 447EE0: using guessed type char *off_447EE0;
// 447EF8: using guessed type char *off_447EF8;
// 447F10: using guessed type char *off_447F10;
// 447F28: using guessed type char *off_447F28;

//----- (000000000041D140) ----------------------------------------------------
int __fastcall sub_41D140(LPVOID lpMem, __int64 a2, unsigned __int64 a3)
{
  void **v4; // rdi
  __int64 v5; // r14
  void **v6; // r15
  void *v7; // rbx
  HANDLE ProcessHeap; // rax
  HANDLE v9; // rax
  int result; // eax
  HANDLE v11; // rax

  v4 = (void **)*((_QWORD *)lpMem + 3);
  v5 = *((_QWORD *)lpMem + 4);
  if ( v5 )
  {
    v6 = v4 + 2;
    do
    {
      if ( *(v6 - 2) && *(v6 - 1) )
      {
        v7 = *v6;
        ProcessHeap = GetProcessHeap();
        HeapFree(ProcessHeap, 0, v7);
      }
      v6 += 14;
      --v5;
    }
    while ( v5 );
  }
  if ( *((_QWORD *)lpMem + 2) )
  {
    v9 = GetProcessHeap();
    HeapFree(v9, 0, v4);
  }
  result = sub_42EB60((__int64 *)lpMem + 5, a2, a3);
  if ( lpMem != (LPVOID)-1LL && !_InterlockedDecrement64((volatile signed __int64 *)lpMem + 1) )
  {
    v11 = GetProcessHeap();
    return HeapFree(v11, 0, lpMem);
  }
  return result;
}
// 41D1BB: variable 'a2' is possibly undefined
// 41D1BB: variable 'a3' is possibly undefined

//----- (000000000041D230) ----------------------------------------------------
void __fastcall sub_41D230(__int64 a1)
{
  void *v2; // rdi
  HANDLE ProcessHeap; // rax
  void *v4; // rdi
  HANDLE v5; // rax
  void *v6; // rdi
  HANDLE v7; // rax
  void *v8; // rsi
  HANDLE v9; // rax

  if ( *(_DWORD *)a1 != 47 )
  {
    if ( *(_QWORD *)(a1 + 64) )
    {
      v2 = *(void **)(a1 + 72);
      ProcessHeap = GetProcessHeap();
      HeapFree(ProcessHeap, 0, v2);
    }
    if ( *(_QWORD *)(a1 + 88) )
    {
      v4 = *(void **)(a1 + 96);
      v5 = GetProcessHeap();
      HeapFree(v5, 0, v4);
    }
    if ( *(_QWORD *)(a1 + 112) )
    {
      v6 = *(void **)(a1 + 120);
      v7 = GetProcessHeap();
      HeapFree(v7, 0, v6);
    }
    if ( *(_QWORD *)(a1 + 136) )
    {
      v8 = *(void **)(a1 + 144);
      v9 = GetProcessHeap();
      HeapFree(v9, 0, v8);
    }
  }
}

//----- (000000000041D2E0) ----------------------------------------------------
char __fastcall sub_41D2E0(__int64 a1, unsigned __int64 *a2, unsigned int a3, __int64 a4)
{
  unsigned __int64 v5; // rax
  unsigned int v6; // ebx
  unsigned __int64 v7; // r15
  unsigned __int64 v8; // r13
  unsigned int v9; // r12d
  unsigned __int64 v10; // rdi
  char *v11; // rdx
  unsigned __int64 v12; // r11
  unsigned __int64 *v13; // r9
  unsigned __int64 *v14; // r9
  __int64 v15; // r9
  unsigned __int64 v16; // r11
  unsigned __int64 *v17; // r10
  __int64 v18; // r14
  unsigned __int64 v19; // r8
  unsigned __int64 v20; // r11
  unsigned __int64 v21; // rdx
  int v22; // ecx
  char v23; // bl
  bool v24; // cf
  unsigned __int64 *v25; // rcx
  __int128 v26; // rt0
  int v27; // ecx
  char v28; // bl
  unsigned __int64 *v29; // rcx
  __int128 v30; // rt0
  unsigned __int64 *v31; // rcx
  __int64 v32; // rbx
  unsigned __int64 *v33; // rcx
  unsigned __int64 v34; // r9
  unsigned __int64 v35; // r8
  __int64 v36; // r11
  __int128 v37; // rt0
  int v38; // ecx
  char v39; // bl
  unsigned __int64 *v40; // rcx
  __int128 v41; // rt0
  __int128 v42; // rt0
  __int128 v43; // rt0
  unsigned __int64 v44; // r11
  int v45; // ecx
  __int64 v46; // rax
  unsigned __int64 *v47; // rsi
  unsigned __int64 v48; // r11
  unsigned __int64 *v49; // r8
  unsigned __int64 v50; // r11
  unsigned __int64 v51; // rdx
  int v52; // ecx
  char v53; // bl
  unsigned __int64 *v54; // rcx
  __int64 v55; // rsi
  unsigned __int64 v56; // r11
  unsigned __int64 v57; // rdx
  int v58; // ecx
  char v59; // r8
  unsigned __int64 v60; // r11
  int v61; // ecx
  char v62; // r8
  unsigned __int64 *v63; // rcx
  __int64 v64; // rcx
  unsigned __int64 *v65; // rcx
  __int128 v66; // rt0
  unsigned __int64 *v67; // rcx
  __int128 v68; // rt0
  unsigned __int64 *v69; // rcx
  __int128 v70; // rt0
  __int64 v71; // rsi
  int v72; // ecx
  char v73; // bl
  unsigned __int64 *v74; // rax
  __int16 v75; // dx
  int v76; // ecx
  char v77; // bl
  unsigned __int64 *v78; // rax
  unsigned __int64 *v79; // rcx
  unsigned __int64 *v80; // rcx
  unsigned __int64 *v81; // rcx
  unsigned __int64 *v82; // rcx
  int v83; // ecx
  unsigned __int64 v84; // rcx
  __int64 v85; // rdx
  unsigned __int64 v86; // r11
  unsigned __int64 v87; // r11
  unsigned __int64 *v88; // rcx
  unsigned __int64 *v89; // rcx
  unsigned __int64 *v90; // rcx
  __int128 v91; // rt0
  int v92; // ecx
  __int128 v93; // rt0
  __int64 v95; // [rsp+28h] [rbp-18h] BYREF
  unsigned __int64 v96; // [rsp+30h] [rbp-10h]
  __int64 v97; // [rsp+38h] [rbp-8h]
  unsigned __int64 *v98; // [rsp+40h] [rbp+0h]

  LODWORD(v5) = a3 >> 8;
  v97 = a4;
  v6 = *(unsigned __int16 *)(a4 + 10);
  v7 = *a2;
  v98 = a2;
  v8 = a2[1];
  v9 = v6;
  while ( 2 )
  {
    v10 = v9;
    v11 = (char *)v7;
    v12 = v8;
    switch ( (__int16)v9 )
    {
      case 1:
        switch ( (char)a3 )
        {
          case 1:
            if ( !v8 )
              goto LABEL_222;
            v54 = v98;
            *v98 = v7 + 1;
            v54[1] = v8 - 1;
            v5 = *(unsigned __int8 *)v7;
            goto LABEL_221;
          case 2:
            if ( v8 <= 1 )
              goto LABEL_222;
            v89 = v98;
            *v98 = v7 + 2;
            v89[1] = v8 - 2;
            v5 = *(unsigned __int16 *)v7;
            goto LABEL_221;
          case 4:
            if ( v8 <= 3 )
              goto LABEL_222;
            v88 = v98;
            *v98 = v7 + 4;
            v88[1] = v8 - 4;
            v5 = *(unsigned int *)v7;
            goto LABEL_221;
          case 8:
            if ( v8 > 7 )
            {
              v90 = v98;
              *v98 = v7 + 8;
              v90[1] = v8 - 8;
              *(_QWORD *)&v91 = ((unsigned __int64)(*(unsigned __int16 *)(v7 + 4) | (*(unsigned __int8 *)(v7 + 6) << 16)) << 40) | ((unsigned __int64)*(unsigned int *)v7 << 8);
              *((_QWORD *)&v91 + 1) = *(unsigned __int8 *)(v7 + 7);
              v5 = v91 >> 8;
LABEL_221:
              v32 = v97;
              LODWORD(v33) = (unsigned int)v5 >> 8;
              v34 = v5 >> 16;
              v35 = v5 & 0xFFFFFFFF00000000uLL;
              v36 = 0LL;
              goto LABEL_158;
            }
LABEL_222:
            LOBYTE(v5) = 19;
            v92 = 0;
LABEL_224:
            *(_BYTE *)(a1 + 8) = v5;
            *(_DWORD *)(a1 + 9) = v92;
            break;
          default:
            v92 = (unsigned __int8)a3;
            LOBYTE(v5) = 23;
            goto LABEL_224;
        }
        goto LABEL_225;
      case 2:
LABEL_171:
        *(_BYTE *)(a1 + 8) = 12;
        goto LABEL_239;
      case 3:
        if ( v8 < 2 )
          goto LABEL_110;
        v48 = v8 - 2;
        v5 = v7 + 2;
        v49 = v98;
        *v98 = v7 + 2;
        v49[1] = v8 - 2;
        v10 = *(unsigned __int16 *)v7;
        goto LABEL_108;
      case 4:
        if ( v8 < 4 )
          goto LABEL_110;
        v48 = v8 - 4;
        v5 = v7 + 4;
        v49 = v98;
        *v98 = v7 + 4;
        v49[1] = v8 - 4;
        v10 = *(unsigned int *)v7;
        goto LABEL_108;
      case 5:
        if ( v8 > 1 )
        {
          v33 = v98;
          *v98 = v7 + 2;
          v33[1] = v8 - 2;
          LOWORD(v5) = *(_WORD *)v7;
          LODWORD(v33) = HIBYTE(*(unsigned __int16 *)v7);
          v36 = 3LL;
          goto LABEL_155;
        }
        LOWORD(v95) = 0;
        *(_DWORD *)((char *)&v95 + 2) = 0;
        LOBYTE(v5) = 0;
        *(_WORD *)(a1 + 8) = 19;
        *(_WORD *)(a1 + 10) = 0;
        goto LABEL_228;
      case 6:
        v32 = v97;
        if ( (a3 & 0xFF00) == 0x400 )
        {
          LOWORD(v5) = *(_WORD *)(v97 + 8) - 2;
          switch ( *(_WORD *)(v97 + 8) )
          {
            case 2:
            case 0x10:
            case 0x19:
            case 0x2A:
            case 0x2C:
            case 0x40:
            case 0x43:
            case 0x46:
            case 0x48:
            case 0x4A:
            case 0x4D:
            case 0x55:
            case 0x79:
              break;
            case 0x38:
              if ( (HIWORD(a3) & 0xFFFE) != 2 )
                goto LABEL_231;
              break;
            default:
              goto LABEL_231;
          }
          if ( v8 >= 4 )
          {
            v33 = v98;
            *v98 = v7 + 4;
            v33[1] = v8 - 4;
            LODWORD(v5) = *(_DWORD *)v7;
            LODWORD(v33) = *(_DWORD *)v7 >> 8;
            LODWORD(v34) = HIWORD(*(_DWORD *)v7);
            v36 = 10LL;
            v35 = 0LL;
            goto LABEL_158;
          }
          *(_BYTE *)(a1 + 8) = 19;
          *(_DWORD *)(a1 + 9) = 0;
LABEL_225:
          *(_BYTE *)(a1 + 15) = 0;
          *(_WORD *)(a1 + 13) = 0;
        }
        else
        {
LABEL_231:
          if ( v8 > 3 )
          {
            v33 = v98;
            *v98 = v7 + 4;
            v33[1] = v8 - 4;
            LODWORD(v5) = *(_DWORD *)v7;
            LODWORD(v33) = *(_DWORD *)v7 >> 8;
            LODWORD(v34) = HIWORD(*(_DWORD *)v7);
            v36 = 4LL;
            v35 = 0LL;
            goto LABEL_158;
          }
          LODWORD(v95) = 0;
          BYTE6(v95) = 0;
          WORD2(v95) = 0;
          *(_BYTE *)(a1 + 11) = 0;
          *(_WORD *)(a1 + 9) = 0;
          LODWORD(v5) = *(_DWORD *)((char *)&v95 + 3);
          *(_BYTE *)(a1 + 8) = 19;
          *(_DWORD *)(a1 + 12) = v5;
        }
        goto LABEL_238;
      case 7:
        v32 = v97;
        if ( (a3 & 0xFF00) == 0x800 )
        {
          LOWORD(v5) = *(_WORD *)(v97 + 8) - 2;
          switch ( *(_WORD *)(v97 + 8) )
          {
            case 2:
            case 0x10:
            case 0x19:
            case 0x2A:
            case 0x2C:
            case 0x40:
            case 0x43:
            case 0x46:
            case 0x48:
            case 0x4A:
            case 0x4D:
            case 0x55:
            case 0x79:
              break;
            case 0x38:
              if ( (HIWORD(a3) & 0xFFFE) != 2 )
                goto LABEL_235;
              break;
            default:
              goto LABEL_235;
          }
          if ( v8 >= 8 )
          {
            v65 = v98;
            *v98 = v7 + 8;
            v65[1] = v8 - 8;
            *(_QWORD *)&v66 = ((unsigned __int64)(*(unsigned __int16 *)(v7 + 4) | (*(unsigned __int8 *)(v7 + 6) << 16)) << 40) | ((unsigned __int64)*(unsigned int *)v7 << 8);
            *((_QWORD *)&v66 + 1) = *(unsigned __int8 *)(v7 + 7);
            v5 = v66 >> 8;
            goto LABEL_180;
          }
          goto LABEL_237;
        }
LABEL_235:
        if ( v8 <= 7 )
          goto LABEL_237;
        v33 = v98;
        *v98 = v7 + 8;
        v33[1] = v8 - 8;
        *(_QWORD *)&v93 = ((unsigned __int64)(*(unsigned __int16 *)(v7 + 4) | (*(unsigned __int8 *)(v7 + 6) << 16)) << 40) | ((unsigned __int64)*(unsigned int *)v7 << 8);
        *((_QWORD *)&v93 + 1) = *(unsigned __int8 *)(v7 + 7);
        v5 = v93 >> 8;
        LODWORD(v33) = (unsigned int)((__int64)v93 >> 8) >> 8;
        v34 = v5 >> 16;
        v35 = v5 & 0xFFFFFFFF00000000uLL;
        v36 = 5LL;
        goto LABEL_158;
      case 8:
        v33 = v98;
        if ( !v8 )
          goto LABEL_110;
        v10 = 0LL;
        while ( *(_BYTE *)(v7 + v10) )
        {
          if ( v8 == ++v10 )
          {
LABEL_110:
            *(_QWORD *)(a1 + 8) = 19LL;
            goto LABEL_238;
          }
        }
        *v98 = v7 + v10 + 1;
        v33[1] = ~v10 + v8;
        LODWORD(v33) = (unsigned int)v7 >> 8;
        v34 = v7 >> 16;
        v35 = v7 & 0xFFFFFFFF00000000uLL;
        v36 = 31LL;
        LOBYTE(v5) = v7;
        goto LABEL_157;
      case 9:
        if ( !v8 )
          goto LABEL_173;
        v55 = a1;
        v5 = v7 + v8;
        v56 = v8 - 1;
        v57 = v7 + 1;
        v10 = 0LL;
        v58 = 0;
        v32 = v97;
        while ( 2 )
        {
          v59 = *(_BYTE *)(v57 - 1);
          if ( v58 == 63 && (unsigned __int8)v59 >= 2u )
          {
LABEL_199:
            v5 = (unsigned __int64)v98;
            *v98 = v57;
            *(_QWORD *)(v5 + 8) = v56;
            v64 = 6LL;
            a1 = v55;
          }
          else
          {
            v10 |= (unsigned __int64)(v59 & 0x7F) << v58;
            if ( v59 < 0 )
            {
              v58 += 7;
              ++v57;
              v24 = v56-- != 0;
              if ( !v24 )
              {
LABEL_117:
                v63 = v98;
                *v98 = v5;
                v63[1] = 0LL;
                a1 = v55;
                v64 = 19LL;
                break;
              }
              continue;
            }
            v33 = v98;
            *v98 = v57;
            v33[1] = v56;
            v24 = v56 < v10;
            v86 = v56 - v10;
            if ( !v24 )
            {
              *v33 = v57 + v10;
              v33[1] = v86;
              LODWORD(v33) = (unsigned int)v57 >> 8;
              v34 = v57 >> 16;
              v35 = v57 & 0xFFFFFFFF00000000uLL;
              v36 = 1LL;
              LOBYTE(v5) = v57;
              goto LABEL_158;
            }
LABEL_211:
            v64 = 19LL;
            v5 = v57;
          }
          break;
        }
LABEL_212:
        *(_QWORD *)(a1 + 8) = v64;
        *(_QWORD *)(a1 + 16) = v5;
        goto LABEL_239;
      case 10:
        if ( !v8 )
          goto LABEL_110;
        v48 = v8 - 1;
        v5 = v7 + 1;
        v49 = v98;
        *v98 = v7 + 1;
        v49[1] = v8 - 1;
        v10 = *(unsigned __int8 *)v7;
LABEL_108:
        v24 = v48 < v10;
        v60 = v48 - v10;
        if ( v24 )
        {
          v11 = (char *)v5;
          goto LABEL_110;
        }
        *v49 = v5 + v10;
        v49[1] = v60;
        LODWORD(v33) = (unsigned int)v5 >> 8;
        v34 = v5 >> 16;
        v35 = v5 & 0xFFFFFFFF00000000uLL;
        v36 = 1LL;
        goto LABEL_157;
      case 11:
        if ( !v8 )
          goto LABEL_133;
        v33 = v98;
        *v98 = v7 + 1;
        v33[1] = v8 - 1;
        LOBYTE(v5) = *(_BYTE *)v7;
        v36 = 2LL;
        LOWORD(v33) = 0;
        goto LABEL_155;
      case 12:
        if ( !v8 )
          goto LABEL_133;
        v33 = v98;
        *v98 = v7 + 1;
        v33[1] = v8 - 1;
        LOBYTE(v5) = *(_BYTE *)v7 != 0;
        v36 = 9LL;
        LOWORD(v33) = 0;
        goto LABEL_155;
      case 13:
        v44 = v8 - 1;
        v45 = 0;
        v46 = 0LL;
        v47 = v98;
        while ( 1 )
        {
          v19 = (unsigned __int64)v11;
          if ( v44 == -1LL )
            goto LABEL_168;
          ++v11;
          *v47 = v19 + 1;
          v47[1] = v44;
          v19 = *(unsigned __int8 *)v19;
          if ( v45 == 63 && (_DWORD)v19 != 127 && (_DWORD)v19 )
          {
            LOBYTE(v5) = 7;
            goto LABEL_201;
          }
          v46 |= (v19 & 0x7F) << v45;
          v45 += 7;
          --v44;
          if ( (v19 & 0x80u) == 0LL )
          {
            v85 = -1LL << v45;
            if ( (unsigned __int8)v19 < 0x40u )
              v85 = 0LL;
            if ( v45 >= 64 )
              v85 = 0LL;
            v5 = v85 | v46;
            LODWORD(v33) = (unsigned int)v5 >> 8;
            v34 = v5 >> 16;
            v35 = v5 & 0xFFFFFFFF00000000uLL;
            v36 = 6LL;
            goto LABEL_157;
          }
        }
      case 14:
        if ( BYTE1(a3) == 8 )
        {
          v67 = v98;
          if ( v8 <= 7 )
            goto LABEL_237;
          *v98 = v7 + 8;
          v67[1] = v8 - 8;
          *(_QWORD *)&v68 = ((unsigned __int64)(*(unsigned __int16 *)(v7 + 4) | (*(unsigned __int8 *)(v7 + 6) << 16)) << 40) | ((unsigned __int64)*(unsigned int *)v7 << 8);
          *((_QWORD *)&v68 + 1) = *(unsigned __int8 *)(v7 + 7);
          v5 = v68 >> 8;
        }
        else
        {
          v81 = v98;
          if ( v8 <= 3 )
            goto LABEL_237;
          *v98 = v7 + 4;
          v81[1] = v8 - 4;
          v5 = *(unsigned int *)v7;
        }
        v32 = v97;
        LODWORD(v33) = (unsigned int)v5 >> 8;
        v34 = v5 >> 16;
        v35 = v5 & 0xFFFFFFFF00000000uLL;
        v36 = 26LL;
        goto LABEL_158;
      case 15:
        if ( !v8 )
          goto LABEL_167;
        v19 = v7 + v8;
        v50 = v8 - 1;
        v51 = v7 + 1;
        v5 = 0LL;
        v72 = 0;
        while ( 2 )
        {
          v73 = *(_BYTE *)(v51 - 1);
          if ( v72 == 63 && (unsigned __int8)v73 >= 2u )
            goto LABEL_200;
          v5 |= (unsigned __int64)(v73 & 0x7F) << v72;
          if ( v73 < 0 )
          {
            v72 += 7;
            ++v51;
            v24 = v50-- != 0;
            if ( !v24 )
              goto LABEL_145;
            continue;
          }
          break;
        }
        v33 = v98;
        *v98 = v51;
        v33[1] = v50;
        LODWORD(v33) = (unsigned int)v5 >> 8;
        v34 = v5 >> 16;
        v35 = v5 & 0xFFFFFFFF00000000uLL;
        v36 = 7LL;
        goto LABEL_157;
      case 16:
        v71 = a1;
        v32 = v97;
        if ( HIWORD(a3) == 2 )
          sub_42E9B0((__int64)&v95, v98, a3);
        else
          sub_42EAB0((__int64)&v95, v98, SBYTE1(a3));
        LOBYTE(v5) = v95;
        if ( (_BYTE)v95 == 75 )
        {
          LOBYTE(v5) = v96;
          a1 = v71;
          LODWORD(v33) = (unsigned int)v96 >> 8;
          v34 = v96 >> 16;
          v35 = v96 & 0xFFFFFFFF00000000uLL;
          v36 = 14LL;
          goto LABEL_158;
        }
        v83 = *(_DWORD *)((char *)&v95 + 1);
        *(_DWORD *)(v71 + 12) = HIDWORD(v95);
        *(_DWORD *)(v71 + 9) = v83;
        v84 = v96;
        *(_BYTE *)(v71 + 8) = v5;
        *(_QWORD *)(v71 + 16) = v84;
        *(_QWORD *)v71 = 46LL;
        return v5;
      case 17:
        if ( !v8 )
          goto LABEL_133;
        v33 = v98;
        *v98 = v7 + 1;
        v33[1] = v8 - 1;
        LOBYTE(v5) = *(_BYTE *)v7;
        v36 = 13LL;
        LOWORD(v33) = 0;
        goto LABEL_155;
      case 18:
        if ( v8 <= 1 )
          goto LABEL_159;
        v33 = v98;
        *v98 = v7 + 2;
        v33[1] = v8 - 2;
        LOWORD(v5) = *(_WORD *)v7;
        LODWORD(v33) = HIBYTE(*(unsigned __int16 *)v7);
        v36 = 13LL;
        goto LABEL_155;
      case 19:
        if ( v8 <= 3 )
          goto LABEL_152;
        v33 = v98;
        *v98 = v7 + 4;
        v33[1] = v8 - 4;
        LODWORD(v5) = *(_DWORD *)v7;
        LODWORD(v33) = *(_DWORD *)v7 >> 8;
        LODWORD(v34) = HIWORD(*(_DWORD *)v7);
        v36 = 13LL;
        goto LABEL_156;
      case 20:
        if ( v8 <= 7 )
          goto LABEL_237;
        v33 = v98;
        *v98 = v7 + 8;
        v33[1] = v8 - 8;
        *(_QWORD *)&v42 = ((unsigned __int64)(*(unsigned __int16 *)(v7 + 4) | (*(unsigned __int8 *)(v7 + 6) << 16)) << 40) | ((unsigned __int64)*(unsigned int *)v7 << 8);
        *((_QWORD *)&v42 + 1) = *(unsigned __int8 *)(v7 + 7);
        v5 = v42 >> 8;
        LODWORD(v33) = (unsigned int)((__int64)v42 >> 8) >> 8;
        v34 = v5 >> 16;
        v35 = v5 & 0xFFFFFFFF00000000uLL;
        v36 = 13LL;
        goto LABEL_157;
      case 21:
        if ( !v8 )
          goto LABEL_167;
        v19 = v7 + v8;
        v50 = v8 - 1;
        v51 = v7 + 1;
        v5 = 0LL;
        v52 = 0;
        while ( 2 )
        {
          v53 = *(_BYTE *)(v51 - 1);
          if ( v52 == 63 && (unsigned __int8)v53 >= 2u )
          {
LABEL_200:
            v5 = (unsigned __int64)v98;
            *v98 = v51;
            *(_QWORD *)(v5 + 8) = v50;
            LOBYTE(v5) = 6;
            goto LABEL_201;
          }
          v5 |= (unsigned __int64)(v53 & 0x7F) << v52;
          if ( v53 < 0 )
          {
            v52 += 7;
            ++v51;
            v24 = v50-- != 0;
            if ( !v24 )
            {
LABEL_145:
              v74 = v98;
              *v98 = v19;
              v74[1] = 0LL;
              goto LABEL_168;
            }
            continue;
          }
          break;
        }
        v33 = v98;
        *v98 = v51;
        v33[1] = v50;
        LODWORD(v33) = (unsigned int)v5 >> 8;
        v34 = v5 >> 16;
        v35 = v5 & 0xFFFFFFFF00000000uLL;
        v36 = 13LL;
        goto LABEL_157;
      case 22:
        if ( v8 )
        {
          --v8;
          ++v7;
          v13 = v98;
          *v98 = (unsigned __int64)(v11 + 1);
          v13[1] = v12 - 1;
          v9 = *v11 & 0x7F;
          if ( *v11 < 0 )
          {
            if ( v12 == 1 )
              goto LABEL_193;
            v8 = v12 - 2;
            v7 = (unsigned __int64)(v11 + 2);
            v14 = v98;
            *v98 = (unsigned __int64)(v11 + 2);
            v14[1] = v12 - 2;
            v15 = a1;
            v9 = ((v11[1] & 0x7F) << 7) | (unsigned __int16)v9;
            if ( v11[1] < 0 )
            {
              if ( v12 == 2 )
              {
LABEL_193:
                LOBYTE(v5) = 19;
                LOWORD(v10) = 0;
                v11 = (char *)v7;
                goto LABEL_227;
              }
              v16 = v12 - 3;
              v7 = (unsigned __int64)(v11 + 3);
              v17 = v98;
              *v98 = (unsigned __int64)(v11 + 3);
              v17[1] = v16;
              if ( (unsigned __int8)v11[2] > 3u )
              {
                LOBYTE(v5) = 6;
                a1 = v15;
                goto LABEL_227;
              }
              v9 = ((unsigned __int8)v11[2] << 14) | (unsigned __int16)v9;
              v8 = v16;
              a1 = v15;
            }
          }
          continue;
        }
        LOBYTE(v5) = 19;
        LOWORD(v10) = 0;
LABEL_227:
        *(_BYTE *)(a1 + 8) = v5;
        *(_BYTE *)(a1 + 9) = 0;
        *(_WORD *)(a1 + 10) = v10;
LABEL_228:
        *(_DWORD *)(a1 + 12) = 0;
LABEL_238:
        *(_QWORD *)(a1 + 16) = v11;
LABEL_239:
        *(_QWORD *)a1 = 46LL;
        return v5;
      case 23:
        if ( BYTE1(a3) == 8 )
        {
          v40 = v98;
          if ( v8 <= 7 )
            goto LABEL_237;
          *v98 = v7 + 8;
          v40[1] = v8 - 8;
          *(_QWORD *)&v41 = ((unsigned __int64)(*(unsigned __int16 *)(v7 + 4) | (*(unsigned __int8 *)(v7 + 6) << 16)) << 40) | ((unsigned __int64)*(unsigned int *)v7 << 8);
          *((_QWORD *)&v41 + 1) = *(unsigned __int8 *)(v7 + 7);
          v5 = v41 >> 8;
        }
        else
        {
          v80 = v98;
          if ( v8 <= 3 )
            goto LABEL_237;
          *v98 = v7 + 4;
          v80[1] = v8 - 4;
          v5 = *(unsigned int *)v7;
        }
        v32 = v97;
LABEL_180:
        LODWORD(v33) = (unsigned int)v5 >> 8;
        v34 = v5 >> 16;
        v35 = v5 & 0xFFFFFFFF00000000uLL;
        v36 = 10LL;
        goto LABEL_158;
      case 24:
        if ( !v8 )
        {
LABEL_173:
          v5 = v7;
          v64 = 19LL;
          goto LABEL_212;
        }
        v55 = a1;
        v5 = v7 + v8;
        v56 = v8 - 1;
        v57 = v7 + 1;
        v10 = 0LL;
        v61 = 0;
        v32 = v97;
        while ( 2 )
        {
          v62 = *(_BYTE *)(v57 - 1);
          if ( v61 == 63 && (unsigned __int8)v62 >= 2u )
            goto LABEL_199;
          v10 |= (unsigned __int64)(v62 & 0x7F) << v61;
          if ( v62 < 0 )
          {
            v61 += 7;
            ++v57;
            v24 = v56-- != 0;
            if ( !v24 )
              goto LABEL_117;
            continue;
          }
          break;
        }
        v33 = v98;
        *v98 = v57;
        v33[1] = v56;
        v24 = v56 < v10;
        v87 = v56 - v10;
        if ( v24 )
          goto LABEL_211;
        *v33 = v57 + v10;
        v33[1] = v87;
        LODWORD(v33) = (unsigned int)v57 >> 8;
        v34 = v57 >> 16;
        v35 = v57 & 0xFFFFFFFF00000000uLL;
        v36 = 8LL;
        LOBYTE(v5) = v57;
        goto LABEL_158;
      case 25:
        v36 = 9LL;
        LOWORD(v33) = 0;
        LOBYTE(v5) = 1;
        goto LABEL_155;
      case 26:
LABEL_21:
        if ( !v8 )
          goto LABEL_167;
        v18 = a1;
        v19 = v7 + v8;
        v20 = v8 - 1;
        v21 = v7 + 1;
        v5 = 0LL;
        v27 = 0;
        while ( 2 )
        {
          v28 = *(_BYTE *)(v21 - 1);
          if ( v27 == 63 && (unsigned __int8)v28 >= 2u )
            goto LABEL_169;
          v5 |= (unsigned __int64)(v28 & 0x7F) << v27;
          if ( v28 < 0 )
          {
            v27 += 7;
            ++v21;
            v24 = v20-- != 0;
            if ( !v24 )
              goto LABEL_166;
            continue;
          }
          break;
        }
        v33 = v98;
        *v98 = v21;
        v33[1] = v20;
        LODWORD(v33) = (unsigned int)v5 >> 8;
        v34 = v5 >> 16;
        v35 = v5 & 0xFFFFFFFF00000000uLL;
        v36 = 29LL;
        goto LABEL_157;
      case 27:
LABEL_11:
        if ( !v8 )
          goto LABEL_167;
        v18 = a1;
        v19 = v7 + v8;
        v20 = v8 - 1;
        v21 = v7 + 1;
        v5 = 0LL;
        v22 = 0;
        while ( 2 )
        {
          v23 = *(_BYTE *)(v21 - 1);
          if ( v22 == 63 && (unsigned __int8)v23 >= 2u )
            goto LABEL_169;
          v5 |= (unsigned __int64)(v23 & 0x7F) << v22;
          if ( v23 < 0 )
          {
            v22 += 7;
            ++v21;
            v24 = v20-- != 0;
            if ( !v24 )
              goto LABEL_166;
            continue;
          }
          break;
        }
        v33 = v98;
        *v98 = v21;
        v33[1] = v20;
        LODWORD(v33) = (unsigned int)v5 >> 8;
        v34 = v5 >> 16;
        v35 = v5 & 0xFFFFFFFF00000000uLL;
        v36 = 12LL;
        goto LABEL_157;
      case 28:
        if ( v8 <= 3 )
          goto LABEL_152;
        v33 = v98;
        *v98 = v7 + 4;
        v33[1] = v8 - 4;
        LODWORD(v5) = *(_DWORD *)v7;
        LODWORD(v33) = *(_DWORD *)v7 >> 8;
        LODWORD(v34) = HIWORD(*(_DWORD *)v7);
        v36 = 15LL;
        goto LABEL_156;
      case 29:
LABEL_18:
        if ( BYTE1(a3) == 8 )
        {
          v25 = v98;
          if ( v8 <= 7 )
            goto LABEL_237;
          *v98 = v7 + 8;
          v25[1] = v8 - 8;
          *(_QWORD *)&v26 = ((unsigned __int64)(*(unsigned __int16 *)(v7 + 4) | (*(unsigned __int8 *)(v7 + 6) << 16)) << 40) | ((unsigned __int64)*(unsigned int *)v7 << 8);
          *((_QWORD *)&v26 + 1) = *(unsigned __int8 *)(v7 + 7);
          v5 = v26 >> 8;
        }
        else
        {
          v31 = v98;
          if ( v8 <= 3 )
            goto LABEL_237;
          *v98 = v7 + 4;
          v31[1] = v8 - 4;
          v5 = *(unsigned int *)v7;
        }
        v32 = v97;
        LODWORD(v33) = (unsigned int)v5 >> 8;
        v34 = v5 >> 16;
        v35 = v5 & 0xFFFFFFFF00000000uLL;
        v36 = 27LL;
        goto LABEL_158;
      case 30:
        if ( v8 < 0x10 )
          goto LABEL_110;
        v33 = v98;
        *v98 = v7 + 16;
        v33[1] = v8 - 16;
        LODWORD(v33) = (unsigned int)v7 >> 8;
        v34 = v7 >> 16;
        v35 = v7 & 0xFFFFFFFF00000000uLL;
        v36 = 1LL;
        v10 = 16LL;
        LOBYTE(v5) = v7;
        goto LABEL_157;
      case 31:
        if ( BYTE1(a3) == 8 )
        {
          v69 = v98;
          if ( v8 > 7 )
          {
            *v98 = v7 + 8;
            v69[1] = v8 - 8;
            *(_QWORD *)&v70 = ((unsigned __int64)(*(unsigned __int16 *)(v7 + 4) | (*(unsigned __int8 *)(v7 + 6) << 16)) << 40) | ((unsigned __int64)*(unsigned int *)v7 << 8);
            *((_QWORD *)&v70 + 1) = *(unsigned __int8 *)(v7 + 7);
            v5 = v70 >> 8;
LABEL_188:
            v32 = v97;
            LODWORD(v33) = (unsigned int)v5 >> 8;
            v34 = v5 >> 16;
            v35 = v5 & 0xFFFFFFFF00000000uLL;
            v36 = 30LL;
            goto LABEL_158;
          }
        }
        else
        {
          v82 = v98;
          if ( v8 > 3 )
          {
            *v98 = v7 + 4;
            v82[1] = v8 - 4;
            v5 = *(unsigned int *)v7;
            goto LABEL_188;
          }
        }
LABEL_237:
        *(_BYTE *)(a1 + 8) = 19;
        *(_BYTE *)(a1 + 15) = 0;
        *(_WORD *)(a1 + 13) = 0;
        *(_DWORD *)(a1 + 9) = 0;
        goto LABEL_238;
      case 32:
        if ( v8 <= 7 )
          goto LABEL_237;
        v33 = v98;
        *v98 = v7 + 8;
        v33[1] = v8 - 8;
        *(_QWORD *)&v37 = ((unsigned __int64)(*(unsigned __int16 *)(v7 + 4) | (*(unsigned __int8 *)(v7 + 6) << 16)) << 40) | ((unsigned __int64)*(unsigned int *)v7 << 8);
        *((_QWORD *)&v37 + 1) = *(unsigned __int8 *)(v7 + 7);
        v5 = v37 >> 8;
        LODWORD(v33) = (unsigned int)((__int64)v37 >> 8) >> 8;
        v34 = v5 >> 16;
        v35 = v5 & 0xFFFFFFFF00000000uLL;
        v36 = 25LL;
        goto LABEL_157;
      case 33:
        if ( (_WORD)v6 == 33 )
        {
          v32 = v97;
          v5 = *(_QWORD *)v97;
          LODWORD(v33) = (unsigned int)*(_QWORD *)v97 >> 8;
          v34 = *(_QWORD *)v97 >> 16;
          v35 = *(_QWORD *)v97 & 0xFFFFFFFF00000000uLL;
          v36 = 6LL;
          goto LABEL_158;
        }
        *(_BYTE *)(a1 + 8) = 70;
        goto LABEL_239;
      case 34:
        if ( !v8 )
          goto LABEL_167;
        v18 = a1;
        v19 = v7 + v8;
        v20 = v8 - 1;
        v21 = v7 + 1;
        v5 = 0LL;
        v76 = 0;
        while ( 1 )
        {
          v77 = *(_BYTE *)(v21 - 1);
          if ( v76 == 63 && (unsigned __int8)v77 >= 2u )
          {
LABEL_169:
            v5 = (unsigned __int64)v98;
            *v98 = v21;
            *(_QWORD *)(v5 + 8) = v20;
            LOBYTE(v5) = 6;
            a1 = v18;
LABEL_201:
            *(_BYTE *)(a1 + 8) = v5;
            *(_BYTE *)(a1 + 9) = 0;
            *(_WORD *)(a1 + 14) = 0;
            *(_DWORD *)(a1 + 10) = 0;
            *(_QWORD *)(a1 + 16) = v19;
            goto LABEL_239;
          }
          v5 |= (unsigned __int64)(v77 & 0x7F) << v76;
          if ( v77 >= 0 )
            break;
          v76 += 7;
          ++v21;
          v24 = v20-- != 0;
          if ( !v24 )
          {
LABEL_166:
            v78 = v98;
            *v98 = v19;
            v78[1] = 0LL;
            a1 = v18;
LABEL_168:
            LOBYTE(v5) = 19;
            goto LABEL_201;
          }
        }
        v33 = v98;
        *v98 = v21;
        v33[1] = v20;
        LODWORD(v33) = (unsigned int)v5 >> 8;
        v34 = v5 >> 16;
        v35 = v5 & 0xFFFFFFFF00000000uLL;
        v36 = 19LL;
LABEL_157:
        v32 = v97;
LABEL_158:
        v75 = *(_WORD *)(v32 + 8);
        v5 = v35 | ((_DWORD)v34 << 16) | (unsigned int)(unsigned __int16)(((_WORD)v33 << 8) | (unsigned __int8)v5);
        *(_QWORD *)a1 = v36;
        *(_QWORD *)(a1 + 8) = v5;
        *(_QWORD *)(a1 + 16) = v10;
        *(_WORD *)(a1 + 24) = v75;
        return v5;
      case 35:
        if ( !v8 )
        {
LABEL_167:
          v19 = v7;
          goto LABEL_168;
        }
        v18 = a1;
        v19 = v7 + v8;
        v20 = v8 - 1;
        v21 = v7 + 1;
        v5 = 0LL;
        v38 = 0;
        while ( 2 )
        {
          v39 = *(_BYTE *)(v21 - 1);
          if ( v38 == 63 && (unsigned __int8)v39 >= 2u )
            goto LABEL_169;
          v5 |= (unsigned __int64)(v39 & 0x7F) << v38;
          if ( v39 < 0 )
          {
            v38 += 7;
            ++v21;
            v24 = v20-- != 0;
            if ( !v24 )
              goto LABEL_166;
            continue;
          }
          break;
        }
        v33 = v98;
        *v98 = v21;
        v33[1] = v20;
        LODWORD(v33) = (unsigned int)v5 >> 8;
        v34 = v5 >> 16;
        v35 = v5 & 0xFFFFFFFF00000000uLL;
        v36 = 24LL;
        goto LABEL_157;
      case 36:
        if ( v8 <= 7 )
          goto LABEL_237;
        v33 = v98;
        *v98 = v7 + 8;
        v33[1] = v8 - 8;
        *(_QWORD *)&v43 = ((unsigned __int64)(*(unsigned __int16 *)(v7 + 4) | (*(unsigned __int8 *)(v7 + 6) << 16)) << 40) | ((unsigned __int64)*(unsigned int *)v7 << 8);
        *((_QWORD *)&v43 + 1) = *(unsigned __int8 *)(v7 + 7);
        v5 = v43 >> 8;
        LODWORD(v33) = (unsigned int)((__int64)v43 >> 8) >> 8;
        v34 = v5 >> 16;
        v35 = v5 & 0xFFFFFFFF00000000uLL;
        v36 = 15LL;
        goto LABEL_157;
      case 37:
        if ( !v8 )
          goto LABEL_133;
        v33 = v98;
        *v98 = v7 + 1;
        v33[1] = v8 - 1;
        LOBYTE(v5) = *(_BYTE *)v7;
        v36 = 29LL;
        LOWORD(v33) = 0;
        goto LABEL_155;
      case 38:
        if ( v8 <= 1 )
          goto LABEL_159;
        v33 = v98;
        *v98 = v7 + 2;
        v33[1] = v8 - 2;
        LOWORD(v5) = *(_WORD *)v7;
        LODWORD(v33) = HIBYTE(*(unsigned __int16 *)v7);
        v36 = 29LL;
        goto LABEL_155;
      case 39:
        if ( v8 <= 2 )
          goto LABEL_237;
        v33 = v98;
        *v98 = v7 + 3;
        v33[1] = v8 - 3;
        LODWORD(v5) = *(unsigned __int16 *)v7;
        LODWORD(v34) = *(unsigned __int8 *)(v7 + 2);
        LODWORD(v33) = ((unsigned int)v5 | ((_DWORD)v34 << 16)) >> 8;
        v36 = 29LL;
        goto LABEL_156;
      case 40:
        if ( v8 <= 3 )
          goto LABEL_152;
        v33 = v98;
        *v98 = v7 + 4;
        v33[1] = v8 - 4;
        LODWORD(v5) = *(_DWORD *)v7;
        LODWORD(v33) = *(_DWORD *)v7 >> 8;
        LODWORD(v34) = HIWORD(*(_DWORD *)v7);
        v36 = 29LL;
        goto LABEL_156;
      case 41:
        if ( v8 )
        {
          v33 = v98;
          *v98 = v7 + 1;
          v33[1] = v8 - 1;
          LOBYTE(v5) = *(_BYTE *)v7;
          v36 = 12LL;
          LOWORD(v33) = 0;
          goto LABEL_155;
        }
LABEL_133:
        *(_WORD *)(a1 + 8) = 19;
        *(_WORD *)(a1 + 14) = 0;
        *(_DWORD *)(a1 + 10) = 0;
        goto LABEL_238;
      case 42:
        if ( v8 <= 1 )
        {
LABEL_159:
          *(_WORD *)(a1 + 9) = 0;
          *(_BYTE *)(a1 + 15) = 0;
          *(_DWORD *)(a1 + 11) = 0;
          *(_BYTE *)(a1 + 8) = 19;
          goto LABEL_238;
        }
        v33 = v98;
        *v98 = v7 + 2;
        v33[1] = v8 - 2;
        LOWORD(v5) = *(_WORD *)v7;
        LODWORD(v33) = HIBYTE(*(unsigned __int16 *)v7);
        v36 = 12LL;
LABEL_155:
        LODWORD(v34) = 0;
        goto LABEL_156;
      case 43:
        if ( v8 <= 2 )
          goto LABEL_237;
        v33 = v98;
        *v98 = v7 + 3;
        v33[1] = v8 - 3;
        LODWORD(v5) = *(unsigned __int16 *)v7;
        LODWORD(v34) = *(unsigned __int8 *)(v7 + 2);
        LODWORD(v33) = ((unsigned int)v5 | ((_DWORD)v34 << 16)) >> 8;
        v36 = 12LL;
        goto LABEL_156;
      case 44:
        if ( v8 <= 3 )
        {
LABEL_152:
          *(_DWORD *)(a1 + 9) = 0;
          *(_BYTE *)(a1 + 15) = 0;
          *(_WORD *)(a1 + 13) = 0;
          *(_BYTE *)(a1 + 8) = 19;
          goto LABEL_238;
        }
        v33 = v98;
        *v98 = v7 + 4;
        v33[1] = v8 - 4;
        LODWORD(v5) = *(_DWORD *)v7;
        LODWORD(v33) = *(_DWORD *)v7 >> 8;
        LODWORD(v34) = HIWORD(*(_DWORD *)v7);
        v36 = 12LL;
LABEL_156:
        v35 = 0LL;
        goto LABEL_157;
      default:
        switch ( (__int16)v9 )
        {
          case 7937:
            goto LABEL_11;
          case 7938:
            goto LABEL_21;
          case 7968:
            if ( BYTE1(a3) == 8 )
            {
              v29 = v98;
              if ( v8 <= 7 )
                goto LABEL_237;
              *v98 = v7 + 8;
              v29[1] = v8 - 8;
              *(_QWORD *)&v30 = ((unsigned __int64)(*(unsigned __int16 *)(v7 + 4) | (*(unsigned __int8 *)(v7 + 6) << 16)) << 40) | ((unsigned __int64)*(unsigned int *)v7 << 8);
              *((_QWORD *)&v30 + 1) = *(unsigned __int8 *)(v7 + 7);
              v5 = v30 >> 8;
            }
            else
            {
              v79 = v98;
              if ( v8 <= 3 )
                goto LABEL_237;
              *v98 = v7 + 4;
              v79[1] = v8 - 4;
              v5 = *(unsigned int *)v7;
            }
            v32 = v97;
            LODWORD(v33) = (unsigned int)v5 >> 8;
            v34 = v5 >> 16;
            v35 = v5 & 0xFFFFFFFF00000000uLL;
            v36 = 15LL;
            break;
          case 7969:
            goto LABEL_18;
          default:
            goto LABEL_171;
        }
        goto LABEL_158;
    }
  }
}

//----- (000000000041E760) ----------------------------------------------------
void __fastcall sub_41E760(_QWORD *a1, unsigned __int8 **a2)
{
  unsigned __int64 v3; // r11
  unsigned __int64 v4; // rbx
  unsigned __int64 v5; // r9
  unsigned __int8 *v6; // r14
  unsigned __int64 v7; // rcx
  unsigned __int64 v8; // r8
  unsigned __int8 *v9; // r12
  unsigned __int64 v10; // rdi
  unsigned __int64 v11; // r15
  unsigned __int8 *v12; // r10
  __int64 v13; // rax
  char v14; // r9
  bool v15; // cf
  __int64 v16; // r13
  unsigned __int64 v17; // r11
  unsigned __int8 *v18; // r14
  __int128 v19; // rt0
  unsigned __int8 *v20; // rdi
  unsigned __int8 *v21; // r11
  unsigned __int64 v22; // r11
  __int64 v23; // rbx
  __int64 v24; // r13
  char v25; // al
  __int64 v26; // r12
  __int64 v27; // rbx
  char v28; // al
  __int64 v29; // rbx
  __int64 v30; // r13
  char v31; // al
  unsigned __int8 *v32; // rax
  unsigned __int64 v33; // r13
  unsigned __int64 v34; // r11
  unsigned __int64 v35; // r14
  unsigned __int64 v36; // r11
  __int64 v37; // r11
  __int64 v38; // r11
  unsigned __int8 *v39; // r14
  int v40; // ecx
  char v41; // al
  unsigned __int64 v42; // rax
  unsigned __int64 v43; // rcx
  unsigned __int8 *v44; // r9
  __int64 v45; // r9
  __int64 v46; // r9
  int v47; // ecx
  char v48; // al
  unsigned __int8 *v49; // r11
  int v50; // ecx
  char v51; // al
  __int128 v52; // rt0
  __int128 v53; // rt0
  __int128 v54; // rt0
  unsigned __int64 v55; // r12
  unsigned __int8 *v56; // r9
  int v57; // ecx
  char v58; // bl
  unsigned __int64 v59; // r13
  unsigned __int64 v60; // rcx
  unsigned __int64 v61; // r13
  unsigned __int64 v62; // rax
  __int128 v63; // rt0
  __int128 v64; // rt0
  __int64 v65; // r11
  unsigned __int64 v66; // rcx
  unsigned __int64 v67; // rax
  __int128 v68; // rt0
  __int128 v69; // rt0
  unsigned __int8 *v70; // r14
  unsigned __int8 *v71; // r14
  unsigned int v72; // eax
  __int64 v73; // rax
  __int64 v74; // rcx
  unsigned __int8 *v75; // [rsp+0h] [rbp-80h]
  unsigned __int8 *v76; // [rsp+8h] [rbp-78h]
  unsigned __int64 v77; // [rsp+18h] [rbp-68h]
  unsigned __int8 *v78; // [rsp+20h] [rbp-60h]
  unsigned __int8 *v79; // [rsp+28h] [rbp-58h]
  unsigned __int8 *v80; // [rsp+30h] [rbp-50h]
  unsigned __int8 *v81; // [rsp+38h] [rbp-48h]
  unsigned __int64 v82; // [rsp+40h] [rbp-40h]
  unsigned __int64 v83; // [rsp+40h] [rbp-40h]
  unsigned __int64 v84; // [rsp+40h] [rbp-40h]
  __int64 v85; // [rsp+48h] [rbp-38h]
  unsigned __int64 v86; // [rsp+50h] [rbp-30h]
  unsigned __int8 *v87; // [rsp+58h] [rbp-28h]
  unsigned __int8 *v88; // [rsp+60h] [rbp-20h]
  unsigned __int8 *v89; // [rsp+60h] [rbp-20h]
  unsigned __int8 *v90; // [rsp+60h] [rbp-20h]
  unsigned __int8 *v91; // [rsp+68h] [rbp-18h]
  _QWORD *v92; // [rsp+70h] [rbp-10h]
  unsigned __int64 v93; // [rsp+78h] [rbp-8h]
  unsigned __int8 v94; // [rsp+87h] [rbp+7h]

  v3 = (unsigned __int64)a2[5];
  if ( !v3 )
  {
LABEL_163:
    *a1 = 0LL;
    return;
  }
  v4 = *((unsigned int *)a2 + 12);
  v5 = 0xFFFFFFFFFFFFFFFFuLL >> (-8 * (unsigned __int8)*((_DWORD *)a2 + 12));
  v6 = a2[4];
  v7 = *((unsigned __int8 *)a2 + 52);
  v87 = (unsigned __int8 *)((__PAIR128__(v5, v4) - 0x50000) >> 64);
  v8 = (unsigned __int64)a2[3];
  v77 = (unsigned __int64)a2[1];
  v86 = v77 - v8;
  v78 = *a2;
  v9 = &(*a2)[v8];
  v85 = (unsigned __int8)v4;
  v79 = a2[2];
  v93 = v5;
  v94 = *((_BYTE *)a2 + 52);
  while ( !(_BYTE)v7 )
  {
    switch ( (int)v85 )
    {
      case 1:
        v7 = (unsigned __int64)(v6 + 1);
        a2[4] = v6 + 1;
        a2[5] = (unsigned __int8 *)(v3 - 1);
        if ( v3 == 1 )
          goto LABEL_173;
        v16 = *v6;
        v17 = v3 - 2;
        v12 = v6 + 2;
        a2[4] = v6 + 2;
        a2[5] = (unsigned __int8 *)v17;
        v18 = (unsigned __int8 *)v6[1];
        goto LABEL_24;
      case 2:
        if ( v3 == 1 )
          goto LABEL_176;
        v7 = (unsigned __int64)(v6 + 2);
        a2[4] = v6 + 2;
        a2[5] = (unsigned __int8 *)(v3 - 2);
        if ( v3 - 2 <= 1 )
          goto LABEL_173;
        v16 = *(unsigned __int16 *)v6;
        v17 = v3 - 4;
        v12 = v6 + 4;
        a2[4] = v6 + 4;
        a2[5] = (unsigned __int8 *)v17;
        v18 = (unsigned __int8 *)*((unsigned __int16 *)v6 + 1);
        goto LABEL_24;
      case 4:
        if ( v3 <= 3 )
          goto LABEL_176;
        v7 = (unsigned __int64)(v6 + 4);
        a2[4] = v6 + 4;
        a2[5] = (unsigned __int8 *)(v3 - 4);
        if ( v3 - 4 <= 3 )
          goto LABEL_173;
        v16 = *(unsigned int *)v6;
        v17 = v3 - 8;
        v12 = v6 + 8;
        a2[4] = v6 + 8;
        a2[5] = (unsigned __int8 *)v17;
        v18 = (unsigned __int8 *)*((unsigned int *)v6 + 1);
        goto LABEL_24;
      case 8:
        if ( v3 <= 7 )
        {
LABEL_176:
          v72 = 19;
          v7 = (unsigned __int64)v6;
          goto LABEL_184;
        }
        v7 = (unsigned __int64)(v6 + 8);
        a2[4] = v6 + 8;
        a2[5] = (unsigned __int8 *)(v3 - 8);
        if ( v3 - 8 < 8 )
        {
LABEL_173:
          v72 = 19;
LABEL_184:
          LODWORD(v4) = v72 >> 8;
          v26 = (unsigned __int8)v72;
          goto LABEL_185;
        }
        *(_QWORD *)&v19 = (((unsigned __int64)(*((unsigned __int16 *)v6 + 2) | (v6[6] << 16)) << 32) | *(unsigned int *)v6) << 8;
        *((_QWORD *)&v19 + 1) = v6[7];
        v16 = v19 >> 8;
        v17 = v3 - 16;
        v12 = v6 + 16;
        a2[4] = v6 + 16;
        a2[5] = (unsigned __int8 *)v17;
        v5 = v93;
        *(_QWORD *)&v19 = ((unsigned __int64)(*((unsigned __int16 *)v6 + 6) | (v6[14] << 16)) << 40) | ((unsigned __int64)*((unsigned int *)v6 + 2) << 8);
        *((_QWORD *)&v19 + 1) = v6[15];
        v18 = (unsigned __int8 *)(v19 >> 8);
LABEL_24:
        v11 = v17;
        if ( !(v16 | (unsigned __int64)v18) )
        {
LABEL_172:
          a2[4] = (unsigned __int8 *)1;
          a2[5] = 0LL;
          *a1 = 0LL;
          return;
        }
        if ( v16 == v5 )
        {
LABEL_92:
          a2[2] = v18;
          v79 = v18;
          goto LABEL_126;
        }
        v20 = v87;
        v21 = v79;
        if ( v79 == v87 )
        {
LABEL_27:
          v79 = v20;
          goto LABEL_126;
        }
LABEL_124:
        v33 = v5 & (unsigned __int64)&v21[v16];
        v35 = v5 & (unsigned __int64)&v18[(_QWORD)v21];
        v49 = v91;
LABEL_125:
        v91 = v49;
        if ( (unsigned __int8 *)v33 != v20 )
        {
          if ( v33 <= v35 )
          {
            *a1 = 1LL;
            a1[1] = v33;
            a1[2] = v35;
            return;
          }
          a2[4] = (unsigned __int8 *)1;
          a2[5] = 0LL;
          v73 = 48LL;
          v74 = 0LL;
LABEL_195:
          a1[1] = v73 | v74;
          a1[2] = v9;
          goto LABEL_186;
        }
LABEL_126:
        v3 = v11;
        v6 = v12;
        v7 = v94;
        if ( !v11 )
          goto LABEL_163;
        break;
      default:
        v72 = (unsigned __int16)((_WORD)v4 << 8) | 0x17;
        goto LABEL_184;
    }
  }
  v10 = v3 - 1;
  v7 = (unsigned __int64)(v6 + 1);
  switch ( *v6 )
  {
    case 0u:
      goto LABEL_172;
    case 1u:
      if ( v3 == 1 )
        goto LABEL_170;
      v11 = v3 - 2;
      v12 = v6 + 2;
      v13 = 0LL;
      v7 = 0LL;
      while ( 2 )
      {
        v14 = *(v12 - 1);
        if ( (_DWORD)v7 == 63 && (unsigned __int8)v14 >= 2u )
        {
          v26 = 6LL;
LABEL_167:
          LOWORD(v4) = 0;
          goto LABEL_185;
        }
        v13 |= (unsigned __int64)(v14 & 0x7F) << v7;
        if ( v14 < 0 )
        {
          v7 = (unsigned int)(v7 + 7);
          ++v12;
          v15 = v11-- != 0;
          if ( !v15 )
          {
            v71 = &v6[v3];
            a2[4] = v71;
            v7 = (unsigned __int64)v71;
            goto LABEL_170;
          }
          continue;
        }
        break;
      }
      a2[4] = v12;
      a2[5] = (unsigned __int8 *)v11;
      if ( v77 < v8 )
        goto LABEL_191;
      v42 = v85 * v13;
      v43 = v86 - v42;
      if ( v86 < v42 )
        goto LABEL_192;
      v44 = &v9[v42];
      switch ( (int)v85 )
      {
        case 1:
          if ( v86 == v42 )
            goto LABEL_190;
          v18 = (unsigned __int8 *)*v44;
          v5 = v93;
          break;
        case 2:
          if ( v43 <= 1 )
            goto LABEL_190;
          v18 = (unsigned __int8 *)*(unsigned __int16 *)v44;
          v5 = v93;
          break;
        case 4:
          if ( v43 <= 3 )
            goto LABEL_190;
          v18 = (unsigned __int8 *)*(unsigned int *)v44;
          v5 = v93;
          break;
        case 8:
          if ( v43 <= 7 )
            goto LABEL_190;
          *(_QWORD *)&v63 = ((unsigned __int64)(*((unsigned __int16 *)v44 + 2) | (v44[6] << 16)) << 40) | ((unsigned __int64)*(unsigned int *)v44 << 8);
          *((_QWORD *)&v63 + 1) = v44[7];
          v18 = (unsigned __int8 *)(v63 >> 8);
          v5 = v93;
          break;
        default:
          goto LABEL_194;
      }
      goto LABEL_92;
    case 2u:
      if ( v3 == 1 )
        goto LABEL_170;
      v88 = v9;
      v84 = v4;
      v92 = a1;
      v11 = v3 - 3;
      v12 = v6 + 3;
      v29 = 0LL;
      v30 = 0LL;
      v7 = 0LL;
      while ( 1 )
      {
        v31 = v6[v29 + 1];
        v26 = 6LL;
        if ( (_DWORD)v7 == 63 && (unsigned __int8)v31 >= 2u )
          goto LABEL_164;
        v30 |= (unsigned __int64)(v31 & 0x7F) << v7;
        if ( v31 >= 0 )
          break;
        v7 = (unsigned int)(v7 + 7);
        ++v29;
        --v11;
        ++v12;
        --v10;
        if ( v3 - 1 == v29 )
        {
          v70 = &v6[v3];
          a2[4] = v70;
          goto LABEL_169;
        }
      }
      v37 = (__int64)&v6[v29 + 2];
      a2[4] = (unsigned __int8 *)v37;
      a2[5] = (unsigned __int8 *)(v10 - 1);
      if ( v10 == 1 )
        goto LABEL_180;
      v38 = (__int64)&v6[v29 + 1];
      v39 = 0LL;
      v40 = 0;
      v4 = v84;
      break;
    case 3u:
      if ( v3 == 1 )
        goto LABEL_170;
      v88 = v9;
      v82 = v4;
      v92 = a1;
      v11 = v3 - 3;
      v12 = v6 + 3;
      v23 = 0LL;
      v24 = 0LL;
      v7 = 0LL;
      while ( 2 )
      {
        v25 = v6[v23 + 1];
        v26 = 6LL;
        if ( (_DWORD)v7 == 63 && (unsigned __int8)v25 >= 2u )
          goto LABEL_164;
        v24 |= (unsigned __int64)(v25 & 0x7F) << v7;
        if ( v25 < 0 )
        {
          v7 = (unsigned int)(v7 + 7);
          ++v23;
          --v11;
          ++v12;
          --v10;
          if ( v3 - 1 == v23 )
            goto LABEL_165;
          continue;
        }
        break;
      }
      v45 = (__int64)&v6[v23 + 2];
      a2[4] = (unsigned __int8 *)v45;
      a2[5] = (unsigned __int8 *)(v10 - 1);
      if ( v10 == 1 )
        goto LABEL_175;
      v46 = (__int64)&v6[v23 + 1];
      v49 = 0LL;
      v50 = 0;
      v4 = v82;
      while ( 1 )
      {
        v51 = *(v12 - 1);
        if ( v50 == 63 && (unsigned __int8)v51 >= 2u )
        {
          LOWORD(v4) = 0;
          v7 = (unsigned __int64)v91;
          goto LABEL_185;
        }
        v49 = (unsigned __int8 *)(((unsigned __int64)(v51 & 0x7F) << v50) | (unsigned __int64)v49);
        if ( v51 >= 0 )
          break;
        v50 += 7;
        ++v12;
        v15 = v11-- != 0;
        if ( !v15 )
          goto LABEL_174;
      }
      a2[4] = v12;
      a2[5] = (unsigned __int8 *)v11;
      if ( v77 < v8 )
        goto LABEL_191;
      v61 = v85 * v24;
      v62 = v86 - v61;
      if ( v86 < v61 )
        goto LABEL_193;
      v9 = v88;
      v20 = v87;
      v44 = &v88[v61];
      switch ( (int)v85 )
      {
        case 1:
          if ( v86 == v61 )
            goto LABEL_190;
          v33 = *v44;
          goto LABEL_155;
        case 2:
          if ( v62 <= 1 )
            goto LABEL_190;
          v33 = *(unsigned __int16 *)v44;
          goto LABEL_155;
        case 4:
          if ( v62 <= 3 )
            goto LABEL_190;
          v33 = *(unsigned int *)v44;
          goto LABEL_155;
        case 8:
          if ( v62 <= 7 )
          {
LABEL_190:
            v73 = 19LL;
            v74 = 0LL;
            v9 = v44;
            goto LABEL_195;
          }
          *(_QWORD *)&v68 = ((unsigned __int64)(*((unsigned __int16 *)v44 + 2) | (v44[6] << 16)) << 40) | ((unsigned __int64)*(unsigned int *)v44 << 8);
          *((_QWORD *)&v68 + 1) = v44[7];
          v33 = v68 >> 8;
LABEL_155:
          v5 = v93;
          v35 = v93 & (unsigned __int64)&v49[v33];
          break;
        default:
LABEL_194:
          v74 = (unsigned __int16)((_WORD)v4 << 8);
          v73 = 23LL;
          v9 = v81;
          goto LABEL_195;
      }
      goto LABEL_125;
    case 4u:
      if ( v3 == 1 )
        goto LABEL_170;
      v89 = v9;
      v83 = v4;
      v92 = a1;
      v11 = v3 - 3;
      v12 = v6 + 3;
      v27 = 0LL;
      v16 = 0LL;
      v7 = 0LL;
      while ( 1 )
      {
        v28 = v6[v27 + 1];
        v26 = 6LL;
        if ( (_DWORD)v7 == 63 && (unsigned __int8)v28 >= 2u )
        {
LABEL_164:
          LOWORD(v4) = 0;
          a1 = v92;
          goto LABEL_185;
        }
        v16 |= (unsigned __int64)(v28 & 0x7F) << v7;
        if ( v28 >= 0 )
          break;
        v7 = (unsigned int)(v7 + 7);
        ++v27;
        --v11;
        ++v12;
        --v10;
        if ( v3 - 1 == v27 )
        {
LABEL_165:
          v70 = &v6[v3];
          a2[4] = v70;
          a2[5] = 0LL;
LABEL_169:
          v7 = (unsigned __int64)v70;
          a1 = v92;
LABEL_170:
          v26 = 19LL;
          LOWORD(v4) = 0;
          goto LABEL_185;
        }
      }
      v45 = (__int64)&v6[v27 + 2];
      a2[4] = (unsigned __int8 *)v45;
      a2[5] = (unsigned __int8 *)(v10 - 1);
      if ( v10 == 1 )
        goto LABEL_175;
      v46 = (__int64)&v6[v27 + 1];
      v18 = 0LL;
      v47 = 0;
      v4 = v83;
      v21 = v79;
      while ( 1 )
      {
        v48 = *(v12 - 1);
        if ( v47 == 63 && (unsigned __int8)v48 >= 2u )
        {
          LOWORD(v4) = 0;
          v7 = (unsigned __int64)v76;
          goto LABEL_185;
        }
        v18 = (unsigned __int8 *)(((unsigned __int64)(v48 & 0x7F) << v47) | (unsigned __int64)v18);
        if ( v48 >= 0 )
          break;
        v47 += 7;
        ++v12;
        v15 = v11-- != 0;
        if ( !v15 )
        {
LABEL_174:
          v45 = v10 + v46;
          a2[4] = (unsigned __int8 *)v45;
          a2[5] = 0LL;
LABEL_175:
          v26 = 19LL;
          LOWORD(v4) = 0;
          v7 = v45;
          goto LABEL_185;
        }
      }
      a2[4] = v12;
      a2[5] = (unsigned __int8 *)v11;
      v76 = v18;
      v9 = v89;
      v5 = v93;
      v20 = v87;
      if ( v79 != v87 )
        goto LABEL_124;
      goto LABEL_27;
    case 5u:
      switch ( (int)v85 )
      {
        case 1:
          if ( v3 == 1 )
            goto LABEL_170;
          v22 = v3 - 2;
          v12 = v6 + 2;
          a2[4] = v6 + 2;
          a2[5] = (unsigned __int8 *)v22;
          v18 = (unsigned __int8 *)v6[1];
          break;
        case 2:
          if ( v10 <= 1 )
            goto LABEL_170;
          v22 = v3 - 3;
          v12 = v6 + 3;
          a2[4] = v6 + 3;
          a2[5] = (unsigned __int8 *)v22;
          v18 = (unsigned __int8 *)*(unsigned __int16 *)(v6 + 1);
          break;
        case 4:
          if ( v10 <= 3 )
            goto LABEL_170;
          v22 = v3 - 5;
          v12 = v6 + 5;
          a2[4] = v6 + 5;
          a2[5] = (unsigned __int8 *)v22;
          v18 = (unsigned __int8 *)*(unsigned int *)(v6 + 1);
          break;
        case 8:
          if ( v10 <= 7 )
            goto LABEL_170;
          v22 = v3 - 9;
          v12 = v6 + 9;
          a2[4] = v6 + 9;
          a2[5] = (unsigned __int8 *)v22;
          *(_QWORD *)&v52 = ((unsigned __int64)(*(unsigned __int16 *)(v6 + 5) | (v6[7] << 16)) << 40) | ((unsigned __int64)*(unsigned int *)(v6 + 1) << 8);
          *((_QWORD *)&v52 + 1) = v6[8];
          v18 = (unsigned __int8 *)(v52 >> 8);
          break;
        default:
          goto LABEL_189;
      }
      v11 = v22;
      goto LABEL_92;
    case 6u:
      switch ( (int)v85 )
      {
        case 1:
          if ( v3 == 1 )
            goto LABEL_170;
          v32 = v6 + 2;
          a2[4] = v6 + 2;
          a2[5] = (unsigned __int8 *)(v3 - 2);
          if ( v3 == 2 )
            goto LABEL_171;
          v33 = v6[1];
          v34 = v3 - 3;
          v12 = v6 + 3;
          a2[4] = v6 + 3;
          a2[5] = (unsigned __int8 *)v34;
          v35 = v6[2];
          break;
        case 2:
          if ( v10 <= 1 )
            goto LABEL_170;
          v32 = v6 + 3;
          a2[4] = v6 + 3;
          a2[5] = (unsigned __int8 *)(v3 - 3);
          if ( v3 - 3 <= 1 )
            goto LABEL_171;
          v33 = *(unsigned __int16 *)(v6 + 1);
          v34 = v3 - 5;
          v12 = v6 + 5;
          a2[4] = v6 + 5;
          a2[5] = (unsigned __int8 *)v34;
          v35 = *(unsigned __int16 *)(v6 + 3);
          break;
        case 4:
          if ( v10 <= 3 )
            goto LABEL_170;
          v32 = v6 + 5;
          a2[4] = v6 + 5;
          a2[5] = (unsigned __int8 *)(v3 - 5);
          if ( v3 - 5 <= 3 )
            goto LABEL_171;
          v33 = *(unsigned int *)(v6 + 1);
          v34 = v3 - 9;
          v12 = v6 + 9;
          a2[4] = v6 + 9;
          a2[5] = (unsigned __int8 *)v34;
          v35 = *(unsigned int *)(v6 + 5);
          break;
        case 8:
          if ( v10 <= 7 )
            goto LABEL_170;
          v32 = v6 + 9;
          a2[4] = v6 + 9;
          a2[5] = (unsigned __int8 *)(v3 - 9);
          if ( v3 - 9 < 8 )
            goto LABEL_171;
          *(_QWORD *)&v53 = (((unsigned __int64)(*(unsigned __int16 *)(v6 + 5) | (v6[7] << 16)) << 32) | *(unsigned int *)(v6 + 1)) << 8;
          *((_QWORD *)&v53 + 1) = v6[8];
          v33 = v53 >> 8;
          v34 = v3 - 17;
          v12 = v6 + 17;
          a2[4] = v6 + 17;
          a2[5] = (unsigned __int8 *)v34;
          *(_QWORD *)&v53 = ((unsigned __int64)(*(unsigned __int16 *)(v6 + 13) | (v6[15] << 16)) << 40) | ((unsigned __int64)*(unsigned int *)(v6 + 9) << 8);
          *((_QWORD *)&v53 + 1) = v6[16];
          v35 = v53 >> 8;
          break;
        default:
          goto LABEL_189;
      }
      v11 = v34;
      v49 = v91;
      goto LABEL_117;
    case 7u:
      switch ( (int)v85 )
      {
        case 1:
          if ( v3 == 1 )
            goto LABEL_170;
          v36 = v3 - 2;
          v32 = v6 + 2;
          a2[4] = v6 + 2;
          a2[5] = (unsigned __int8 *)v36;
          v33 = v6[1];
          break;
        case 2:
          if ( v10 <= 1 )
            goto LABEL_170;
          v36 = v3 - 3;
          v32 = v6 + 3;
          a2[4] = v6 + 3;
          a2[5] = (unsigned __int8 *)v36;
          v33 = *(unsigned __int16 *)(v6 + 1);
          break;
        case 4:
          if ( v10 <= 3 )
            goto LABEL_170;
          v36 = v3 - 5;
          v32 = v6 + 5;
          a2[4] = v6 + 5;
          a2[5] = (unsigned __int8 *)v36;
          v33 = *(unsigned int *)(v6 + 1);
          break;
        case 8:
          if ( v10 <= 7 )
            goto LABEL_170;
          v36 = v3 - 9;
          v32 = v6 + 9;
          a2[4] = v6 + 9;
          a2[5] = (unsigned __int8 *)v36;
          *(_QWORD *)&v54 = ((unsigned __int64)(*(unsigned __int16 *)(v6 + 5) | (v6[7] << 16)) << 40) | ((unsigned __int64)*(unsigned int *)(v6 + 1) << 8);
          *((_QWORD *)&v54 + 1) = v6[8];
          v33 = v54 >> 8;
          break;
        default:
LABEL_189:
          v26 = 23LL;
          goto LABEL_185;
      }
      if ( !v36 )
        goto LABEL_171;
      v90 = v9;
      v55 = v4;
      v11 = v36 - 1;
      v12 = v32 + 1;
      v56 = 0LL;
      v57 = 0;
      while ( 1 )
      {
        v58 = *(v12 - 1);
        if ( v57 == 63 && (unsigned __int8)v58 >= 2u )
        {
          v26 = 6LL;
          LOWORD(v4) = 0;
          v7 = (unsigned __int64)v75;
          goto LABEL_185;
        }
        v56 = (unsigned __int8 *)(((unsigned __int64)(v58 & 0x7F) << v57) | (unsigned __int64)v56);
        if ( v58 >= 0 )
          break;
        v57 += 7;
        ++v12;
        v15 = v11-- != 0;
        if ( !v15 )
        {
          v32 += v36;
          a2[4] = v32;
          a2[5] = 0LL;
LABEL_171:
          v26 = 19LL;
          LOWORD(v4) = 0;
          v7 = (unsigned __int64)v32;
          goto LABEL_185;
        }
      }
      a2[4] = v12;
      a2[5] = (unsigned __int8 *)v11;
      v35 = v93 & (unsigned __int64)&v56[v33];
      v75 = v56;
      v5 = v93;
      v49 = v91;
      v4 = v55;
      v9 = v90;
LABEL_117:
      v20 = v87;
      goto LABEL_125;
    default:
      v26 = 48LL;
      goto LABEL_167;
  }
  do
  {
    v41 = *(v12 - 1);
    if ( v40 == 63 && (unsigned __int8)v41 >= 2u )
    {
      LOWORD(v4) = 0;
      v7 = (unsigned __int64)v80;
      goto LABEL_185;
    }
    v39 = (unsigned __int8 *)(((unsigned __int64)(v41 & 0x7F) << v40) | (unsigned __int64)v39);
    if ( v41 >= 0 )
    {
      a2[4] = v12;
      a2[5] = (unsigned __int8 *)v11;
      if ( v77 < v8 )
      {
LABEL_191:
        v73 = 19LL;
        v74 = 0LL;
        v9 = v78;
        goto LABEL_195;
      }
      v59 = v85 * v30;
      v60 = v86 - v59;
      if ( v86 < v59 )
      {
LABEL_193:
        v73 = 19LL;
        v74 = 0LL;
        v9 = v88;
        goto LABEL_195;
      }
      v9 = v88;
      v20 = v87;
      v44 = &v88[v59];
      switch ( (int)v85 )
      {
        case 1:
          if ( v86 == v59 )
            goto LABEL_190;
          v33 = *v44;
          break;
        case 2:
          if ( v60 <= 1 )
            goto LABEL_190;
          v33 = *(unsigned __int16 *)v44;
          break;
        case 4:
          if ( v60 <= 3 )
            goto LABEL_190;
          v33 = *(unsigned int *)v44;
          break;
        case 8:
          if ( v60 <= 7 )
            goto LABEL_190;
          *(_QWORD *)&v64 = ((unsigned __int64)(*((unsigned __int16 *)v44 + 2) | (v44[6] << 16)) << 40) | ((unsigned __int64)*(unsigned int *)v44 << 8);
          *((_QWORD *)&v64 + 1) = v44[7];
          v33 = v64 >> 8;
          break;
        default:
          goto LABEL_194;
      }
      v65 = v85 * (_QWORD)v39;
      v66 = v86 - v85 * (_QWORD)v39;
      if ( v86 < v85 * (__int64)v39 )
      {
LABEL_192:
        v73 = 19LL;
        v74 = 0LL;
        goto LABEL_195;
      }
      v44 = &v88[v65];
      switch ( (int)v85 )
      {
        case 1:
          if ( v86 == v65 )
            goto LABEL_190;
          v67 = *v44;
          goto LABEL_162;
        case 2:
          if ( v66 <= 1 )
            goto LABEL_190;
          v67 = *(unsigned __int16 *)v44;
          goto LABEL_162;
        case 4:
          if ( v66 <= 3 )
            goto LABEL_190;
          v67 = *(unsigned int *)v44;
LABEL_162:
          v49 = v91;
          v80 = v39;
          v81 = (unsigned __int8 *)v67;
          v35 = v67;
          v5 = v93;
          break;
        case 8:
          if ( v66 <= 7 )
            goto LABEL_190;
          *(_QWORD *)&v69 = ((unsigned __int64)(*((unsigned __int16 *)v44 + 2) | (v44[6] << 16)) << 40) | ((unsigned __int64)*(unsigned int *)v44 << 8);
          *((_QWORD *)&v69 + 1) = v44[7];
          v49 = v91;
          v80 = v39;
          v81 = (unsigned __int8 *)(v69 >> 8);
          v35 = (unsigned __int64)v81;
          v5 = v93;
          break;
        default:
          goto LABEL_194;
      }
      goto LABEL_125;
    }
    v40 += 7;
    ++v12;
    v15 = v11-- != 0;
  }
  while ( v15 );
  v37 = v10 + v38;
  a2[4] = (unsigned __int8 *)v37;
  a2[5] = 0LL;
LABEL_180:
  v26 = 19LL;
  LOWORD(v4) = 0;
  v7 = v37;
LABEL_185:
  a2[4] = (unsigned __int8 *)1;
  a2[5] = 0LL;
  a1[1] = v26 | (unsigned __int16)((_WORD)v4 << 8);
  a1[2] = v7;
LABEL_186:
  *a1 = 2LL;
}
// 41F029: variable 'v91' is possibly undefined
// 41F41A: variable 'v75' is possibly undefined
// 41F4BE: variable 'v76' is possibly undefined
// 41F4CE: variable 'v80' is possibly undefined
// 41F5C1: variable 'v81' is possibly undefined

//----- (000000000041F5E0) ----------------------------------------------------
__int64 __fastcall sub_41F5E0(__int64 *a1, __int64 a2)
{
  __int64 v2; // rsi
  __int64 v3; // rax
  unsigned __int64 v5; // rdx
  __int64 v6; // rbx
  __int64 v7; // rcx
  __int64 v8; // rax
  __int64 result; // rax
  _QWORD v10[3]; // [rsp+28h] [rbp-28h] BYREF
  __int64 v11; // [rsp+40h] [rbp-10h] BYREF
  __int64 v12; // [rsp+48h] [rbp-8h]
  __int64 v13; // [rsp+50h] [rbp+0h]

  v2 = a2;
  v3 = *a1;
  if ( *a1 == -1 )
    goto LABEL_13;
  v5 = v3 + 1;
  if ( 2 * v3 > (unsigned __int64)(v3 + 1) )
    v5 = 2 * v3;
  v6 = 4LL;
  if ( v5 >= 5 )
    v6 = v5;
  v7 = 0LL;
  a2 = v5 >> 59;
  if ( a2 )
LABEL_13:
    sub_40408F(0LL, a2, v2);
  if ( (unsigned __int64)(32 * v6) > 0x7FFFFFFFFFFFFFF8LL )
LABEL_15:
    sub_40408F(v7, a2, v2);
  if ( v3 )
  {
    v10[0] = a1[1];
    v10[2] = 32 * v3;
    v8 = 8LL;
  }
  else
  {
    v8 = 0LL;
  }
  v10[1] = v8;
  sub_413370(&v11, (void *)8, 32 * v6, (__int64)v10);
  if ( (_DWORD)v11 == 1 )
  {
    v7 = v12;
    a2 = v13;
    goto LABEL_15;
  }
  result = v12;
  a1[1] = v12;
  *a1 = v6;
  return result;
}

//----- (000000000041F6B0) ----------------------------------------------------
__int64 __fastcall sub_41F6B0(unsigned __int64 *a1, __int64 a2)
{
  unsigned __int128 v2; // rax
  unsigned __int64 v3; // r8
  unsigned __int64 v5; // rax
  unsigned __int64 v6; // rdi
  __int64 v7; // rcx
  __int64 v8; // rcx
  __int64 result; // rax
  _QWORD v10[3]; // [rsp+20h] [rbp-30h] BYREF
  __int64 v11; // [rsp+38h] [rbp-18h] BYREF
  __int64 v12; // [rsp+40h] [rbp-10h]
  __int64 v13; // [rsp+48h] [rbp-8h]

  *((_QWORD *)&v2 + 1) = a2;
  v3 = *a1;
  if ( *a1 == -1LL )
    goto LABEL_13;
  v5 = v3 + 1;
  if ( 2 * v3 > v3 + 1 )
    v5 = 2 * v3;
  v6 = 4LL;
  if ( v5 >= 5 )
    v6 = v5;
  v7 = 0LL;
  v2 = 0x218 * (unsigned __int128)v6;
  if ( !is_mul_ok(0x218uLL, v6) )
LABEL_13:
    sub_40408F(0LL, *((__int64 *)&v2 + 1), (__int64)&off_4482C0);
  if ( (unsigned __int64)v2 > 0x7FFFFFFFFFFFFFF8LL )
LABEL_15:
    sub_40408F(v7, *((__int64 *)&v2 + 1), (__int64)&off_4482C0);
  if ( v3 )
  {
    v10[0] = a1[1];
    v10[2] = 536 * v3;
    v8 = 8LL;
  }
  else
  {
    v8 = 0LL;
  }
  v10[1] = v8;
  sub_413370(&v11, (void *)8, v2, (__int64)v10);
  if ( (_DWORD)v11 == 1 )
  {
    v7 = v12;
    *((_QWORD *)&v2 + 1) = v13;
    goto LABEL_15;
  }
  result = v12;
  a1[1] = v12;
  *a1 = v6;
  return result;
}
// 4482C0: using guessed type char *off_4482C0;

//----- (000000000041F780) ----------------------------------------------------
void __fastcall sub_41F780(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v4; // r8
  char v5; // cl

  if ( !_InterlockedDecrement64(*(volatile signed __int64 **)(a1 + 344)) )
    sub_41D140(*(LPVOID *)(a1 + 344), a2, a3);
  sub_41D230(a1 + 96);
  if ( *(_QWORD *)(a1 + 432) )
    sub_4215A0(a1 + 440);
  if ( *(_QWORD *)(a1 + 472) )
    sub_4265D0(a1 + 480);
  v5 = *(_BYTE *)(a1 + 512);
  if ( v5 != 76 )
    sub_42E900(v5, *(_QWORD *)(a1 + 520), v4);
}
// 41F7FF: variable 'v4' is possibly undefined

//----- (000000000041F880) ----------------------------------------------------
__int64 __fastcall sub_41F880(__int64 a1, __int64 *a2)
{
  __int128 v2; // xmm0
  unsigned __int64 v3; // r13
  __int128 v6; // xmm6
  const void *v7; // rbx
  __int64 v8; // rax
  unsigned __int64 v9; // r12
  unsigned __int64 v10; // rbx
  __int64 v11; // rcx
  unsigned __int64 v12; // rsi
  const void *v13; // r12
  __int64 v14; // rax
  unsigned __int64 v15; // r12
  unsigned __int64 v16; // rsi
  __int64 v17; // rcx
  const void *v18; // r13
  __int64 v19; // rax
  unsigned __int64 v20; // rbx
  unsigned __int64 v21; // r13
  SIZE_T v22; // rsi
  __int64 v23; // rcx
  const void *v24; // rbx
  __int64 v25; // r15
  unsigned __int64 v26; // r10
  __int64 v27; // rdx
  __int64 v28; // r8
  __int64 result; // rax
  __int64 v30; // r9
  __int64 v31; // rcx
  unsigned __int64 v32; // r10
  unsigned int v33; // r11d
  unsigned __int64 v34; // rsi
  unsigned __int64 v35; // rbx
  __int128 v36; // [rsp+20h] [rbp-60h]
  __int64 v37; // [rsp+38h] [rbp-48h]
  __int64 v38; // [rsp+40h] [rbp-40h]
  __int64 v39; // [rsp+48h] [rbp-38h]
  __int64 v40; // [rsp+50h] [rbp-30h]
  unsigned __int64 v41; // [rsp+58h] [rbp-28h]
  __int64 v42; // [rsp+60h] [rbp-20h]
  __int64 v43; // [rsp+68h] [rbp-18h]
  unsigned __int64 v44; // [rsp+70h] [rbp-10h]
  LPVOID v45; // [rsp+78h] [rbp-8h]
  LPVOID v46; // [rsp+80h] [rbp+0h]
  unsigned __int64 v47; // [rsp+88h] [rbp+8h]
  LPVOID lpMem; // [rsp+90h] [rbp+10h]
  unsigned __int64 v49; // [rsp+98h] [rbp+18h]
  unsigned __int64 v50; // [rsp+A0h] [rbp+20h]
  int v51; // [rsp+A8h] [rbp+28h]
  char v52; // [rsp+AFh] [rbp+2Fh]

  v3 = a2[10];
  if ( v3 >> 62 || 4 * v3 > 0x7FFFFFFFFFFFFFFELL )
    sub_4040B0((__int64)&off_447C90);
  v51 = *((_DWORD *)a2 + 58);
  v6 = *((_OWORD *)a2 + 12);
  v39 = a2[26];
  v52 = *((_BYTE *)a2 + 241);
  v37 = a2[20];
  v38 = a2[21];
  v7 = (const void *)a2[9];
  if ( 4 * v3 )
  {
    v8 = (__int64)sub_43C4F0(4 * v3);
    v9 = v3;
    if ( !v8 )
      sub_4040E9(2LL, 4 * v3);
  }
  else
  {
    v8 = 2LL;
    v9 = 0LL;
  }
  v45 = (LPVOID)v8;
  memcpy((void *)v8, v7, 4 * v3);
  v10 = a2[13];
  v11 = 0LL;
  v12 = 24 * v10;
  v44 = v9;
  if ( !is_mul_ok(0x18uLL, v10) || v12 > 0x7FFFFFFFFFFFFFF8LL )
LABEL_12:
    sub_40408F(v11, v12, (__int64)&off_447C90);
  v13 = (const void *)a2[12];
  v40 = a2[13];
  if ( v12 )
  {
    v14 = (__int64)sub_43C4F0(v12);
    v50 = v10;
    if ( !v14 )
    {
      v11 = 8LL;
      goto LABEL_12;
    }
  }
  else
  {
    v14 = 8LL;
    v50 = 0LL;
  }
  v46 = (LPVOID)v14;
  memcpy((void *)v14, v13, v12);
  v15 = a2[16];
  v16 = 4 * v15;
  v17 = 0LL;
  if ( v15 > 0x3FFFFFFFFFFFFFFFLL || (v41 = v3, v16 > 0x7FFFFFFFFFFFFFFELL) )
LABEL_19:
    sub_40408F(v17, 4 * v15, (__int64)&off_447C90);
  v18 = (const void *)a2[15];
  if ( v16 )
  {
    v19 = (__int64)sub_43C4F0(4 * v15);
    v20 = v15;
    if ( !v19 )
    {
      v17 = 2LL;
      goto LABEL_19;
    }
  }
  else
  {
    v19 = 2LL;
    v20 = 0LL;
  }
  lpMem = (LPVOID)v19;
  memcpy((void *)v19, v18, 4 * v15);
  v21 = a2[19];
  v22 = v21 << 6;
  v23 = 0LL;
  v47 = v20;
  if ( v21 >> 58 || v22 > 0x7FFFFFFFFFFFFFF8LL )
LABEL_26:
    sub_40408F(v23, v22, (__int64)&off_447C90);
  v24 = (const void *)a2[18];
  if ( v22 )
  {
    v25 = (__int64)sub_43C4F0(v22);
    v49 = v21;
    if ( !v25 )
    {
      v23 = 8LL;
      goto LABEL_26;
    }
  }
  else
  {
    v25 = 8LL;
    v49 = 0LL;
  }
  memcpy((void *)v25, v24, v22);
  v27 = a2[22];
  v28 = a2[23];
  result = a2[27];
  v30 = *a2;
  v42 = result;
  v43 = a2[28];
  if ( *a2 == 46 )
  {
    v31 = v25;
  }
  else
  {
    switch ( v30 )
    {
      case 0LL:
      case 5LL:
      case 6LL:
      case 7LL:
      case 10LL:
      case 11LL:
      case 12LL:
      case 13LL:
      case 14LL:
      case 15LL:
      case 16LL:
      case 17LL:
      case 18LL:
      case 19LL:
      case 20LL:
      case 21LL:
      case 22LL:
      case 23LL:
      case 24LL:
      case 25LL:
      case 26LL:
      case 27LL:
      case 28LL:
      case 29LL:
      case 30LL:
      case 39LL:
      case 44LL:
      case 45LL:
        v31 = v25;
        v32 = a2[1];
        v33 = (unsigned int)v32 >> 8;
        v34 = v32 >> 16;
        v35 = v32 & 0xFFFFFFFF00000000uLL;
        break;
      case 1LL:
      case 8LL:
      case 31LL:
        v31 = v25;
        v32 = a2[1];
        result = a2[2];
        v33 = (unsigned int)v32 >> 8;
        v34 = v32 >> 16;
        v35 = v32 & 0xFFFFFFFF00000000uLL;
        break;
      case 2LL:
      case 9LL:
      case 32LL:
      case 33LL:
      case 34LL:
      case 35LL:
      case 36LL:
      case 37LL:
      case 40LL:
      case 41LL:
      case 42LL:
      case 43LL:
        v31 = v25;
        LOBYTE(v32) = *((_BYTE *)a2 + 8);
        v35 = 0LL;
        LODWORD(v34) = 0;
        LOWORD(v33) = 0;
        break;
      case 3LL:
      case 38LL:
        v31 = v25;
        LOWORD(v32) = *((_WORD *)a2 + 4);
        v33 = BYTE1(v32);
        v35 = 0LL;
        LODWORD(v34) = 0;
        break;
      case 4LL:
        v31 = v25;
        LODWORD(v32) = *((_DWORD *)a2 + 2);
        v33 = (unsigned int)v32 >> 8;
        LODWORD(v34) = WORD1(v32);
        v35 = 0LL;
        break;
    }
    v2 = *(_OWORD *)(a2 + 3);
    v25 = a2[5];
    v36 = *((_OWORD *)a2 + 3);
    v26 = v35 | ((_DWORD)v34 << 16) | (unsigned int)(unsigned __int16)(((_WORD)v33 << 8) | (unsigned __int8)v32);
  }
  *(_DWORD *)(a1 + 232) = v51;
  *(_OWORD *)(a1 + 192) = v6;
  *(_QWORD *)(a1 + 208) = v39;
  *(_DWORD *)(a1 + 236) = *((_DWORD *)a2 + 59);
  *(_BYTE *)(a1 + 240) = *((_BYTE *)a2 + 240);
  *(_BYTE *)(a1 + 241) = v52;
  *(_QWORD *)(a1 + 160) = v37;
  *(_QWORD *)(a1 + 168) = v38;
  *(_QWORD *)(a1 + 64) = v44;
  *(_QWORD *)(a1 + 72) = v45;
  *(_QWORD *)(a1 + 80) = v41;
  *(_QWORD *)(a1 + 88) = v50;
  *(_QWORD *)(a1 + 96) = v46;
  *(_QWORD *)(a1 + 104) = v40;
  *(_QWORD *)(a1 + 112) = v47;
  *(_QWORD *)(a1 + 120) = lpMem;
  *(_QWORD *)(a1 + 128) = v15;
  *(_QWORD *)(a1 + 136) = v49;
  *(_QWORD *)(a1 + 144) = v31;
  *(_QWORD *)(a1 + 152) = v21;
  *(_QWORD *)(a1 + 176) = v27;
  *(_QWORD *)(a1 + 184) = v28;
  *(_QWORD *)(a1 + 216) = v42;
  *(_QWORD *)(a1 + 224) = v43;
  *(_QWORD *)a1 = v30;
  *(_QWORD *)(a1 + 8) = v26;
  *(_QWORD *)(a1 + 16) = result;
  *(_OWORD *)(a1 + 24) = v2;
  *(_QWORD *)(a1 + 40) = v25;
  *(_OWORD *)(a1 + 48) = v36;
  return result;
}
// 41FC4B: variable 'v26' is possibly undefined
// 41FC53: variable 'v2' is possibly undefined
// 41FC5F: variable 'v36' is possibly undefined
// 447C90: using guessed type char *off_447C90;

//----- (000000000041FD50) ----------------------------------------------------
int __fastcall sub_41FD50(__int64 *a1, __int64 a2, __int64 a3, _QWORD *a4)
{
  _UNKNOWN *__ptr32 *v4; // rdi
  char v5; // bl
  __int128 v6; // xmm7
  _QWORD *v7; // r13
  unsigned int v8; // r9d
  unsigned int v9; // r10d
  unsigned __int64 v10; // rcx
  unsigned __int64 v11; // rax
  unsigned __int64 v12; // r15
  char *v13; // rbx
  unsigned __int64 v14; // r8
  unsigned __int64 v15; // r12
  unsigned __int8 v16; // dl
  _UNKNOWN *__ptr32 *v17; // r11
  char *v18; // rax
  unsigned __int64 v19; // rdx
  unsigned __int64 v20; // rdi
  int v21; // ecx
  char v22; // r9
  bool v23; // cf
  unsigned __int64 v24; // r8
  unsigned __int64 v25; // rdi
  int v26; // ecx
  char v27; // si
  __int64 v28; // rax
  unsigned __int64 v29; // r14
  __int64 v30; // rsi
  unsigned __int8 v31; // al
  signed __int64 v32; // rcx
  unsigned __int64 v33; // r15
  unsigned __int64 v34; // rcx
  unsigned __int8 *v35; // rbx
  unsigned __int64 v36; // r14
  unsigned __int64 v37; // r11
  unsigned __int64 v38; // rax
  unsigned __int64 v39; // rax
  unsigned __int64 v40; // rdx
  unsigned __int64 v41; // rtt
  char v42; // al
  char *v43; // rdx
  unsigned __int64 v44; // rax
  int v45; // ecx
  char v46; // r9
  char *v47; // rdx
  unsigned __int64 v48; // rax
  int v49; // ecx
  char v50; // r9
  unsigned __int64 v51; // r15
  __int64 v52; // rdx
  int v53; // ecx
  __int64 v54; // rax
  int v55; // r9d
  char *v56; // r9
  unsigned __int64 v57; // rax
  int v58; // ecx
  char v59; // r10
  __int64 v60; // rax
  unsigned __int64 v61; // rax
  unsigned __int64 v62; // rax
  unsigned __int64 v63; // rdx
  unsigned __int64 v64; // rtt
  __int64 v65; // rax
  unsigned __int64 v66; // rdx
  _BYTE *v67; // rcx
  __int64 v68; // rax
  char *v69; // r9
  unsigned __int64 v70; // rax
  int v71; // ecx
  char v72; // r10
  unsigned __int64 v73; // r8
  unsigned __int64 v74; // rdi
  _BYTE *v75; // rcx
  __int64 v76; // r15
  unsigned __int64 v77; // rsi
  int v78; // ecx
  unsigned __int64 v79; // r9
  char *v80; // r10
  char v81; // r11
  unsigned __int64 v82; // rdx
  __int64 v83; // rdx
  __int64 v84; // rax
  unsigned __int64 v85; // rax
  unsigned __int64 v86; // rax
  unsigned __int64 v87; // rdx
  unsigned __int64 v88; // r15
  unsigned __int64 v89; // rcx
  unsigned __int64 v90; // rdi
  __int64 v91; // r13
  unsigned __int64 v92; // rbx
  int v93; // ecx
  char v94; // r11
  __int128 v95; // rt0
  unsigned __int64 v96; // r14
  int v97; // ecx
  char *v98; // r9
  char v99; // r10
  _QWORD *v100; // rbx
  char *v101; // r11
  unsigned __int64 v102; // r8
  __int64 v103; // r14
  int v104; // ecx
  char v105; // r10
  char *v106; // r13
  __int64 v107; // r9
  __int64 v108; // rsi
  int v109; // ecx
  char v110; // r10
  __int64 v111; // rdi
  unsigned __int64 v112; // r11
  __int64 v113; // rcx
  __int64 v114; // rdx
  unsigned __int64 v115; // rcx
  _UNKNOWN *__ptr32 *v116; // r15
  unsigned __int64 v117; // rax
  void *v118; // r14
  __int64 v119; // rsi
  __int64 v120; // rdi
  __int64 v121; // r12
  HANDLE v122; // rax
  LPVOID v123; // rbx
  _UNKNOWN *__ptr32 *v124; // r12
  __int64 v125; // r14
  __int64 v126; // rbx
  int v127; // edi
  int v128; // esi
  unsigned __int64 v129; // rax
  __int64 v130; // r15
  __int64 v131; // rax
  __int64 v132; // rax
  unsigned __int64 v133; // r14
  char *v134; // rax
  __int64 v135; // rcx
  unsigned __int64 v136; // rbx
  __int64 *v137; // r8
  void *v138; // rsi
  HANDLE ProcessHeap; // rax
  void *v140; // rsi
  HANDLE v141; // rax
  void *v142; // rsi
  HANDLE v143; // rax
  void *v144; // rsi
  HANDLE v145; // rax
  void *v146; // rsi
  HANDLE v147; // rax
  void *v148; // rsi
  unsigned __int64 v149; // rbx
  _QWORD *v150; // r14
  void *v151; // rdi
  HANDLE v152; // rax
  HANDLE v153; // rax
  _QWORD *v154; // r8
  __int64 v155; // r15
  __int64 v156; // rbx
  __int64 v157; // rsi
  __int64 v158; // rdi
  _QWORD *v159; // rdi
  unsigned __int64 v160; // r15
  __int64 v161; // rsi
  __int64 v162; // r13
  _QWORD *v163; // r8
  __int64 v164; // r14
  __int64 v165; // rbx
  __int64 v166; // r12
  __int64 v167; // rdi
  HANDLE v168; // rax
  void **v169; // rbx
  void *v170; // rsi
  HANDLE v171; // rax
  HANDLE v172; // rax
  HANDLE v173; // rax
  __int64 v174; // rbx
  unsigned __int64 v175; // rsi
  HANDLE v176; // rax
  HANDLE v177; // rax
  void *v178; // rsi
  HANDLE v179; // rax
  void *v180; // rsi
  HANDLE v181; // rax
  void *v182; // rsi
  HANDLE v183; // rax
  void *v184; // rsi
  HANDLE v185; // rax
  unsigned __int64 v187; // [rsp+30h] [rbp-50h]
  unsigned __int64 v188; // [rsp+38h] [rbp-48h]
  unsigned __int64 v189; // [rsp+40h] [rbp-40h]
  unsigned __int64 v190; // [rsp+48h] [rbp-38h]
  unsigned __int64 v191; // [rsp+50h] [rbp-30h]
  char **v194; // [rsp+68h] [rbp-18h]
  unsigned __int64 v195; // [rsp+70h] [rbp-10h]
  unsigned __int64 v196; // [rsp+78h] [rbp-8h]
  unsigned __int64 v197; // [rsp+80h] [rbp+0h]
  __int64 v198; // [rsp+88h] [rbp+8h] BYREF
  __int64 v199; // [rsp+90h] [rbp+10h]
  __int64 v200; // [rsp+98h] [rbp+18h]
  _QWORD v201[31]; // [rsp+A0h] [rbp+20h] BYREF
  __int128 v202; // [rsp+198h] [rbp+118h]
  __int64 v203; // [rsp+1A8h] [rbp+128h]
  unsigned __int64 v204; // [rsp+1B0h] [rbp+130h]
  _BYTE v205[25]; // [rsp+1B8h] [rbp+138h] BYREF
  char v206; // [rsp+1D1h] [rbp+151h]
  int v207; // [rsp+1D2h] [rbp+152h]
  __int128 v208; // [rsp+1D8h] [rbp+158h]
  unsigned __int64 v209; // [rsp+1E8h] [rbp+168h]
  unsigned __int64 v210; // [rsp+1F0h] [rbp+170h]
  unsigned __int64 v211; // [rsp+1F8h] [rbp+178h] BYREF
  LPVOID v212; // [rsp+200h] [rbp+180h]
  __int64 v213; // [rsp+208h] [rbp+188h]
  unsigned __int64 v214; // [rsp+210h] [rbp+190h] BYREF
  LPVOID lpMem; // [rsp+218h] [rbp+198h]
  unsigned __int64 v216; // [rsp+220h] [rbp+1A0h]
  unsigned __int64 v217; // [rsp+228h] [rbp+1A8h] BYREF
  LPVOID v218; // [rsp+230h] [rbp+1B0h]
  unsigned __int64 v219; // [rsp+238h] [rbp+1B8h]
  __int64 v220; // [rsp+240h] [rbp+1C0h]
  unsigned __int64 v221; // [rsp+248h] [rbp+1C8h]
  unsigned __int64 v222; // [rsp+250h] [rbp+1D0h]
  __int64 *v223; // [rsp+258h] [rbp+1D8h]

  v223 = a1;
  v217 = 0LL;
  v218 = (LPVOID)8;
  v219 = 0LL;
  v214 = 0LL;
  lpMem = (LPVOID)8;
  v216 = 0LL;
  v5 = *(_BYTE *)(a3 + 236);
  v6 = *(_OWORD *)(a3 + 176);
  v7 = v201;
  memcpy(v201, (const void *)a3, sizeof(v201));
  v202 = 0LL;
  v203 = 1LL;
  v204 = 1LL;
  memset(v205, 0, sizeof(v205));
  v206 = v5;
  v207 = 0;
  v208 = v6;
  v220 = 8LL;
  v194 = &off_447FA8;
  v10 = 0LL;
  v11 = 0LL;
  while ( 1 )
  {
    v221 = v10;
    if ( (v11 & 1) != 0 )
    {
      v11 = BYTE4(v201[29]);
      *(_OWORD *)(v7 + 31) = 0LL;
      v203 = 1LL;
      v204 = 1LL;
      v205[24] = 0;
      *(_OWORD *)(v7 + 35) = 0LL;
      v206 = v11;
      BYTE1(v207) = 0;
    }
    *(_QWORD *)&v205[16] = 0LL;
    LOBYTE(v207) = 0;
    HIWORD(v207) = 0;
    v12 = *((_QWORD *)&v208 + 1);
    if ( !*((_QWORD *)&v208 + 1) )
      goto LABEL_224;
    v222 = v11;
LABEL_6:
    v13 = (char *)v208;
    v14 = v12 - 1;
    v15 = v208 + 1;
    *(_QWORD *)&v208 = v208 + 1;
    *((_QWORD *)&v208 + 1) = v12 - 1;
    v16 = *v13;
    if ( !*v13 )
    {
      if ( v12 == 1 )
        goto LABEL_200;
      v24 = v12 - 2;
      v19 = 0LL;
      v25 = 0LL;
      v26 = 0;
      while ( 1 )
      {
        v27 = *(_BYTE *)v15;
        v28 = 6LL;
        if ( v26 == 63 && (unsigned __int8)v27 >= 2u )
        {
LABEL_203:
          LOBYTE(v8) = 0;
          v9 = 0;
          goto LABEL_204;
        }
        v29 = (unsigned __int64)(v27 & 0x7F) << v26;
        v30 = v15 + 1;
        v25 |= v29;
        if ( *(char *)v15 >= 0 )
          break;
        v26 += 7;
        ++v15;
        v23 = v24-- != 0;
        if ( !v23 )
        {
LABEL_199:
          v136 = (unsigned __int64)&v13[v12];
          v208 = v136;
          v15 = v136;
          goto LABEL_200;
        }
      }
      v23 = v24 < v25;
      v14 = v24 - v25;
      if ( v23 )
        goto LABEL_282;
      *(_QWORD *)&v208 = v30 + v25;
      *((_QWORD *)&v208 + 1) = v14;
      if ( !v25 )
        goto LABEL_282;
      v35 = (unsigned __int8 *)(v15 + 2);
      v36 = v25 - 1;
      switch ( *(_BYTE *)(v15 + 1) )
      {
        case 1:
          BYTE1(v207) = 1;
          v4 = jpt_41FF21;
LABEL_30:
          v33 = v221;
          goto LABEL_40;
        case 2:
          v19 = 0LL;
          v28 = 23LL;
          switch ( LOBYTE(v201[29]) )
          {
            case 1:
              v4 = jpt_41FF21;
              if ( !v36 )
                goto LABEL_263;
              v82 = *v35;
              break;
            case 2:
              v4 = jpt_41FF21;
              if ( v36 <= 1 )
                goto LABEL_263;
              v82 = *(unsigned __int16 *)v35;
              break;
            case 4:
              v4 = jpt_41FF21;
              if ( v36 <= 3 )
                goto LABEL_263;
              v82 = *(unsigned int *)v35;
              break;
            case 8:
              v4 = jpt_41FF21;
              if ( v36 <= 7 )
                goto LABEL_263;
              *(_QWORD *)&v95 = ((unsigned __int64)(*(unsigned __int16 *)(v15 + 6) | (*(unsigned __int8 *)(v15 + 8) << 16)) << 40) | ((unsigned __int64)*(unsigned int *)(v15 + 2) << 8);
              *((_QWORD *)&v95 + 1) = *(unsigned __int8 *)(v15 + 9);
              v82 = v95 >> 8;
              break;
            default:
              LOBYTE(v8) = v201[29];
              v9 = 0;
              v15 = v196;
              goto LABEL_204;
          }
          v8 = (unsigned int)v82 >> 8;
          v9 = WORD1(v82);
          v222 = HIDWORD(v82);
          v205[24] = v82 == 0xFFFFFFFFFFFFFFFFuLL >> (-8 * LOBYTE(v201[29]));
          v196 = v82;
          v202 = v82;
          goto LABEL_44;
        case 3:
          if ( WORD1(v201[29]) >= 5u )
            goto LABEL_102;
          if ( v25 == 1 )
            goto LABEL_263;
          v73 = v25 - 3;
          v74 = v25 - 4;
          v75 = (_BYTE *)(v15 + 2);
          v76 = 0LL;
          v222 = v15 + 2;
          while ( *v75 )
          {
            ++v75;
            ++v76;
            --v73;
            --v74;
            if ( v36 == v76 )
            {
              LOBYTE(v8) = 0;
              v28 = 19LL;
              v19 = 0LL;
              v9 = 0;
              v15 = v222;
              goto LABEL_204;
            }
          }
          v30 = v222 + v76 + 1;
          v96 = ~v76 + v36;
          if ( !v96 )
            goto LABEL_282;
          v19 = 0LL;
          v15 = 0LL;
          v97 = 0;
          v98 = (char *)(v222 + v76 + 1);
          break;
        case 4:
          if ( v25 == 1 )
            goto LABEL_263;
          v19 = 0LL;
          v77 = 0LL;
          v78 = 0;
          v79 = v25 - 1;
          v80 = (char *)(v15 + 2);
          v15 = v190;
          while ( 1 )
          {
            v81 = *v80;
            if ( v78 == 63 && (unsigned __int8)v81 >= 2u )
              break;
            v77 |= (unsigned __int64)(v81 & 0x7F) << v78;
            if ( v81 >= 0 )
            {
              v8 = (unsigned int)v77 >> 8;
              v9 = WORD1(v77);
              v222 = HIDWORD(v77);
              *(_QWORD *)&v205[16] = v77;
              v190 = v77;
              goto LABEL_103;
            }
            --v79;
            ++v80;
            v78 += 7;
            if ( !v79 )
            {
              v35 += v36;
LABEL_263:
              LOBYTE(v8) = 0;
              v28 = 19LL;
              v19 = 0LL;
              v9 = 0;
              v15 = (unsigned __int64)v35;
              goto LABEL_204;
            }
          }
          LOBYTE(v8) = 0;
          goto LABEL_202;
        default:
LABEL_102:
          v8 = (unsigned int)v35 >> 8;
          v9 = (unsigned int)v35 >> 16;
          v222 = HIDWORD(v35);
          goto LABEL_103;
      }
      while ( 1 )
      {
        v99 = *v98;
        if ( v97 == 63 && (unsigned __int8)v99 >= 2u )
          goto LABEL_203;
        v100 = v7;
        v101 = v98 + 1;
        v15 |= (unsigned __int64)(v99 & 0x7F) << v97;
        if ( v99 >= 0 )
          break;
        v97 += 7;
        --v74;
        ++v98;
        v23 = v73-- != 0;
        if ( !v23 )
        {
          v30 += v96;
LABEL_282:
          LOBYTE(v8) = 0;
          v28 = 19LL;
          v19 = 0LL;
          v9 = 0;
          v15 = v30;
          goto LABEL_204;
        }
      }
      if ( !v73 )
        goto LABEL_286;
      v102 = v73 + 1;
      v19 = 0LL;
      v103 = 0LL;
      v104 = 0;
      do
      {
        v105 = *v101;
        if ( v104 == 63 && (unsigned __int8)v105 >= 2u )
          goto LABEL_203;
        v106 = v101 + 1;
        v103 |= (unsigned __int64)(v105 & 0x7F) << v104;
        if ( v105 >= 0 )
        {
          if ( v74 )
          {
            v210 = v74 + 1;
            v19 = 0LL;
            v107 = 0LL;
            v108 = 0LL;
            v109 = 0;
            do
            {
              v110 = *v106;
              if ( v109 == 63 && (unsigned __int8)v110 >= 2u )
                goto LABEL_203;
              v108 |= (unsigned __int64)(*v106 & 0x7F) << v109;
              if ( v110 >= 0 )
              {
                v111 = v201[19];
                if ( v201[19] == v201[17] )
                  sub_415470(&v201[17], (__int64)&off_4478D0);
                v112 = v222;
                v8 = (unsigned int)v222 >> 8;
                v9 = WORD1(v222);
                v113 = v201[18];
                v114 = v111 << 6;
                *(_QWORD *)(v201[18] + v114) = 31LL;
                *(_QWORD *)(v113 + v114 + 8) = v112;
                *(_QWORD *)(v113 + v114 + 16) = v76;
                *(_BYTE *)(v113 + v114 + 24) = v15;
                *(_DWORD *)(v113 + v114 + 25) = v15 >> 8;
                *(_BYTE *)(v113 + v114 + 31) = HIBYTE(v15);
                *(_WORD *)(v113 + v114 + 29) = HIDWORD(v15) >> 8;
                *(_QWORD *)(v113 + v114 + 32) = v103;
                *(_QWORD *)(v113 + v114 + 40) = v108;
                *(_OWORD *)(v113 + v114 + 48) = 0LL;
                v201[19] = v111 + 1;
                v14 = *((_QWORD *)&v208 + 1);
                v222 = HIDWORD(v112);
                v7 = v100;
                goto LABEL_103;
              }
              ++v106;
              v109 += 7;
              ++v107;
            }
            while ( v74 != v107 );
            v106 = &v101[v210];
          }
          v137 = v223;
          LOBYTE(v8) = 0;
          v28 = 19LL;
          v19 = 0LL;
          v9 = 0;
          v15 = (unsigned __int64)v106;
          goto LABEL_205;
        }
        v104 += 7;
        ++v101;
        v23 = v74-- != 0;
      }
      while ( v23 );
      v101 = &v98[v102];
LABEL_286:
      LOBYTE(v8) = 0;
      v28 = 19LL;
      v19 = 0LL;
      v9 = 0;
      v15 = (unsigned __int64)v101;
LABEL_204:
      v137 = v223;
LABEL_205:
      v208 = 1uLL;
      v137[1] = v28 | ((unsigned __int8)v8 << 8) | (v19 << 32) | (v9 << 16);
      v137[2] = v15;
      *v137 = 0LL;
LABEL_206:
      if ( v201[8] )
      {
        v138 = (void *)v201[9];
        ProcessHeap = GetProcessHeap();
        LODWORD(v28) = HeapFree(ProcessHeap, 0, v138);
      }
      if ( v201[11] )
      {
        v140 = (void *)v201[12];
        v141 = GetProcessHeap();
        LODWORD(v28) = HeapFree(v141, 0, v140);
      }
      if ( v201[14] )
      {
        v142 = (void *)v201[15];
        v143 = GetProcessHeap();
        LODWORD(v28) = HeapFree(v143, 0, v142);
      }
      if ( v201[17] )
      {
        v144 = (void *)v201[18];
        v145 = GetProcessHeap();
        LODWORD(v28) = HeapFree(v145, 0, v144);
      }
      if ( v214 )
      {
        v146 = lpMem;
        v147 = GetProcessHeap();
        LODWORD(v28) = HeapFree(v147, 0, v146);
      }
      v148 = v218;
      v149 = v219;
      if ( v219 )
      {
        v150 = (char *)v218 + 8;
        do
        {
          if ( *v150 )
          {
            v151 = (void *)*(v150 - 1);
            v152 = GetProcessHeap();
            LODWORD(v28) = HeapFree(v152, 0, v151);
          }
          v150 += 4;
          --v149;
        }
        while ( v149 );
      }
      if ( v217 )
      {
LABEL_222:
        v153 = GetProcessHeap();
        LODWORD(v28) = HeapFree(v153, 0, v148);
      }
      return v28;
    }
    if ( v16 < BYTE1(v201[30]) )
      break;
    if ( !LOBYTE(v201[30]) )
      sub_408A70();
    v31 = (unsigned __int8)(v16 - BYTE1(v201[30])) / LOBYTE(v201[30]);
    v32 = SHIBYTE(v201[29])
        + (unsigned __int64)(unsigned __int8)((unsigned __int8)(v16 - BYTE1(v201[30])) % LOBYTE(v201[30]));
    v33 = v221;
    if ( v32 < 0 )
    {
      v37 = v204 + v32;
      v23 = v204 < -v32;
      v34 = 0LL;
      if ( !v23 )
        v34 = v37;
    }
    else
    {
      v34 = v204 + v32;
    }
    v204 = v34;
    if ( BYTE6(v201[29]) == 1 )
    {
      v202 = v31 * (unsigned __int64)BYTE5(v201[29]) + (unsigned __int64)v202;
    }
    else
    {
      if ( !BYTE6(v201[29]) )
        goto LABEL_294;
      v38 = *((_QWORD *)&v202 + 1) + v31;
      if ( HIDWORD(v38) )
      {
        v41 = v38;
        v39 = v38 / BYTE6(v201[29]);
        v40 = v41 % BYTE6(v201[29]);
      }
      else
      {
        v40 = (unsigned int)v38 % BYTE6(v201[29]);
        v39 = (unsigned int)v38 / BYTE6(v201[29]);
      }
      *(_QWORD *)&v202 = BYTE5(v201[29]) * v39 + v202;
      *((_QWORD *)&v202 + 1) = v40;
    }
LABEL_40:
    if ( v205[24] )
    {
      if ( BYTE1(v207) )
      {
        v42 = BYTE4(v201[29]);
        *(_OWORD *)(v7 + 31) = 0LL;
        v203 = 1LL;
        v204 = 1LL;
        *(_OWORD *)((char *)v7 + 289) = 0LL;
        *(_OWORD *)(v7 + 35) = 0LL;
        v206 = v42;
        v207 = 0;
      }
      else
      {
        *(_QWORD *)&v205[16] = 0LL;
        LOBYTE(v207) = 0;
        HIWORD(v207) = 0;
      }
      goto LABEL_44;
    }
    if ( BYTE1(v207) )
    {
      if ( v33 )
      {
        v115 = v33;
        v116 = v4;
        v117 = v214;
        v118 = lpMem;
        v119 = *(_QWORD *)lpMem;
        v120 = v202;
        v214 = 0LL;
        lpMem = (LPVOID)8;
        v216 = 0LL;
        if ( v117 <= v115 )
        {
          v123 = v118;
        }
        else
        {
          v121 = 24 * v115;
          v122 = GetProcessHeap();
          v123 = HeapReAlloc(v122, 0, v118, v121);
          if ( !v123 )
            sub_4040E9(8LL, v121);
        }
        v133 = v219;
        if ( v219 == v217 )
          sub_41F5E0((__int64 *)&v217, (__int64)&off_448368);
        v134 = (char *)v218;
        v135 = 32 * v133;
        *(_QWORD *)((char *)v218 + v135) = v123;
        *(_QWORD *)&v134[v135 + 8] = v221;
        *(_QWORD *)&v134[v135 + 16] = v119;
        *(_QWORD *)&v134[v135 + 24] = v120;
        v219 = v133 + 1;
        v220 = 8LL;
        v4 = v116;
        v10 = 0LL;
        v11 = BYTE1(v207);
      }
      else
      {
        v10 = 0LL;
        v11 = BYTE1(v207);
      }
    }
    else
    {
      v124 = v4;
      v125 = v202;
      v126 = v203;
      v127 = v204;
      v128 = *(_DWORD *)v205;
      v129 = v33;
      v130 = 3 * v33;
      if ( v129 && v220 + 8 * v130 != 24 && *(_QWORD *)(v220 + 8 * v130 - 24) == (_QWORD)v202 )
      {
        v131 = v220 + 8 * v130;
        *(_QWORD *)(v131 - 16) = v203;
        *(_DWORD *)(v131 - 8) = v127;
        *(_DWORD *)(v131 - 4) = v128;
        v4 = v124;
        v10 = v221;
        v11 = BYTE1(v207);
      }
      else
      {
        if ( v221 == v214 )
        {
          sub_426260(&v214, (__int64)&off_448350);
          v220 = (__int64)lpMem;
        }
        v132 = v220;
        *(_QWORD *)(v220 + 8 * v130) = v125;
        *(_QWORD *)(v132 + 8 * v130 + 8) = v126;
        *(_DWORD *)(v132 + 8 * v130 + 16) = v127;
        *(_DWORD *)(v132 + 8 * v130 + 20) = v128;
        v10 = v221 + 1;
        v216 = v221 + 1;
        v4 = v124;
        v11 = BYTE1(v207);
      }
    }
  }
  switch ( *v13 )
  {
    case 1:
      goto LABEL_30;
    case 2:
      if ( v12 == 1 )
        goto LABEL_200;
      v17 = v4;
      v14 = v12 - 2;
      v18 = v13 + 2;
      v19 = 0LL;
      v20 = 0LL;
      v21 = 0;
      v15 = v195;
      while ( 2 )
      {
        v22 = *(v18 - 1);
        if ( v21 == 63 && (unsigned __int8)v22 >= 2u )
          goto LABEL_232;
        v20 |= (unsigned __int64)(v22 & 0x7F) << v21;
        if ( v22 < 0 )
        {
          v21 += 7;
          ++v18;
          v23 = v14-- != 0;
          if ( !v23 )
            goto LABEL_199;
          continue;
        }
        break;
      }
      *(_QWORD *)&v208 = v18;
      *((_QWORD *)&v208 + 1) = v14;
      v8 = (unsigned int)v20 >> 8;
      v9 = WORD1(v20);
      v222 = HIDWORD(v20);
      if ( BYTE6(v201[29]) == 1 )
      {
        v202 = v20 * BYTE5(v201[29]) + (unsigned __int64)v202;
      }
      else
      {
        if ( !BYTE6(v201[29]) )
LABEL_294:
          sub_406390((__int64)v194);
        v85 = v20 + *((_QWORD *)&v202 + 1);
        if ( (v20 + *((_QWORD *)&v202 + 1)) >> 32 )
        {
          v86 = v85 / BYTE6(v201[29]);
          v87 = (v20 + *((_QWORD *)&v202 + 1)) % BYTE6(v201[29]);
        }
        else
        {
          v87 = (unsigned int)v85 % BYTE6(v201[29]);
          v86 = (unsigned int)v85 / BYTE6(v201[29]);
        }
        *(_QWORD *)&v202 = BYTE5(v201[29]) * v86 + v202;
        *((_QWORD *)&v202 + 1) = v87;
      }
      v195 = v20;
      v4 = v17;
      goto LABEL_44;
    case 3:
      v51 = v12 - 1;
      v52 = 0LL;
      v53 = 0;
      v54 = 0LL;
      v15 = v209;
      do
      {
        if ( v51 == v52 )
        {
          v15 = (unsigned __int64)&v13[v52 + 1];
LABEL_200:
          LOBYTE(v8) = 0;
          v28 = 19LL;
LABEL_201:
          v19 = 0LL;
LABEL_202:
          v9 = 0;
          goto LABEL_204;
        }
        --v14;
        *(_QWORD *)&v208 = &v13[v52 + 2];
        *((_QWORD *)&v208 + 1) = v14;
        v55 = (unsigned __int8)v13[v52 + 1];
        if ( v53 == 63 && v55 != 127 && v13[v52 + 1] )
        {
          LOBYTE(v8) = 0;
          v28 = 7LL;
          goto LABEL_201;
        }
        v54 |= (unsigned __int64)(v55 & 0x7F) << v53;
        v53 += 7;
        ++v52;
      }
      while ( (v55 & 0x80u) != 0 );
      v83 = -1LL << v53;
      if ( (unsigned __int8)v55 < 0x40u )
        v83 = 0LL;
      if ( v53 >= 64 )
        v83 = 0LL;
      v84 = v83 | v54;
      v8 = (unsigned int)v84 >> 8;
      v9 = WORD1(v84);
      v222 = HIDWORD(v84);
      if ( v84 < 0 )
      {
        if ( v204 >= -v84 )
          v204 += v84;
        else
          v204 = 0LL;
        v209 = v84;
      }
      else
      {
        v204 += v84;
        v209 = v84;
      }
LABEL_44:
      v12 = v14;
      if ( v14 )
        goto LABEL_6;
LABEL_224:
      if ( v219 >= 2 )
      {
        if ( v219 >= 0x15 )
          sub_42C980(v218, v219);
        else
          sub_42CAB0(v218, v219);
      }
      v211 = 0LL;
      v212 = (LPVOID)8;
      v213 = 0LL;
      if ( WORD1(v201[29]) >= 5u )
      {
        if ( !v201[19] )
          goto LABEL_233;
        v154 = (_QWORD *)v201[18];
LABEL_230:
        sub_42CBF0(&v198, a2, v154, (__int64)v201, a4);
        v155 = v198;
        v156 = v199;
        v157 = v200;
        if ( v198 != 0x8000000000000000uLL )
        {
          sub_426260(&v211, (__int64)&off_448398);
          goto LABEL_236;
        }
        v28 = (__int64)v223;
        v223[1] = v199;
        *(_QWORD *)(v28 + 16) = v157;
        *(_QWORD *)v28 = 0LL;
        v158 = 8LL;
LABEL_257:
        if ( v211 )
        {
          v172 = GetProcessHeap();
          LODWORD(v28) = HeapFree(v172, 0, (LPVOID)v158);
        }
        goto LABEL_206;
      }
      if ( LODWORD(v201[0]) != 46 )
      {
        v154 = v201;
        goto LABEL_230;
      }
LABEL_233:
      sub_426260(&v211, (__int64)&off_448380);
      v156 = 1LL;
      v155 = 0LL;
      v157 = 0LL;
LABEL_236:
      v159 = v212;
      *(_QWORD *)v212 = v155;
      v159[1] = v156;
      v159[2] = v157;
      v213 = 1LL;
      v160 = 1LL;
      v161 = 64LL;
      v162 = 5LL;
      while ( 2 )
      {
        if ( WORD1(v201[29]) >= 5u )
        {
          if ( v201[19] <= v160 )
            break;
          v163 = (_QWORD *)(v161 + v201[18]);
          goto LABEL_245;
        }
        if ( v160 )
        {
          if ( v160 - 1 >= v201[19] )
            break;
          v163 = (_QWORD *)(v201[18] + ((v160 - 1) << 6));
          goto LABEL_245;
        }
        v163 = v201;
        if ( LODWORD(v201[0]) != 46 )
        {
LABEL_245:
          sub_42CBF0(&v198, a2, v163, (__int64)v201, a4);
          v164 = v198;
          v165 = v199;
          v166 = v200;
          if ( v198 == 0x8000000000000000uLL )
          {
            v28 = (__int64)v223;
            v223[1] = v199;
            *(_QWORD *)(v28 + 16) = v166;
            v158 = (__int64)v212;
            *(_QWORD *)v28 = 0LL;
            if ( v160 )
            {
              v169 = (void **)(v158 + 8);
              do
              {
                if ( *(v169 - 1) )
                {
                  v170 = *v169;
                  v171 = GetProcessHeap();
                  LODWORD(v28) = HeapFree(v171, 0, v170);
                }
                v169 += 3;
                --v160;
              }
              while ( v160 );
            }
            goto LABEL_257;
          }
          if ( v160 == v211 )
          {
            sub_426260(&v211, (__int64)&off_4483B0);
            v159 = v212;
          }
          v159[v162 - 2] = v164;
          v159[v162 - 1] = v165;
          v159[v162] = v166;
          v213 = ++v160;
          v161 += 64LL;
          v162 += 3LL;
          continue;
        }
        break;
      }
      v167 = (__int64)v212;
      if ( v211 > v160 )
      {
        if ( v160 )
        {
          v168 = GetProcessHeap();
          v167 = (__int64)HeapReAlloc(v168, 0, (LPVOID)v167, 24 * v160);
          if ( !v167 )
            sub_4040E9(8LL, 24 * v160);
        }
        else
        {
          v173 = GetProcessHeap();
          HeapFree(v173, 0, (LPVOID)v167);
          v167 = 8LL;
        }
      }
      v174 = (__int64)v218;
      v175 = v219;
      if ( v217 > v219 )
      {
        if ( v219 )
        {
          v176 = GetProcessHeap();
          v174 = (__int64)HeapReAlloc(v176, 0, (LPVOID)v174, 32 * v175);
          if ( !v174 )
            sub_4040E9(8LL, 32 * v175);
        }
        else
        {
          v177 = GetProcessHeap();
          HeapFree(v177, 0, (LPVOID)v174);
          v174 = 8LL;
        }
      }
      v28 = (__int64)v223;
      *v223 = v167;
      *(_QWORD *)(v28 + 8) = v160;
      *(_QWORD *)(v28 + 16) = v174;
      *(_QWORD *)(v28 + 24) = v175;
      if ( v201[8] )
      {
        v178 = (void *)v201[9];
        v179 = GetProcessHeap();
        LODWORD(v28) = HeapFree(v179, 0, v178);
      }
      if ( v201[11] )
      {
        v180 = (void *)v201[12];
        v181 = GetProcessHeap();
        LODWORD(v28) = HeapFree(v181, 0, v180);
      }
      if ( v201[14] )
      {
        v182 = (void *)v201[15];
        v183 = GetProcessHeap();
        LODWORD(v28) = HeapFree(v183, 0, v182);
      }
      if ( v201[17] )
      {
        v184 = (void *)v201[18];
        v185 = GetProcessHeap();
        LODWORD(v28) = HeapFree(v185, 0, v184);
      }
      if ( v214 )
      {
        v148 = lpMem;
        goto LABEL_222;
      }
      return v28;
    case 4:
      if ( v12 == 1 )
        goto LABEL_200;
      v14 = v12 - 2;
      v56 = v13 + 2;
      v19 = 0LL;
      v57 = 0LL;
      v58 = 0;
      v15 = v189;
      while ( 1 )
      {
        v59 = *(v56 - 1);
        if ( v58 == 63 && (unsigned __int8)v59 >= 2u )
          break;
        v57 |= (unsigned __int64)(v59 & 0x7F) << v58;
        if ( v59 >= 0 )
        {
          *(_QWORD *)&v208 = v56;
          *((_QWORD *)&v208 + 1) = v14;
          v8 = (unsigned int)v57 >> 8;
          v9 = WORD1(v57);
          v222 = HIDWORD(v57);
          v203 = v57;
          v189 = v57;
          goto LABEL_44;
        }
        v58 += 7;
        ++v56;
        v23 = v14-- != 0;
        if ( !v23 )
          goto LABEL_199;
      }
LABEL_232:
      v28 = 6LL;
      LOBYTE(v8) = 0;
      goto LABEL_202;
    case 5:
      if ( v12 == 1 )
        goto LABEL_200;
      v14 = v12 - 2;
      v47 = v13 + 2;
      v48 = 0LL;
      v49 = 0;
      v15 = v188;
      while ( 1 )
      {
        v50 = *(v47 - 1);
        if ( v49 == 63 && (unsigned __int8)v50 >= 2u )
          break;
        v48 |= (unsigned __int64)(v50 & 0x7F) << v49;
        if ( v50 >= 0 )
        {
          *(_QWORD *)&v208 = v47;
          *((_QWORD *)&v208 + 1) = v14;
          v8 = (unsigned int)v48 >> 8;
          v9 = WORD1(v48);
          v222 = HIDWORD(v48);
          *(_QWORD *)v205 = v48;
          v188 = v48;
          goto LABEL_44;
        }
        v49 += 7;
        ++v47;
        v23 = v14-- != 0;
        if ( !v23 )
          goto LABEL_199;
      }
      *(_QWORD *)&v208 = v47;
      goto LABEL_261;
    case 6:
      v206 ^= 1u;
      goto LABEL_44;
    case 7:
      LOBYTE(v207) = 1;
      goto LABEL_44;
    case 8:
      if ( LOBYTE(v201[30]) )
      {
        v60 = (unsigned __int8)((unsigned __int8)~BYTE1(v201[30]) / LOBYTE(v201[30]));
        if ( BYTE6(v201[29]) == 1 )
        {
          v202 = v60 * BYTE5(v201[29]) + (unsigned __int64)v202;
          goto LABEL_44;
        }
        if ( BYTE6(v201[29]) )
        {
          v61 = *((_QWORD *)&v202 + 1) + v60;
          if ( HIDWORD(v61) )
          {
            v64 = v61;
            v62 = v61 / BYTE6(v201[29]);
            v63 = v64 % BYTE6(v201[29]);
          }
          else
          {
            v63 = (unsigned int)v61 % BYTE6(v201[29]);
            v62 = (unsigned int)v61 / BYTE6(v201[29]);
          }
          *(_QWORD *)&v202 = BYTE5(v201[29]) * v62 + v202;
          *((_QWORD *)&v202 + 1) = v63;
          goto LABEL_44;
        }
      }
      else
      {
        v194 = &off_447FC0;
      }
      goto LABEL_294;
    case 9:
      if ( v14 > 1 )
      {
        *(_QWORD *)&v208 = v13 + 3;
        *((_QWORD *)&v208 + 1) = v12 - 3;
        v65 = *(unsigned __int16 *)(v13 + 1);
        v202 = (unsigned __int64)(v65 + v202);
        v8 = (unsigned int)v65 >> 8;
        v14 = v12 - 3;
        goto LABEL_44;
      }
      LOWORD(v198) = 0;
      *(_DWORD *)((char *)&v198 + 2) = 0;
      v9 = 0;
      LOBYTE(v8) = 0;
      v28 = 19LL;
      v19 = 0LL;
      goto LABEL_204;
    case 10:
      BYTE2(v207) = 1;
      goto LABEL_44;
    case 11:
      HIBYTE(v207) = 1;
      goto LABEL_44;
    case 12:
      if ( v12 == 1 )
        goto LABEL_200;
      v14 = v12 - 2;
      v43 = v13 + 2;
      v44 = 0LL;
      v45 = 0;
      v15 = v187;
      while ( 1 )
      {
        v46 = *(v43 - 1);
        if ( v45 == 63 && (unsigned __int8)v46 >= 2u )
          break;
        v44 |= (unsigned __int64)(v46 & 0x7F) << v45;
        if ( v46 >= 0 )
        {
          *(_QWORD *)&v208 = v43;
          *((_QWORD *)&v208 + 1) = v14;
          v8 = (unsigned int)v44 >> 8;
          v9 = WORD1(v44);
          v222 = HIDWORD(v44);
          *(_QWORD *)&v205[8] = v44;
          v187 = v44;
          goto LABEL_44;
        }
        v45 += 7;
        ++v43;
        v23 = v14-- != 0;
        if ( !v23 )
          goto LABEL_199;
      }
      *(_QWORD *)&v208 = v43;
      *((_QWORD *)&v208 + 1) = v14;
LABEL_261:
      LOBYTE(v8) = 0;
      v28 = 6LL;
      goto LABEL_201;
    default:
      v66 = (unsigned __int8)(v16 - 1);
      if ( v201[21] < v66 )
      {
        v28 = 19LL;
        v19 = v222;
        v15 = v201[20];
        goto LABEL_204;
      }
      v67 = (_BYTE *)(v66 + v201[20]);
      if ( v201[21] == v66 )
      {
        LOBYTE(v8) = 0;
        v28 = 19LL;
        v19 = 0LL;
        v9 = 0;
        v15 = (unsigned __int64)v67;
        goto LABEL_204;
      }
      v68 = (unsigned __int8)*v67;
      if ( !*v67 )
        goto LABEL_44;
      if ( (_DWORD)v68 != 1 )
      {
        v30 = v15;
        v88 = v12 - 1;
        v89 = 0LL;
        do
        {
          if ( !v88 )
            goto LABEL_282;
          v210 = v89;
          v90 = v88 - 1;
          v91 = v30 + 1;
          v19 = 0LL;
          v92 = 0LL;
          v93 = 0;
          while ( 1 )
          {
            v94 = *(_BYTE *)(v91 - 1);
            if ( v93 == 63 && (unsigned __int8)v94 >= 2u )
            {
              v28 = 6LL;
              LOBYTE(v8) = 0;
              v9 = 0;
              v15 = v197;
              goto LABEL_204;
            }
            v92 |= (unsigned __int64)(*(_BYTE *)(v91 - 1) & 0x7F) << v93;
            if ( v94 >= 0 )
              break;
            v93 += 7;
            ++v91;
            v23 = v90-- != 0;
            if ( !v23 )
            {
              v30 += v88;
              v208 = (unsigned __int64)v30;
              goto LABEL_282;
            }
          }
          *(_QWORD *)&v208 = v91;
          *((_QWORD *)&v208 + 1) = v90;
          v89 = v210 + 1;
          v30 = v91;
          v88 = v90;
          v197 = v92;
        }
        while ( v210 + 1 != v68 );
        if ( v14 >= v91 - v15 )
        {
          v8 = (unsigned int)v15 >> 8;
          v9 = WORD1(v15);
          v14 = v90;
          v197 = v92;
          v222 = HIDWORD(v15);
          v7 = v201;
LABEL_103:
          v4 = jpt_41FF21;
          goto LABEL_44;
        }
        v28 = 19LL;
        v19 = v222;
        goto LABEL_204;
      }
      if ( v12 != 1 )
      {
        v14 = v12 - 2;
        v69 = v13 + 2;
        v19 = 0LL;
        v70 = 0LL;
        v71 = 0;
        while ( 1 )
        {
          v72 = *(v69 - 1);
          if ( v71 == 63 && (unsigned __int8)v72 >= 2u )
            break;
          v70 |= (unsigned __int64)(v72 & 0x7F) << v71;
          if ( v72 >= 0 )
          {
            *(_QWORD *)&v208 = v69;
            *((_QWORD *)&v208 + 1) = v14;
            v8 = (unsigned int)v70 >> 8;
            v9 = WORD1(v70);
            v222 = HIDWORD(v70);
            v191 = v70;
            goto LABEL_44;
          }
          v71 += 7;
          ++v69;
          v23 = v14-- != 0;
          if ( !v23 )
            goto LABEL_199;
        }
        v28 = 6LL;
        LOBYTE(v8) = 0;
        v9 = 0;
        v15 = v191;
        goto LABEL_204;
      }
      goto LABEL_200;
  }
}
// 41FF2C: variable 'v4' is possibly undefined
// 41FF3D: variable 'v195' is possibly undefined
// 4201C5: variable 'v187' is possibly undefined
// 420224: variable 'v188' is possibly undefined
// 420300: variable 'v189' is possibly undefined
// 42052B: variable 'v190' is possibly undefined
// 420DA4: variable 'v8' is possibly undefined
// 420DB2: variable 'v9' is possibly undefined
// 421244: variable 'v197' is possibly undefined
// 42127F: variable 'v191' is possibly undefined
// 421464: variable 'v196' is possibly undefined
// 440CD8: using guessed type _UNKNOWN *__ptr32 jpt_41FF21[12];
// 4478D0: using guessed type char *off_4478D0;
// 447FA8: using guessed type char *off_447FA8;
// 447FC0: using guessed type char *off_447FC0;
// 448350: using guessed type char *off_448350;
// 448368: using guessed type char *off_448368;
// 448380: using guessed type char *off_448380;
// 448398: using guessed type char *off_448398;
// 4483B0: using guessed type char *off_4483B0;

//----- (00000000004215A0) ----------------------------------------------------
void __fastcall sub_4215A0(__int64 a1)
{
  void **v1; // rdi
  __int64 v3; // r14
  void **v4; // r15
  void *v5; // rbx
  HANDLE ProcessHeap; // rax
  HANDLE v7; // rax
  __int64 v8; // rbx
  _QWORD *v9; // rsi
  _QWORD *v10; // r14
  void *v11; // rdi
  HANDLE v12; // rax
  HANDLE v13; // rax

  v1 = *(void ***)a1;
  if ( *(_QWORD *)a1 )
  {
    v3 = *(_QWORD *)(a1 + 8);
    if ( v3 )
    {
      v4 = v1 + 1;
      do
      {
        if ( *(v4 - 1) )
        {
          v5 = *v4;
          ProcessHeap = GetProcessHeap();
          HeapFree(ProcessHeap, 0, v5);
        }
        v4 += 3;
        --v3;
      }
      while ( v3 );
      v7 = GetProcessHeap();
      HeapFree(v7, 0, v1);
    }
    v8 = *(_QWORD *)(a1 + 24);
    if ( v8 )
    {
      v9 = *(_QWORD **)(a1 + 16);
      v10 = v9 + 1;
      do
      {
        if ( *v10 )
        {
          v11 = (void *)*(v10 - 1);
          v12 = GetProcessHeap();
          HeapFree(v12, 0, v11);
        }
        v10 += 4;
        --v8;
      }
      while ( v8 );
      v13 = GetProcessHeap();
      HeapFree(v13, 0, v9);
    }
  }
}

//----- (0000000000421680) ----------------------------------------------------
__int64 __fastcall sub_421680(__int64 a1, __int64 *a2)
{
  _QWORD *v3; // rsi
  unsigned int v4; // eax
  __int64 v5; // rax
  __int64 v6; // rax
  __int64 v7; // rdx
  __int64 v8; // rax
  __int64 v9; // rdx
  __int64 v10; // rdx
  __int64 v11; // rax
  unsigned __int64 v12; // rdx
  __int64 v13; // rax
  unsigned __int64 v14; // rdx
  __int64 v15; // rax
  unsigned __int64 v16; // rdx
  __int64 v17; // rax
  unsigned __int64 v18; // rdx
  __int64 v19; // rax
  unsigned __int64 v20; // rdx
  __int64 v21; // rax
  unsigned __int64 v22; // rdx
  __int64 v23; // rax
  unsigned __int64 v24; // rdx
  __int64 v25; // rax
  unsigned __int64 v26; // rdx
  __int64 v27; // rax
  unsigned __int64 v28; // rdx
  __int64 v29; // rax
  unsigned __int64 v30; // rdx
  __int64 v31; // rax
  unsigned __int64 v32; // rdx
  __int64 v33; // rdx
  __int64 result; // rax

  v3 = (_QWORD *)a1;
  v4 = *((unsigned __int16 *)a2 + 12);
  if ( v4 > 0x2130 )
  {
    switch ( v4 )
    {
      case 0x2131u:
        if ( sub_42C880(a2) == 1 )
        {
          v3[1] = v33;
          result = 45LL;
          goto LABEL_81;
        }
        break;
      case 0x2132u:
LABEL_27:
        if ( *a2 == 10 )
        {
          *(_QWORD *)(a1 + 8) = a2[1];
          result = 23LL;
          goto LABEL_81;
        }
LABEL_56:
        while ( 2 )
        {
          switch ( a1 )
          {
            case 0LL:
              *(_OWORD *)(v3 + 1) = *(_OWORD *)(a2 + 1);
              result = 1LL;
              break;
            case 1LL:
              *((_BYTE *)v3 + 8) = *((_BYTE *)a2 + 8);
              result = 2LL;
              break;
            case 2LL:
              *((_WORD *)v3 + 4) = *((_WORD *)a2 + 4);
              result = 3LL;
              break;
            case 3LL:
              *((_DWORD *)v3 + 2) = *((_DWORD *)a2 + 2);
              result = 4LL;
              break;
            case 4LL:
              v3[1] = a2[1];
              result = 5LL;
              break;
            case 5LL:
              v8 = a2[1];
              goto LABEL_76;
            case 6LL:
              goto LABEL_68;
            case 7LL:
              goto LABEL_80;
            default:
              continue;
          }
          goto LABEL_81;
        }
      case 0x2133u:
LABEL_15:
        if ( *a2 == 10 )
        {
          *(_QWORD *)(a1 + 8) = a2[1];
          result = 11LL;
          goto LABEL_81;
        }
        goto LABEL_56;
    }
LABEL_67:
    v3[1] = a2[1];
    result = 0LL;
    goto LABEL_81;
  }
  switch ( *((_WORD *)a2 + 12) )
  {
    case 2:
    case 0x19:
    case 0x2A:
    case 0x40:
    case 0x46:
    case 0x48:
    case 0x4A:
    case 0x4D:
      v6 = *a2;
      if ( *a2 == 1 || (_DWORD)v6 == 8 )
        goto LABEL_80;
      if ( (_DWORD)v6 == 10 )
        goto LABEL_79;
      goto LABEL_56;
    case 9:
      v19 = sub_42C880(a2);
      if ( v20 >= 0x100 || v19 != 1 )
        goto LABEL_67;
      *((_BYTE *)v3 + 8) = v20;
      result = 43LL;
      break;
    case 0xB:
    case 0xC:
    case 0xD:
      a1 = *a2 - 1;
      switch ( *a2 )
      {
        case 1LL:
        case 8LL:
          goto LABEL_80;
        case 2LL:
          v8 = *((unsigned __int8 *)a2 + 8);
          goto LABEL_86;
        case 3LL:
          v8 = *((unsigned __int16 *)a2 + 4);
          goto LABEL_86;
        case 4LL:
          v8 = *((unsigned int *)a2 + 2);
          goto LABEL_86;
        case 5LL:
        case 7LL:
LABEL_68:
          v8 = a2[1];
          goto LABEL_86;
        case 6LL:
          v8 = a2[1];
          if ( v8 >= 0 )
          {
LABEL_86:
            v3[1] = v8;
            result = 7LL;
          }
          else
          {
LABEL_76:
            v3[1] = v8;
            result = 6LL;
          }
          break;
        default:
          goto LABEL_56;
      }
      break;
    case 0x10:
      if ( *a2 != 10 )
        goto LABEL_56;
      *(_QWORD *)(a1 + 8) = a2[1];
      result = 16LL;
      break;
    case 0x12:
    case 0x39:
    case 0x3B:
    case 0x57:
    case 0x59:
      if ( sub_42C880(a2) != 1 )
        goto LABEL_67;
      goto LABEL_32;
    case 0x13:
      v23 = sub_42C880(a2);
      if ( v24 >= 0x10000 || v23 != 1 )
        goto LABEL_67;
      *((_WORD *)v3 + 4) = v24;
      result = 38LL;
      break;
    case 0x17:
      v25 = sub_42C880(a2);
      if ( v26 >= 0x100 || v25 != 1 )
        goto LABEL_67;
      *((_BYTE *)v3 + 8) = v26;
      result = 36LL;
      break;
    case 0x20:
      v27 = sub_42C880(a2);
      if ( v28 >= 0x100 || v27 != 1 )
        goto LABEL_67;
      *((_BYTE *)v3 + 8) = v28;
      result = 42LL;
      break;
    case 0x22:
    case 0x2F:
    case 0x37:
    case 0x4E:
    case 0x4F:
    case 0x50:
    case 0x71:
    case 0x7E:
    case 0x7F:
    case 0x83:
    case 0x84:
    case 0x85:
    case 0x86:
      v5 = *a2;
      if ( *a2 != 1 )
        goto LABEL_4;
      goto LABEL_80;
    case 0x2C:
    case 0x55:
      if ( *a2 != 10 )
        goto LABEL_56;
      *(_QWORD *)(a1 + 8) = a2[1];
      result = 22LL;
      break;
    case 0x2E:
    case 0x51:
      if ( sub_42C880(a2) == 1 )
        goto LABEL_32;
      if ( *a2 != 8 && (unsigned int)*a2 != 1 )
        goto LABEL_56;
      goto LABEL_80;
    case 0x32:
      v13 = sub_42C880(a2);
      if ( v14 >= 0x100 || v13 != 1 )
        goto LABEL_67;
      *((_BYTE *)v3 + 8) = v14;
      result = 35LL;
      break;
    case 0x33:
      if ( sub_42C880(a2) != 1 )
        goto LABEL_67;
      v3[1] = v10;
      result = 39LL;
      break;
    case 0x36:
      v15 = sub_42C880(a2);
      if ( v16 >= 0x100 || v15 != 1 )
        goto LABEL_67;
      *((_BYTE *)v3 + 8) = v16;
      result = 41LL;
      break;
    case 0x38:
      if ( sub_42C880(a2) == 1 )
      {
LABEL_32:
        v3[1] = v7;
        result = 7LL;
        break;
      }
      v5 = *a2;
      if ( *a2 == 1 )
        goto LABEL_80;
      if ( (_DWORD)v5 == 10 )
      {
LABEL_79:
        v3[1] = a2[1];
        result = 17LL;
      }
      else
      {
LABEL_4:
        if ( (_DWORD)v5 != 8 )
          goto LABEL_56;
LABEL_80:
        *(_OWORD *)(v3 + 1) = *(_OWORD *)(a2 + 1);
        result = 8LL;
      }
      break;
    case 0x3A:
    case 0x58:
      if ( sub_42C880(a2) != 1 )
        goto LABEL_67;
      v3[1] = v9;
      result = 44LL;
      break;
    case 0x3E:
      v21 = sub_42C880(a2);
      if ( v22 >= 0x100 || v21 != 1 )
        goto LABEL_67;
      *((_BYTE *)v3 + 8) = v22;
      result = 32LL;
      break;
    case 0x42:
      v29 = sub_42C880(a2);
      if ( v30 >= 0x100 || v29 != 1 )
        goto LABEL_67;
      *((_BYTE *)v3 + 8) = v30;
      result = 40LL;
      break;
    case 0x43:
      if ( *a2 != 10 )
        goto LABEL_56;
      *(_QWORD *)(a1 + 8) = a2[1];
      result = 20LL;
      break;
    case 0x4C:
      v17 = sub_42C880(a2);
      if ( v18 >= 0x100 || v17 != 1 )
        goto LABEL_67;
      *((_BYTE *)v3 + 8) = v18;
      result = 37LL;
      break;
    case 0x5E:
      v31 = sub_42C880(a2);
      if ( v32 >= 0x100 || v31 != 1 )
        goto LABEL_67;
      *((_BYTE *)v3 + 8) = v32;
      result = 33LL;
      break;
    case 0x65:
      v11 = sub_42C880(a2);
      if ( v12 >= 0x100 || v11 != 1 )
        goto LABEL_67;
      *((_BYTE *)v3 + 8) = v12;
      result = 34LL;
      break;
    case 0x72:
      if ( *a2 != 10 )
        goto LABEL_56;
      *(_QWORD *)(a1 + 8) = a2[1];
      result = 28LL;
      break;
    case 0x73:
      goto LABEL_15;
    case 0x74:
      goto LABEL_27;
    case 0x79:
      if ( *a2 != 10 )
        goto LABEL_56;
      *(_QWORD *)(a1 + 8) = a2[1];
      result = 21LL;
      break;
    case 0x8C:
      if ( *a2 != 10 )
        goto LABEL_56;
      *(_QWORD *)(a1 + 8) = a2[1];
      result = 18LL;
      break;
    default:
      goto LABEL_67;
  }
LABEL_81:
  *v3 = result;
  return result;
}
// 421780: variable 'v9' is possibly undefined
// 4217ED: variable 'v10' is possibly undefined
// 42180D: variable 'v7' is possibly undefined
// 421843: variable 'v12' is possibly undefined
// 421883: variable 'v14' is possibly undefined
// 4218B1: variable 'v16' is possibly undefined
// 4218DF: variable 'v18' is possibly undefined
// 42191F: variable 'v20' is possibly undefined
// 42194D: variable 'v22' is possibly undefined
// 421989: variable 'v24' is possibly undefined
// 4219BD: variable 'a1' is possibly undefined
// 4219D5: variable 'v26' is possibly undefined
// 421A03: variable 'v28' is possibly undefined
// 421A2D: variable 'v30' is possibly undefined
// 421A57: variable 'v32' is possibly undefined
// 421A79: variable 'v33' is possibly undefined

//----- (0000000000421DF0) ----------------------------------------------------
void __fastcall sub_421DF0(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  if ( !_InterlockedDecrement64(*(volatile signed __int64 **)(a1 + 344)) )
    sub_41D140(*(LPVOID *)(a1 + 344), a2, a3);
  sub_41D230(a1 + 96);
}

//----- (0000000000421E50) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_421E50(__int128 *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // r8
  size_t v3; // rsi
  _OWORD *v6; // rax
  void *v7; // rdi
  HANDLE ProcessHeap; // rax
  _OWORD v9[258]; // [rsp+28h] [rbp-58h] BYREF

  v2 = 250000LL;
  if ( a2 < 0x3D090 )
    v2 = a2;
  if ( a2 >> 1 > v2 )
    v2 = a2 >> 1;
  v3 = 48LL;
  if ( v2 >= 0x31 )
    v3 = v2;
  if ( v2 >= 0x81 )
  {
    if ( a2 >> 60 || 32 * v3 >= 0x7FFFFFFFFFFFFFF9LL )
      sub_4040B0((__int64)&off_447D68);
    v6 = sub_43C4F0(32 * v3);
    if ( !v6 )
      sub_4040E9(8LL, 32 * v3);
    v7 = v6;
    sub_42B660(a1, a2, v6, v3, a2 < 0x41);
    ProcessHeap = GetProcessHeap();
    HeapFree(ProcessHeap, 0, v7);
  }
  else
  {
    sub_42B660(a1, a2, v9, 0x80uLL, a2 < 0x41);
  }
}
// 421EC9: positive sp value 1028 has been found
// 447D68: using guessed type char *off_447D68;

//----- (0000000000421F80) ----------------------------------------------------
__int64 __fastcall sub_421F80(__int64 a1, __int64 a2)
{
  __int64 v2; // rdx
  __int64 v3; // r9
  __int64 result; // rax
  __int64 v5; // r10
  __int64 v6; // r10
  __int64 v7; // r8
  unsigned __int64 v8; // r9
  __int64 v9; // r11
  __int128 v10; // xmm0
  __int64 v11; // r10
  bool v12; // cf
  __int128 v13; // [rsp+0h] [rbp-20h]
  __int64 v14; // [rsp+10h] [rbp-10h]

  v2 = a1 + 32 * a2;
  v3 = a1 + 32;
  result = 32LL;
  v5 = a1;
  do
  {
    v7 = v3;
    v8 = *(_QWORD *)(v5 + 32);
    if ( v8 < *(_QWORD *)v5 )
    {
      v14 = *(_QWORD *)(v5 + 56);
      v13 = *(_OWORD *)(v5 + 40);
      v9 = result;
      do
      {
        v10 = *(_OWORD *)(a1 + v9 - 32);
        *(_OWORD *)(a1 + v9 + 16) = *(_OWORD *)(a1 + v9 - 16);
        *(_OWORD *)(a1 + v9) = v10;
        if ( v9 == 32 )
        {
          v6 = a1;
          goto LABEL_3;
        }
        v11 = v9 - 32;
        v12 = v8 < *(_QWORD *)(a1 + v9 - 64);
        v9 -= 32LL;
      }
      while ( v12 );
      v6 = a1 + v11;
LABEL_3:
      *(_QWORD *)v6 = v8;
      *(_OWORD *)(v6 + 8) = v13;
      *(_QWORD *)(v6 + 24) = v14;
    }
    v3 = v7 + 32;
    result += 32LL;
    v5 = v7;
  }
  while ( v7 + 32 != v2 );
  return result;
}

//----- (0000000000422030) ----------------------------------------------------
void __fastcall sub_422030(_QWORD *a1, __int64 a2, unsigned __int64 a3)
{
  void *v4; // rsi
  __int64 v5; // r15
  __int64 v6; // rcx
  __int64 v7; // r14
  HANDLE ProcessHeap; // rax

  v4 = (void *)a1[1];
  v5 = a1[2] + 1LL;
  v6 = (__int64)v4;
  while ( v5 != 1 )
  {
    v7 = v6 + 536;
    --v5;
    sub_41F780(v6, a2, a3);
    v6 = v7;
  }
  if ( *a1 )
  {
    ProcessHeap = GetProcessHeap();
    HeapFree(ProcessHeap, 0, v4);
  }
}
// 422070: variable 'a2' is possibly undefined
// 422070: variable 'a3' is possibly undefined

//----- (0000000000422100) ----------------------------------------------------
void __fastcall sub_422100(_QWORD *a1, __int64 a2, unsigned __int64 a3)
{
  char *v4; // rsi
  __int64 v5; // r15
  LPVOID *v6; // rbx
  HANDLE ProcessHeap; // rax

  v4 = (char *)a1[1];
  v5 = a1[2];
  if ( v5 )
  {
    v6 = (LPVOID *)(v4 + 432);
    do
    {
      if ( !_InterlockedDecrement64((volatile signed __int64 *)*(v6 - 11)) )
        sub_41D140(*(v6 - 11), a2, a3);
      sub_41D230((__int64)(v6 - 42));
      v6 += 54;
      --v5;
    }
    while ( v5 );
  }
  if ( *a1 )
  {
    ProcessHeap = GetProcessHeap();
    HeapFree(ProcessHeap, 0, v4);
  }
}
// 422156: variable 'a2' is possibly undefined
// 422156: variable 'a3' is possibly undefined

//----- (00000000004221F0) ----------------------------------------------------
__int64 __fastcall sub_4221F0(unsigned __int64 *a1, __int64 a2)
{
  unsigned __int128 v2; // rax
  unsigned __int64 v3; // r8
  unsigned __int64 v5; // rax
  unsigned __int64 v6; // rdi
  __int64 v7; // rcx
  __int64 v8; // rcx
  __int64 result; // rax
  _QWORD v10[3]; // [rsp+20h] [rbp-30h] BYREF
  __int64 v11; // [rsp+38h] [rbp-18h] BYREF
  __int64 v12; // [rsp+40h] [rbp-10h]
  __int64 v13; // [rsp+48h] [rbp-8h]

  *((_QWORD *)&v2 + 1) = a2;
  v3 = *a1;
  if ( *a1 == -1LL )
    goto LABEL_13;
  v5 = v3 + 1;
  if ( 2 * v3 > v3 + 1 )
    v5 = 2 * v3;
  v6 = 4LL;
  if ( v5 >= 5 )
    v6 = v5;
  v7 = 0LL;
  v2 = 0x1B0 * (unsigned __int128)v6;
  if ( !is_mul_ok(0x1B0uLL, v6) )
LABEL_13:
    sub_40408F(0LL, *((__int64 *)&v2 + 1), (__int64)&off_448320);
  if ( (unsigned __int64)v2 > 0x7FFFFFFFFFFFFFF8LL )
LABEL_15:
    sub_40408F(v7, *((__int64 *)&v2 + 1), (__int64)&off_448320);
  if ( v3 )
  {
    v10[0] = a1[1];
    v10[2] = 432 * v3;
    v8 = 8LL;
  }
  else
  {
    v8 = 0LL;
  }
  v10[1] = v8;
  sub_413370(&v11, (void *)8, v2, (__int64)v10);
  if ( (_DWORD)v11 == 1 )
  {
    v7 = v12;
    *((_QWORD *)&v2 + 1) = v13;
    goto LABEL_15;
  }
  result = v12;
  a1[1] = v12;
  *a1 = v6;
  return result;
}
// 448320: using guessed type char *off_448320;

//----- (00000000004222C0) ----------------------------------------------------
void __fastcall sub_4222C0(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  if ( !_InterlockedDecrement64(*(volatile signed __int64 **)(a1 + 344)) )
    sub_41D140(*(LPVOID *)(a1 + 344), a2, a3);
  sub_41D230(a1 + 96);
}

//----- (0000000000422320) ----------------------------------------------------
int __fastcall sub_422320(__int64 *a1, __int64 a2, unsigned __int64 a3)
{
  __int64 v3; // rsi
  volatile signed __int64 *v4; // rax
  int result; // eax
  HANDLE ProcessHeap; // rax

  v3 = *a1;
  v4 = *(volatile signed __int64 **)(*a1 + 224);
  if ( v4 && !_InterlockedDecrement64(v4) )
    sub_422320(v3 + 224);
  result = sub_42B180((__int64 *)(v3 + 232), a2, a3);
  if ( v3 != -1 && !_InterlockedDecrement64((volatile signed __int64 *)(v3 + 8)) )
  {
    ProcessHeap = GetProcessHeap();
    return HeapFree(ProcessHeap, 0, (LPVOID)v3);
  }
  return result;
}
// 422354: variable 'a2' is possibly undefined
// 422354: variable 'a3' is possibly undefined

//----- (00000000004223D0) ----------------------------------------------------
void __fastcall sub_4223D0(char *lpMem, __int64 a2, unsigned __int64 a3)
{
  char *v4; // rsi
  __int64 i; // r14
  char *v6; // rbx
  HANDLE ProcessHeap; // rax

  v4 = lpMem;
  for ( i = a2 + 1; i != 1; --i )
  {
    v6 = lpMem + 536;
    sub_41F780((__int64)lpMem, a2, a3);
    lpMem = v6;
  }
  if ( a2 )
  {
    ProcessHeap = GetProcessHeap();
    HeapFree(ProcessHeap, 0, v4);
  }
}
// 422400: variable 'a2' is possibly undefined
// 422400: variable 'a3' is possibly undefined

//----- (0000000000422480) ----------------------------------------------------
void __fastcall sub_422480(__int64 a1, unsigned int *a2, unsigned __int64 a3)
{
  __int64 v3; // rax
  __int16 v4; // r9
  unsigned __int64 v5; // r10
  __int64 v6; // r10
  __int64 v7; // r11
  __int64 v8; // rsi
  unsigned __int64 v9; // r8
  __int64 v10; // rdi
  bool v11; // cf
  unsigned __int64 v12; // r8
  unsigned int *v13; // rbx
  __int64 v14; // r14
  unsigned __int64 v15; // r8
  unsigned int *v16; // r12
  unsigned int v17; // eax
  char v18; // al
  unsigned __int64 v19; // r12
  unsigned __int64 v20; // rax
  unsigned __int64 v21; // r15
  unsigned __int64 v22; // r13
  unsigned __int64 v23; // r8
  unsigned int v24; // eax
  int v25; // r12d
  char v26; // al
  unsigned int v27; // eax
  unsigned __int64 v28; // r13
  unsigned int v29; // eax
  int v30; // r12d
  unsigned int v31; // eax
  int v32; // r12d
  unsigned int *v33; // r13
  unsigned int v34; // eax
  unsigned int v35; // eax
  unsigned int v36; // eax
  int v37; // r12d
  unsigned int v38; // r13d
  unsigned __int64 v39; // r12
  unsigned int v40; // r13d
  unsigned int v41; // r13d
  int v42; // eax
  unsigned int v43; // r13d
  int v44; // eax
  unsigned int v45; // r13d
  int v46; // eax
  unsigned int v47; // r12d
  int v48; // eax
  char v49; // cl
  unsigned __int64 v50; // rax
  unsigned int v51; // r13d
  unsigned int v52; // r13d
  unsigned __int64 v53; // [rsp+0h] [rbp-50h]
  unsigned __int64 v54; // [rsp+8h] [rbp-48h]
  unsigned __int64 v55; // [rsp+10h] [rbp-40h]
  unsigned __int64 v56; // [rsp+18h] [rbp-38h]
  unsigned __int64 v57; // [rsp+20h] [rbp-30h]
  unsigned __int64 v58; // [rsp+28h] [rbp-28h]
  __int64 v59; // [rsp+38h] [rbp-18h]
  unsigned int *v60; // [rsp+38h] [rbp-18h]
  unsigned int *v61; // [rsp+40h] [rbp-10h]
  unsigned __int64 v62; // [rsp+40h] [rbp-10h]
  unsigned __int64 v63; // [rsp+40h] [rbp-10h]
  unsigned int *v64; // [rsp+48h] [rbp-8h]
  unsigned int *v65; // [rsp+48h] [rbp-8h]
  unsigned int *v66; // [rsp+48h] [rbp-8h]

  if ( !a3 )
  {
    *(_QWORD *)a1 = 0LL;
    *(_QWORD *)(a1 + 8) = a2;
    *(_QWORD *)(a1 + 16) = 0LL;
    *(_QWORD *)(a1 + 24) = a2;
    *(_QWORD *)(a1 + 32) = 0LL;
    *(_QWORD *)(a1 + 40) = a2;
    *(_QWORD *)(a1 + 48) = 0LL;
    *(_QWORD *)(a1 + 56) = a2;
    *(_OWORD *)(a1 + 64) = 0LL;
    *(_QWORD *)(a1 + 78) = 0LL;
    return;
  }
  if ( a3 <= 3 )
    goto LABEL_13;
  v3 = *a2;
  v4 = 2;
  if ( v3 != 2 )
  {
    v4 = 5;
    if ( (unsigned __int16)v3 != 5LL )
    {
      *(_BYTE *)(a1 + 8) = 17;
      *(_QWORD *)(a1 + 16) = (unsigned __int16)v3;
LABEL_15:
      *(_BYTE *)a1 = 22;
      return;
    }
  }
  v5 = a3 & 0xFFFFFFFFFFFFFFFCuLL;
  if ( (a3 & 0xFFFFFFFFFFFFFFFCuLL) == 4 )
  {
    ++a2;
LABEL_13:
    *(_BYTE *)(a1 + 11) = 0;
    *(_WORD *)(a1 + 9) = 0;
    *(_BYTE *)(a1 + 8) = 19;
    *(_DWORD *)(a1 + 12) = 0;
LABEL_14:
    *(_QWORD *)(a1 + 16) = a2;
    goto LABEL_15;
  }
  if ( v5 == 8 )
  {
    a2 += 2;
    goto LABEL_13;
  }
  if ( v5 == 12 )
  {
    a2 += 3;
    goto LABEL_13;
  }
  v6 = a2[1];
  v7 = a2[2];
  v8 = a2[3];
  if ( a2[3]
    && ((unsigned int)v8 <= (unsigned int)v7
     || (16843009
       * (((((_DWORD)v8 - (((unsigned int)v8 >> 1) & 0x55555555)) & 0x33333333)
         + ((((unsigned int)v8 - (((unsigned int)v8 >> 1) & 0x55555555)) >> 2) & 0x33333333)
         + (((((_DWORD)v8 - (((unsigned int)v8 >> 1) & 0x55555555)) & 0x33333333)
           + ((((unsigned int)v8 - (((unsigned int)v8 >> 1) & 0x55555555)) >> 2) & 0x33333333)) >> 4)) & 0xF0F0F0F)) >> 24 >= 2) )
  {
    *(_BYTE *)(a1 + 8) = 72;
    goto LABEL_15;
  }
  v9 = a3 - 16;
  a2 += 4;
  v10 = 2 * v8;
  v11 = v9 < 8 * v8;
  v12 = v9 - 8 * v8;
  if ( v11 )
  {
    *(_QWORD *)(a1 + 8) = 19LL;
    goto LABEL_14;
  }
  v13 = &a2[v10];
  v14 = v8;
  v11 = v12 < 4 * v8;
  v15 = v12 - 4 * v8;
  if ( v11 )
  {
    *(_QWORD *)(a1 + 8) = 19LL;
    *(_QWORD *)(a1 + 16) = v13;
    goto LABEL_15;
  }
  if ( (unsigned int)v6 > 8 )
  {
    *(_BYTE *)(a1 + 8) = 71;
    goto LABEL_15;
  }
  v16 = &v13[v14];
  if ( !(_DWORD)v6 )
  {
    v64 = &v13[v14];
    v20 = 0LL;
    LOBYTE(v57) = 0;
    LOBYTE(v56) = 0;
    LOBYTE(v55) = 0;
    LODWORD(v54) = 0;
    LOBYTE(v53) = 0;
    LOWORD(v21) = 0;
    LOBYTE(v19) = 0;
    goto LABEL_33;
  }
  if ( (_DWORD)v3 != 2 )
  {
    if ( v15 <= 3 )
      goto LABEL_108;
    v65 = &v13[v14];
    v24 = *v16 - 1;
    if ( v24 >= 8 )
      goto LABEL_106;
    v25 = 253;
    if ( !_bittest(&v25, v24) )
      goto LABEL_106;
    v59 = a1;
    v26 = 8 * v24;
    v19 = 0x110D130B08000707uLL >> v26;
    if ( (_DWORD)v6 == 1 )
    {
      v20 = 0LL;
      LOBYTE(v57) = 0;
      LOBYTE(v56) = 0;
      LOBYTE(v55) = 0;
      LODWORD(v54) = 0;
      LOBYTE(v53) = 0;
      LOWORD(v21) = 0;
      v15 -= 4LL;
      v64 = v65 + 1;
      goto LABEL_33;
    }
    v58 = 0x110D130B08000707uLL >> v26;
    v16 = v65 + 1;
    if ( v15 - 4 < 4 )
      goto LABEL_108;
    v29 = v65[1] - 1;
    if ( v29 > 7 )
      goto LABEL_106;
    v30 = 253;
    if ( !_bittest(&v30, v29) )
      goto LABEL_106;
    v28 = v15 - 8;
    v16 = v65 + 2;
    v21 = 0x110D130B08000707uLL >> (8 * (unsigned __int8)v29);
    if ( (_DWORD)v6 == 2 )
      goto LABEL_46;
    if ( v28 < 4 )
      goto LABEL_108;
    v31 = v65[2] - 1;
    if ( v31 > 7 )
      goto LABEL_106;
    v32 = 253;
    if ( !_bittest(&v32, v31) )
      goto LABEL_106;
    v62 = v15 - 12;
    v33 = v65 + 3;
    v53 = 0x110D130B08000707uLL >> (8 * (unsigned __int8)v31);
    if ( (_DWORD)v6 == 3 )
    {
      v20 = 0LL;
      LOBYTE(v57) = 0;
      LOBYTE(v56) = 0;
      LOBYTE(v55) = 0;
      LODWORD(v54) = 0;
    }
    else
    {
      v16 = v65 + 3;
      if ( v62 < 4 )
        goto LABEL_108;
      v36 = v65[3] - 1;
      if ( v36 > 7 )
        goto LABEL_106;
      v37 = 253;
      if ( !_bittest(&v37, v36) )
        goto LABEL_106;
      v62 = v15 - 16;
      v33 = v65 + 4;
      v54 = 0x110D130B08000707uLL >> (8 * (unsigned __int8)v36);
      if ( (_DWORD)v6 != 4 )
      {
        v16 = v65 + 4;
        if ( v62 >= 4 )
        {
          if ( v65[4] - 1 > 7 )
            goto LABEL_106;
          v41 = v65[4] - 1;
          v42 = 253;
          if ( !_bittest(&v42, v41) )
            goto LABEL_106;
          v39 = v15 - 20;
          v61 = v65 + 5;
          v55 = 0x110D130B08000707uLL >> (8 * (unsigned __int8)v41);
          if ( (_DWORD)v6 == 5 )
            goto LABEL_76;
          v11 = v39 < 4;
          v16 = v65 + 5;
          if ( !v11 )
          {
            if ( v65[5] - 1 > 7 )
              goto LABEL_106;
            v43 = v65[5] - 1;
            v44 = 253;
            if ( !_bittest(&v44, v43) )
              goto LABEL_106;
            v39 = v15 - 24;
            v61 = v65 + 6;
            v56 = 0x110D130B08000707uLL >> (8 * (unsigned __int8)v43);
            if ( (_DWORD)v6 == 6 )
              goto LABEL_82;
            v11 = v39 < 4;
            v16 = v65 + 6;
            if ( !v11 )
            {
              if ( v65[6] - 1 > 7 )
                goto LABEL_106;
              v45 = v65[6] - 1;
              v46 = 253;
              if ( !_bittest(&v46, v45) )
                goto LABEL_106;
              v39 = v15 - 28;
              v61 = v65 + 7;
              v57 = 0x110D130B08000707uLL >> (8 * (unsigned __int8)v45);
              if ( (_DWORD)v6 == 7 )
                goto LABEL_77;
              v11 = v39 < 4;
              v16 = v65 + 7;
              if ( !v11 )
              {
                v47 = v65[7] - 1;
                if ( v47 <= 7 )
                {
                  v48 = 253;
                  if ( _bittest(&v48, v47) )
                  {
                    v15 -= 32LL;
                    v64 = v65 + 8;
                    v49 = 8 * v47;
                    v50 = 0x110D130B08000707LL;
LABEL_105:
                    v20 = v50 >> v49;
                    goto LABEL_48;
                  }
                }
LABEL_106:
                *(_BYTE *)(a1 + 8) = 74;
                goto LABEL_15;
              }
            }
          }
        }
        goto LABEL_108;
      }
      v20 = 0LL;
      LOBYTE(v57) = 0;
      LOBYTE(v56) = 0;
      LOBYTE(v55) = 0;
    }
    v15 = v62;
    v64 = v33;
    goto LABEL_48;
  }
  if ( v15 < 4 )
    goto LABEL_108;
  v17 = *v16 - 1;
  if ( v17 > 7 )
    goto LABEL_106;
  v59 = a1;
  v61 = v16 + 1;
  v18 = 8 * v17;
  v19 = 0xD0C130A08001507uLL >> v18;
  if ( (_DWORD)v6 == 1 )
  {
    v20 = 0LL;
    LOBYTE(v57) = 0;
    LOBYTE(v56) = 0;
    LOBYTE(v55) = 0;
    LODWORD(v54) = 0;
    LOBYTE(v53) = 0;
    LOWORD(v21) = 0;
    v15 -= 4LL;
    v64 = v61;
    goto LABEL_33;
  }
  v66 = &v13[v14];
  v58 = 0xD0C130A08001507uLL >> v18;
  if ( v15 - 4 < 4 )
  {
LABEL_107:
    v16 = v61;
    goto LABEL_108;
  }
  v27 = *v61 - 1;
  if ( v27 > 7 )
    goto LABEL_106;
  v16 = &v13[v14 + 2];
  v28 = v15 - 8;
  v21 = 0xD0C130A08001507uLL >> (8 * (unsigned __int8)v27);
  if ( (_DWORD)v6 != 2 )
  {
    if ( v28 >= 4 )
    {
      v34 = *v16 - 1;
      if ( v34 > 7 )
        goto LABEL_106;
      v16 = v66 + 3;
      v63 = v15 - 12;
      v53 = 0xD0C130A08001507uLL >> (8 * (unsigned __int8)v34);
      if ( (_DWORD)v6 == 3 )
      {
        v20 = 0LL;
        LOBYTE(v57) = 0;
        LOBYTE(v56) = 0;
        LOBYTE(v55) = 0;
        LODWORD(v54) = 0;
LABEL_63:
        v15 = v63;
        goto LABEL_47;
      }
      if ( v63 >= 4 )
      {
        v35 = *v16 - 1;
        if ( v35 > 7 )
          goto LABEL_106;
        v16 = v66 + 4;
        v63 = v15 - 16;
        v54 = 0xD0C130A08001507uLL >> (8 * (unsigned __int8)v35);
        if ( (_DWORD)v6 == 4 )
        {
          v20 = 0LL;
          LOBYTE(v57) = 0;
          LOBYTE(v56) = 0;
          LOBYTE(v55) = 0;
          goto LABEL_63;
        }
        if ( v63 >= 4 )
        {
          v38 = *v16 - 1;
          if ( v38 > 7 )
            goto LABEL_106;
          v61 = v66 + 5;
          v39 = v15 - 20;
          v55 = 0xD0C130A08001507uLL >> (8 * (unsigned __int8)v38);
          if ( (_DWORD)v6 == 5 )
          {
LABEL_76:
            LOBYTE(v57) = 0;
            LOBYTE(v56) = 0;
LABEL_77:
            v15 = v39;
            v20 = 0LL;
            v64 = v61;
            goto LABEL_48;
          }
          if ( v39 >= 4 )
          {
            v40 = *v61 - 1;
            if ( v40 > 7 )
              goto LABEL_106;
            v61 = v66 + 6;
            v39 = v15 - 24;
            v56 = 0xD0C130A08001507uLL >> (8 * (unsigned __int8)v40);
            if ( (_DWORD)v6 == 6 )
            {
LABEL_82:
              LOBYTE(v57) = 0;
              goto LABEL_77;
            }
            if ( v39 >= 4 )
            {
              v51 = *v61 - 1;
              if ( v51 > 7 )
                goto LABEL_106;
              v61 = v66 + 7;
              v39 = v15 - 28;
              v57 = 0xD0C130A08001507uLL >> (8 * (unsigned __int8)v51);
              if ( (_DWORD)v6 == 7 )
                goto LABEL_77;
              if ( v39 >= 4 )
              {
                v52 = *v61 - 1;
                if ( v52 <= 7 )
                {
                  v64 = v66 + 8;
                  v15 -= 32LL;
                  v49 = 8 * v52;
                  v50 = 0xD0C130A08001507LL;
                  goto LABEL_105;
                }
                goto LABEL_106;
              }
            }
          }
          goto LABEL_107;
        }
      }
    }
LABEL_108:
    *(_BYTE *)(a1 + 11) = 0;
    *(_WORD *)(a1 + 9) = 0;
    *(_BYTE *)(a1 + 8) = 19;
    *(_DWORD *)(a1 + 12) = 0;
    *(_QWORD *)(a1 + 16) = v16;
    goto LABEL_15;
  }
LABEL_46:
  v20 = 0LL;
  LOBYTE(v57) = 0;
  LOBYTE(v56) = 0;
  LOBYTE(v55) = 0;
  LODWORD(v54) = 0;
  LOBYTE(v53) = 0;
  v15 = v28;
LABEL_47:
  v64 = v16;
LABEL_48:
  a1 = v59;
  LOBYTE(v19) = v58;
LABEL_33:
  v22 = 4 * v6 * v7;
  v11 = v15 < v22;
  v23 = v15 - v22;
  if ( v11 )
  {
    *(_QWORD *)(a1 + 8) = 19LL;
    *(_QWORD *)(a1 + 16) = v64;
    goto LABEL_15;
  }
  v60 = &v64[v22 / 4];
  if ( v23 < v22 )
  {
    *(_QWORD *)(a1 + 8) = 19LL;
    *(_QWORD *)(a1 + 16) = v60;
    goto LABEL_15;
  }
  *(_QWORD *)a1 = (v20 << 56) | ((unsigned __int64)(unsigned __int8)v57 << 48) | ((unsigned __int64)(unsigned __int8)v56 << 40) | ((unsigned __int64)(unsigned __int8)v55 << 32) | (unsigned int)((_DWORD)v54 << 24) | ((unsigned __int8)v53 << 16) | (unsigned __int16)((_WORD)v21 << 8) | (unsigned __int8)v19;
  *(_QWORD *)(a1 + 8) = a2;
  *(_QWORD *)(a1 + 16) = v10 * 4;
  *(_QWORD *)(a1 + 24) = v13;
  *(_QWORD *)(a1 + 32) = v14 * 4;
  *(_QWORD *)(a1 + 40) = v64;
  *(_QWORD *)(a1 + 48) = v22;
  *(_QWORD *)(a1 + 56) = v60;
  *(_QWORD *)(a1 + 64) = v22;
  *(_DWORD *)(a1 + 72) = v6;
  *(_DWORD *)(a1 + 76) = v7;
  *(_DWORD *)(a1 + 80) = v8;
  *(_WORD *)(a1 + 84) = v4;
}

//----- (0000000000422E90) ----------------------------------------------------
void __fastcall sub_422E90(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  void *v4; // rdi
  HANDLE ProcessHeap; // rax
  void *v6; // rbx
  __int64 v7; // rdi
  __int64 v8; // r15
  __int64 v9; // rcx
  __int64 v10; // r14
  HANDLE v11; // rax

  if ( !_InterlockedDecrement64(*(volatile signed __int64 **)a1) )
    sub_422320((__int64 *)a1, a2, a3);
  if ( *(_QWORD *)(a1 + 16) )
  {
    v4 = *(void **)(a1 + 8);
    ProcessHeap = GetProcessHeap();
    HeapFree(ProcessHeap, 0, v4);
  }
  v6 = *(void **)(a1 + 24);
  v7 = *(_QWORD *)(a1 + 32);
  v8 = v7 + 1;
  v9 = (__int64)v6;
  while ( v8 != 1 )
  {
    v10 = v9 + 536;
    --v8;
    sub_41F780(v9, a2, a3);
    v9 = v10;
  }
  if ( v7 )
  {
    v11 = GetProcessHeap();
    HeapFree(v11, 0, v6);
  }
  sub_42B0A0(*(char **)(a1 + 40), *(_QWORD *)(a1 + 48), a3);
}
// 422F00: variable 'a2' is possibly undefined
// 422F00: variable 'a3' is possibly undefined

//----- (0000000000422FC0) ----------------------------------------------------
void *__fastcall sub_422FC0(__int64 a1, __int64 a2)
{
  unsigned __int128 v2; // rax
  unsigned __int64 v4; // rax
  unsigned __int64 v5; // rdi
  __int64 v6; // rcx
  __int64 v7; // rcx
  void *result; // rax
  _QWORD v9[3]; // [rsp+20h] [rbp-30h] BYREF
  __int64 v10; // [rsp+38h] [rbp-18h] BYREF
  void *v11; // [rsp+40h] [rbp-10h]
  __int64 v12; // [rsp+48h] [rbp-8h]

  *((_QWORD *)&v2 + 1) = a2;
  if ( *((_QWORD *)&xmmword_43F038 + 1) == -1LL )
    goto LABEL_13;
  v4 = *((_QWORD *)&xmmword_43F038 + 1) + 1LL;
  if ( 2LL * *((_QWORD *)&xmmword_43F038 + 1) > (unsigned __int64)(*((_QWORD *)&xmmword_43F038 + 1) + 1LL) )
    v4 = 2LL * *((_QWORD *)&xmmword_43F038 + 1);
  v5 = 4LL;
  if ( v4 >= 5 )
    v5 = v4;
  v6 = 0LL;
  v2 = 0x230 * (unsigned __int128)v5;
  if ( !is_mul_ok(0x230uLL, v5) )
LABEL_13:
    sub_40408F(0LL, *((__int64 *)&v2 + 1), a1);
  if ( (unsigned __int64)v2 > 0x7FFFFFFFFFFFFFF8LL )
LABEL_15:
    sub_40408F(v6, *((__int64 *)&v2 + 1), a1);
  if ( *((_QWORD *)&xmmword_43F038 + 1) )
  {
    v9[0] = Src;
    v9[2] = 560LL * *((_QWORD *)&xmmword_43F038 + 1);
    v7 = 8LL;
  }
  else
  {
    v7 = 0LL;
  }
  v9[1] = v7;
  sub_413370(&v10, (void *)8, v2, (__int64)v9);
  if ( (_DWORD)v10 == 1 )
  {
    v6 = (__int64)v11;
    *((_QWORD *)&v2 + 1) = v12;
    goto LABEL_15;
  }
  result = v11;
  Src = v11;
  *((_QWORD *)&xmmword_43F038 + 1) = v5;
  return result;
}
// 43F038: using guessed type __int128 xmmword_43F038;

//----- (00000000004230A0) ----------------------------------------------------
void __fastcall sub_4230A0(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  void *v4; // rdi
  HANDLE ProcessHeap; // rax
  void *v6; // rdi

  sub_422E90(a1 + 424, a2, a3);
  if ( *(_QWORD *)a1 )
  {
    v4 = *(void **)(a1 + 8);
    ProcessHeap = GetProcessHeap();
    HeapFree(ProcessHeap, 0, v4);
  }
  v6 = *(void **)(a1 + 480);
  UnmapViewOfFile(*(LPCVOID *)(a1 + 488));
  CloseHandle(v6);
  sub_419960((_QWORD *)(a1 + 504));
}

//----- (0000000000423160) ----------------------------------------------------
int __fastcall sub_423160(_QWORD *a1, __int64 a2, volatile signed __int64 **a3, volatile signed __int64 **a4)
{
  unsigned __int8 v4; // di
  volatile signed __int64 **v5; // r13
  unsigned __int64 v6; // r14
  volatile signed __int64 *v7; // r15
  char v9; // cl
  volatile signed __int64 *v10; // rsi
  __int64 v11; // rax
  unsigned __int8 v12; // al
  __int16 v13; // r14
  unsigned __int64 v14; // rdi
  volatile signed __int64 **v15; // r13
  volatile signed __int64 **v16; // r13
  unsigned __int64 v17; // rdi
  unsigned __int64 v18; // rax
  bool v19; // of
  _QWORD *v20; // rax
  __int64 v21; // rcx
  volatile signed __int64 *v22; // r9
  __int64 v23; // rt0
  volatile signed __int64 **v24; // r8
  volatile signed __int64 **v25; // rdx
  _QWORD *v26; // rcx
  _QWORD *v27; // r9
  __int64 v28; // rcx
  __int64 v29; // rax
  unsigned __int64 v30; // rdx
  __int64 v31; // r8
  _QWORD *v32; // rsi
  __int128 v34; // [rsp+30h] [rbp-50h] BYREF
  __int128 v35; // [rsp+48h] [rbp-38h] BYREF
  unsigned __int64 v36; // [rsp+58h] [rbp-28h]
  __int64 v37; // [rsp+60h] [rbp-20h]
  _QWORD v38[2]; // [rsp+68h] [rbp-18h] BYREF
  __int64 v39; // [rsp+78h] [rbp-8h]
  __int64 v40; // [rsp+A0h] [rbp+20h]
  volatile signed __int64 *v41; // [rsp+A8h] [rbp+28h]
  volatile signed __int64 *v42; // [rsp+B0h] [rbp+30h]
  volatile signed __int64 *v43; // [rsp+B8h] [rbp+38h]
  _QWORD *v44; // [rsp+C0h] [rbp+40h]
  volatile signed __int64 **v45; // [rsp+C8h] [rbp+48h]
  volatile signed __int64 **v46; // [rsp+D0h] [rbp+50h]
  _QWORD *v47; // [rsp+D8h] [rbp+58h]
  __int64 v48; // [rsp+E0h] [rbp+60h] BYREF
  volatile signed __int64 **v49; // [rsp+E8h] [rbp+68h]
  volatile signed __int64 **v50; // [rsp+F0h] [rbp+70h]
  unsigned __int64 v51; // [rsp+F8h] [rbp+78h]
  volatile signed __int64 *v52; // [rsp+100h] [rbp+80h] BYREF
  volatile signed __int64 **v53; // [rsp+108h] [rbp+88h]
  volatile signed __int64 **v54; // [rsp+110h] [rbp+90h]
  unsigned __int64 v55; // [rsp+118h] [rbp+98h]
  _QWORD *v56; // [rsp+120h] [rbp+A0h]

  v46 = a3;
  v44 = a1;
  v45 = a4;
  v43 = *a4;
  v47 = v43 + 2;
  v9 = *(_BYTE *)(a2 + 512);
  while ( 1 )
  {
    while ( 1 )
    {
      if ( v9 != 76 )
      {
        if ( v9 == 75 )
        {
          v26 = *(_QWORD **)(a2 + 520);
          if ( !v26 )
          {
LABEL_39:
            v29 = 0LL;
            v30 = 0LL;
            v28 = a2;
            v31 = 0LL;
            v27 = v47;
            goto LABEL_40;
          }
          v27 = (_QWORD *)(*v26 + 16LL);
          v28 = (__int64)(v26 + 1);
          v29 = 2LL;
          v30 = 0LL;
          v31 = 0LL;
        }
        else
        {
          v27 = *(_QWORD **)(a2 + 512);
          v29 = *(unsigned __int8 *)(a2 + 520);
          v28 = *(unsigned __int16 *)(a2 + 525);
          v30 = ((unsigned __int64)((unsigned int)v28 | (*(unsigned __int8 *)(a2 + 527) << 16)) << 40) | ((unsigned __int64)*(unsigned int *)(a2 + 521) << 8);
          v31 = 1LL;
        }
LABEL_40:
        v52 = (volatile signed __int64 *)a2;
        v54 = v46;
        v53 = v45;
        *(_QWORD *)&v35 = v31;
        *((_QWORD *)&v35 + 1) = v27;
        v36 = v30 | v29;
        v37 = v28;
        v32 = v44;
        LODWORD(v18) = sub_423B70((unsigned __int64)(v44 + 1), (__int64 *)&v52, (__int64)&v35);
        *v32 = 0LL;
        return v18;
      }
      if ( (*(_BYTE *)(a2 + 80) & 1) == 0 )
      {
        *(_BYTE *)(a2 + 512) = 75;
        *(_QWORD *)(a2 + 520) = 0LL;
        goto LABEL_39;
      }
      v10 = *(volatile signed __int64 **)(a2 + 368);
      if ( v10 )
        v42 = *(volatile signed __int64 **)(a2 + 376);
      v41 = *(volatile signed __int64 **)(a2 + 88);
      v11 = *(_QWORD *)(a2 + 344) + 16LL;
      v35 = *(_OWORD *)(a2 + 40);
      v36 = a2;
      v37 = v11;
      v38[0] = 0LL;
      v40 = 0LL;
      sub_42AD40((__int64 *)&v52, (__int64)&v35);
      v12 = (unsigned __int8)v52;
      if ( (_BYTE)v52 == 75 )
        break;
      v4 = BYTE1(v52);
      v6 = *(unsigned int *)((char *)&v52 + 2) | ((unsigned __int64)HIWORD(v52) << 32);
      v5 = v53;
LABEL_27:
      v18 = v12 | (unsigned __int64)(v4 << 8) | (v6 << 16);
      v7 = (volatile signed __int64 *)v5;
      v9 = *(_BYTE *)(a2 + 512);
      if ( v9 == 76 )
        goto LABEL_28;
    }
    if ( !v38[0] )
    {
      v12 = 66;
      goto LABEL_27;
    }
    v13 = 118;
    if ( *(_WORD *)(a2 + 74) < 5u )
      v13 = 8496;
    if ( (*(_BYTE *)v39 & 1) != 0 )
    {
      v14 = *(_QWORD *)(v39 + 24);
      v15 = *(volatile signed __int64 ***)(v39 + 16);
    }
    else
    {
      v14 = *(_QWORD *)(v39 + 8);
      if ( v14 >= 6 )
        sub_405B00(*(_QWORD *)(v39 + 8), 5LL, (__int64)&off_446D68);
      v15 = (volatile signed __int64 **)(v39 + 16);
    }
    v52 = (volatile signed __int64 *)v38[0];
    v53 = (volatile signed __int64 **)v38[1];
    v54 = v15;
    v55 = v14;
    v56 = v38;
    if ( !v14 )
      break;
    v16 = v15 + 2;
    v17 = v14 - 1;
    do
    {
      if ( v17 == -1LL )
      {
        v20 = v56;
        if ( (v56[5] & 1) == 0 )
        {
          v21 = (__int64)v52 - *v56;
          v56[5] = 1LL;
          v20[6] = v21;
        }
        goto LABEL_31;
      }
      v34 = *((_OWORD *)v16 - 1);
      sub_41D2E0((__int64)&v48, (unsigned __int64 *)&v52, *(_DWORD *)(v56[3] + 72LL), (__int64)&v34);
      if ( v48 == 46 )
      {
        v12 = (unsigned __int8)v49;
        v4 = BYTE1(v49);
        v6 = *(unsigned int *)((char *)&v49 + 2) | ((unsigned __int64)HIWORD(v49) << 32);
        v5 = v50;
        goto LABEL_27;
      }
      v54 = v16;
      v55 = v17;
      v16 += 2;
      --v17;
    }
    while ( v13 != (_WORD)v51 );
    v53 = v49;
    v54 = v50;
    v52 = (volatile signed __int64 *)v48;
    v55 = v51;
    sub_421680((__int64)&v48, (__int64 *)&v52);
    v12 = (unsigned __int8)v49;
    v4 = BYTE1(v49);
    v6 = *(unsigned int *)((char *)&v49 + 2) | ((unsigned __int64)HIWORD(v49) << 32);
    v5 = v50;
    if ( v48 == 47 )
      goto LABEL_27;
    v52 = (volatile signed __int64 *)v48;
    LOWORD(v53) = (_WORD)v49;
    *(_DWORD *)((char *)&v53 + 2) = *(_DWORD *)((char *)&v49 + 2);
    HIWORD(v53) = WORD2(v6);
    v54 = v50;
    if ( v48 == 46 )
      break;
    sub_427DD0((__int64 *)&v35, v47, *(unsigned __int8 *)(a2 + 73), *(_QWORD *)(a2 + 392), &v52);
    v18 = *((_QWORD *)&v35 + 1);
    v7 = (volatile signed __int64 *)v36;
    v19 = __OFSUB__((_DWORD)v35, 1);
    if ( (_DWORD)v35 != 1 )
      goto LABEL_32;
    v9 = *(_BYTE *)(a2 + 512);
    if ( v9 == 76 )
    {
LABEL_28:
      *(_BYTE *)(a2 + 512) = v18;
      *(_BYTE *)(a2 + 519) = HIBYTE(v18);
      *(_WORD *)(a2 + 517) = HIDWORD(v18) >> 8;
      *(_DWORD *)(a2 + 513) = v18 >> 8;
      *(_QWORD *)(a2 + 520) = v7;
      v9 = v18;
    }
  }
LABEL_31:
  v19 = 0;
  v18 = 0LL;
LABEL_32:
  v22 = v43;
  v23 = _InterlockedIncrement64(v43);
  if ( (v23 < 0) ^ v19 | (v23 == 0) )
    BUG();
  v52 = (volatile signed __int64 *)a2;
  v54 = v46;
  v24 = v45;
  v53 = v45;
  v25 = (volatile signed __int64 **)v44;
  v44[11] = v46;
  v25[9] = v52;
  v25[10] = (volatile signed __int64 *)v53;
  *v25 = v22;
  v25[1] = v41;
  v25[2] = v10;
  v25[3] = v42;
  v25[4] = (volatile signed __int64 *)v18;
  v25[5] = v7;
  v25[6] = (volatile signed __int64 *)a2;
  v25[7] = (volatile signed __int64 *)a2;
  v25[8] = (volatile signed __int64 *)v24;
  return v18;
}
// 423473: variable 'v4' is possibly undefined
// 423480: variable 'v6' is possibly undefined
// 423487: variable 'v5' is possibly undefined
// 42355F: variable 'v7' is possibly undefined
// 446D68: using guessed type char *off_446D68;

//----- (0000000000423680) ----------------------------------------------------
void *__fastcall sub_423680(__int64 a1, __int128 *a2, __int64 a3, char *a4)
{
  __int64 *v4; // rsi
  volatile signed __int64 *v5; // r10
  __int128 v8; // xmm0
  __int128 v9; // xmm1
  _OWORD *v10; // rcx
  __int128 v11; // xmm0
  __int128 v12; // xmm1
  __int128 v13; // xmm1
  __int128 v14; // xmm2
  __int128 v15; // xmm3
  void *result; // rax
  unsigned __int64 v17; // r14
  unsigned __int64 v18; // r13
  unsigned __int64 v19; // rdi
  __int64 *v20; // r15
  __int64 *v21; // rax
  __int64 v22; // rcx
  int v23; // r11d
  unsigned __int64 v24; // rdx
  __int64 v25; // r8
  unsigned __int64 v26; // rcx
  unsigned __int64 v27; // rdx
  __int128 v28; // xmm0
  __int128 v29; // xmm1
  __int128 v30; // xmm2
  int v31; // edi
  __int64 *v32; // rbx
  __int64 v33; // rcx
  __int128 v34; // xmm1
  __int128 v35; // xmm2
  __int128 v36; // xmm3
  __int128 v37; // xmm4
  __int64 v38; // r12
  __int64 v39; // r15
  __int64 v40; // rax
  unsigned __int64 v41; // r14
  __int64 v42; // rsi
  unsigned __int64 v43; // rcx
  __int64 v44; // rsi
  bool v45; // cf
  unsigned __int64 v46; // rdx
  __int64 v47; // r10
  _QWORD *v48; // rdx
  unsigned __int64 v49; // r13
  char v50; // [rsp+28h] [rbp-58h] BYREF
  _BYTE Src[136]; // [rsp+30h] [rbp-50h] BYREF
  __int64 *v52; // [rsp+B8h] [rbp+38h]
  __int64 *v53; // [rsp+C0h] [rbp+40h]
  unsigned __int64 v54; // [rsp+C8h] [rbp+48h]
  __int64 v55; // [rsp+D0h] [rbp+50h]
  volatile signed __int64 **v56; // [rsp+D8h] [rbp+58h]
  volatile signed __int64 **v57; // [rsp+E0h] [rbp+60h]
  __int64 *v58; // [rsp+E8h] [rbp+68h]
  int v59; // [rsp+F4h] [rbp+74h]
  __int64 *v60; // [rsp+F8h] [rbp+78h]
  unsigned __int64 v61; // [rsp+100h] [rbp+80h] BYREF
  LPVOID lpMem; // [rsp+108h] [rbp+88h]
  unsigned __int64 v63; // [rsp+110h] [rbp+90h]
  unsigned __int64 v64; // [rsp+118h] [rbp+98h]
  __int64 v65; // [rsp+120h] [rbp+A0h]

  v55 = a1;
  if ( *(_QWORD *)a2 )
  {
LABEL_2:
    v8 = *a2;
    v9 = a2[1];
    v10 = (_OWORD *)v55;
    *(_OWORD *)(v55 + 32) = a2[2];
    v10[1] = v9;
    *v10 = v8;
    v11 = a2[3];
    v12 = a2[4];
    *(_OWORD *)&Src[32] = a2[5];
    *(_OWORD *)&Src[16] = v12;
    *(_OWORD *)Src = v11;
    v13 = *(_OWORD *)(a3 + 16);
    v14 = *(_OWORD *)(a3 + 32);
    v15 = *(_OWORD *)(a3 + 48);
    *(_OWORD *)&Src[48] = *(_OWORD *)a3;
    *(_OWORD *)&Src[64] = v13;
    *(_OWORD *)&Src[80] = v14;
    *(_OWORD *)&Src[96] = v15;
    *(_OWORD *)&Src[112] = *(_OWORD *)(a3 + 64);
    *(_QWORD *)&Src[128] = *(_QWORD *)(a3 + 80);
    return memcpy(v10 + 3, Src, 0x88uLL);
  }
  else
  {
    v56 = *(volatile signed __int64 ***)a3;
    v52 = *(__int64 **)(a3 + 8);
    v57 = *(volatile signed __int64 ***)(a3 + 16);
    v17 = *(_QWORD *)(a3 + 48);
    v18 = *(_QWORD *)(a3 + 72);
    v19 = *(_QWORD *)(a3 + 32);
    v64 = *(_QWORD *)(a3 + 40);
    v60 = *(__int64 **)(a3 + 24);
    LOBYTE(v65) = *(_BYTE *)(a3 + 80);
    v20 = *(__int64 **)(a3 + 56);
    while ( 1 )
    {
      v21 = (__int64 *)*((_QWORD *)a2 + 1);
      LODWORD(v22) = *((_DWORD *)a2 + 4);
      v23 = *((_DWORD *)a2 + 5);
      v24 = *((_QWORD *)a2 + 3);
      v25 = *((_QWORD *)a2 + 4);
      if ( (_DWORD)v22 == 3 )
      {
        v32 = (__int64 *)*((_QWORD *)a2 + 1);
        v21 = (__int64 *)HIDWORD(v24);
        v31 = 5;
        LODWORD(v22) = v24;
        v17 = v25;
        goto LABEL_22;
      }
      v58 = (__int64 *)*((_QWORD *)a2 + 4);
      v4 = (__int64 *)*((_QWORD *)a2 + 5);
      if ( v21 )
        break;
      if ( (_DWORD)v22 != 2 )
      {
        v17 = v24;
        v32 = 0LL;
        LODWORD(v21) = v23;
        v20 = v58;
        v31 = 4;
        goto LABEL_22;
      }
      if ( (v65 & 1) != 0 || (__int64 *)v17 == v20 )
      {
LABEL_23:
        v31 = 3;
LABEL_21:
        v32 = 0LL;
        goto LABEL_22;
      }
      v21 = v20 - 4;
      while ( 1 )
      {
        v20 = v21;
        if ( v21[3] <= v18 )
        {
          *(_QWORD *)(a3 + 56) = v21;
          *(_BYTE *)(a3 + 80) = 1;
          LOBYTE(v65) = 1;
          v21 = (__int64 *)&v61;
          v22 = 0LL;
          goto LABEL_17;
        }
        if ( v19 < v21[1] && v64 > *v21 )
          break;
        v21 -= 4;
        if ( v20 == (__int64 *)v17 )
        {
          v31 = 3;
          *(_QWORD *)(a3 + 56) = v20;
          goto LABEL_21;
        }
      }
      *(_QWORD *)(a3 + 56) = v21;
      v26 = v21[2];
      v25 = (__int64)v60;
      v27 = v60[4];
      if ( v26 >= v27 )
        sub_4050B0(v26, v27, &off_448308);
      v61 = v60[3] + 536 * v26;
      v21 = (__int64 *)&v50;
      v22 = (__int64)v20;
LABEL_17:
      *v21 = v22;
      v24 = v61;
      if ( !v61 )
        goto LABEL_23;
      v4 = (__int64 *)&Src[8];
      sub_423160(&Src[8], v61, v56, v57);
      a2[5] = *(_OWORD *)&Src[88];
      a2[4] = *(_OWORD *)&Src[72];
      v28 = *(_OWORD *)&Src[8];
      v29 = *(_OWORD *)&Src[24];
      v30 = *(_OWORD *)&Src[40];
      a2[3] = *(_OWORD *)&Src[56];
      a2[2] = v30;
      a2[1] = v29;
      *a2 = v28;
      if ( *(_QWORD *)a2 )
        goto LABEL_2;
    }
    v61 = 0LL;
    lpMem = (LPVOID)8;
    v63 = 0LL;
    v38 = v21[2];
    v39 = v21[3];
    v65 = *v21;
    v60 = v21;
    v64 = v21[1];
    v40 = 8LL;
    v41 = 0LL;
    v59 = v23;
    v31 = v22;
    v54 = v24;
    v53 = v4;
    while ( 1 )
    {
      if ( v39 == 1 )
      {
        v44 = 0LL;
      }
      else
      {
        if ( !v39 )
          break;
        v43 = v39;
        v44 = 0LL;
        do
        {
          v46 = v43 >> 1;
          v47 = 32 * ((v43 >> 1) + v44);
          if ( *(_QWORD *)(v38 + v47 + 16) <= v41
            && (*(_QWORD *)(v38 + v47 + 16) < v41 || *(_QWORD *)(v38 + v47) <= (unsigned __int64)v56) )
          {
            v44 += v43 >> 1;
          }
          v45 = v43 == v46;
          v43 -= v46;
        }
        while ( !v45 && v43 != 1 );
      }
      v48 = (_QWORD *)(v38 + 32 * v44);
      if ( v48[2] > v41
        || *(_QWORD *)(v38 + 32 * v44 + 16) < v41
        || *v48 > (unsigned __int64)v56
        || v48[1] <= (unsigned __int64)v56 )
      {
        break;
      }
      v49 = *(_QWORD *)(v38 + 32 * v44 + 24);
      if ( v49 >= v64 )
        sub_4050B0(*(_QWORD *)(v38 + 32 * v44 + 24), v64, &off_4483F8);
      if ( v41 == v61 )
      {
        sub_42AC70((__int64 *)&v61, (__int64)v48);
        v40 = (__int64)lpMem;
      }
      *(_QWORD *)(v40 + 8 * v41++) = v65 + 48 * v49;
      v63 = v41;
      v42 = v44 + 1;
      v39 -= v42;
      v38 += 32 * v42;
    }
    v25 = v61;
    v24 = (unsigned __int64)lpMem;
    a4 = (char *)lpMem + 8 * v41;
    v5 = *v57 + 2;
    LODWORD(v22) = v54;
    v21 = (__int64 *)HIDWORD(v54);
    v17 = (unsigned __int64)v58;
    v23 = v59;
    v4 = v52;
    v32 = v60;
    v20 = v53;
LABEL_22:
    *(_DWORD *)&Src[8] = v31;
    *(_DWORD *)&Src[12] = v23;
    *(_DWORD *)&Src[16] = v22;
    *(_DWORD *)&Src[20] = (_DWORD)v21;
    *(_QWORD *)&Src[24] = v17;
    *(_QWORD *)&Src[32] = v20;
    *(_QWORD *)&Src[40] = v4;
    *(_QWORD *)&Src[48] = v5;
    *(_QWORD *)&Src[56] = v32;
    *(_QWORD *)&Src[64] = v24;
    *(_QWORD *)&Src[72] = v24;
    *(_QWORD *)&Src[80] = v25;
    *(_QWORD *)&Src[88] = a4;
    result = a4;
    v33 = v55;
    *(_QWORD *)(v55 + 80) = a4;
    v34 = *(_OWORD *)&Src[8];
    v35 = *(_OWORD *)&Src[24];
    v36 = *(_OWORD *)&Src[40];
    v37 = *(_OWORD *)&Src[56];
    *(_OWORD *)(v33 + 64) = *(_OWORD *)&Src[72];
    *(_OWORD *)(v33 + 48) = v37;
    *(_OWORD *)(v33 + 32) = v36;
    *(_OWORD *)(v33 + 16) = v35;
    *(_OWORD *)v33 = v34;
    *(_BYTE *)(v33 + 176) = 2;
  }
  return result;
}
// 4238E0: variable 'v4' is possibly undefined
// 4238E4: variable 'v5' is possibly undefined
// 4238F8: variable 'a4' is possibly undefined
// 4050B0: using guessed type void __fastcall __noreturn sub_4050B0(_QWORD, _QWORD, _QWORD);
// 448308: using guessed type char *off_448308;
// 4483F8: using guessed type char *off_4483F8;

//----- (0000000000423B70) ----------------------------------------------------
int __fastcall sub_423B70(unsigned __int64 a1, __int64 *a2, __int64 a3)
{
  __m128i v3; // xmm0
  __int64 v5; // rsi
  _QWORD *v6; // rdi
  char v7; // dl
  unsigned __int64 v8; // rax
  __int64 v9; // rbx
  __int64 v10; // r13
  __int64 v11; // rcx
  char *v12; // rax
  _QWORD *v13; // rcx
  unsigned int v14; // ebx
  unsigned __int64 v15; // r8
  int v16; // r9d
  unsigned __int64 v17; // r10
  _QWORD *v18; // r10
  __int64 v19; // r11
  __int64 v20; // r9
  __int64 v21; // r8
  __int64 v22; // r12
  void *v23; // r9
  unsigned __int64 v24; // rdx
  char *v25; // r14
  char *v26; // r10
  char *v27; // r11
  unsigned __int64 v28; // r8
  int v29; // ecx
  char v30; // di
  bool v31; // cf
  __int64 v32; // rax
  __int64 v33; // rax
  __int64 v34; // rcx
  __int64 v35; // r11
  __int64 v36; // r9
  char v37; // di
  unsigned __int64 v38; // rbx
  __int64 v39; // r9
  unsigned __int64 v40; // rcx
  char *v41; // r15
  __int64 v42; // rbx
  __int64 v43; // r13
  char *v44; // rax
  char *v45; // rcx
  unsigned int *v46; // rax
  __int64 v47; // rax
  __int128 v48; // rt0
  LPVOID v49; // rax
  void *v50; // rax
  __int64 v51; // rcx
  void *v52; // rax
  __int64 v53; // rax
  __int64 v54; // rcx
  char *v55; // rax
  unsigned __int64 v56; // rax
  __int128 v57; // rt0
  __int128 v58; // rt0
  unsigned __int64 v59; // rcx
  __int64 v60; // rax
  void *v61; // rcx
  __int64 v62; // r13
  LPVOID v63; // rax
  unsigned __int64 v64; // r15
  char *v65; // rdi
  char v66; // bl
  unsigned __int64 v67; // rcx
  __int64 v68; // rax
  __int64 v69; // rdx
  __int64 v70; // r15
  LPVOID v71; // rdi
  void *v72; // r13
  unsigned __int64 v73; // rcx
  __int64 v74; // rax
  char *v75; // rax
  __int64 v76; // rcx
  __m128i v77; // xmm1
  __int128 v78; // xmm2
  __int64 v79; // r14
  unsigned __int64 v80; // r15
  HANDLE ProcessHeap; // rax
  unsigned __int64 v82; // rax
  __int64 v83; // r13
  HANDLE v84; // rax
  char *v85; // r9
  unsigned __int64 v86; // r15
  unsigned __int64 v87; // r13
  void *v88; // rbx
  HANDLE v89; // rax
  void *v90; // r14
  _QWORD *v91; // rdi
  void *v92; // rbx
  HANDLE v93; // rax
  void *v94; // rbx
  HANDLE v95; // rax
  HANDLE v96; // rax
  unsigned __int64 v97; // r15
  unsigned __int8 v98; // cl
  HANDLE v99; // rax
  HANDLE v100; // rax
  __m128i v101; // xmm1
  unsigned __int64 v102; // r14
  unsigned __int64 v103; // rdx
  __int64 v104; // r15
  __int64 v105; // r8
  __int64 v106; // rdx
  unsigned __int64 v107; // rcx
  unsigned __int64 v108; // rdx
  __int64 v109; // r13
  __int64 *v110; // r10
  unsigned __int64 v111; // r15
  unsigned __int64 v112; // r12
  __int64 v113; // rax
  char v114; // r11
  unsigned __int64 v115; // rdx
  unsigned __int64 v116; // r8
  _QWORD *v117; // rdx
  __int64 v118; // r11
  __int64 v119; // r12
  __int64 v120; // r8
  __int64 v121; // r9
  unsigned __int64 v122; // rax
  _QWORD *v123; // rdi
  char v124; // r10
  unsigned __int64 v125; // rdi
  int v126; // edx
  unsigned __int64 v127; // rbx
  unsigned int v128; // r15d
  unsigned __int64 v129; // rdi
  void *v130; // rbx
  HANDLE v131; // rax
  HANDLE v132; // rax
  unsigned __int64 v133; // r15
  LPVOID v134; // rax
  int v135; // r12d
  unsigned __int64 v136; // r8
  unsigned __int64 v137; // rdx
  __m128i v138; // xmm1
  unsigned __int64 v139; // r10
  unsigned __int64 v140; // r9
  unsigned __int64 v141; // r9
  unsigned __int64 v142; // r10
  unsigned __int64 v143; // r11
  __int64 v144; // r10
  unsigned __int64 v145; // r9
  int v146; // ecx
  __int64 v147; // rcx
  unsigned __int64 v148; // rdi
  unsigned __int64 v149; // r9
  unsigned __int64 v150; // r14
  __int64 v151; // r11
  unsigned __int64 *v152; // r10
  unsigned __int64 v153; // r9
  unsigned __int64 v154; // rcx
  unsigned __int64 v155; // rax
  __int64 v156; // rcx
  unsigned __int64 v157; // rdx
  unsigned __int64 v158; // rdx
  __int64 v159; // rdx
  __int64 v160; // r11
  __int64 v161; // r9
  char v162; // di
  __int64 v163; // rax
  __int64 v164; // rdx
  __int64 v165; // rbx
  __int64 v166; // r12
  __int64 v167; // r15
  unsigned __int64 v168; // rdx
  void *v169; // rax
  void *v170; // rbx
  void *v171; // r12
  HANDLE v172; // rax
  __int64 v173; // rax
  __int64 v174; // rbx
  __int64 v175; // rdi
  HANDLE v176; // rax
  HANDLE v177; // rax
  HANDLE v178; // rax
  __int64 v179; // r15
  HANDLE v180; // rax
  HANDLE v181; // rax
  __int64 v182; // rdi
  __m128i v184; // [rsp+58h] [rbp-28h] BYREF
  __m128i v185; // [rsp+68h] [rbp-18h] BYREF
  __int128 v186; // [rsp+78h] [rbp-8h]
  __int128 v187; // [rsp+88h] [rbp+8h]
  __int64 v188; // [rsp+98h] [rbp+18h]
  char *v189; // [rsp+150h] [rbp+D0h]
  unsigned __int64 v190; // [rsp+158h] [rbp+D8h]
  unsigned __int64 v191; // [rsp+160h] [rbp+E0h]
  __int64 v192; // [rsp+168h] [rbp+E8h]
  __int64 v193; // [rsp+170h] [rbp+F0h]
  __int64 v194; // [rsp+178h] [rbp+F8h]
  __int64 v195; // [rsp+180h] [rbp+100h]
  __int64 v196; // [rsp+188h] [rbp+108h]
  char *v197; // [rsp+190h] [rbp+110h]
  __int64 v198; // [rsp+198h] [rbp+118h]
  __int64 v199; // [rsp+1A0h] [rbp+120h]
  __int64 v200; // [rsp+1A8h] [rbp+128h]
  __int64 v201; // [rsp+1B0h] [rbp+130h]
  char *v202; // [rsp+1B8h] [rbp+138h]
  LPVOID v203; // [rsp+1C0h] [rbp+140h]
  int v204; // [rsp+1CCh] [rbp+14Ch]
  unsigned int v205; // [rsp+1D0h] [rbp+150h]
  int v206; // [rsp+1D4h] [rbp+154h]
  __int64 v207; // [rsp+1D8h] [rbp+158h]
  unsigned __int64 v208; // [rsp+1E0h] [rbp+160h] BYREF
  LPVOID lpMem; // [rsp+1E8h] [rbp+168h]
  unsigned __int64 v210; // [rsp+1F0h] [rbp+170h]
  char *v211; // [rsp+1F8h] [rbp+178h]
  __int64 v212; // [rsp+200h] [rbp+180h]
  unsigned __int64 v213; // [rsp+208h] [rbp+188h]
  __int64 v214; // [rsp+210h] [rbp+190h]
  __int64 v215; // [rsp+218h] [rbp+198h]
  unsigned __int64 v216; // [rsp+220h] [rbp+1A0h]
  unsigned __int64 v217; // [rsp+228h] [rbp+1A8h]
  __int64 v218; // [rsp+230h] [rbp+1B0h]
  _QWORD *v219; // [rsp+238h] [rbp+1B8h]
  unsigned __int64 v220; // [rsp+240h] [rbp+1C0h]
  __int64 v221; // [rsp+248h] [rbp+1C8h]
  __int64 v222; // [rsp+250h] [rbp+1D0h]
  char *v223; // [rsp+258h] [rbp+1D8h]
  LPVOID v224[2]; // [rsp+260h] [rbp+1E0h] BYREF
  __m128i v225; // [rsp+270h] [rbp+1F0h] BYREF
  __int64 v226; // [rsp+280h] [rbp+200h]
  unsigned __int64 v227; // [rsp+288h] [rbp+208h]
  int v228; // [rsp+294h] [rbp+214h]
  LPVOID v229; // [rsp+298h] [rbp+218h]
  unsigned __int64 v230; // [rsp+2A0h] [rbp+220h]
  __int128 v231; // [rsp+2A8h] [rbp+228h] BYREF
  unsigned __int64 v232; // [rsp+2B8h] [rbp+238h]
  LPVOID v233[2]; // [rsp+2C0h] [rbp+240h] BYREF
  void *v234; // [rsp+2D0h] [rbp+250h]
  _QWORD *v235; // [rsp+2E0h] [rbp+260h]
  unsigned __int64 v236; // [rsp+2E8h] [rbp+268h]
  LPVOID v237; // [rsp+2F0h] [rbp+270h]
  __int64 v238; // [rsp+2F8h] [rbp+278h]
  LPVOID v239; // [rsp+300h] [rbp+280h]

  v5 = a1;
  v6 = *(_QWORD **)(a3 + 8);
  v7 = *(_BYTE *)(a3 + 16);
  if ( (*(_BYTE *)a3 & 1) != 0 )
  {
    LODWORD(v8) = *(_DWORD *)(a3 + 17);
    *(_DWORD *)(a1 + 28) = *(_DWORD *)(a3 + 20);
    *(_DWORD *)(a1 + 25) = v8;
    *(_QWORD *)(a1 + 16) = v6;
    *(_BYTE *)(a1 + 24) = v7;
LABEL_224:
    *(_DWORD *)(v5 + 8) = 3;
    return v8;
  }
  LOBYTE(v229) = *(_BYTE *)(a3 + 16);
  v9 = *(_QWORD *)(a3 + 24);
  v10 = *a2;
  if ( (*(_BYTE *)(*a2 + 472) & 1) != 0 )
    goto LABEL_159;
  v208 = 0LL;
  lpMem = (LPVOID)8;
  v210 = 0LL;
  *(_QWORD *)&v231 = 0LL;
  *((_QWORD *)&v231 + 1) = 8LL;
  v232 = 0LL;
  v11 = *(_QWORD *)(v9 + 344) + 16LL;
  v12 = *(char **)(v9 + 48);
  v224[0] = *(LPVOID *)(v9 + 40);
  v224[1] = v12;
  v225.m128i_i64[0] = v9;
  v225.m128i_i64[1] = v11;
  v226 = 0LL;
  v215 = v10;
  v237 = a2;
  v198 = v5;
  if ( !v12 )
  {
    v239 = (LPVOID)8;
    v236 = 0LL;
    goto LABEL_130;
  }
  v13 = (_QWORD *)v9;
  v14 = *(_DWORD *)(v9 + 72);
  v15 = v13[52];
  v189 = (char *)v6[25];
  v191 = (unsigned __int64)&v189[-v15];
  v204 = v14 & 0xFF00;
  v205 = HIWORD(v14);
  v16 = 0;
  v17 = 0LL;
  if ( v14 < 0x50000 )
    v17 = v15;
  LOBYTE(v16) = v14 >= 0x50000;
  if ( (v6[30] & 1) == 0 )
    v17 = 0LL;
  v190 = v17;
  v18 = (_QWORD *)v13[50];
  v220 = v6[3];
  v230 = v220 - (_QWORD)v18;
  v206 = v16;
  v19 = (unsigned int)(16 * v16);
  v20 = v6[24];
  v216 = v15;
  v196 = v20;
  v200 = v20 + v15;
  LODWORD(v217) = v14;
  v192 = BYTE1(v14);
  v21 = v6[2];
  v219 = v18;
  v207 = v21;
  v211 = (char *)v18 + v21;
  v201 = v14;
  v199 = (unsigned __int8)v14;
  v193 = v19;
  v194 = v19 + 8;
  v238 = (__int64)v13;
  v195 = v13[48];
  v218 = 8LL;
  v236 = 0LL;
  v22 = 0LL;
  v235 = v6;
LABEL_10:
  v23 = v224[0];
  v24 = v225.m128i_i64[0];
  v25 = (char *)v224[0]
      + 8 * (*(_BYTE *)(v225.m128i_i64[0] + 73) == 8)
      + *(_QWORD *)(v225.m128i_i64[0] + 56)
      - *(_QWORD *)(v225.m128i_i64[0] + 40)
      - *(_QWORD *)(v225.m128i_i64[0] + 48)
      + 4;
  v26 = v12 - 1;
  v27 = (char *)v224[0] + 1;
  v28 = 0LL;
  v29 = 0;
  while ( 1 )
  {
    v30 = *(v27 - 1);
    if ( v29 == 63 && (unsigned __int8)v30 >= 2u )
    {
      LOBYTE(v12) = 6;
      v239 = v12;
      LOWORD(v87) = 0;
      goto LABEL_138;
    }
    v28 |= (unsigned __int64)(v30 & 0x7F) << v29;
    if ( v30 >= 0 )
      break;
    v29 += 7;
    ++v27;
    v31 = v26-- != 0LL;
    if ( !v31 )
    {
      v85 = &v12[(unsigned __int64)v224[0]];
      LOBYTE(v12) = 19;
      v239 = v12;
      v86 = 0LL;
      LOWORD(v87) = 0;
      v5 = (__int64)v85;
      goto LABEL_139;
    }
  }
  v224[0] = v27;
  v224[1] = v26;
  if ( !v28 )
  {
    --v226;
    v212 = 0LL;
    v6 = v235;
    goto LABEL_98;
  }
  if ( v28 - 1 >= *(_QWORD *)(v225.m128i_i64[1] + 16) )
  {
    v33 = *(_QWORD *)(v225.m128i_i64[1] + 24);
    if ( !v33 )
    {
      v239 = (LPVOID)18;
      LOWORD(v87) = 0;
      v86 = 0LL;
      v5 = v212;
      goto LABEL_139;
    }
    LOBYTE(v23) = 18;
    v239 = v23;
    v34 = *(_QWORD *)(v225.m128i_i64[1] + 32);
LABEL_22:
    v35 = 8 * (unsigned int)*(unsigned __int16 *)(v33 + 1330);
    v36 = -1LL;
    do
    {
      if ( !v35 )
      {
        v36 = *(unsigned __int16 *)(v33 + 1330);
LABEL_30:
        v86 = 0LL;
        v31 = v34-- == 0;
        if ( v31 )
        {
          LOWORD(v87) = 0;
          v5 = v212;
          goto LABEL_139;
        }
        v33 = *(_QWORD *)(v33 + 8 * v36 + 1336);
        goto LABEL_22;
      }
      v37 = *(_QWORD *)(v33 + 8 * v36 + 1248) != v28;
      if ( *(_QWORD *)(v33 + 8 * v36 + 1248) > v28 )
        v37 = -1;
      ++v36;
      v35 -= 8LL;
    }
    while ( v37 == 1 );
    if ( v37 )
      goto LABEL_30;
    v32 = 112 * v36 + v33;
  }
  else
  {
    v32 = *(_QWORD *)(v225.m128i_i64[1] + 8) + 112 * (v28 - 1);
  }
  v6 = v235;
  v212 = v32;
  if ( *(_BYTE *)(v32 + 106) == 1 )
    ++v226;
  if ( *(_WORD *)(v212 + 104) != 46 )
  {
    if ( (*(_BYTE *)v212 & 1) != 0 )
    {
      v39 = *(_QWORD *)(v212 + 16);
      v40 = *(_QWORD *)(v212 + 24);
    }
    else
    {
      v40 = *(_QWORD *)(v212 + 8);
      if ( v40 >= 6 )
        goto LABEL_331;
      v39 = v212 + 16;
    }
    sub_425CD0((__int64)&v184, (char **)v224, *(_DWORD *)(v225.m128i_i64[0] + 72), v39, v40);
    if ( v184.m128i_i8[0] != 75 )
    {
      v239 = (LPVOID)v184.m128i_u8[0];
      LOWORD(v87) = *(__int16 *)((char *)v184.m128i_i16 + 1);
      v86 = (((unsigned __int64)((v184.m128i_u8[7] << 16) | (unsigned int)*(unsigned __int16 *)((char *)&v184.m128i_u16[2]
                                                                                              + 1)) << 32) | *(unsigned int *)((char *)v184.m128i_u32 + 1)) >> 8;
      v5 = v184.m128i_i64[1];
      goto LABEL_139;
    }
    goto LABEL_98;
  }
  if ( (*(_BYTE *)v212 & 1) != 0 )
  {
    v239 = *(LPVOID *)(v212 + 16);
    v38 = *(_QWORD *)(v212 + 24);
  }
  else
  {
    v38 = *(_QWORD *)(v212 + 8);
    if ( v38 > 5 )
    {
      v40 = *(_QWORD *)(v212 + 8);
LABEL_331:
      sub_405B00(v40, 5LL, (__int64)&off_446D68);
    }
    v239 = (LPVOID)(v212 + 16);
  }
  v41 = v223;
  if ( !v38 )
    goto LABEL_98;
  v42 = 16 * v38;
  v43 = 0LL;
  v221 = 0LL;
  v222 = 0LL;
  v203 = 0LL;
  v228 = 0;
  while ( 1 )
  {
    v3 = _mm_loadu_si128((const __m128i *)((char *)v239 + v43));
    *(__m128i *)v233 = v3;
    sub_41D2E0((__int64)&v184, (unsigned __int64 *)v224, *(_DWORD *)(v225.m128i_i64[0] + 72), (__int64)v233);
    if ( v184.m128i_i32[0] == 46 )
    {
      v64 = v184.m128i_u64[1];
      v5 = v185.m128i_i64[0];
      v87 = (unsigned __int64)v184.m128i_i64[1] >> 8;
LABEL_261:
      v239 = (LPVOID)v64;
      v86 = v64 >> 16;
      goto LABEL_139;
    }
    if ( v185.m128i_u16[4] == 17 )
    {
      sub_421680((__int64)v233, v184.m128i_i64);
      if ( v233[0] )
      {
        if ( LODWORD(v233[0]) != 12 )
          goto LABEL_45;
        v50 = (void *)v220;
        if ( v220 < (unsigned __int64)v219 )
        {
LABEL_306:
          LOBYTE(v50) = 19;
          v239 = v50;
          LOWORD(v87) = 0;
          v5 = v207;
          goto LABEL_138;
        }
        v54 = v199 * (__int64)v233[1];
        v24 = v230 - v199 * (__int64)v233[1];
        if ( v230 < v199 * (__int64)v233[1] )
          goto LABEL_308;
        v55 = &v211[v54];
        switch ( (char)v217 )
        {
          case 1:
            if ( v230 == v54 )
              goto LABEL_322;
            v56 = (unsigned __int8)*v55;
            goto LABEL_86;
          case 2:
            if ( v24 <= 1 )
              goto LABEL_322;
            v56 = *(unsigned __int16 *)v55;
            goto LABEL_86;
          case 4:
            if ( v24 <= 3 )
              goto LABEL_322;
            v56 = *(unsigned int *)v55;
            goto LABEL_86;
          case 8:
            if ( v24 <= 7 )
            {
LABEL_322:
              LOBYTE(v54) = 19;
              v239 = (LPVOID)v54;
              LOWORD(v87) = 0;
              v5 = (__int64)v55;
              goto LABEL_138;
            }
            v54 = (unsigned __int8)v55[7];
            *(_QWORD *)&v57 = ((unsigned __int64)(*((unsigned __int16 *)v55 + 2) | ((unsigned __int8)v55[6] << 16)) << 40) | ((unsigned __int64)*(unsigned int *)v55 << 8);
            *((_QWORD *)&v57 + 1) = v54;
            v56 = v57 >> 8;
LABEL_86:
            LOBYTE(v54) = 1;
            v221 = v54;
            v213 = v56;
            break;
          default:
            LOBYTE(v55) = 23;
            v239 = v55;
            LOWORD(v87) = v201;
            v5 = v213;
            goto LABEL_138;
        }
      }
      else
      {
        v221 = 1LL;
        v56 = (unsigned __int64)v233[1];
      }
      v227 = v56;
      goto LABEL_45;
    }
    if ( v185.m128i_u16[4] == 18 )
      break;
    if ( v185.m128i_u16[4] == 85 )
    {
      sub_421680((__int64)v233, v184.m128i_i64);
      LODWORD(v45) = v233[0];
      if ( v233[0] == (LPVOID)22 )
      {
        v44 = (char *)v233[1] + v190;
LABEL_79:
        LOBYTE(v45) = 1;
        v228 = (int)v45;
        goto LABEL_44;
      }
      if ( LODWORD(v233[0]) != 24 )
      {
        v228 = 0;
        v44 = v202;
LABEL_44:
        v202 = v44;
        goto LABEL_45;
      }
      v45 = v189;
      if ( (unsigned __int64)v189 < v216 )
      {
        v5 = v196;
      }
      else
      {
        v45 = (char *)(v191 - v192 * (__int64)v233[1]);
        if ( v191 < v192 * (__int64)v233[1] )
        {
          v5 = v200;
        }
        else
        {
          v46 = (unsigned int *)(v200 + v192 * (__int64)v233[1]);
          if ( v204 == 2048 )
          {
            if ( (unsigned __int64)v45 <= 7 )
              goto LABEL_320;
            LODWORD(v45) = *((unsigned __int8 *)v46 + 7);
            *(_QWORD *)&v48 = ((unsigned __int64)(*((unsigned __int16 *)v46 + 2) | (*((unsigned __int8 *)v46 + 6) << 16)) << 40) | ((unsigned __int64)*v46 << 8);
            *((_QWORD *)&v48 + 1) = *((unsigned __int8 *)v46 + 7);
            v47 = v48 >> 8;
            goto LABEL_78;
          }
          if ( (unsigned __int64)v45 > 3 )
          {
            v47 = *v46;
LABEL_78:
            v44 = (char *)(v216 + v47);
            goto LABEL_79;
          }
LABEL_320:
          v5 = v200 + v192 * (__int64)v233[1];
        }
      }
      LOBYTE(v45) = 19;
      v239 = v45;
      v86 = 0LL;
      LOWORD(v87) = 0;
      goto LABEL_139;
    }
LABEL_45:
    v43 += 16LL;
    if ( v42 == v43 )
    {
      if ( (v228 & 1) != 0 )
      {
        v223 = v41;
        v59 = *(_QWORD *)((char *)v6 + v194 + 176);
        v60 = *(_QWORD *)((char *)v6 + v193 + 176);
        v24 = (unsigned __int64)v202;
        v31 = v59 < (unsigned __int64)v202;
        v61 = (void *)(v59 - (_QWORD)v202);
        v62 = v215;
        if ( v31 )
        {
          LOBYTE(v61) = 19;
          v239 = v61;
          v86 = 0LL;
          LOWORD(v87) = 0;
          v5 = v60;
          goto LABEL_139;
        }
        v184.m128i_i64[0] = v207;
        v184.m128i_i64[1] = v220;
        v185.m128i_i64[0] = v195;
        v185.m128i_i64[1] = (__int64)v219;
        *(_QWORD *)&v186 = &v202[v60];
        *((_QWORD *)&v186 + 1) = v61;
        LOWORD(v187) = v217;
        WORD1(v187) = v205;
        BYTE4(v187) = v206;
        sub_41E760(v233, (unsigned __int8 **)&v184);
        v63 = v233[0];
        if ( v233[0] == (LPVOID)2 )
        {
LABEL_103:
          v64 = (unsigned __int64)v233[1];
          v87 = (unsigned __int64)v233[1] >> 8;
          if ( LOBYTE(v233[1]) != 75 )
          {
            v5 = (__int64)v234;
            goto LABEL_261;
          }
          if ( (BYTE1(v233[1]) & 1) == 0 )
            goto LABEL_98;
        }
        else
        {
          v66 = 0;
          while ( v63 == (LPVOID)1 )
          {
            v70 = v62;
            v71 = v233[1];
            v72 = v234;
            if ( v233[1] < v234 )
            {
              if ( v236 == (_QWORD)v231 )
              {
                sub_426260((unsigned __int64 *)&v231, (__int64)&off_448458);
                v218 = *((_QWORD *)&v231 + 1);
              }
              v67 = v236;
              v68 = 3 * v236;
              v69 = v218;
              *(_QWORD *)(v218 + 8 * v68) = v71;
              *(_QWORD *)(v69 + 8 * v68 + 8) = v72;
              *(_QWORD *)(v69 + 8 * v68 + 16) = v22;
              v236 = v67 + 1;
              v232 = v67 + 1;
              v66 = 1;
            }
            v6 = v235;
            sub_41E760(v233, (unsigned __int8 **)&v184);
            v63 = v233[0];
            v62 = v70;
            if ( v233[0] == (LPVOID)2 )
              goto LABEL_103;
          }
          if ( (v66 & 1) == 0 )
            goto LABEL_98;
        }
        goto LABEL_125;
      }
      if ( (v221 & 1) == 0 )
        goto LABEL_111;
      if ( (v222 & 1) != 0 )
      {
        if ( v227 < (unsigned __int64)v41 )
        {
          v223 = v41;
          v65 = v41;
          if ( v236 == (_QWORD)v231 )
          {
            sub_426260((unsigned __int64 *)&v231, (__int64)&off_448458);
            v218 = *((_QWORD *)&v231 + 1);
            v65 = v223;
          }
          goto LABEL_123;
        }
LABEL_111:
        v223 = v41;
        goto LABEL_98;
      }
      v223 = v41;
      if ( ((unsigned __int8)v203 & 1) != 0 )
      {
        v65 = &v197[v227];
        if ( v227 < (unsigned __int64)&v197[v227] )
        {
          if ( v236 == (_QWORD)v231 )
          {
            sub_426260((unsigned __int64 *)&v231, (__int64)&off_448458);
            v218 = *((_QWORD *)&v231 + 1);
          }
LABEL_123:
          v73 = v236;
          v74 = 3 * v236;
          v24 = v218;
          *(_QWORD *)(v218 + 8 * v74) = v227;
          *(_QWORD *)(v24 + 8 * v74 + 8) = v65;
          *(_QWORD *)(v24 + 8 * v74 + 16) = v22;
          v236 = v73 + 1;
          v232 = v73 + 1;
          v6 = v235;
LABEL_125:
          v184 = (__m128i)(unsigned __int64)v25;
          if ( v22 == v208 )
            sub_426330(&v208, v24);
          v75 = (char *)lpMem;
          v76 = 9 * v22;
          *((_QWORD *)lpMem + v76 + 8) = v188;
          v3 = _mm_loadu_si128(&v184);
          v77 = _mm_loadu_si128(&v185);
          v78 = v186;
          *(_OWORD *)&v75[8 * v76 + 48] = v187;
          *(_OWORD *)&v75[8 * v76 + 32] = v78;
          *(__m128i *)&v75[8 * v76 + 16] = v77;
          *(__m128i *)&v75[8 * v76] = v3;
          v210 = ++v22;
          goto LABEL_98;
        }
        v6 = v235;
      }
LABEL_98:
      v12 = (char *)v224[1];
      if ( !v224[1] )
      {
        v239 = (LPVOID)*((_QWORD *)&v231 + 1);
        if ( v236 < 2 )
          goto LABEL_303;
        if ( v236 >= 0x15 )
        {
          sub_425B00(v239, v236);
          v6 = v235;
          v9 = v238;
        }
        else
        {
          sub_425C30((__int64)v239, v236);
          v6 = v235;
LABEL_303:
          v9 = v238;
        }
LABEL_130:
        v79 = (__int64)lpMem;
        v80 = v210;
        if ( v208 <= v210 )
        {
LABEL_133:
          v82 = v236;
          if ( (unsigned __int64)v231 <= v236 )
            goto LABEL_154;
        }
        else
        {
          if ( v210 )
          {
            ProcessHeap = GetProcessHeap();
            v238 = 72 * v80;
            v79 = (__int64)HeapReAlloc(ProcessHeap, 0, (LPVOID)v79, 72 * v80);
            if ( !v79 )
              sub_4040E9(8LL, v238);
            goto LABEL_133;
          }
          v99 = GetProcessHeap();
          HeapFree(v99, 0, (LPVOID)v79);
          v79 = 8LL;
          v82 = v236;
          if ( (unsigned __int64)v231 <= v236 )
          {
LABEL_154:
            v5 = (__int64)v239;
LABEL_156:
            v87 = v80 >> 8;
            v98 = v80;
            v97 = v80 >> 16;
            a2 = (__int64 *)v237;
            v24 = v236;
            goto LABEL_157;
          }
        }
        if ( v82 )
        {
          v83 = 24 * v82;
          v84 = GetProcessHeap();
          v5 = (__int64)HeapReAlloc(v84, 0, v239, v83);
          if ( !v5 )
            sub_4040E9(8LL, v83);
        }
        else
        {
          v100 = GetProcessHeap();
          HeapFree(v100, 0, v239);
          v5 = 8LL;
        }
        goto LABEL_156;
      }
      goto LABEL_10;
    }
  }
  sub_421680((__int64)v233, v184.m128i_i64);
  v49 = v233[0];
  if ( !v233[0] )
  {
    v222 = 1LL;
    v41 = (char *)v233[1];
    goto LABEL_45;
  }
  if ( LODWORD(v233[0]) == 7 )
  {
    LOBYTE(v49) = 1;
    v203 = v49;
    v197 = (char *)v233[1];
    goto LABEL_45;
  }
  if ( LODWORD(v233[0]) != 12 )
    goto LABEL_45;
  v50 = (void *)v220;
  if ( v220 < (unsigned __int64)v219 )
    goto LABEL_306;
  v51 = v199 * (__int64)v233[1];
  v24 = v230 - v199 * (__int64)v233[1];
  if ( v230 < v199 * (__int64)v233[1] )
  {
LABEL_308:
    LOBYTE(v50) = 19;
    v239 = v50;
    LOWORD(v87) = 0;
    v5 = (__int64)v211;
    goto LABEL_138;
  }
  v52 = v211;
  v5 = (__int64)&v211[v51];
  switch ( (char)v217 )
  {
    case 1:
      if ( v230 == v51 )
        goto LABEL_323;
      v53 = *(unsigned __int8 *)v5;
      goto LABEL_94;
    case 2:
      if ( v24 <= 1 )
        goto LABEL_323;
      v53 = *(unsigned __int16 *)v5;
      goto LABEL_94;
    case 4:
      if ( v24 <= 3 )
        goto LABEL_323;
      v53 = *(unsigned int *)v5;
      goto LABEL_94;
    case 8:
      if ( v24 > 7 )
      {
        v51 = *(unsigned __int8 *)(v5 + 7);
        *(_QWORD *)&v58 = ((unsigned __int64)(*(unsigned __int16 *)(v5 + 4) | (*(unsigned __int8 *)(v5 + 6) << 16)) << 40) | ((unsigned __int64)*(unsigned int *)v5 << 8);
        *((_QWORD *)&v58 + 1) = v51;
        v53 = v58 >> 8;
LABEL_94:
        LOBYTE(v51) = 1;
        v222 = v51;
        v214 = v53;
        v41 = (char *)v53;
        goto LABEL_45;
      }
LABEL_323:
      LOBYTE(v51) = 19;
      v239 = (LPVOID)v51;
      LOWORD(v87) = 0;
LABEL_138:
      v86 = 0LL;
LABEL_139:
      if ( (_QWORD)v231 )
      {
        v88 = (void *)*((_QWORD *)&v231 + 1);
        v89 = GetProcessHeap();
        HeapFree(v89, 0, v88);
      }
      v90 = lpMem;
      if ( v22 )
      {
        v91 = (char *)lpMem + 40;
        do
        {
          if ( *(v91 - 4) )
          {
            v92 = (void *)*(v91 - 3);
            if ( v92 )
            {
              if ( *(v91 - 2) )
              {
                v93 = GetProcessHeap();
                HeapFree(v93, 0, v92);
              }
              if ( *v91 )
              {
                v94 = (void *)*(v91 - 1);
                v95 = GetProcessHeap();
                HeapFree(v95, 0, v94);
              }
            }
          }
          v91 += 9;
          --v22;
        }
        while ( v22 );
      }
      if ( v208 )
      {
        v96 = GetProcessHeap();
        HeapFree(v96, 0, v90);
      }
      v97 = v86 & 0xFFFFFFFFFFFFLL;
      v79 = 0LL;
      v6 = v235;
      v9 = v238;
      a2 = (__int64 *)v237;
      v98 = (unsigned __int8)v239;
LABEL_157:
      v184.m128i_i64[0] = v79;
      a1 = (v97 << 16) | (unsigned __int16)((_WORD)v87 << 8) | v98;
      v184.m128i_i64[1] = a1;
      v185.m128i_i64[0] = v5;
      v185.m128i_i64[1] = v24;
      v10 = v215;
      if ( !*(_QWORD *)(v215 + 472) )
      {
        v5 = v198;
        *(_QWORD *)(v215 + 472) = 1LL;
        v3 = _mm_loadu_si128(&v184);
        v101 = _mm_loadu_si128(&v185);
        *(__m128i *)(v10 + 480) = v3;
        *(__m128i *)(v10 + 496) = v101;
        if ( *(_QWORD *)(v10 + 480) )
          goto LABEL_160;
        goto LABEL_162;
      }
      sub_4265D0((__int64)&v184);
      v5 = v198;
LABEL_159:
      if ( !*(_QWORD *)(v10 + 480) )
      {
LABEL_162:
        LODWORD(a1) = *(unsigned __int8 *)(v10 + 488);
        v8 = *(_QWORD *)(v10 + 496);
        if ( (_BYTE)a1 == 75 )
          goto LABEL_163;
        v126 = *(_DWORD *)(v10 + 489);
        *(_DWORD *)(v5 + 20) = *(_DWORD *)(v10 + 492);
        *(_DWORD *)(v5 + 17) = v126;
        *(_BYTE *)(v5 + 16) = a1;
        goto LABEL_223;
      }
LABEL_160:
      v8 = v10 + 480;
LABEL_163:
      v102 = a2[2];
      v103 = *(_QWORD *)(v8 + 24);
      v104 = 0LL;
      if ( !v103 )
        goto LABEL_195;
      a1 = *(_QWORD *)(v8 + 16);
      if ( v103 != 1 )
      {
        v105 = 0LL;
        do
        {
          v104 = (v103 >> 1) + v105;
          if ( v102 < *(_QWORD *)(a1 + 24 * v104) )
            v104 = v105;
          v103 -= v103 >> 1;
          v105 = v104;
        }
        while ( v103 > 1 );
      }
      v106 = 3 * v104;
      v104 = 0LL;
      if ( v102 < *(_QWORD *)(a1 + 8 * v106) || v102 >= *(_QWORD *)(a1 + 8 * v106 + 8) )
      {
LABEL_195:
        v135 = 2;
        if ( *(_DWORD *)(v10 + 96) == 47 )
          goto LABEL_196;
        goto LABEL_199;
      }
      v235 = v6;
      v215 = v10;
      v107 = *(_QWORD *)(a1 + 8 * v106 + 16);
      v108 = *(_QWORD *)(v8 + 8);
      if ( v107 >= v108 )
        sub_4050B0(v107, v108, &off_448338);
      v8 = *(_QWORD *)v8;
      a1 = 9 * v107;
      v109 = v8 + 8 * a1 + 8;
      if ( (*(_BYTE *)v109 & 1) == 0 )
      {
        v110 = a2;
        v111 = *(_QWORD *)(v8 + 8 * a1);
        v112 = *(_QWORD *)(v9 + 48);
        v113 = *(_QWORD *)(v9 + 56);
        v114 = *(_BYTE *)(v9 + 73);
        a1 = v114 == 8;
        v115 = v113 - v112 + 8 * a1 + 4;
        v116 = v111 - v115;
        v236 = v111;
        if ( v111 < v115 || v112 <= v116 )
        {
          LOBYTE(v125) = 56;
          v119 = v9;
          goto LABEL_184;
        }
        LOBYTE(v239) = v114;
        v219 = (_QWORD *)v110[1];
        v117 = *(_QWORD **)(v9 + 344);
        a1 = 8 * a1 + 4;
        v118 = *(_QWORD *)(v9 + 40);
        v184.m128i_i64[0] = v118 + v116;
        v184.m128i_i64[1] = v112 - v116;
        v185.m128i_i64[0] = v9;
        v185.m128i_i64[1] = (__int64)(v117 + 2);
        *(_QWORD *)&v186 = 0LL;
        v119 = v118 + v112;
        v120 = v113 + a1 + ~v111;
        v121 = v111 - a1 - v113;
        v122 = 0LL;
        LODWORD(a1) = 0;
        v123 = v235;
        while ( 1 )
        {
          v124 = *(_BYTE *)(v119 + v121);
          if ( (_DWORD)a1 == 63 && (unsigned __int8)v124 > 1u )
          {
            LOBYTE(v125) = 6;
            goto LABEL_184;
          }
          v122 |= (unsigned __int64)(v124 & 0x7F) << a1;
          if ( v124 >= 0 )
            break;
          LODWORD(a1) = a1 + 7;
          --v120;
          if ( !++v121 )
          {
            LOBYTE(v125) = 19;
            goto LABEL_184;
          }
        }
        v184.m128i_i64[0] = v119 + v121 + 1;
        v184.m128i_i64[1] = v120;
        if ( !v122 )
          sub_407050((__int64)&off_448428);
        if ( v122 - 1 < v117[4] )
        {
          v147 = v117[3] + 112 * (v122 - 1);
          goto LABEL_262;
        }
        a1 = v117[5];
        LOBYTE(v125) = 18;
        if ( !a1 )
        {
LABEL_184:
          v127 = 0LL;
          LOBYTE(v128) = 0;
          goto LABEL_185;
        }
        v159 = v117[6];
LABEL_250:
        v160 = 8 * (unsigned int)*(unsigned __int16 *)(a1 + 1330);
        v161 = -1LL;
        do
        {
          if ( !v160 )
          {
            v161 = *(unsigned __int16 *)(a1 + 1330);
LABEL_258:
            LOBYTE(v125) = 18;
            v31 = v159-- == 0;
            if ( v31 )
              goto LABEL_184;
            a1 = *(_QWORD *)(a1 + 8 * v161 + 1336);
            goto LABEL_250;
          }
          v162 = *(_QWORD *)(a1 + 8 * v161 + 1248) != v122;
          if ( *(_QWORD *)(a1 + 8 * v161 + 1248) > v122 )
            v162 = -1;
          ++v161;
          v160 -= 8LL;
        }
        while ( v162 == 1 );
        if ( v162 )
          goto LABEL_258;
        v147 = 112 * v161 + a1;
        v123 = v235;
LABEL_262:
        v238 = v9;
        if ( *(_BYTE *)(v147 + 106) == 1 )
          *(_QWORD *)&v186 = 1LL;
        v163 = sub_409E2D(v147);
        if ( v164 )
        {
          v165 = v163;
          v220 = *(_QWORD *)(v238 + 392);
          v166 = 16 * v164;
          v167 = 0LL;
          v237 = 0LL;
          v216 = v163;
          while ( 1 )
          {
            v3 = _mm_loadu_si128((const __m128i *)(v165 + v167));
            *(__m128i *)v233 = v3;
            sub_41D2E0((__int64)v224, (unsigned __int64 *)&v184, *(_DWORD *)(v185.m128i_i64[0] + 72), (__int64)v233);
            if ( LODWORD(v224[0]) == 46 )
            {
              v125 = (unsigned __int64)v224[1];
              v119 = v225.m128i_i64[0];
LABEL_299:
              v128 = (unsigned int)v125 >> 8;
              v127 = v125 >> 16;
LABEL_185:
              v229 = 0LL;
              goto LABEL_186;
            }
            if ( v225.m128i_u16[4] > 0x46u )
              break;
            if ( v225.m128i_u16[4] == 3 )
            {
              if ( !v237 )
              {
                sub_421680((__int64)v233, (__int64 *)v224);
                v165 = v216;
                sub_427DD0((__int64 *)&v231, v123, (unsigned __int8)v239, v220, v233);
                v168 = v217;
                if ( !(_BYTE)v231 )
                  v168 = v232;
                v169 = (void *)*((_QWORD *)&v231 + 1);
                if ( (_BYTE)v231 )
                  v169 = 0LL;
                v237 = v169;
                v217 = v168;
                v230 = v168;
              }
              goto LABEL_267;
            }
            if ( v225.m128i_u16[4] == 49 )
              goto LABEL_277;
LABEL_267:
            v167 += 16LL;
            if ( v166 == v167 )
              goto LABEL_287;
          }
          if ( v225.m128i_u16[4] != 71 )
          {
            if ( v225.m128i_u16[4] == 110 || v225.m128i_u16[4] == 8199 )
            {
              sub_421680((__int64)v233, (__int64 *)v224);
              sub_427DD0((__int64 *)&v231, v123, (unsigned __int8)v239, v220, v233);
              if ( !(_BYTE)v231 )
              {
                v230 = v232;
                v237 = (LPVOID)*((_QWORD *)&v231 + 1);
              }
              v165 = v216;
            }
            goto LABEL_267;
          }
LABEL_277:
          if ( !v237 )
          {
            sub_421680((__int64)v233, (__int64 *)v224);
            sub_427FC0(
              (__int64)&v231,
              (__int64)v233[0],
              (unsigned __int64)v233[1],
              (unsigned __int8)v229,
              v238,
              v219,
              v123,
              16LL);
            v237 = (LPVOID)*((_QWORD *)&v231 + 1);
            v230 = v232;
            if ( (_DWORD)v231 == 1 )
            {
              v125 = (unsigned __int64)v237;
              v119 = v230;
              goto LABEL_299;
            }
          }
          goto LABEL_267;
        }
        v237 = 0LL;
LABEL_287:
        v233[0] = 0LL;
        v233[1] = (LPVOID)8;
        v234 = 0LL;
        v224[0] = 0LL;
        v224[1] = (LPVOID)8;
        v225.m128i_i64[0] = 0LL;
        sub_4266A0(
          &v231,
          (unsigned __int64 *)&v184,
          0LL,
          (unsigned __int8)v229,
          v238,
          v219,
          (__int64)v123,
          (unsigned __int64 *)v233,
          (__int64 *)v224,
          0LL);
        if ( (_BYTE)v231 != 75 )
        {
          v229 = (LPVOID)(unsigned __int8)v231;
          LOBYTE(v128) = BYTE1(v231);
          v174 = *(unsigned int *)((char *)&v231 + 2);
          v175 = WORD3(v231);
          v119 = *((_QWORD *)&v231 + 1);
          if ( v224[0] )
          {
            v237 = v224[1];
            v176 = GetProcessHeap();
            HeapFree(v176, 0, v237);
          }
          v125 = v175 << 32;
          if ( v233[0] )
          {
            v237 = v233[1];
            v177 = GetProcessHeap();
            HeapFree(v177, 0, v237);
          }
          v127 = v125 | v174;
          LOBYTE(v125) = (_BYTE)v229;
          goto LABEL_185;
        }
        v170 = v224[1];
        a1 = v225.m128i_i64[0];
        v238 = v225.m128i_i64[0];
        if ( v225.m128i_i64[0] >= 2uLL )
        {
          v182 = v238;
          if ( v225.m128i_i64[0] >= 0x15uLL )
            sub_427BE0((__int128 *)v224[1], v238);
          else
            sub_427D10((_OWORD *)v224[1], v238);
          a1 = v182;
        }
        v171 = v233[1];
        v125 = (unsigned __int64)v234;
        if ( v233[0] <= v234 )
        {
          v173 = (__int64)v233[1];
        }
        else if ( v234 )
        {
          v172 = GetProcessHeap();
          v173 = (__int64)HeapReAlloc(v172, 0, v171, 48 * v125);
          a1 = v238;
          if ( !v173 )
            sub_4040E9(8LL, 48 * v125);
        }
        else
        {
          v178 = GetProcessHeap();
          HeapFree(v178, 0, v171);
          v173 = 8LL;
          a1 = v238;
        }
        v229 = (LPVOID)v173;
        if ( v224[0] <= (LPVOID)a1 )
        {
          v119 = (__int64)v170;
        }
        else if ( a1 )
        {
          v179 = 32 * a1;
          v180 = GetProcessHeap();
          v119 = (__int64)HeapReAlloc(v180, 0, v170, v179);
          if ( !v119 )
            sub_4040E9(8LL, v179);
        }
        else
        {
          v181 = GetProcessHeap();
          HeapFree(v181, 0, v170);
          v119 = 8LL;
        }
        v128 = (unsigned int)v125 >> 8;
        v127 = v125 >> 16;
LABEL_186:
        v8 = (v127 << 16) | ((unsigned __int8)v128 << 8);
        v129 = v8 | (unsigned __int8)v125;
        if ( *(_QWORD *)v109 )
        {
          v130 = v229;
          if ( v229 )
          {
            if ( v129 )
            {
              v131 = GetProcessHeap();
              LODWORD(v8) = HeapFree(v131, 0, v130);
            }
            if ( v238 )
            {
              v132 = GetProcessHeap();
              LODWORD(v8) = HeapFree(v132, 0, (LPVOID)v119);
            }
          }
        }
        else
        {
          v133 = v236;
          v134 = v237;
          *(_QWORD *)v109 = 1LL;
          *(_QWORD *)(v109 + 8) = v229;
          *(_QWORD *)(v109 + 16) = v129;
          *(_QWORD *)(v109 + 24) = v119;
          LODWORD(a1) = v238;
          *(_QWORD *)(v109 + 32) = v238;
          *(_QWORD *)(v109 + 40) = v133;
          *(_QWORD *)(v109 + 48) = v134;
          v8 = v230;
          *(_QWORD *)(v109 + 56) = v230;
        }
      }
      if ( *(_QWORD *)(v109 + 8) )
      {
        v104 = v109 + 8;
        v10 = v215;
        v6 = v235;
        goto LABEL_195;
      }
      v8 = *(unsigned __int8 *)(v109 + 16);
      v104 = *(_QWORD *)(v109 + 24);
      v6 = v235;
      if ( (_BYTE)v8 != 75 )
      {
        v146 = *(_DWORD *)(v109 + 17);
        *(_DWORD *)(v5 + 20) = *(_DWORD *)(v109 + 20);
        *(_DWORD *)(v5 + 17) = v146;
        *(_BYTE *)(v5 + 16) = v8;
        *(_QWORD *)(v5 + 24) = v104;
        goto LABEL_224;
      }
      v10 = v215;
      v135 = 2;
      if ( *(_DWORD *)(v215 + 96) == 47 )
        goto LABEL_196;
LABEL_199:
      if ( (*(_BYTE *)(v10 + 432) & 1) == 0 )
      {
        sub_41F880((__int64)&v184, (__int64 *)(v10 + 96));
        sub_41FD50((__int64 *)v224, v10, (__int64)&v184, v6);
        if ( !*(_QWORD *)(v10 + 432) )
        {
          *(_QWORD *)(v10 + 432) = 1LL;
          v3 = _mm_loadu_si128((const __m128i *)v224);
          v138 = _mm_loadu_si128(&v225);
          *(__m128i *)(v10 + 440) = v3;
          *(__m128i *)(v10 + 456) = v138;
          if ( *(_QWORD *)(v10 + 440) )
            goto LABEL_203;
          goto LABEL_208;
        }
        sub_4215A0((__int64)v224);
      }
      if ( *(_QWORD *)(v10 + 440) )
      {
LABEL_203:
        v8 = v10 + 440;
        goto LABEL_204;
      }
LABEL_208:
      a1 = *(unsigned __int8 *)(v10 + 448);
      v8 = *(_QWORD *)(v10 + 456);
      if ( a1 != 75 )
      {
        *(_QWORD *)(v5 + 16) = a1 | ((unsigned __int64)(*(unsigned __int16 *)(v10 + 453) | (*(unsigned __int8 *)(v10 + 455) << 16)) << 40) | ((unsigned __int64)*(unsigned int *)(v10 + 449) << 8);
LABEL_223:
        *(_QWORD *)(v5 + 24) = v8;
        goto LABEL_224;
      }
      if ( !v8 )
        goto LABEL_196;
LABEL_204:
      a1 = *(_QWORD *)(v8 + 24);
      if ( a1 )
      {
        v136 = *(_QWORD *)(v8 + 16);
        if ( a1 == 1 )
        {
          v137 = 0LL;
        }
        else
        {
          v139 = 0LL;
          v140 = *(_QWORD *)(v8 + 24);
          do
          {
            v137 = (v140 >> 1) + v139;
            if ( *(_QWORD *)(v136 + 32 * v137 + 16) > v102 )
              v137 = v139;
            v140 -= v140 >> 1;
            v139 = v137;
          }
          while ( v140 > 1 );
        }
        v141 = *(_QWORD *)(v136 + 32 * v137 + 16);
        v142 = *(_QWORD *)(v136 + 32 * v137 + 24);
        if ( v141 > v102 || v142 <= v102 )
        {
          if ( ((v142 <= v102) & (unsigned __int8)(v141 <= v102)) + v137 )
            goto LABEL_196;
          v137 = 0LL;
        }
        if ( v137 >= a1 )
          goto LABEL_235;
        v143 = *(_QWORD *)(v136 + 32 * v137 + 8);
        if ( !v143 )
          goto LABEL_235;
        v144 = *(_QWORD *)(v136 + 32 * v137);
        if ( v143 == 1 )
        {
          v145 = 0LL;
        }
        else
        {
          v148 = 0LL;
          do
          {
            v145 = (v143 >> 1) + v148;
            if ( *(_QWORD *)(v144 + 24 * v145) > v102 )
              v145 = v148;
            v143 -= v143 >> 1;
            v148 = v145;
          }
          while ( v143 > 1 );
        }
        if ( *(_QWORD *)(v144 + 24 * v145) != v102 )
        {
          v149 = (*(_QWORD *)(v144 + 24 * v145) < v102) + v145;
          v31 = v149 == 0;
          v145 = v149 - 1;
          if ( v31 )
LABEL_235:
            v145 = 0LL;
        }
        if ( v137 < a1 )
        {
          v150 = v102 + 1;
          v151 = 32 * v137;
          if ( *(_QWORD *)(v136 + 32 * v137 + 16) < v150 )
          {
            v152 = (unsigned __int64 *)(v136 + v151);
            if ( v145 >= *(_QWORD *)(v136 + v151 + 8) )
            {
              if ( v137 + 1 != a1 )
              {
                v158 = a1 + ~v137;
                v152 = (unsigned __int64 *)(v151 + v136 + 32);
                v145 = 0LL;
                do
                {
                  if ( v152[2] >= v150 )
                    break;
                  if ( v152[1] )
                    goto LABEL_239;
                  v152 += 4;
                  --v158;
                }
                while ( v158 );
              }
            }
            else
            {
LABEL_239:
              a1 = *v152;
              if ( *(_QWORD *)(*v152 + 24 * v145) < v150 )
              {
                v153 = a1 + 24 * v145;
                v154 = *(_QWORD *)(v153 + 8);
                if ( v154 >= *(_QWORD *)(v8 + 8) )
                {
                  v157 = 0LL;
                }
                else
                {
                  v155 = *(_QWORD *)v8;
                  v156 = 3 * v154;
                  v157 = *(_QWORD *)(v155 + 8 * v156 + 8);
                  v136 = *(_QWORD *)(v155 + 8 * v156 + 16);
                }
                LODWORD(a1) = *(_DWORD *)(v153 + 16);
                v135 = a1 != 0;
                v8 = (*(_DWORD *)(v153 + 20) != 0) | ((unsigned __int64)*(unsigned int *)(v153 + 20) << 32);
                v3 = _mm_unpacklo_epi64((__m128i)v157, (__m128i)v136);
              }
            }
          }
        }
      }
LABEL_196:
      *(_QWORD *)v5 = v104;
      *(_DWORD *)(v5 + 8) = v135;
      *(_DWORD *)(v5 + 12) = a1;
      *(_QWORD *)(v5 + 16) = v8;
      *(__m128i *)(v5 + 24) = v3;
      return v8;
    default:
      LOBYTE(v52) = 23;
      v239 = v52;
      LOWORD(v87) = v201;
      v5 = v214;
      goto LABEL_138;
  }
}
// 424694: variable 'v24' is possibly undefined
// 424CD0: variable 'a1' is possibly undefined
// 424CD3: variable 'v8' is possibly undefined
// 424CD7: variable 'v3' is possibly undefined
// 4250DA: variable 'v164' is possibly undefined
// 4050B0: using guessed type void __fastcall __noreturn sub_4050B0(_QWORD, _QWORD, _QWORD);
// 446D68: using guessed type char *off_446D68;
// 448338: using guessed type char *off_448338;
// 448428: using guessed type char *off_448428;
// 448458: using guessed type char *off_448458;

//----- (0000000000425980) ----------------------------------------------------
void __fastcall sub_425980(__int64 a1)
{
  void *v1; // rsi
  HANDLE ProcessHeap; // rax

  if ( *(_QWORD *)(a1 + 72) )
  {
    if ( (unsigned int)(*(_DWORD *)a1 - 3) >= 3 )
    {
      v1 = *(void **)(a1 + 56);
      ProcessHeap = GetProcessHeap();
      HeapFree(ProcessHeap, 0, v1);
    }
  }
}

//----- (00000000004259C0) ----------------------------------------------------
unsigned __int64 __fastcall sub_4259C0(_QWORD *a1, unsigned __int64 a2)
{
  unsigned __int64 v3; // rdx
  unsigned __int64 result; // rax
  __int64 v5; // r9
  unsigned __int64 v6; // r11
  unsigned __int64 v7; // r10
  unsigned __int64 v8; // r10
  unsigned __int64 v9; // rax
  unsigned __int64 v10; // rax
  unsigned __int64 v11; // rsi
  __int64 v12; // rdx
  __int64 v13; // rdx
  __int64 v14; // rsi
  bool v15; // cf
  unsigned __int64 v16; // rsi
  unsigned __int64 v17; // r8
  unsigned __int64 v18; // rdi
  unsigned __int64 v19; // rsi
  __int64 v20; // rdx

  v3 = a1[2];
  result = 0LL;
  if ( !v3 )
    return result;
  v5 = a1[1];
  if ( v3 != 1 )
  {
    v6 = 0LL;
    v7 = a1[2];
    do
    {
      result = (v7 >> 1) + v6;
      if ( *(_QWORD *)(v5 + 16 * result) > a2 )
        result = v6;
      v7 -= v7 >> 1;
      v6 = result;
    }
    while ( v7 > 1 );
  }
  v8 = *(_QWORD *)(v5 + 16 * result);
  if ( v8 != a2 )
  {
    v9 = (v8 < a2) + result;
    if ( !v9 )
      return 0LL;
    result = v9 - 1;
  }
  if ( result >= v3 )
    sub_4050B0(result, v3, &off_44A478);
  v10 = *(_QWORD *)(v5 + 16 * result + 8);
  if ( *(_BYTE *)v10 )
  {
    v11 = v10;
    if ( off_43F010(0, v10, (const __m128i *)(v10 + 8)) && v12 - v11 >= 9 )
      sub_405B00(v12 - v11, 8LL, (__int64)&off_4480F8);
    return v11;
  }
  v13 = a1[7];
  if ( !v13 )
    return 0LL;
  v14 = *(unsigned int *)(v10 + 4);
  v15 = __CFADD__(a1[9], v14);
  v16 = a1[9] + v14;
  if ( v15 )
    return 0LL;
  v17 = a1[10];
  v18 = v17 - v16;
  if ( v17 < v16 || v17 > a1[8] )
    return 0LL;
  v19 = v13 + v16;
  if ( !off_43F010(0, v19, (const __m128i *)(v13 + v17)) )
    return 0LL;
  result = 0LL;
  if ( v20 - v19 <= v18 )
    return v19;
  return result;
}
// 425A63: variable 'v12' is possibly undefined
// 425AD6: variable 'v20' is possibly undefined
// 4050B0: using guessed type void __fastcall __noreturn sub_4050B0(_QWORD, _QWORD, _QWORD);
// 43F010: using guessed type _BOOL8 (__fastcall *off_43F010)(unsigned __int8 a1, unsigned __int64 a2, const __m128i *a3);
// 4480F8: using guessed type char *off_4480F8;
// 44A478: using guessed type char *off_44A478;

//----- (0000000000425B00) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_425B00(_QWORD *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // r8
  unsigned __int64 v3; // rsi
  SIZE_T v5; // rax
  _QWORD *v6; // rdi
  LPVOID v7; // rax
  __int64 v8; // rdi
  HANDLE ProcessHeap; // rax
  _OWORD v10[258]; // [rsp+30h] [rbp-50h] BYREF

  v2 = 333333LL;
  if ( a2 < 0x51615 )
    v2 = a2;
  if ( a2 >> 1 > v2 )
    v2 = a2 >> 1;
  v3 = 48LL;
  if ( v2 >= 0x31 )
    v3 = v2;
  if ( v2 >= 0xAB )
  {
    v5 = 24 * v3;
    if ( !is_mul_ok(0x18uLL, v3) || v5 >= 0x7FFFFFFFFFFFFFF9LL )
      sub_4040B0((__int64)&off_447D68);
    if ( v5 )
    {
      v6 = a1;
      v7 = sub_43C4F0(v5);
      a1 = v6;
      v8 = (__int64)v7;
      if ( !v7 )
        sub_4040E9(8LL, 24 * v3);
    }
    else
    {
      v8 = 8LL;
      v3 = 0LL;
    }
    sub_429AE0(a1, a2, (_OWORD *)v8, (_QWORD *)v3, a2 < 0x41);
    ProcessHeap = GetProcessHeap();
    HeapFree(ProcessHeap, 0, (LPVOID)v8);
  }
  else
  {
    sub_429AE0(a1, a2, v10, (_QWORD *)0xAA, a2 < 0x41);
  }
}
// 425B75: positive sp value 1030 has been found
// 447D68: using guessed type char *off_447D68;

//----- (0000000000425C30) ----------------------------------------------------
__int64 __fastcall sub_425C30(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  __int64 v3; // r9
  __int64 v4; // rdx
  __int64 v5; // r10
  __int64 v6; // r10
  __int64 v7; // r8
  unsigned __int64 v8; // r9
  __int64 v9; // r11
  __int64 v10; // r10
  bool v11; // cf
  __int128 v12; // [rsp+0h] [rbp-10h]

  result = a1 + 24 * a2;
  v3 = a1 + 24;
  v4 = 24LL;
  v5 = a1;
  do
  {
    v7 = v3;
    v8 = *(_QWORD *)(v5 + 24);
    if ( v8 < *(_QWORD *)v5 )
    {
      v12 = *(_OWORD *)(v5 + 32);
      v9 = v4;
      do
      {
        *(_QWORD *)(a1 + v9 + 16) = *(_QWORD *)(a1 + v9 - 8);
        *(_OWORD *)(a1 + v9) = *(_OWORD *)(a1 + v9 - 24);
        if ( v9 == 24 )
        {
          v6 = a1;
          goto LABEL_3;
        }
        v10 = v9 - 24;
        v11 = v8 < *(_QWORD *)(a1 + v9 - 48);
        v9 -= 24LL;
      }
      while ( v11 );
      v6 = a1 + v10;
LABEL_3:
      *(_QWORD *)v6 = v8;
      *(_OWORD *)(v6 + 8) = v12;
    }
    v3 = v7 + 24;
    v4 += 24LL;
    v5 = v7;
  }
  while ( v7 + 24 != result );
  return result;
}

//----- (0000000000425CD0) ----------------------------------------------------
char __fastcall sub_425CD0(__int64 a1, char **a2, unsigned int a3, __int64 a4, __int64 a5)
{
  unsigned __int64 v5; // rax
  char *v6; // r13
  unsigned __int64 v7; // rbx
  int v8; // r11d
  unsigned __int64 v9; // r12
  __int64 v10; // rdi
  int v11; // r11d
  unsigned __int8 v12; // r14
  bool v13; // cf
  unsigned __int64 v14; // r11
  int v15; // ecx
  char v16; // r14
  char *v17; // r11
  unsigned __int16 v19; // r14
  unsigned __int64 v20; // rbx
  unsigned __int64 v21; // r11
  unsigned __int16 v22; // si
  unsigned __int64 v23; // rbx
  char *v24; // r11
  __int64 v25; // rdi
  char *v26; // rbx
  __int16 v27; // dx
  char *v29; // [rsp+0h] [rbp-20h]
  char *v30; // [rsp+8h] [rbp-18h]
  __int64 v31; // [rsp+10h] [rbp-10h]
  unsigned __int8 v32; // [rsp+18h] [rbp-8h]
  __int16 v33; // [rsp+1Ch] [rbp-4h]

  LOBYTE(v5) = a5;
  if ( !a5 )
    goto LABEL_85;
  v5 = a4 + 16 * a5;
  v6 = *a2;
  v7 = (unsigned __int64)a2[1];
  v8 = a3 >> 8;
  if ( (a3 & 0xFFFF0000) == 0x20000 )
    LOWORD(v8) = a3;
  v32 = v8;
  v9 = 0LL;
  v33 = v8;
  v10 = (__int64)*a2;
  while ( 2 )
  {
    v11 = *(unsigned __int16 *)(a4 + 10);
    switch ( *(_WORD *)(a4 + 10) )
    {
      case 1:
        v12 = a3;
        goto LABEL_28;
      case 2:
      case 3:
      case 4:
      case 8:
      case 9:
      case 0xA:
      case 0xD:
      case 0xF:
      case 0x15:
      case 0x16:
      case 0x18:
      case 0x1A:
      case 0x1B:
      case 0x22:
      case 0x23:
        goto LABEL_14;
      case 5:
      case 0x12:
      case 0x26:
      case 0x2A:
        v12 = 2;
        goto LABEL_28;
      case 6:
      case 0x13:
      case 0x1C:
      case 0x28:
      case 0x2C:
        v12 = 4;
        goto LABEL_28;
      case 7:
      case 0x14:
      case 0x20:
      case 0x24:
        v12 = 8;
        goto LABEL_28;
      case 0xB:
      case 0xC:
      case 0x11:
      case 0x25:
      case 0x29:
        v12 = 1;
        goto LABEL_28;
      case 0xE:
      case 0x17:
      case 0x1D:
      case 0x1F:
        goto LABEL_11;
      case 0x10:
        v12 = v32;
        goto LABEL_28;
      case 0x19:
      case 0x21:
        v12 = 0;
        goto LABEL_28;
      case 0x1E:
        v12 = 16;
        goto LABEL_28;
      case 0x27:
      case 0x2B:
        v12 = 3;
        goto LABEL_28;
      default:
        if ( (unsigned int)(v11 - 7968) < 2 )
        {
LABEL_11:
          v12 = BYTE1(a3);
LABEL_28:
          v9 += v12;
          goto LABEL_29;
        }
LABEL_14:
        if ( v9 )
        {
          v13 = v7 < v9;
          v7 -= v9;
          if ( v13 )
            goto LABEL_82;
          v10 += v9;
          *a2 = (char *)v10;
          a2[1] = (char *)v7;
        }
        break;
    }
    v6 = (char *)v10;
    switch ( v11 )
    {
      case 3:
LABEL_62:
        if ( v7 <= 1 )
        {
          *(_WORD *)(a1 + 1) = 0;
          *(_BYTE *)(a1 + 7) = 0;
          *(_DWORD *)(a1 + 3) = 0;
          goto LABEL_82;
        }
        v7 -= 2LL;
        v10 = (__int64)(v6 + 2);
        *a2 = v6 + 2;
        a2[1] = (char *)v7;
        v9 = *(unsigned __int16 *)v6;
        v6 += 2;
        goto LABEL_29;
      case 4:
LABEL_55:
        if ( v7 <= 3 )
        {
          *(_DWORD *)(a1 + 1) = 0;
          *(_BYTE *)(a1 + 7) = 0;
          *(_WORD *)(a1 + 5) = 0;
          goto LABEL_82;
        }
        v7 -= 4LL;
        v10 = (__int64)(v6 + 4);
        *a2 = v6 + 4;
        a2[1] = (char *)v7;
        v9 = *(unsigned int *)v6;
        v6 += 4;
        goto LABEL_29;
      case 5:
      case 6:
      case 7:
      case 11:
      case 12:
      case 14:
      case 16:
      case 17:
      case 18:
      case 19:
      case 20:
      case 23:
      case 25:
      case 28:
      case 29:
      case 30:
      case 31:
      case 32:
      case 33:
        goto LABEL_92;
      case 8:
LABEL_57:
        v24 = v6;
        if ( !v7 )
          goto LABEL_91;
        v25 = 0LL;
        while ( v6[v25] )
        {
          if ( v7 == ++v25 )
          {
LABEL_91:
            v5 = (unsigned __int64)v30 & 0xFFFFFFFFFFFFFF00uLL | 0x13;
            *(_QWORD *)a1 = v5;
            *(_QWORD *)(a1 + 8) = v6;
            return v5;
          }
        }
        v6 += v25 + 1;
        v7 += ~v25;
        *a2 = v6;
        a2[1] = (char *)v7;
        v10 = (__int64)&v24[v25 + 1];
        v30 = v24;
        v9 = 0LL;
        goto LABEL_29;
      case 9:
      case 24:
LABEL_18:
        if ( !v7 )
          goto LABEL_87;
        v31 = a1;
        v14 = v7 - 1;
        v10 = (__int64)(v6 + 1);
        v9 = 0LL;
        v15 = 0;
LABEL_20:
        v16 = *(_BYTE *)(v10 - 1);
        if ( v15 == 63 && (unsigned __int8)v16 >= 2u )
        {
          *a2 = (char *)v10;
          a2[1] = (char *)v14;
          LOBYTE(v5) = 6;
          a1 = v31;
          v6 = v29;
          goto LABEL_88;
        }
        v9 |= (unsigned __int64)(*(_BYTE *)(v10 - 1) & 0x7F) << v15;
        if ( v16 >= 0 )
        {
          *a2 = (char *)v10;
          a2[1] = (char *)v14;
          v6 = (char *)v10;
          v7 = v14;
          v29 = (char *)v9;
          a1 = v31;
LABEL_29:
          a4 += 16LL;
          if ( a4 == v5 )
          {
            if ( v9 )
            {
              v13 = v7 < v9;
              v26 = (char *)(v7 - v9);
              if ( v13 )
              {
LABEL_82:
                *(_BYTE *)a1 = 19;
                goto LABEL_90;
              }
              *a2 = &v6[v9];
              a2[1] = v26;
            }
LABEL_85:
            *(_BYTE *)a1 = 75;
            return v5;
          }
          continue;
        }
        v15 += 7;
        ++v10;
        v13 = v14-- != 0;
        if ( v13 )
          goto LABEL_20;
        v6 += v7;
        *a2 = v6;
        a2[1] = 0LL;
        a1 = v31;
LABEL_87:
        LOBYTE(v5) = 19;
LABEL_88:
        *(_BYTE *)a1 = v5;
        *(_BYTE *)(a1 + 1) = 0;
LABEL_89:
        *(_WORD *)(a1 + 6) = 0;
        *(_DWORD *)(a1 + 2) = 0;
LABEL_90:
        *(_QWORD *)(a1 + 8) = v6;
        return v5;
      case 10:
LABEL_64:
        if ( !v7 )
        {
          *(_WORD *)a1 = 19;
          goto LABEL_89;
        }
        --v7;
        v10 = (__int64)(v6 + 1);
        *a2 = v6 + 1;
        a2[1] = (char *)v7;
        v9 = (unsigned __int8)*v6++;
        goto LABEL_29;
      case 13:
      case 15:
      case 21:
      case 26:
      case 27:
      case 34:
      case 35:
        goto LABEL_32;
      case 22:
        if ( v7 )
        {
          ++v10;
          *a2 = v6 + 1;
          a2[1] = (char *)(v7 - 1);
          v19 = *v6 & 0x7F;
          if ( *v6 >= 0 )
          {
            v20 = v7 - 1;
LABEL_46:
            v21 = v20;
            v22 = v19;
            while ( 1 )
            {
              v6 = (char *)v10;
              v7 = v21;
              v33 = v22;
              switch ( v22 )
              {
                case 1u:
                  v12 = a3;
                  goto LABEL_79;
                case 2u:
                  goto LABEL_92;
                case 3u:
                  goto LABEL_62;
                case 4u:
                  goto LABEL_55;
                case 5u:
                case 0x12u:
                case 0x26u:
                case 0x2Au:
                  v12 = 2;
                  goto LABEL_79;
                case 6u:
                case 0x13u:
                case 0x1Cu:
                case 0x28u:
                case 0x2Cu:
                  v12 = 4;
                  goto LABEL_79;
                case 7u:
                case 0x14u:
                case 0x20u:
                case 0x24u:
                  v12 = 8;
                  goto LABEL_79;
                case 8u:
                  goto LABEL_57;
                case 9u:
                case 0x18u:
                  goto LABEL_18;
                case 0xAu:
                  goto LABEL_64;
                case 0xBu:
                case 0xCu:
                case 0x11u:
                case 0x25u:
                case 0x29u:
                  v12 = 1;
                  goto LABEL_79;
                case 0xDu:
                case 0xFu:
                case 0x15u:
                case 0x1Au:
                case 0x1Bu:
                case 0x22u:
                case 0x23u:
                  goto LABEL_32;
                case 0xEu:
                case 0x17u:
                case 0x1Du:
                case 0x1Fu:
                  goto LABEL_71;
                case 0x10u:
                  v12 = v32;
                  goto LABEL_79;
                case 0x16u:
                  if ( !v21 )
                    goto LABEL_93;
                  --v21;
                  ++v10;
                  *a2 = v6 + 1;
                  a2[1] = (char *)(v7 - 1);
                  v22 = *v6 & 0x7F;
                  if ( *v6 >= 0 )
                    continue;
                  if ( v7 == 1 )
                    goto LABEL_97;
                  v21 = v7 - 2;
                  v10 = (__int64)(v6 + 2);
                  *a2 = v6 + 2;
                  a2[1] = (char *)(v7 - 2);
                  v22 |= (v6[1] & 0x7F) << 7;
                  if ( v6[1] >= 0 )
                    continue;
                  if ( v7 == 2 )
                    goto LABEL_97;
                  v23 = v7 - 3;
                  v10 = (__int64)(v6 + 3);
                  *a2 = v6 + 3;
                  a2[1] = (char *)v23;
                  if ( (unsigned __int8)v6[2] > 3u )
                  {
                    LOBYTE(v5) = 6;
                    v27 = 22;
                    goto LABEL_98;
                  }
                  v22 |= (unsigned __int8)v6[2] << 14;
                  v21 = v23;
                  break;
                case 0x19u:
                case 0x21u:
                  v12 = 0;
                  goto LABEL_79;
                case 0x1Eu:
                  v12 = 16;
                  goto LABEL_79;
                case 0x27u:
                case 0x2Bu:
                  v12 = 3;
                  goto LABEL_79;
                default:
                  if ( (unsigned int)v22 - 7937 < 2 )
                    goto LABEL_32;
                  if ( (unsigned int)v22 - 7968 >= 2 )
                    goto LABEL_92;
LABEL_71:
                  v12 = BYTE1(a3);
LABEL_79:
                  v9 = 0LL;
                  goto LABEL_28;
              }
            }
          }
          if ( v7 == 1 )
            goto LABEL_97;
          v10 = (__int64)(v6 + 2);
          *a2 = v6 + 2;
          a2[1] = (char *)(v7 - 2);
          v19 |= (v6[1] & 0x7F) << 7;
          if ( v6[1] >= 0 )
          {
            v20 = v7 - 2;
            goto LABEL_46;
          }
          if ( v7 == 2 )
          {
LABEL_97:
            LOBYTE(v5) = 19;
            v27 = 0;
            v6 = (char *)v10;
          }
          else
          {
            v20 = v7 - 3;
            v10 = (__int64)(v6 + 3);
            *a2 = v6 + 3;
            a2[1] = (char *)v20;
            if ( (unsigned __int8)v6[2] <= 3u )
            {
              v19 |= (unsigned __int8)v6[2] << 14;
              goto LABEL_46;
            }
            LOBYTE(v5) = 6;
            v27 = v33;
          }
        }
        else
        {
LABEL_93:
          LOBYTE(v5) = 19;
          v27 = 0;
        }
LABEL_98:
        *(_BYTE *)a1 = v5;
        *(_BYTE *)(a1 + 1) = 0;
        *(_WORD *)(a1 + 2) = v27;
        *(_DWORD *)(a1 + 4) = 0;
        goto LABEL_90;
      default:
        if ( (unsigned int)(v11 - 7937) >= 2 )
        {
LABEL_92:
          *(_BYTE *)a1 = 12;
          return v5;
        }
LABEL_32:
        v17 = v6;
        do
        {
          v13 = v7-- == 0;
          if ( v13 )
          {
            *(_WORD *)a1 = 19;
            *(_WORD *)(a1 + 6) = 0;
            *(_DWORD *)(a1 + 2) = 0;
            *(_QWORD *)(a1 + 8) = v17;
            return v5;
          }
          v6 = v17 + 1;
          *a2 = v17 + 1;
          a2[1] = (char *)v7;
        }
        while ( *v17++ < 0 );
        v10 = (__int64)v6;
        v9 = 0LL;
        goto LABEL_29;
    }
  }
}
// 426194: variable 'v29' is possibly undefined
// 4261DA: variable 'v30' is possibly undefined

//----- (0000000000426260) ----------------------------------------------------
__int64 __fastcall sub_426260(unsigned __int64 *a1, __int64 a2)
{
  unsigned __int128 v2; // rax
  __int64 v3; // rsi
  unsigned __int64 v4; // r8
  unsigned __int64 v6; // rax
  unsigned __int64 v7; // rbx
  __int64 v8; // rcx
  __int64 v9; // rcx
  __int64 result; // rax
  _QWORD v11[3]; // [rsp+28h] [rbp-28h] BYREF
  __int64 v12; // [rsp+40h] [rbp-10h] BYREF
  __int64 v13; // [rsp+48h] [rbp-8h]
  __int64 v14; // [rsp+50h] [rbp+0h]

  *((_QWORD *)&v2 + 1) = a2;
  v3 = *((_QWORD *)&v2 + 1);
  v4 = *a1;
  if ( *a1 == -1LL )
    goto LABEL_13;
  v6 = v4 + 1;
  if ( 2 * v4 > v4 + 1 )
    v6 = 2 * v4;
  v7 = 4LL;
  if ( v6 >= 5 )
    v7 = v6;
  v8 = 0LL;
  v2 = 0x18 * (unsigned __int128)v7;
  if ( !is_mul_ok(0x18uLL, v7) )
LABEL_13:
    sub_40408F(0LL, *((__int64 *)&v2 + 1), v3);
  if ( (unsigned __int64)v2 > 0x7FFFFFFFFFFFFFF8LL )
LABEL_15:
    sub_40408F(v8, *((__int64 *)&v2 + 1), v3);
  if ( v4 )
  {
    v11[0] = a1[1];
    v11[2] = 24 * v4;
    v9 = 8LL;
  }
  else
  {
    v9 = 0LL;
  }
  v11[1] = v9;
  sub_413370(&v12, (void *)8, v2, (__int64)v11);
  if ( (_DWORD)v12 == 1 )
  {
    v8 = v13;
    *((_QWORD *)&v2 + 1) = v14;
    goto LABEL_15;
  }
  result = v13;
  a1[1] = v13;
  *a1 = v7;
  return result;
}

//----- (0000000000426330) ----------------------------------------------------
__int64 __fastcall sub_426330(unsigned __int64 *a1, __int64 a2)
{
  unsigned __int128 v2; // rax
  unsigned __int64 v3; // r8
  unsigned __int64 v5; // rax
  unsigned __int64 v6; // rdi
  __int64 v7; // rcx
  __int64 v8; // rcx
  __int64 result; // rax
  _QWORD v10[3]; // [rsp+20h] [rbp-30h] BYREF
  __int64 v11; // [rsp+38h] [rbp-18h] BYREF
  __int64 v12; // [rsp+40h] [rbp-10h]
  __int64 v13; // [rsp+48h] [rbp-8h]

  *((_QWORD *)&v2 + 1) = a2;
  v3 = *a1;
  if ( *a1 == -1LL )
    goto LABEL_13;
  v5 = v3 + 1;
  if ( 2 * v3 > v3 + 1 )
    v5 = 2 * v3;
  v6 = 4LL;
  if ( v5 >= 5 )
    v6 = v5;
  v7 = 0LL;
  v2 = 0x48 * (unsigned __int128)v6;
  if ( !is_mul_ok(0x48uLL, v6) )
LABEL_13:
    sub_40408F(0LL, *((__int64 *)&v2 + 1), (__int64)&off_448440);
  if ( (unsigned __int64)v2 > 0x7FFFFFFFFFFFFFF8LL )
LABEL_15:
    sub_40408F(v7, *((__int64 *)&v2 + 1), (__int64)&off_448440);
  if ( v3 )
  {
    v10[0] = a1[1];
    v10[2] = 72 * v3;
    v8 = 8LL;
  }
  else
  {
    v8 = 0LL;
  }
  v10[1] = v8;
  sub_413370(&v11, (void *)8, v2, (__int64)v10);
  if ( (_DWORD)v11 == 1 )
  {
    v7 = v12;
    *((_QWORD *)&v2 + 1) = v13;
    goto LABEL_15;
  }
  result = v12;
  a1[1] = v12;
  *a1 = v6;
  return result;
}
// 448440: using guessed type char *off_448440;

//----- (0000000000426400) ----------------------------------------------------
void __fastcall sub_426400(_QWORD *a1)
{
  void *v1; // rsi
  _QWORD *v2; // rdi
  HANDLE ProcessHeap; // rax
  void *v4; // rsi
  HANDLE v5; // rax

  if ( a1[1] )
  {
    v1 = (void *)a1[2];
    if ( v1 )
    {
      if ( a1[3] )
      {
        v2 = a1;
        ProcessHeap = GetProcessHeap();
        HeapFree(ProcessHeap, 0, v1);
        a1 = v2;
      }
      if ( a1[5] )
      {
        v4 = (void *)a1[4];
        v5 = GetProcessHeap();
        HeapFree(v5, 0, v4);
      }
    }
  }
}

//----- (0000000000426470) ----------------------------------------------------
void __fastcall sub_426470(_QWORD *a1)
{
  _QWORD *v2; // rsi
  __int64 v3; // r14
  _QWORD *v4; // r15
  void *v5; // rbx
  HANDLE ProcessHeap; // rax
  void *v7; // rbx
  HANDLE v8; // rax
  HANDLE v9; // rax

  v2 = (_QWORD *)a1[1];
  v3 = a1[2];
  if ( v3 )
  {
    v4 = v2 + 5;
    do
    {
      if ( *(v4 - 4) )
      {
        v5 = (void *)*(v4 - 3);
        if ( v5 )
        {
          if ( *(v4 - 2) )
          {
            ProcessHeap = GetProcessHeap();
            HeapFree(ProcessHeap, 0, v5);
          }
          if ( *v4 )
          {
            v7 = (void *)*(v4 - 1);
            v8 = GetProcessHeap();
            HeapFree(v8, 0, v7);
          }
        }
      }
      v4 += 9;
      --v3;
    }
    while ( v3 );
  }
  if ( *a1 )
  {
    v9 = GetProcessHeap();
    HeapFree(v9, 0, v2);
  }
}

//----- (0000000000426530) ----------------------------------------------------
void __fastcall sub_426530(char *lpMem, __int64 a2)
{
  __int64 v2; // rdi
  _QWORD *v4; // r14
  void *v5; // rbx
  HANDLE ProcessHeap; // rax
  void *v7; // rbx
  HANDLE v8; // rax
  HANDLE v9; // rax

  if ( a2 )
  {
    v2 = a2;
    v4 = lpMem + 40;
    do
    {
      if ( *(v4 - 4) )
      {
        v5 = (void *)*(v4 - 3);
        if ( v5 )
        {
          if ( *(v4 - 2) )
          {
            ProcessHeap = GetProcessHeap();
            HeapFree(ProcessHeap, 0, v5);
          }
          if ( *v4 )
          {
            v7 = (void *)*(v4 - 1);
            v8 = GetProcessHeap();
            HeapFree(v8, 0, v7);
          }
        }
      }
      v4 += 9;
      --v2;
    }
    while ( v2 );
    v9 = GetProcessHeap();
    HeapFree(v9, 0, lpMem);
  }
}

//----- (00000000004265D0) ----------------------------------------------------
void __fastcall sub_4265D0(__int64 a1)
{
  _QWORD *v1; // rdi
  __int64 v3; // r14
  _QWORD *v4; // r15
  void *v5; // rbx
  HANDLE ProcessHeap; // rax
  void *v7; // rbx
  HANDLE v8; // rax
  HANDLE v9; // rax
  void *v10; // rsi
  HANDLE v11; // rax

  v1 = *(_QWORD **)a1;
  if ( *(_QWORD *)a1 )
  {
    v3 = *(_QWORD *)(a1 + 8);
    if ( v3 )
    {
      v4 = v1 + 5;
      do
      {
        if ( *(v4 - 4) )
        {
          v5 = (void *)*(v4 - 3);
          if ( v5 )
          {
            if ( *(v4 - 2) )
            {
              ProcessHeap = GetProcessHeap();
              HeapFree(ProcessHeap, 0, v5);
            }
            if ( *v4 )
            {
              v7 = (void *)*(v4 - 1);
              v8 = GetProcessHeap();
              HeapFree(v8, 0, v7);
            }
          }
        }
        v4 += 9;
        --v3;
      }
      while ( v3 );
      v9 = GetProcessHeap();
      HeapFree(v9, 0, v1);
    }
    if ( *(_QWORD *)(a1 + 24) )
    {
      v10 = *(void **)(a1 + 16);
      v11 = GetProcessHeap();
      HeapFree(v11, 0, v10);
    }
  }
}

//----- (00000000004266A0) ----------------------------------------------------
char __fastcall sub_4266A0(
        _OWORD *a1,
        unsigned __int64 *a2,
        signed __int64 a3,
        unsigned __int8 a4,
        __int64 a5,
        _QWORD *a6,
        __int64 a7,
        unsigned __int64 *a8,
        __int64 *a9,
        __int64 a10)
{
  unsigned int v10; // ebx
  __int64 v11; // r9
  int v12; // esi
  __int64 v13; // rdi
  signed __int64 v14; // rax
  __int64 v15; // r13
  __int64 v16; // rsi
  unsigned __int64 v17; // r14
  unsigned __int64 v18; // r8
  unsigned __int64 v19; // r11
  char v20; // r9
  unsigned __int64 *v21; // rdi
  unsigned __int64 v22; // r12
  unsigned __int64 v23; // rsi
  unsigned __int64 v24; // r10
  int v25; // ecx
  char v26; // r15
  bool v27; // cf
  __int64 v28; // rbx
  _QWORD *v29; // rdx
  __int64 v30; // r10
  __int64 v31; // rdx
  int v32; // ecx
  signed __int64 v33; // rsi
  signed __int64 v34; // r12
  __int64 v35; // r9
  unsigned __int64 v36; // rcx
  signed __int64 v37; // r11
  __int64 v38; // rcx
  __int64 v39; // rdx
  __int64 v40; // r12
  __int64 v41; // r11
  char v42; // r15
  unsigned __int64 v43; // rsi
  signed __int64 v44; // rsi
  signed __int64 v45; // rbx
  __int64 v46; // r9
  char v47; // cl
  signed __int64 v48; // rdx
  signed __int64 v49; // r13
  unsigned __int64 v50; // r10
  unsigned __int64 v51; // r11
  unsigned __int64 v52; // r14
  unsigned __int64 v53; // rsi
  unsigned __int64 v54; // r9
  int v55; // ecx
  char v56; // r15
  _QWORD *v57; // r10
  signed __int64 v58; // rsi
  __int64 v59; // rax
  __int64 v60; // rbx
  __int64 v61; // r10
  __int64 v62; // r14
  __int64 v63; // r11
  char v64; // r15
  __int64 v65; // r15
  __int64 v66; // rax
  __int64 v67; // rdx
  __int64 v68; // rsi
  __int64 v69; // r12
  unsigned __int64 v70; // r13
  unsigned __int64 v71; // rax
  __int64 v72; // rcx
  __int64 v73; // r12
  unsigned __int64 v74; // rcx
  unsigned __int64 v75; // rax
  unsigned __int64 v76; // rcx
  char v77; // r11
  __int64 v78; // rdx
  int v79; // r9d
  signed __int64 v80; // rbx
  _OWORD *v81; // r10
  __int64 v82; // r15
  __int64 v83; // rcx
  __int64 v84; // rsi
  __int64 v85; // rax
  __int64 v86; // rdx
  __int64 v87; // rax
  char v88; // al
  __int64 v89; // rdx
  unsigned __int64 v90; // r9
  __int64 v91; // r11
  unsigned __int8 *v92; // rcx
  unsigned __int64 v93; // rax
  __int64 v94; // rax
  __int64 v95; // r13
  char v96; // al
  __int64 v97; // rdx
  unsigned __int64 v98; // r9
  unsigned __int8 *v99; // rcx
  unsigned __int64 v100; // rcx
  __int64 v101; // rax
  __int64 v102; // rax
  __int64 v103; // rcx
  __int64 v104; // rax
  int v105; // ecx
  unsigned int *v106; // rax
  __int64 v107; // r9
  unsigned __int64 v108; // rcx
  unsigned int *v109; // rax
  __int64 v110; // rax
  __int128 v111; // rt0
  __int64 v112; // rax
  unsigned __int8 *v113; // rcx
  __int128 v114; // rt0
  unsigned __int64 v115; // rax
  __int64 v116; // rax
  __int128 v117; // rt0
  __int64 v118; // rax
  __int64 v119; // rdx
  __int64 v120; // rsi
  unsigned __int64 v121; // r14
  __int64 *v122; // rcx
  __int64 v123; // r12
  unsigned __int8 *v124; // rsi
  __int64 v125; // r14
  __int64 v126; // rax
  __int64 v127; // rdx
  unsigned __int8 *v128; // rdx
  unsigned __int64 v129; // rdx
  char v130; // r8
  _OWORD *v131; // r9
  __int64 v133; // [rsp+58h] [rbp-28h]
  __int64 v134; // [rsp+60h] [rbp-20h]
  unsigned __int64 v135; // [rsp+68h] [rbp-18h]
  __int64 v136; // [rsp+70h] [rbp-10h]
  unsigned __int64 v137; // [rsp+78h] [rbp-8h]
  __int64 v138; // [rsp+80h] [rbp+0h]
  __int64 v139; // [rsp+88h] [rbp+8h]
  unsigned int *v140; // [rsp+90h] [rbp+10h]
  unsigned int *v141; // [rsp+98h] [rbp+18h]
  __int64 v142; // [rsp+A0h] [rbp+20h]
  __int64 v143; // [rsp+A8h] [rbp+28h]
  __int64 v144; // [rsp+B0h] [rbp+30h]
  __int64 v145; // [rsp+B8h] [rbp+38h]
  unsigned __int64 v146; // [rsp+C0h] [rbp+40h]
  unsigned int *v147; // [rsp+C8h] [rbp+48h]
  __int64 v148; // [rsp+D0h] [rbp+50h]
  __int64 v149; // [rsp+D8h] [rbp+58h]
  unsigned int *v150; // [rsp+E0h] [rbp+60h]
  int v151; // [rsp+E8h] [rbp+68h]
  unsigned int v152; // [rsp+ECh] [rbp+6Ch]
  __int64 v153; // [rsp+F0h] [rbp+70h] BYREF
  __int64 v154; // [rsp+F8h] [rbp+78h]
  __int64 v155; // [rsp+100h] [rbp+80h]
  unsigned __int64 v156; // [rsp+108h] [rbp+88h]
  unsigned __int64 v157; // [rsp+110h] [rbp+90h]
  unsigned __int64 v158; // [rsp+118h] [rbp+98h]
  __int64 v159; // [rsp+120h] [rbp+A0h]
  __int64 v160; // [rsp+128h] [rbp+A8h]
  __int64 v161; // [rsp+130h] [rbp+B0h]
  __int64 v162; // [rsp+138h] [rbp+B8h]
  unsigned __int64 v163; // [rsp+140h] [rbp+C0h]
  __int64 v164; // [rsp+148h] [rbp+C8h]
  unsigned __int8 *v165; // [rsp+150h] [rbp+D0h]
  __int64 v166; // [rsp+158h] [rbp+D8h]
  _BYTE v167[24]; // [rsp+160h] [rbp+E0h] BYREF
  unsigned __int64 v168; // [rsp+178h] [rbp+F8h]
  __int64 v169; // [rsp+180h] [rbp+100h]
  unsigned __int64 v170; // [rsp+188h] [rbp+108h]
  __int16 v171; // [rsp+190h] [rbp+110h]
  __int16 v172; // [rsp+192h] [rbp+112h]
  bool v173; // [rsp+194h] [rbp+114h]
  unsigned __int8 *v174; // [rsp+198h] [rbp+118h]
  signed __int64 v175; // [rsp+1A0h] [rbp+120h]
  unsigned __int64 v176; // [rsp+1A8h] [rbp+128h]
  __int128 v177; // [rsp+1B0h] [rbp+130h] BYREF
  unsigned __int64 v178; // [rsp+1C0h] [rbp+140h]
  unsigned __int16 v179; // [rsp+1D6h] [rbp+156h]
  __int64 v180; // [rsp+1D8h] [rbp+158h]
  __int64 v181; // [rsp+1E0h] [rbp+160h]
  __int64 v182; // [rsp+1E8h] [rbp+168h]
  __int64 v183; // [rsp+1F0h] [rbp+170h]
  unsigned __int8 *v184; // [rsp+1F8h] [rbp+178h]
  __int128 v185; // [rsp+200h] [rbp+180h] BYREF
  int v186; // [rsp+218h] [rbp+198h]
  bool v187; // [rsp+21Fh] [rbp+19Fh]
  signed __int64 v188; // [rsp+220h] [rbp+1A0h]
  unsigned __int8 *v189; // [rsp+228h] [rbp+1A8h]
  unsigned __int8 *v190; // [rsp+230h] [rbp+1B0h]
  __int64 v191; // [rsp+238h] [rbp+1B8h]
  unsigned __int8 v192; // [rsp+246h] [rbp+1C6h]
  unsigned __int8 v193; // [rsp+247h] [rbp+1C7h]
  _OWORD *v194; // [rsp+248h] [rbp+1C8h]
  unsigned int v195; // [rsp+254h] [rbp+1D4h]

  v192 = a4;
  v10 = *(_DWORD *)(a5 + 72);
  v11 = *(_QWORD *)(a5 + 416);
  v12 = 0;
  v13 = 0LL;
  if ( v10 < 0x50000 )
    v13 = *(_QWORD *)(a5 + 416);
  if ( (*(_BYTE *)(a7 + 240) & 1) == 0 )
    v13 = 0LL;
  v14 = a2[4];
  v175 = v14;
  v188 = a3;
  if ( v14 <= a3 )
    goto LABEL_222;
  v135 = *(_QWORD *)(a7 + 200);
  v137 = v135 - v11;
  v151 = v10 & 0xFF00;
  v152 = HIWORD(v10);
  v136 = v13;
  v15 = *(_QWORD *)(a5 + 400);
  v157 = *(_QWORD *)(a7 + 24);
  v163 = v157 - v15;
  LOBYTE(v12) = v10 >= 0x50000;
  v16 = (unsigned int)(16 * v12);
  v17 = *a2;
  v18 = a2[2];
  v144 = *a2
       + *(_QWORD *)(v18 + 56)
       + 8LL * (*(_BYTE *)(v18 + 73) == 8)
       - (*(_QWORD *)(v18 + 40)
        + *(_QWORD *)(v18 + 48))
       + 4;
  v193 = *(_BYTE *)(a5 + 73);
  v179 = *(_WORD *)(a5 + 74);
  v145 = *(_QWORD *)(a5 + 392);
  v140 = *(unsigned int **)(a7 + 192);
  v147 = (unsigned int *)((char *)v140 + v11);
  v138 = BYTE1(v10);
  v14 = *(_QWORD *)(a7 + 16);
  v156 = v15;
  v165 = (unsigned __int8 *)(v14 + v15);
  v164 = (unsigned __int8)v10;
  v134 = v16 + 8;
  v139 = *(_QWORD *)(a5 + 384);
  v194 = a1;
  v195 = v10;
  v146 = v11;
  v133 = v16;
  v187 = v10 >= 0x50000;
LABEL_7:
  v19 = a2[1];
  v20 = 19;
  if ( !v19 )
    goto LABEL_225;
  v21 = a2;
  v22 = v19 - 1;
  v23 = v17 + 1;
  v24 = 0LL;
  v25 = 0;
  while ( 1 )
  {
    v26 = *(_BYTE *)(v23 - 1);
    if ( v25 == 63 && (unsigned __int8)v26 >= 2u )
    {
      *a2 = v23;
      a2[1] = v22;
      v20 = 6;
LABEL_224:
      a1 = v194;
LABEL_225:
      *(_BYTE *)a1 = v20;
      *((_BYTE *)a1 + 1) = 0;
      *((_WORD *)a1 + 3) = 0;
      *(_DWORD *)((char *)a1 + 2) = 0;
      *((_QWORD *)a1 + 1) = v17;
      return v14;
    }
    v24 |= (unsigned __int64)(*(_BYTE *)(v23 - 1) & 0x7F) << v25;
    if ( v26 >= 0 )
      break;
    v25 += 7;
    ++v23;
    v27 = v22-- != 0;
    if ( !v27 )
    {
      v17 += v19;
      *a2 = v17;
      a2[1] = 0LL;
      goto LABEL_224;
    }
  }
  *a2 = v23;
  a2[1] = v22;
  v28 = a5;
  if ( !v24 )
  {
    a2[4] = v175 - 1;
    v158 = 0LL;
    v37 = v188;
    goto LABEL_205;
  }
  v29 = (_QWORD *)a2[3];
  if ( v24 - 1 < v29[2] )
  {
    v30 = v29[1] + 112 * (v24 - 1);
    v31 = v195;
    if ( *(_BYTE *)(v30 + 106) != 1 )
      goto LABEL_18;
    goto LABEL_17;
  }
  v38 = v29[3];
  v20 = 18;
  if ( !v38 )
  {
LABEL_230:
    a1 = v194;
    v17 = v158;
    goto LABEL_225;
  }
  v39 = v29[4];
LABEL_25:
  v40 = 8 * (unsigned int)*(unsigned __int16 *)(v38 + 1330);
  v41 = -1LL;
  do
  {
    if ( !v40 )
    {
      v41 = *(unsigned __int16 *)(v38 + 1330);
LABEL_33:
      v27 = v39-- == 0;
      if ( v27 )
        goto LABEL_230;
      v38 = *(_QWORD *)(v38 + 8 * v41 + 1336);
      goto LABEL_25;
    }
    v42 = *(_QWORD *)(v38 + 8 * v41 + 1248) != v24;
    if ( *(_QWORD *)(v38 + 8 * v41 + 1248) > v24 )
      v42 = -1;
    ++v41;
    v40 -= 8LL;
  }
  while ( v42 == 1 );
  if ( v42 )
    goto LABEL_33;
  v30 = 112 * v41 + v38;
  v28 = a5;
  v31 = v195;
  if ( *(_BYTE *)(v30 + 106) == 1 )
LABEL_17:
    v21[4] = v175 + 1;
LABEL_18:
  v32 = *(unsigned __int16 *)(v30 + 104);
  v158 = v30;
  if ( v32 == 29 )
  {
    if ( (*(_BYTE *)v30 & 1) != 0 )
    {
      v148 = *(_QWORD *)(v30 + 16);
      v43 = *(_QWORD *)(v30 + 24);
    }
    else
    {
      v43 = *(_QWORD *)(v30 + 8);
      if ( v43 >= 6 )
        sub_405B00(*(_QWORD *)(v30 + 8), 5LL, (__int64)&off_446D68);
      v148 = v30 + 16;
    }
    v184 = (unsigned __int8 *)v14;
    if ( !v43 )
    {
      v180 = 0LL;
      v181 = 0LL;
      v162 = 0LL;
      v186 = 0;
      v159 = 0LL;
      v160 = 0LL;
      v166 = 0LL;
      v183 = 0LL;
LABEL_85:
      v70 = a8[2];
      if ( v70 == *a8 )
      {
        sub_429A10(a8, v31);
        LOWORD(v31) = v195;
      }
      v71 = a8[1];
      v72 = 48 * v70;
      *(_QWORD *)(v71 + v72) = v166;
      *(_QWORD *)(v71 + v72 + 8) = v149;
      *(_QWORD *)(v71 + v72 + 16) = v144;
      *(_QWORD *)(v71 + v72 + 24) = v183;
      *(_QWORD *)(v71 + v72 + 32) = v161;
      *(_DWORD *)(v71 + v72 + 40) = v160;
      *(_DWORD *)(v71 + v72 + 44) = v159;
      a8[2] = v70 + 1;
      v73 = a7;
      if ( (v186 & 1) != 0 )
      {
        v74 = *(_QWORD *)(a7 + v134 + 176);
        v75 = *(_QWORD *)(a7 + v133 + 176);
        v27 = v74 < (unsigned __int64)v141;
        v76 = v74 - (_QWORD)v141;
        if ( v27 )
        {
          v77 = 19;
          v78 = 0LL;
          LOBYTE(v79) = 0;
          v80 = v188;
          v81 = v194;
          v82 = v191;
        }
        else
        {
          *(_QWORD *)v167 = v184;
          *(_QWORD *)&v167[8] = v157;
          *(_QWORD *)&v167[16] = v139;
          v168 = v156;
          v169 = (__int64)v141 + v75;
          v170 = v76;
          v171 = v31;
          v172 = v152;
          v173 = v187;
          while ( 1 )
          {
            sub_41E760(&v177, (unsigned __int8 **)v167);
            if ( (_QWORD)v177 == 2LL )
              break;
            if ( (_QWORD)v177 != 1LL )
            {
              v83 = (__int64)a9;
              v82 = v191;
              goto LABEL_200;
            }
            v120 = *((_QWORD *)&v177 + 1);
            v121 = v178;
            if ( *((_QWORD *)&v177 + 1) < v178 )
            {
              v122 = a9;
              v123 = a9[2];
              if ( v123 == *a9 )
              {
                sub_41F5E0(a9, (__int64)&off_448488);
                v122 = a9;
              }
              v118 = v122[1];
              v119 = 32 * v123;
              *(_QWORD *)(v118 + v119) = v120;
              *(_QWORD *)(v118 + v119 + 8) = v121;
              *(_QWORD *)(v118 + v119 + 16) = a10;
              *(_QWORD *)(v118 + v119 + 24) = v70;
              v122[2] = v123 + 1;
              v73 = a7;
            }
          }
          v77 = BYTE8(v177);
          v83 = (__int64)a9;
          v82 = v191;
          if ( BYTE8(v177) == 75 )
            goto LABEL_200;
          v75 = v178;
          v79 = DWORD2(v177) >> 8;
          v78 = *((_QWORD *)&v177 + 1) >> 16;
          v80 = v188;
          v81 = v194;
        }
        LOBYTE(v185) = v77;
        BYTE1(v185) = v79;
        *(_DWORD *)((char *)&v185 + 2) = v78;
        WORD3(v185) = WORD2(v78);
        *((_QWORD *)&v185 + 1) = v75;
      }
      else
      {
        v83 = (__int64)a9;
        v82 = v191;
        if ( (v180 & 1) != 0 )
        {
          if ( (v181 & 1) != 0 )
          {
            if ( (unsigned __int64)v174 < v176 )
            {
              v84 = a9[2];
              if ( v84 == *a9 )
              {
                sub_41F5E0(a9, (__int64)&off_448488);
                v83 = (__int64)a9;
              }
              v85 = *(_QWORD *)(v83 + 8);
              v86 = 32 * v84;
              *(_QWORD *)(v85 + v86) = v174;
              *(_QWORD *)(v85 + v86 + 8) = v176;
              *(_QWORD *)(v85 + v86 + 16) = a10;
              *(_QWORD *)(v85 + v86 + 24) = v70;
              *(_QWORD *)(v83 + 16) = v84 + 1;
            }
          }
          else if ( (v162 & 1) != 0 )
          {
            v124 = &v174[v143];
            if ( v174 < &v174[v143] )
            {
              v125 = a9[2];
              if ( v125 == *a9 )
              {
                sub_41F5E0(a9, (__int64)&off_448488);
                v83 = (__int64)a9;
              }
              v126 = *(_QWORD *)(v83 + 8);
              v127 = 32 * v125;
              *(_QWORD *)(v126 + v127) = v174;
              *(_QWORD *)(v126 + v127 + 8) = v124;
              *(_QWORD *)(v126 + v127 + 16) = a10;
              *(_QWORD *)(v126 + v127 + 24) = v70;
              *(_QWORD *)(v83 + 16) = v125 + 1;
            }
          }
        }
LABEL_200:
        sub_4266A0((unsigned int)&v185, (_DWORD)v21, v175, v192, v28, (__int64)a6, v73, (__int64)a8, v83, a10 + 1);
        v80 = v188;
        v81 = v194;
      }
      v14 = (signed __int64)v184;
      v91 = v182;
      goto LABEL_202;
    }
    v68 = 16 * v43;
    v69 = 0LL;
    v183 = 0LL;
    v166 = 0LL;
    v160 = 0LL;
    v159 = 0LL;
    v186 = 0;
    v162 = 0LL;
    v181 = 0LL;
    v180 = 0LL;
    while ( 1 )
    {
      v177 = *(_OWORD *)(v148 + v69);
      sub_41D2E0((__int64)v167, v21, *(_DWORD *)(v21[2] + 72), (__int64)&v177);
      if ( *(_QWORD *)v167 == 46LL )
      {
        v185 = *(_OWORD *)&v167[8];
        goto LABEL_183;
      }
      switch ( (__int16)v168 )
      {
        case 3:
          if ( v183 )
            goto LABEL_97;
          sub_421680((__int64)&v177, (__int64 *)v167);
          sub_427DD0(&v153, (_QWORD *)a7, v193, v145, &v177);
          if ( (_BYTE)v153 )
          {
            v183 = 0LL;
            v31 = v195;
            v104 = v142;
          }
          else
          {
            v183 = v154;
            v104 = v155;
            v31 = v195;
          }
          v142 = v104;
          v161 = v104;
          goto LABEL_98;
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
        case 16:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 31:
        case 32:
        case 33:
        case 34:
        case 35:
        case 36:
        case 37:
        case 38:
        case 39:
        case 40:
        case 41:
        case 42:
        case 43:
        case 44:
        case 45:
        case 46:
        case 47:
        case 48:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
        case 64:
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
        case 72:
        case 73:
        case 74:
        case 75:
        case 76:
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
        case 83:
        case 84:
        case 86:
          goto LABEL_97;
        case 17:
          sub_421680((__int64)&v177, (__int64 *)v167);
          v94 = v177;
          if ( (_QWORD)v177 )
          {
            if ( (_DWORD)v177 == 12 )
            {
              v95 = v28;
              v96 = 19;
              v80 = v188;
              v81 = v194;
              v91 = v182;
              if ( v157 < v156 )
              {
                v99 = v184;
                v82 = v191;
LABEL_220:
                v128 = v190;
                LOBYTE(v185) = v96;
                *(_DWORD *)((char *)&v185 + 1) = v82;
                BYTE7(v185) = BYTE6(v82);
                *(_WORD *)((char *)&v185 + 5) = WORD2(v82);
                *((_QWORD *)&v185 + 1) = v99;
                v14 = (signed __int64)v184;
                goto LABEL_203;
              }
              v97 = v164 * *((_QWORD *)&v177 + 1);
              v98 = v163 - v164 * *((_QWORD *)&v177 + 1);
              if ( v163 < v164 * *((_QWORD *)&v177 + 1) )
              {
                v99 = v165;
                v82 = v191;
                goto LABEL_220;
              }
              v99 = &v165[v97];
              switch ( (int)v164 )
              {
                case 1:
                  if ( v163 == v97 )
                    goto LABEL_213;
                  v100 = *v99;
                  goto LABEL_170;
                case 2:
                  v31 = v195;
                  if ( v98 <= 1 )
                    goto LABEL_213;
                  v113 = (unsigned __int8 *)*(unsigned __int16 *)v99;
                  goto LABEL_173;
                case 4:
                  v31 = v195;
                  if ( v98 <= 3 )
                    goto LABEL_213;
                  v113 = (unsigned __int8 *)*(unsigned int *)v99;
LABEL_173:
                  LOBYTE(v94) = 1;
                  v180 = v94;
                  v189 = v113;
                  v28 = v95;
                  v174 = v113;
                  break;
                case 8:
                  if ( v98 <= 7 )
                  {
LABEL_213:
                    v82 = 0LL;
                    v81 = v194;
                    goto LABEL_220;
                  }
                  v94 = v99[7];
                  *(_QWORD *)&v114 = ((unsigned __int64)(*((unsigned __int16 *)v99 + 2) | (v99[6] << 16)) << 40) | ((unsigned __int64)*(unsigned int *)v99 << 8);
                  *((_QWORD *)&v114 + 1) = v94;
                  v100 = v114 >> 8;
LABEL_170:
                  LOBYTE(v94) = 1;
                  v180 = v94;
                  v189 = (unsigned __int8 *)v100;
                  v31 = v195;
                  v28 = v95;
                  v174 = (unsigned __int8 *)v100;
                  break;
                default:
                  v82 = v164 + (v191 & 0xFFFFFFFFFFFFFF00uLL);
                  v96 = 23;
                  v81 = v194;
                  v99 = v189;
                  goto LABEL_220;
              }
            }
            else
            {
              v31 = v195;
            }
          }
          else
          {
            v180 = 1LL;
            v31 = v195;
            v174 = (unsigned __int8 *)*((_QWORD *)&v177 + 1);
          }
LABEL_98:
          v69 += 16LL;
          if ( v68 == v69 )
            goto LABEL_85;
          break;
        case 18:
          sub_421680((__int64)&v177, (__int64 *)v167);
          v87 = v177;
          if ( (_QWORD)v177 )
          {
            v31 = v195;
            if ( (_DWORD)v177 == 7 )
            {
              LOBYTE(v87) = 1;
              v162 = v87;
              v143 = *((_QWORD *)&v177 + 1);
            }
            else if ( (_DWORD)v177 == 12 )
            {
              v88 = 19;
              v80 = v188;
              v81 = v194;
              if ( v157 < v156 )
              {
                v128 = v184;
                v91 = v182;
                goto LABEL_217;
              }
              v89 = v164 * *((_QWORD *)&v177 + 1);
              v90 = v163 - v164 * *((_QWORD *)&v177 + 1);
              v91 = v182;
              if ( v163 < v164 * *((_QWORD *)&v177 + 1) )
              {
                v128 = v165;
                goto LABEL_217;
              }
              v92 = &v165[v89];
              switch ( (int)v164 )
              {
                case 1:
                  if ( v163 == v89 )
                    goto LABEL_216;
                  v93 = *v92;
                  LOBYTE(v92) = 1;
                  v181 = (__int64)v92;
                  v176 = v93;
                  v190 = (unsigned __int8 *)v93;
                  goto LABEL_178;
                case 2:
                  v31 = v195;
                  if ( v90 <= 1 )
                    goto LABEL_216;
                  v115 = *(unsigned __int16 *)v92;
                  goto LABEL_181;
                case 4:
                  v31 = v195;
                  if ( v90 <= 3 )
                    goto LABEL_216;
                  v115 = *(unsigned int *)v92;
LABEL_181:
                  LOBYTE(v92) = 1;
                  v181 = (__int64)v92;
                  v176 = v115;
                  v190 = (unsigned __int8 *)v115;
                  v28 = a5;
                  goto LABEL_98;
                case 8:
                  if ( v90 <= 7 )
                  {
LABEL_216:
                    v128 = v92;
                    v91 = 0LL;
                    v80 = v188;
                    v81 = v194;
LABEL_217:
                    v82 = v191;
                    v99 = v189;
LABEL_218:
                    LOBYTE(v185) = v88;
                    *(_DWORD *)((char *)&v185 + 1) = v91;
                    BYTE7(v185) = BYTE6(v91);
                    *(_WORD *)((char *)&v185 + 5) = WORD2(v91);
                    *((_QWORD *)&v185 + 1) = v128;
                    v14 = (signed __int64)v184;
                    goto LABEL_203;
                  }
                  v116 = v92[7];
                  *(_QWORD *)&v117 = ((unsigned __int64)(*((unsigned __int16 *)v92 + 2) | (v92[6] << 16)) << 40) | ((unsigned __int64)*(unsigned int *)v92 << 8);
                  *((_QWORD *)&v117 + 1) = v116;
                  LOBYTE(v116) = 1;
                  v181 = v116;
                  v176 = v117 >> 8;
                  v190 = (unsigned __int8 *)v176;
LABEL_178:
                  v31 = v195;
                  v28 = a5;
                  break;
                default:
                  v91 = v164 + (v182 & 0xFFFFFFFFFFFFFF00uLL);
                  v88 = 23;
                  v81 = v194;
                  v82 = v191;
                  v99 = v189;
                  v128 = v190;
                  goto LABEL_218;
              }
            }
          }
          else
          {
            v181 = 1LL;
            v176 = *((_QWORD *)&v177 + 1);
LABEL_97:
            v31 = v195;
          }
          goto LABEL_98;
        case 49:
        case 71:
          if ( v183 )
            goto LABEL_97;
          sub_421680((__int64)&v177, (__int64 *)v167);
          sub_427FC0((__int64)&v153, v177, *((unsigned __int64 *)&v177 + 1), v192, v28, a6, (_QWORD *)a7, 16LL);
          v183 = v154;
          if ( (_DWORD)v153 == 1 )
          {
            *(_QWORD *)&v185 = v183;
            *((_QWORD *)&v185 + 1) = v155;
LABEL_183:
            v80 = v188;
            v81 = v194;
            v14 = (signed __int64)v184;
            v91 = v182;
            v82 = v191;
LABEL_202:
            v99 = v189;
            v128 = v190;
LABEL_203:
            if ( (_BYTE)v185 != 75 )
            {
              *v81 = v185;
              return v14;
            }
            v190 = v128;
            v189 = v99;
            v191 = v82;
            v182 = v91;
            v37 = v80;
LABEL_205:
            v18 = v21[2];
            v17 = *v21;
            v144 = *v21
                 + *(_QWORD *)(v18 + 56)
                 + 8LL * (*(_BYTE *)(v18 + 73) == 8)
                 - (*(_QWORD *)(v18 + 40)
                  + *(_QWORD *)(v18 + 48))
                 + 4;
            v175 = v21[4];
            a1 = v194;
            a2 = v21;
            if ( v175 <= v37 )
            {
LABEL_222:
              *(_BYTE *)a1 = 75;
              return v14;
            }
            goto LABEL_7;
          }
          v161 = v155;
          goto LABEL_97;
        case 85:
          sub_421680((__int64)&v177, (__int64 *)v167);
          v105 = v177;
          if ( (_QWORD)v177 == 24LL )
          {
            v107 = v28;
            v80 = v188;
            v81 = v194;
            v91 = v182;
            if ( v135 < v146 )
            {
              v109 = v140;
LABEL_212:
              *(_QWORD *)&v185 = 19LL;
              *((_QWORD *)&v185 + 1) = v109;
              v150 = v109;
              v14 = (signed __int64)v184;
              v82 = v191;
              goto LABEL_202;
            }
            v108 = v137 - v138 * *((_QWORD *)&v177 + 1);
            if ( v137 < v138 * *((_QWORD *)&v177 + 1) )
            {
              v109 = v147;
              goto LABEL_212;
            }
            v109 = (unsigned int *)((char *)v147 + v138 * *((_QWORD *)&v177 + 1));
            if ( v151 == 2048 )
            {
              if ( v108 <= 7 )
                goto LABEL_212;
              LODWORD(v108) = *((unsigned __int8 *)v109 + 7);
              *(_QWORD *)&v111 = ((unsigned __int64)(*((unsigned __int16 *)v109 + 2) | (*((unsigned __int8 *)v109 + 6) << 16)) << 40) | ((unsigned __int64)*v109 << 8);
              *((_QWORD *)&v111 + 1) = *((unsigned __int8 *)v109 + 7);
              v110 = v111 >> 8;
            }
            else
            {
              if ( v108 <= 3 )
                goto LABEL_212;
              v110 = *v109;
            }
            v106 = (unsigned int *)(v146 + v110);
            LOBYTE(v108) = 1;
            v186 = v108;
            v31 = v195;
            v28 = v107;
          }
          else if ( (_DWORD)v177 == 22 )
          {
            v106 = (unsigned int *)(v136 + *((_QWORD *)&v177 + 1));
            LOBYTE(v105) = 1;
            v186 = v105;
            v31 = v195;
          }
          else
          {
            v186 = 0;
            v31 = v195;
            v106 = v150;
          }
          v150 = v106;
          v141 = v106;
          goto LABEL_98;
        case 87:
          v31 = v195;
          switch ( *(_QWORD *)v167 )
          {
            case 2LL:
              v101 = v167[8];
              break;
            case 3LL:
              v101 = *(unsigned __int16 *)&v167[8];
              break;
            case 4LL:
              v101 = *(unsigned int *)&v167[8];
              break;
            case 5LL:
            case 7LL:
              v101 = *(_QWORD *)&v167[8];
              break;
            case 6LL:
              v101 = *(_QWORD *)&v167[8];
              if ( *(__int64 *)&v167[8] < 0 )
                goto LABEL_162;
              break;
            default:
LABEL_162:
              v101 = 0LL;
              break;
          }
          v159 = v101;
          goto LABEL_98;
        case 88:
          sub_421680((__int64)&v177, (__int64 *)v167);
          if ( (_DWORD)v177 == 44 )
          {
            v102 = v149;
            if ( v179 >= 5u || *((_QWORD *)&v177 + 1) != 0LL )
              v102 = *((_QWORD *)&v177 + 1);
            v149 = v102;
            v103 = v166;
            if ( v179 >= 5u || *((_QWORD *)&v177 + 1) != 0LL )
              v103 = 1LL;
            v166 = v103;
          }
          goto LABEL_97;
        case 89:
          v31 = v195;
          switch ( *(_QWORD *)v167 )
          {
            case 2LL:
              v160 = v167[8];
              break;
            case 3LL:
              v160 = *(unsigned __int16 *)&v167[8];
              break;
            case 4LL:
              v160 = *(unsigned int *)&v167[8];
              break;
            case 5LL:
            case 7LL:
              v160 = *(_QWORD *)&v167[8];
              break;
            case 6LL:
              v112 = *(_QWORD *)&v167[8];
              if ( *(__int64 *)&v167[8] >= 0 )
                goto LABEL_157;
              goto LABEL_156;
            default:
LABEL_156:
              v112 = 0LL;
LABEL_157:
              v160 = v112;
              break;
          }
          goto LABEL_98;
        default:
          if ( (unsigned __int16)v168 == 110 || (unsigned __int16)v168 == 8199 )
          {
            sub_421680((__int64)&v177, (__int64 *)v167);
            sub_427DD0(&v153, (_QWORD *)a7, v193, v145, &v177);
            if ( !(_BYTE)v153 )
            {
              v161 = v155;
              v183 = v154;
            }
          }
          goto LABEL_97;
      }
    }
  }
  if ( v32 != 46 )
  {
    v44 = v188;
    if ( (*(_BYTE *)v30 & 1) != 0 )
    {
      v45 = v14;
      v46 = *(_QWORD *)(v30 + 16);
      v36 = *(_QWORD *)(v30 + 24);
    }
    else
    {
      v36 = *(_QWORD *)(v30 + 8);
      if ( v36 >= 6 )
        goto LABEL_234;
      v45 = v14;
      v46 = v30 + 16;
    }
    sub_425CD0((__int64)v167, (char **)v21, *(_DWORD *)(v18 + 72), v46, v36);
    if ( v167[0] == 75 )
    {
      v37 = v44;
      v14 = v45;
      goto LABEL_205;
    }
    LOBYTE(v14) = (_BYTE)v194;
    *v194 = *(_OWORD *)v167;
    return v14;
  }
  v33 = v188;
  if ( (*(_BYTE *)v30 & 1) != 0 )
  {
    v34 = v14;
    v35 = *(_QWORD *)(v30 + 16);
    v36 = *(_QWORD *)(v30 + 24);
    goto LABEL_43;
  }
  v36 = *(_QWORD *)(v30 + 8);
  if ( v36 >= 6 )
LABEL_234:
    sub_405B00(v36, 5LL, (__int64)&off_446D68);
  v34 = v14;
  v35 = v30 + 16;
LABEL_43:
  LOBYTE(v14) = sub_425CD0((__int64)v167, (char **)v21, *(_DWORD *)(v18 + 72), v35, v36);
  v47 = v167[0];
  if ( v167[0] == 75 )
  {
    v48 = v21[4];
    if ( v48 <= v175 )
    {
      v37 = v33;
      v14 = v34;
      goto LABEL_205;
    }
    v37 = v33;
    while ( 1 )
    {
      v49 = v37;
      v50 = *v21;
      v51 = v21[1];
      if ( !v51 )
        break;
      v52 = v51 - 1;
      v53 = v50 + 1;
      v54 = 0LL;
      v55 = 0;
      while ( 1 )
      {
        v56 = *(_BYTE *)(v53 - 1);
        if ( v55 == 63 && (unsigned __int8)v56 >= 2u )
        {
          *v21 = v53;
          v21[1] = v52;
          v47 = 6;
          goto LABEL_228;
        }
        v54 |= (unsigned __int64)(*(_BYTE *)(v53 - 1) & 0x7F) << v55;
        if ( v56 >= 0 )
          break;
        v55 += 7;
        ++v53;
        v27 = v52-- != 0;
        if ( !v27 )
        {
          v50 += v51;
          *v21 = v50;
          v21[1] = 0LL;
          goto LABEL_227;
        }
      }
      *v21 = v53;
      v21[1] = v52;
      if ( !v54 )
      {
        v21[4] = --v48;
        v14 = 0LL;
        v37 = v49;
        goto LABEL_73;
      }
      v57 = (_QWORD *)v21[3];
      if ( v54 - 1 < v57[2] )
      {
        v58 = v49;
        v59 = v57[1] + 112 * (v54 - 1);
        goto LABEL_69;
      }
      v60 = v57[3];
      v47 = 18;
      if ( !v60 )
        goto LABEL_228;
      v61 = v57[4];
LABEL_59:
      v62 = 8 * (unsigned int)*(unsigned __int16 *)(v60 + 1330);
      v63 = -1LL;
      do
      {
        if ( !v62 )
        {
          v63 = *(unsigned __int16 *)(v60 + 1330);
LABEL_67:
          v27 = v61-- == 0;
          if ( v27 )
            goto LABEL_228;
          v60 = *(_QWORD *)(v60 + 8 * v63 + 1336);
          goto LABEL_59;
        }
        v64 = *(_QWORD *)(v60 + 8 * v63 + 1248) != v54;
        if ( *(_QWORD *)(v60 + 8 * v63 + 1248) > v54 )
          v64 = -1;
        ++v63;
        v62 -= 8LL;
      }
      while ( v64 == 1 );
      if ( v64 )
        goto LABEL_67;
      v59 = 112 * v63 + v60;
      v58 = v49;
LABEL_69:
      v65 = v59;
      if ( *(_BYTE *)(v59 + 106) == 1 )
        v21[4] = v48 + 1;
      v66 = sub_409E2D(v59);
      sub_425CD0((__int64)v167, (char **)v21, *(_DWORD *)(v21[2] + 72), v66, v67);
      v47 = v167[0];
      if ( v167[0] != 75 )
        goto LABEL_231;
      v48 = v21[4];
      v14 = v65;
      v37 = v58;
LABEL_73:
      if ( v48 <= v175 )
      {
        v14 = v34;
        goto LABEL_205;
      }
    }
LABEL_227:
    v47 = 19;
    v14 = v50;
LABEL_228:
    v129 = 0LL;
    v130 = 0;
  }
  else
  {
LABEL_231:
    v130 = v167[1];
    v129 = *(unsigned int *)&v167[2] | ((unsigned __int64)*(unsigned __int16 *)&v167[6] << 32);
    v14 = *(_QWORD *)&v167[8];
  }
  v131 = v194;
  *(_BYTE *)v194 = v47;
  *((_BYTE *)v131 + 1) = v130;
  *(_DWORD *)((char *)v131 + 2) = v129;
  *((_WORD *)v131 + 3) = WORD2(v129);
  *((_QWORD *)v131 + 1) = v14;
  return v14;
}
// 426BF2: variable 'v67' is possibly undefined
// 426D92: variable 'v149' is possibly undefined
// 426E0C: variable 'v141' is possibly undefined
// 4273F2: variable 'v150' is possibly undefined
// 427422: variable 'v142' is possibly undefined
// 4277D9: variable 'v143' is possibly undefined
// 427B57: variable 'v14' is possibly undefined
// 446D68: using guessed type char *off_446D68;
// 448488: using guessed type char *off_448488;

//----- (0000000000427BE0) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_427BE0(__int128 *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // r8
  size_t v3; // rsi
  _OWORD *v6; // rax
  void *v7; // rdi
  HANDLE ProcessHeap; // rax
  _OWORD v9[258]; // [rsp+28h] [rbp-58h] BYREF

  v2 = 250000LL;
  if ( a2 < 0x3D090 )
    v2 = a2;
  if ( a2 >> 1 > v2 )
    v2 = a2 >> 1;
  v3 = 48LL;
  if ( v2 >= 0x31 )
    v3 = v2;
  if ( v2 >= 0x81 )
  {
    if ( a2 >> 60 || 32 * v3 >= 0x7FFFFFFFFFFFFFF9LL )
      sub_4040B0((__int64)&off_447D68);
    v6 = sub_43C4F0(32 * v3);
    if ( !v6 )
      sub_4040E9(8LL, 32 * v3);
    v7 = v6;
    sub_428690(a1, a2, v6, v3, a2 < 0x41);
    ProcessHeap = GetProcessHeap();
    HeapFree(ProcessHeap, 0, v7);
  }
  else
  {
    sub_428690(a1, a2, v9, 0x80uLL, a2 < 0x41);
  }
}
// 427C59: positive sp value 1028 has been found
// 447D68: using guessed type char *off_447D68;

//----- (0000000000427D10) ----------------------------------------------------
__int64 __fastcall sub_427D10(_OWORD *a1, __int64 a2)
{
  _OWORD *v2; // rdx
  _OWORD *v3; // r9
  __int64 result; // rax
  _OWORD *v5; // r8
  char *v6; // rdi
  _OWORD *v7; // rbx
  unsigned __int64 v8; // r9
  unsigned __int64 v9; // r10
  __int64 v10; // rsi
  __int64 v11; // r11
  __int128 v12; // xmm0
  __int64 v13; // rbx
  __int128 v14; // xmm0
  __int64 v15; // r14

  v2 = &a1[2 * a2];
  v3 = a1 + 2;
  result = 0LL;
  v5 = a1;
  do
  {
    v7 = v5;
    v5 = v3;
    v8 = *((_QWORD *)v7 + 6);
    v9 = *((_QWORD *)v7 + 4);
    if ( v8 < *((_QWORD *)v7 + 2) || v8 <= *((_QWORD *)v7 + 2) && v9 < *(_QWORD *)v7 )
    {
      v10 = *((_QWORD *)v7 + 5);
      v11 = *((_QWORD *)v7 + 7);
      v12 = *v7;
      v5[1] = v7[1];
      *v5 = v12;
      v6 = (char *)a1;
      if ( v7 != a1 )
      {
        v13 = result;
        while ( 1 )
        {
          v6 = (char *)a1 + v13;
          v15 = (__int64)a1 + v13 - 32;
          if ( v8 >= *(_QWORD *)((char *)a1 + v13 - 16)
            && (v8 > *(_QWORD *)((char *)a1 + v13 - 16) || v9 >= *(_QWORD *)v15) )
          {
            break;
          }
          v14 = *(_OWORD *)v15;
          *((_OWORD *)v6 + 1) = *(_OWORD *)(v15 + 16);
          *(_OWORD *)v6 = v14;
          v13 -= 32LL;
          if ( !v13 )
          {
            v6 = (char *)a1;
            break;
          }
        }
      }
      *(_QWORD *)v6 = v9;
      *((_QWORD *)v6 + 1) = v10;
      *((_QWORD *)v6 + 2) = v8;
      *((_QWORD *)v6 + 3) = v11;
    }
    v3 = v5 + 2;
    result += 32LL;
  }
  while ( v5 + 2 != v2 );
  return result;
}

//----- (0000000000427DD0) ----------------------------------------------------
__int64 __fastcall sub_427DD0(__int64 *a1, _QWORD *a2, __int64 a3, __int64 a4, _QWORD *a5)
{
  unsigned __int64 v5; // r9
  __int64 v6; // r8
  unsigned __int64 v7; // rax
  unsigned __int64 v8; // rax
  __int64 i; // rdx
  __int64 v10; // rax
  unsigned __int64 v11; // r8
  unsigned __int64 v12; // rax
  unsigned __int64 v13; // rax
  __int64 result; // rax

  switch ( *a5 )
  {
    case 0x1ALL:
      v5 = a5[1];
      v6 = a2[12];
      v7 = a2[13];
      if ( v7 >= v5 )
      {
        v6 += v5;
        v8 = v7 - v5;
        if ( v8 )
        {
          for ( i = 0LL; i != v8; ++i )
          {
            if ( !*(_BYTE *)(v6 + i) )
            {
              a1[1] = v6;
              result = 0LL;
              goto LABEL_17;
            }
          }
        }
      }
      *((_BYTE *)a1 + 8) = 19;
      result = 1LL;
      goto LABEL_19;
    case 0x1BLL:
      v10 = a2[26];
      if ( !v10 )
        goto LABEL_15;
      v11 = a5[1];
      i = *(_QWORD *)(v10 + 112);
      v12 = *(_QWORD *)(v10 + 120);
      if ( v12 < v11 )
        goto LABEL_14;
      i += v11;
      v13 = v12 - v11;
      if ( !v13 )
        goto LABEL_14;
      v6 = 0LL;
      break;
    default:
LABEL_15:
      *((_BYTE *)a1 + 8) = 69;
      result = 1LL;
      *a1 = 1LL;
      return result;
  }
  while ( *(_BYTE *)(i + v6) )
  {
    if ( v13 == ++v6 )
    {
LABEL_14:
      *((_BYTE *)a1 + 8) = 19;
      result = 1LL;
LABEL_17:
      a1[2] = i;
      *a1 = result;
      return result;
    }
  }
  a1[1] = i;
  result = 0LL;
LABEL_19:
  a1[2] = v6;
  *a1 = result;
  return result;
}

//----- (0000000000427FC0) ----------------------------------------------------
void __fastcall sub_427FC0(
        __int64 a1,
        __int64 a2,
        unsigned __int64 a3,
        unsigned __int8 a4,
        __int64 a5,
        _QWORD *a6,
        _QWORD *a7,
        __int64 a8)
{
  __int64 v8; // rdx
  unsigned __int64 v9; // r9
  __int64 v10; // rax
  __int64 v11; // rsi
  unsigned __int64 v12; // rdx
  __int64 v13; // rax
  __int64 v14; // rdi
  unsigned __int64 v16; // rdx
  __int64 v17; // rax
  __int64 v18; // rdi
  __int64 v19; // rdi
  __int64 v20; // rsi
  __int64 v21; // r9
  __int64 v22; // rdi
  bool v23; // cf
  unsigned __int64 v24; // r8
  unsigned __int64 v25; // rsi
  unsigned __int64 v26; // rbx
  __int64 v27; // rbx
  __int64 v28; // rdi
  __int64 v29; // rbx
  __int64 v30; // rdi
  unsigned __int64 v31; // rdx
  unsigned __int64 v32; // rbx

  if ( !a8 )
    goto LABEL_9;
  if ( a2 == 13 )
    goto LABEL_15;
  if ( a2 != 14 )
  {
    if ( a2 == 15 )
    {
      v8 = a7[26];
      if ( v8 )
      {
        v9 = a6[6];
        if ( v9 )
        {
          v10 = a6[5];
          if ( v9 == 1 )
          {
            v11 = 0LL;
          }
          else
          {
            v19 = 0LL;
            do
            {
              v11 = (v9 >> 1) + v19;
              if ( *(_QWORD *)(v10 + 432 * v11 + 424) > a3 )
                v11 = v19;
              v9 -= v9 >> 1;
              v19 = v11;
            }
            while ( v9 > 1 );
          }
          if ( *(_QWORD *)(v10 + 432 * v11 + 424) != a3 )
          {
            v20 = (*(_QWORD *)(v10 + 432 * v11 + 424) < a3) + v11;
            if ( v20 )
            {
              v21 = 432 * v20;
              if ( (*(_BYTE *)(v10 + 432 * v20 - 432) & 1) == 0 )
              {
                v22 = v10 + v21;
                v23 = a3 < *(_QWORD *)(v10 + v21 - 424);
                v24 = a3 - *(_QWORD *)(v10 + v21 - 424);
                if ( !v23 )
                {
                  v25 = *(_QWORD *)(v22 - 384);
                  v26 = *(_QWORD *)(v22 - 376) - v25 + 8LL * (*(_BYTE *)(v22 - 359) == 8) + 4;
                  if ( v24 >= v26 && v24 - v26 < v25 )
                  {
                    sub_428290(a1, 1u, v21 + v10 - 432, v24, (__int64)a6, (_QWORD *)(v8 + 16), a8);
                    return;
                  }
                }
              }
            }
          }
        }
        goto LABEL_46;
      }
    }
LABEL_9:
    *(_OWORD *)a1 = 0LL;
    return;
  }
  if ( a4 )
  {
    if ( a4 != 1 )
      goto LABEL_46;
    v12 = a6[6];
    if ( !v12 )
      goto LABEL_46;
    v13 = a6[5];
    if ( v12 == 1 )
    {
      v14 = 0LL;
    }
    else
    {
      v27 = 0LL;
      do
      {
        v14 = (v12 >> 1) + v27;
        if ( *(_QWORD *)(v13 + 432 * v14 + 424) > a3 )
          v14 = v27;
        v12 -= v12 >> 1;
        v27 = v14;
      }
      while ( v12 > 1 );
    }
    if ( *(_QWORD *)(v13 + 432 * v14 + 424) == a3 )
      goto LABEL_46;
    v28 = (*(_QWORD *)(v13 + 432 * v14 + 424) < a3) + v14;
    if ( !v28 )
      goto LABEL_46;
    a5 = 432 * v28 + v13 - 432;
  }
  else
  {
    v16 = a6[4];
    if ( !v16 )
      goto LABEL_46;
    v17 = a6[3];
    if ( v16 == 1 )
    {
      v18 = 0LL;
    }
    else
    {
      v29 = 0LL;
      do
      {
        v18 = (v16 >> 1) + v29;
        if ( *(_QWORD *)(v17 + 536 * v18 + 424) > a3 )
          v18 = v29;
        v16 -= v16 >> 1;
        v29 = v18;
      }
      while ( v16 > 1 );
    }
    if ( *(_QWORD *)(v17 + 536 * v18 + 424) == a3 )
      goto LABEL_46;
    v30 = (*(_QWORD *)(v17 + 536 * v18 + 424) < a3) + v18;
    if ( !v30 )
      goto LABEL_46;
    a5 = 536 * v30 + v17 - 536;
  }
  if ( (*(_BYTE *)a5 & 1) == 0 )
  {
    v23 = a3 < *(_QWORD *)(a5 + 8);
    a3 -= *(_QWORD *)(a5 + 8);
    if ( !v23 )
    {
      v31 = *(_QWORD *)(a5 + 48);
      v32 = *(_QWORD *)(a5 + 56) - v31 + 8LL * (*(_BYTE *)(a5 + 73) == 8) + 4;
      if ( a3 >= v32 && a3 - v32 < v31 )
      {
LABEL_15:
        sub_428290(a1, a4, a5, a3, (__int64)a6, a7, a8);
        return;
      }
    }
  }
LABEL_46:
  *(_QWORD *)(a1 + 8) = 55LL;
  *(_QWORD *)a1 = 1LL;
}

//----- (0000000000428290) ----------------------------------------------------
char __fastcall sub_428290(
        __int64 a1,
        unsigned __int8 a2,
        __int64 a3,
        unsigned __int64 a4,
        __int64 a5,
        _QWORD *a6,
        __int64 a7)
{
  unsigned __int64 v9; // rax
  __int64 v10; // rcx
  unsigned int v11; // r14d
  _BOOL8 v12; // r11
  _QWORD *v13; // r8
  __int64 v14; // rbx
  unsigned __int64 v15; // r10
  __int64 v16; // r9
  unsigned __int64 v17; // r13
  int v18; // ecx
  char v19; // r11
  char v20; // cl
  __int64 v21; // rbx
  unsigned __int64 v22; // r12
  __int64 v23; // rbx
  __int64 v24; // rbx
  __int64 v25; // r8
  __int64 v26; // r15
  __int64 v27; // r10
  char v28; // r12
  __int64 v30; // r12
  __int64 v31; // r13
  __int128 v33; // [rsp+40h] [rbp-40h] BYREF
  unsigned __int64 v34[2]; // [rsp+58h] [rbp-28h] BYREF
  __int64 v35; // [rsp+68h] [rbp-18h]
  _QWORD *v36; // [rsp+70h] [rbp-10h]
  __int64 v37; // [rsp+78h] [rbp-8h]
  __int64 v38; // [rsp+80h] [rbp+0h] BYREF
  __int128 v39; // [rsp+88h] [rbp+8h]
  unsigned __int16 v40; // [rsp+98h] [rbp+18h]
  __int64 v41; // [rsp+A0h] [rbp+20h]
  __int64 v42; // [rsp+A8h] [rbp+28h]
  __int64 v43; // [rsp+B0h] [rbp+30h] BYREF
  __int128 v44; // [rsp+B8h] [rbp+38h]
  __int64 v45; // [rsp+C8h] [rbp+48h]
  __int64 v46; // [rsp+D0h] [rbp+50h]
  __int64 v47; // [rsp+D8h] [rbp+58h]
  unsigned __int8 v48; // [rsp+E7h] [rbp+67h]

  v9 = *(_QWORD *)(a3 + 48);
  v10 = *(_QWORD *)(a3 + 56);
  v11 = *(unsigned __int8 *)(a3 + 73);
  v12 = (_BYTE)v11 == 8;
  if ( a4 < v10 - v9 + 8 * v12 + 4 || a4 - (v10 - v9 + 8 * v12 + 4) >= v9 )
  {
    *(_QWORD *)(a1 + 8) = 56LL;
    *(_QWORD *)(a1 + 16) = a3;
  }
  else
  {
    v13 = *(_QWORD **)(a3 + 344);
    v14 = 8 * v12 + 4;
    v9 += *(_QWORD *)(a3 + 40);
    v35 = a3;
    v36 = v13 + 2;
    v37 = 0LL;
    v15 = v10 + v14 + ~a4;
    v16 = a4 - v14 - v10;
    v17 = 0LL;
    v18 = 0;
    while ( 1 )
    {
      v19 = *(_BYTE *)(v9 + v16);
      if ( v18 == 63 && (unsigned __int8)v19 > 1u )
      {
        v20 = 6;
        goto LABEL_10;
      }
      v17 |= (unsigned __int64)(v19 & 0x7F) << v18;
      if ( v19 >= 0 )
        break;
      v18 += 7;
      --v15;
      if ( !++v16 )
      {
        v20 = 19;
LABEL_10:
        *(_BYTE *)(a1 + 8) = v20;
        *(_BYTE *)(a1 + 9) = 0;
        *(_WORD *)(a1 + 14) = 0;
        *(_DWORD *)(a1 + 10) = 0;
        *(_QWORD *)(a1 + 16) = v9;
        goto LABEL_11;
      }
    }
    v34[0] = v9 + v16 + 1;
    v34[1] = v15;
    if ( v17 )
    {
      if ( v17 - 1 < v13[4] )
      {
        v21 = v13[3] + 112 * (v17 - 1);
        if ( *(_BYTE *)(v21 + 106) != 1 )
          goto LABEL_16;
        goto LABEL_15;
      }
      v24 = v13[5];
      v20 = 18;
      if ( v24 )
      {
        v25 = v13[6];
        while ( 1 )
        {
          v26 = 8 * (unsigned int)*(unsigned __int16 *)(v24 + 1330);
          v27 = -1LL;
          do
          {
            if ( !v26 )
            {
              v27 = *(unsigned __int16 *)(v24 + 1330);
              goto LABEL_30;
            }
            v28 = *(_QWORD *)(v24 + 8 * v27 + 1248) != v17;
            if ( *(_QWORD *)(v24 + 8 * v27 + 1248) > v17 )
              v28 = -1;
            ++v27;
            v26 -= 8LL;
          }
          while ( v28 == 1 );
          if ( !v28 )
          {
            LOBYTE(v9) = 112 * v27;
            v21 = 112 * v27 + v24;
            if ( *(_BYTE *)(v21 + 106) != 1 )
            {
LABEL_16:
              if ( (*(_BYTE *)v21 & 1) != 0 )
              {
                v22 = *(_QWORD *)(v21 + 24);
                v23 = *(_QWORD *)(v21 + 16);
                if ( !v22 )
                  goto LABEL_54;
              }
              else
              {
                v22 = *(_QWORD *)(v21 + 8);
                if ( v22 >= 6 )
                  sub_405B00(*(_QWORD *)(v21 + 8), 5LL, (__int64)&off_446D68);
                v23 = v21 + 16;
                if ( !v22 )
                  goto LABEL_54;
              }
              v48 = a2;
              v45 = *(_QWORD *)(a3 + 392);
              v30 = 16 * v22;
              v46 = 46LL;
              v31 = 0LL;
              v47 = 0LL;
              while ( 2 )
              {
                v33 = *(_OWORD *)(v23 + v31);
                LOBYTE(v9) = sub_41D2E0((__int64)&v38, v34, *(_DWORD *)(v35 + 72), (__int64)&v33);
                if ( (_DWORD)v38 == 46 )
                {
                  *(_OWORD *)(a1 + 8) = v39;
                  goto LABEL_11;
                }
                if ( v40 <= 0x46u )
                {
                  if ( v40 == 3 )
                  {
                    sub_421680((__int64)&v33, &v38);
                    sub_427DD0(&v43, a6, v11, v45, &v33);
                    if ( !(_BYTE)v43 )
                    {
                      v42 = *((_QWORD *)&v44 + 1);
                      v47 = v44;
                    }
                    goto LABEL_38;
                  }
                  if ( v40 != 49 )
                    goto LABEL_38;
                }
                else if ( v40 != 71 )
                {
                  if ( v40 == 110 || v40 == 8199 )
                  {
                    sub_421680((__int64)&v33, &v38);
                    LOBYTE(v9) = sub_427DD0(&v43, a6, v11, v45, &v33);
                    if ( (v43 & 1) == 0 )
                    {
                      *(_OWORD *)(a1 + 8) = v44;
                      *(_QWORD *)a1 = 0LL;
                      return v9;
                    }
                  }
LABEL_38:
                  v31 += 16LL;
                  if ( v30 == v31 )
                  {
                    if ( v47 )
                    {
                      *(_QWORD *)(a1 + 8) = v47;
                      LOBYTE(v9) = v42;
                      *(_QWORD *)(a1 + 16) = v42;
                      *(_QWORD *)a1 = 0LL;
                      return v9;
                    }
                    LOBYTE(v9) = a5;
                    if ( v46 != 46 )
                    {
                      LOBYTE(v9) = sub_427FC0(a1, v46, v41, v48, a3, a5, (__int64)a6, a7 - 1);
                      return v9;
                    }
LABEL_54:
                    *(_OWORD *)a1 = 0LL;
                    return v9;
                  }
                  continue;
                }
                break;
              }
              sub_421680((__int64)&v33, &v38);
              v41 = *((_QWORD *)&v33 + 1);
              v46 = v33;
              goto LABEL_38;
            }
LABEL_15:
            v37 = 1LL;
            goto LABEL_16;
          }
LABEL_30:
          if ( v25-- == 0 )
            break;
          v24 = *(_QWORD *)(v24 + 8 * v27 + 1336);
        }
      }
      goto LABEL_10;
    }
    *(_BYTE *)(a1 + 8) = 55;
  }
LABEL_11:
  *(_QWORD *)a1 = 1LL;
  return v9;
}
// 427FC0: using guessed type __int64 __fastcall sub_427FC0(_DWORD, _DWORD, _DWORD, _DWORD, __int64, __int64, __int64, __int64);
// 446D68: using guessed type char *off_446D68;

//----- (0000000000428690) ----------------------------------------------------
void __fastcall sub_428690(__int128 *a1, unsigned __int64 a2, _OWORD *a3, size_t a4, char a5)
{
  _OWORD *v5; // r12
  unsigned __int64 v6; // rax
  __int64 v7; // rax
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // r15
  unsigned __int64 v10; // r13
  unsigned __int64 v11; // r11
  unsigned __int64 v12; // rdx
  __int64 v13; // rax
  __int128 *v14; // rcx
  unsigned __int64 v15; // rbx
  unsigned __int64 v16; // rdi
  unsigned __int64 v17; // rsi
  unsigned __int64 v18; // rcx
  unsigned __int64 v19; // rcx
  unsigned __int64 v20; // rcx
  unsigned __int64 v21; // r8
  unsigned __int64 v22; // rsi
  unsigned __int64 v23; // rdx
  char v24; // si
  unsigned __int64 v25; // rdi
  __int128 *v26; // r10
  unsigned __int64 v27; // r9
  unsigned __int64 v28; // r11
  __int128 *v29; // r10
  unsigned __int64 v30; // r11
  bool v31; // cc
  unsigned __int64 v32; // r11
  __int64 v33; // rcx
  unsigned __int64 v34; // rcx
  __int128 *v35; // r8
  __int128 *v36; // r10
  __int128 v37; // xmm0
  __int128 v38; // xmm0
  unsigned __int64 v39; // rax
  unsigned __int64 v40; // rcx
  __int128 *v41; // r13
  __int128 *v42; // rdx
  unsigned __int64 v43; // rbx
  unsigned __int64 v44; // rdi
  unsigned __int64 v45; // r14
  size_t v46; // rsi
  unsigned __int64 v47; // rax
  unsigned __int64 v48; // rax
  size_t v49; // r12
  __int128 *v50; // rbx
  __int128 *v51; // rdx
  char *v52; // r15
  __int128 *v53; // rax
  __int128 *v54; // r10
  unsigned __int64 v55; // r8
  char *v56; // r15
  unsigned __int64 v57; // r9
  __int128 *v58; // rbx
  bool v59; // cl
  char *v60; // rdx
  __int128 v61; // xmm0
  __int128 *v62; // r9
  unsigned __int64 v63; // rax
  unsigned __int64 v64; // rcx
  bool v65; // cf
  bool v66; // zf
  bool v67; // al
  bool v68; // cl
  __int128 *v69; // r8
  __int128 v70; // xmm0
  unsigned __int64 v71; // rax
  _QWORD v72[75]; // [rsp+30h] [rbp-50h]
  unsigned __int64 v73; // [rsp+288h] [rbp+208h]
  __int128 *v74; // [rsp+290h] [rbp+210h]
  __int128 *v75; // [rsp+298h] [rbp+218h]
  __int128 *v76; // [rsp+2A0h] [rbp+220h]
  __int128 *v77; // [rsp+2A8h] [rbp+228h]
  __int128 *v78; // [rsp+2B0h] [rbp+230h]
  unsigned __int64 v79; // [rsp+2B8h] [rbp+238h]
  unsigned __int64 v80; // [rsp+2C0h] [rbp+240h]
  __int128 *v81; // [rsp+2C8h] [rbp+248h]
  unsigned __int64 v82; // [rsp+2D0h] [rbp+250h]
  unsigned __int64 v83; // [rsp+2D8h] [rbp+258h]
  unsigned __int64 v84; // [rsp+2E0h] [rbp+260h]
  unsigned __int64 v85; // [rsp+2E8h] [rbp+268h]
  __int128 *v86; // [rsp+2F0h] [rbp+270h]
  void *Src; // [rsp+2F8h] [rbp+278h]
  size_t v88; // [rsp+300h] [rbp+280h]

  v5 = a3;
  v86 = a1;
  if ( (a2 | (a2 + 0x3FFFFFFFFFFFFFFFLL)) >> 32 )
    v6 = (a2 + 0x3FFFFFFFFFFFFFFFLL) / a2;
  else
    v6 = ((int)a2 - 1) / (unsigned int)a2;
  v80 = v6;
  v84 = a2;
  if ( a2 >= 0x1001 )
  {
    _BitScanReverse64(&v8, a2 | 1);
    v85 = ((1LL << ((((unsigned int)v8 ^ 0xFFFFFFC0) + 65) >> 1)) + (a2 >> ((((unsigned int)v8 ^ 0xFFFFFFC0) + 65) >> 1))) >> 1;
  }
  else
  {
    v7 = 64LL;
    if ( a2 - (a2 >> 1) < 0x40 )
      v7 = a2 - (a2 >> 1);
    v85 = v7;
  }
  v81 = v86 + 5;
  v77 = v86 + 1;
  v78 = v86 - 1;
  v76 = v86 - 2;
  v9 = 1LL;
  v10 = 0LL;
  v11 = 0LL;
  v88 = a4;
  Src = a3;
  v12 = v84;
  if ( !v84 )
    goto LABEL_15;
LABEL_10:
  v13 = 2 * v10;
  v14 = &v86[2 * v10];
  v15 = v12;
  if ( v12 < v85 )
    goto LABEL_11;
  if ( v12 < 2 )
  {
    v18 = 2 * v12 + 1;
    goto LABEL_50;
  }
  v21 = *((_QWORD *)v14 + 6);
  if ( v21 >= *((_QWORD *)v14 + 2)
    && ((v22 = *((_QWORD *)v14 + 4), v21 > *((_QWORD *)v14 + 2)) || v22 >= *(_QWORD *)v14) )
  {
    if ( v12 == 2 )
    {
      v23 = 2LL;
      v24 = 0;
      goto LABEL_43;
    }
    v25 = v11;
    v29 = &v81[v13];
    v23 = 2LL;
    v27 = v15;
    do
    {
      v30 = v21;
      v21 = *(_QWORD *)v29;
      v31 = *(_QWORD *)v29 <= v30;
      if ( *(_QWORD *)v29 < v30 || (v32 = *((_QWORD *)v29 - 2), v31) && v32 < v22 )
      {
        v24 = 0;
        goto LABEL_42;
      }
      ++v23;
      v29 += 2;
      v22 = v32;
    }
    while ( v15 != v23 );
    v24 = 0;
LABEL_41:
    v23 = v27;
  }
  else
  {
    v23 = 2LL;
    v24 = 1;
    if ( v15 == 2 )
      goto LABEL_43;
    v25 = v11;
    v26 = &v81[v13];
    v23 = 2LL;
    v27 = v15;
    while ( 1 )
    {
      v28 = v21;
      v21 = *(_QWORD *)v26;
      if ( *(_QWORD *)v26 >= v28 && (*(_QWORD *)v26 > v28 || *((_QWORD *)v26 - 2) >= *((_QWORD *)v26 - 6)) )
        break;
      ++v23;
      v26 += 2;
      if ( v15 == v23 )
        goto LABEL_41;
    }
  }
LABEL_42:
  a4 = v88;
  v11 = v25;
LABEL_43:
  if ( v23 >= v85 )
  {
    if ( v24 )
    {
      v33 = 1LL;
      if ( v23 < 2 )
      {
LABEL_49:
        v18 = 2 * v33 + 1;
        goto LABEL_50;
      }
      v34 = v23 >> 1;
      v35 = &v77[v13];
      v36 = &v78[2 * v23 + v13];
      do
      {
        v37 = *(v35 - 1);
        *(v35 - 1) = *(v36 - 1);
        *(v36 - 1) = v37;
        v38 = *v35;
        *v35 = *v36;
        *v36 = v38;
        v35 += 2;
        v36 -= 2;
        --v34;
      }
      while ( v34 );
    }
    v33 = v23;
    goto LABEL_49;
  }
LABEL_11:
  if ( a5 )
  {
    v16 = v15;
    if ( v15 >= 0x20 )
      v16 = 32LL;
    v17 = v11;
    sub_428E00(v14, v16, v5, a4, 0, 0LL);
    v11 = v17;
    a4 = v88;
    v18 = 2LL * (unsigned int)v16 + 1;
  }
  else
  {
    v20 = v15;
    if ( v85 < v15 )
      v20 = v85;
    v18 = 2 * v20;
  }
LABEL_50:
  v79 = v18;
  v39 = (v80 * (2 * v10 - (v9 >> 1))) ^ (v80 * ((v18 >> 1) + 2 * v10));
  if ( !v39 )
  {
    v19 = 64LL;
    if ( v11 < 2 )
      goto LABEL_95;
    goto LABEL_54;
  }
  _BitScanReverse64(&v40, v39);
  v19 = v40 ^ 0x3F;
  if ( v11 >= 2 )
  {
LABEL_54:
    v75 = &v86[2 * v10];
    v74 = &v76[2 * v10];
    v83 = v19;
    v73 = v10;
    while ( 1 )
    {
      while ( 1 )
      {
        if ( *((_BYTE *)&v72[66] + v11 + 5) < (unsigned __int8)v19 )
          goto LABEL_95;
        v43 = v72[--v11];
        v44 = v43 >> 1;
        v45 = v9 >> 1;
        v46 = (v43 >> 1) + (v9 >> 1);
        if ( v46 > a4 || (((unsigned __int8)v9 | (unsigned __int8)v43) & 1) != 0 )
          break;
        v9 = 2 * v46;
        if ( v11 <= 1 )
        {
LABEL_94:
          v11 = 1LL;
          goto LABEL_95;
        }
      }
      v41 = &v86[2 * (v10 - v46)];
      v82 = v11;
      if ( (v43 & 1) != 0 )
      {
        if ( (v9 & 1) != 0 )
          goto LABEL_65;
      }
      else
      {
        _BitScanReverse64(&v47, v44 | 1);
        sub_428E00(v41, v44, v5, a4, (2 * (v47 ^ 0x3F)) ^ 0x7E, 0LL);
        LOBYTE(v19) = v83;
        v11 = v82;
        a4 = v88;
        if ( (v9 & 1) != 0 )
        {
LABEL_65:
          if ( v9 >= 2 )
            goto LABEL_69;
          goto LABEL_57;
        }
      }
      _BitScanReverse64(&v48, v45 | 1);
      sub_428E00(&v41[2 * v44], v9 >> 1, v5, a4, (2 * (v48 ^ 0x3F)) ^ 0x7E, 0LL);
      LOBYTE(v19) = v83;
      v11 = v82;
      a4 = v88;
      if ( v9 >= 2 )
      {
LABEL_69:
        if ( v43 >= 2 )
        {
          v49 = v9 >> 1;
          if ( v44 < v45 )
            v49 = v43 >> 1;
          if ( v49 <= a4 )
          {
            v50 = &v41[2 * v44];
            v51 = v41;
            if ( v45 < v44 )
              v51 = &v41[2 * v44];
            memcpy(Src, v51, 32 * v49);
            v52 = (char *)Src + 32 * v49;
            if ( v45 >= v44 )
            {
              if ( v49 )
              {
                v42 = (__int128 *)Src;
                v62 = v75;
                do
                {
                  v63 = *((_QWORD *)v50 + 2);
                  v64 = *((_QWORD *)v42 + 2);
                  v65 = v63 < v64;
                  v66 = v63 == v64;
                  if ( v63 >= v64 )
                  {
                    v69 = v50;
                    v67 = v63 <= v64 && *(_QWORD *)v50 < *(_QWORD *)v42;
                    if ( !v67 )
                      v69 = v42;
                    v68 = !v65 && !v66 || *(_QWORD *)v50 >= *(_QWORD *)v42;
                  }
                  else
                  {
                    v67 = 1;
                    v68 = 0;
                    v69 = v50;
                  }
                  v70 = *v69;
                  v41[1] = v69[1];
                  *v41 = v70;
                  v42 += 2 * (unsigned int)v68;
                  v41 += 2;
                  if ( v42 == (__int128 *)v52 )
                    break;
                  v50 += 2 * (unsigned int)v67;
                }
                while ( v50 != v62 );
              }
              else
              {
                v42 = (__int128 *)Src;
              }
            }
            else
            {
              v53 = v74;
              v54 = (__int128 *)Src;
              do
              {
                v55 = *((_QWORD *)v52 - 2);
                v56 = v52 - 32;
                v57 = *((_QWORD *)v50 - 2);
                v58 = v50 - 2;
                v59 = 1;
                v60 = (char *)v58;
                if ( v55 >= v57 )
                {
                  v60 = (char *)v58;
                  v59 = v55 <= v57 && *(_QWORD *)v56 < *(_QWORD *)v58;
                  if ( !v59 )
                    v60 = v56;
                }
                v61 = *(_OWORD *)v60;
                v53[1] = *((_OWORD *)v60 + 1);
                *v53 = v61;
                v50 = &v58[2 * !v59];
                v52 = &v56[32 * v59];
                if ( v50 == v41 )
                  break;
                v53 -= 2;
              }
              while ( v52 != (char *)v54 );
              v41 = v50;
              v42 = v54;
            }
            memcpy(v41, v42, v52 - (char *)v42);
            a4 = v88;
            v11 = v82;
            LOBYTE(v19) = v83;
          }
        }
      }
LABEL_57:
      v9 = 2 * v46 + 1;
      v5 = Src;
      v10 = v73;
      if ( v11 <= 1 )
        goto LABEL_94;
    }
  }
LABEL_95:
  while ( 1 )
  {
    v72[v11] = v9;
    *((_BYTE *)&v72[66] + v11 + 6) = v19;
    if ( v84 <= v10 )
      break;
    ++v11;
    v9 = v79;
    v10 += v79 >> 1;
    v12 = v84 - v10;
    if ( v84 > v10 )
      goto LABEL_10;
LABEL_15:
    v19 = 0LL;
    v79 = 1LL;
    if ( v11 >= 2 )
      goto LABEL_54;
  }
  if ( (v9 & 1) == 0 )
  {
    _BitScanReverse64(&v71, v84 | 1);
    sub_428E00(v86, v84, v5, a4, (2 * (v71 ^ 0x3F)) ^ 0x7E, 0LL);
  }
}

//----- (0000000000428E00) ----------------------------------------------------
void __fastcall sub_428E00(__int128 *a1, unsigned __int64 a2, _OWORD *a3, size_t a4, int a5, __int128 *a6)
{
  unsigned __int64 v7; // rbx
  size_t v9; // r14
  bool v10; // cf
  int v11; // r12d
  _BYTE *v12; // r15
  unsigned __int64 *v13; // rdx
  unsigned __int64 *v14; // r8
  unsigned __int64 v15; // rdi
  unsigned __int64 v16; // rbx
  unsigned __int64 v17; // rax
  unsigned __int64 v18; // r9
  unsigned __int64 v19; // r10
  unsigned __int64 v20; // r11
  char v21; // cl
  char *v22; // r12
  bool v23; // zf
  char v24; // bl
  __int128 v25; // xmm0
  unsigned __int64 v26; // rax
  _OWORD *v27; // rdi
  char *v28; // r13
  char *v29; // rax
  _OWORD *v30; // rcx
  size_t i; // rdx
  bool v32; // r9
  _OWORD *v33; // r10
  __int64 v34; // r11
  __int128 v35; // xmm0
  unsigned __int64 v36; // r9
  unsigned __int64 v37; // r10
  __int64 v38; // rdx
  __int128 v39; // xmm0
  void *v40; // rcx
  __int64 v41; // r13
  size_t v42; // rdx
  __int64 v43; // rax
  _OWORD *v44; // r8
  __int128 *v45; // r15
  __int64 v46; // r9
  __int128 v47; // xmm0
  __int64 v48; // r9
  __int128 v49; // xmm1
  char *v50; // rcx
  __int64 v51; // r8
  __int64 v52; // rax
  __int128 v53; // xmm0
  _OWORD *v54; // rdi
  unsigned __int64 v55; // r13
  char *v56; // rax
  _OWORD *v57; // rcx
  size_t j; // r11
  char *v59; // rdx
  bool v60; // r8
  _OWORD *v61; // r9
  __int64 v62; // r10
  __int128 v63; // xmm0
  unsigned __int64 v64; // r8
  unsigned __int64 v65; // r9
  __int64 v66; // rdx
  __int128 v67; // xmm0
  __int64 v68; // r12
  __int64 v69; // rax
  _OWORD *v70; // rdx
  __int128 *v71; // r15
  __int64 v72; // r8
  __int128 v73; // xmm0
  __int64 v74; // r8
  __int128 v75; // xmm1
  char *v76; // rcx
  __int64 v77; // rdx
  __int64 v78; // rax
  __int128 v79; // xmm0
  size_t v80; // r12
  __int64 v81; // r14
  __int128 *v82; // r15
  char *v83; // r14
  size_t v84; // rax
  __int128 v85; // xmm0
  __int128 v86; // xmm0
  __int64 v87; // rdx
  size_t v88; // r8
  char *v89; // r13
  __int64 v90; // r13
  __int128 v91; // xmm0
  _OWORD *v92; // rcx
  unsigned __int64 v93; // r9
  unsigned __int64 v94; // r10
  _OWORD *v95; // r13
  __int64 v96; // rdi
  __int64 v97; // r11
  __int128 v98; // xmm1
  __int64 v99; // rcx
  __int128 v100; // xmm0
  __int64 v101; // r15
  size_t v102; // rcx
  __int64 v103; // rdx
  char *v104; // rdi
  __int64 v105; // rdi
  __int128 v106; // xmm0
  char *v107; // r13
  unsigned __int64 v108; // r8
  unsigned __int64 v109; // r9
  char *v110; // rdi
  __int64 v111; // r11
  __int64 v112; // r10
  __int128 v113; // xmm1
  __int64 v114; // rcx
  __int128 v115; // xmm0
  __int64 v116; // r13
  char *v117; // rcx
  __int128 *v118; // rax
  _OWORD *v119; // r8
  _OWORD *v120; // r9
  char *v121; // rdx
  __int128 v122; // xmm0
  __int64 v123; // r10
  unsigned __int64 v124; // r13
  unsigned __int64 v125; // r15
  bool v126; // r10
  bool v127; // r11
  char *v128; // rdi
  __int128 v129; // xmm0
  unsigned __int64 v130; // r15
  unsigned __int64 v131; // r13
  __int128 *v132; // rdi
  char *v133; // rcx
  BOOL v134; // r9d
  char *v135; // r11
  __int128 v136; // xmm0
  _OWORD v137[2]; // [rsp+30h] [rbp-50h] BYREF
  _QWORD v138[3]; // [rsp+50h] [rbp-30h] BYREF
  __int128 v139; // [rsp+68h] [rbp-18h]
  _OWORD *v140; // [rsp+80h] [rbp+0h]
  unsigned __int64 v141; // [rsp+88h] [rbp+8h]
  _OWORD *v142; // [rsp+90h] [rbp+10h]
  int v143; // [rsp+9Ch] [rbp+1Ch]
  __int128 *v144; // [rsp+A0h] [rbp+20h]
  size_t Size; // [rsp+A8h] [rbp+28h]
  void *v146; // [rsp+B0h] [rbp+30h]

  Size = a4;
  v7 = a2;
  if ( a2 >= 0x21 )
  {
    v144 = a6;
    v142 = a3 - 2;
    do
    {
      v146 = a1;
      v140 = a1 + 2;
      v9 = v7;
      while ( 1 )
      {
        v10 = a5 == 0;
        v11 = a5 - 1;
        if ( v10 )
        {
          sub_428690((_DWORD)v146, v9, (_DWORD)a3, Size, 1);
          return;
        }
        v12 = v146;
        v13 = (unsigned __int64 *)((char *)v146 + 128 * (v9 >> 3));
        v14 = (unsigned __int64 *)((char *)v146 + 224 * (v9 >> 3));
        v143 = v11;
        if ( v9 >= 0x40 )
        {
          v22 = (char *)sub_429900((unsigned __int64 *)v146, v13, v14, v9 >> 3);
        }
        else
        {
          v15 = *(_QWORD *)v146;
          v16 = *((_QWORD *)v146 + 2);
          v17 = *v13;
          v18 = v13[2];
          if ( v16 >= v18 )
          {
            v21 = v16 <= v18 && v15 < v17;
            v19 = *v14;
            v20 = v14[2];
            if ( v16 >= v20 )
            {
              v22 = (char *)v146;
              if ( v21 == (v16 <= v20 && v15 < v19) )
                goto LABEL_16;
            }
            else
            {
              v22 = (char *)v146;
              v23 = v21 == 0;
              v21 = 1;
              if ( !v23 )
                goto LABEL_16;
            }
          }
          else
          {
            v19 = *v14;
            v20 = v14[2];
            v21 = 1;
            if ( v16 < v20 || (v22 = (char *)v146, v16 <= v20) && (v22 = (char *)v146, v15 < v19) )
            {
LABEL_16:
              v24 = 1;
              if ( v18 >= v20 )
                v24 = v18 <= v20 && v17 < v19;
              if ( v24 != v21 )
                v13 = (unsigned __int64 *)((char *)v146 + 224 * (v9 >> 3));
              v22 = (char *)v13;
            }
          }
        }
        v141 = (unsigned __int64)(v22 - v12) >> 5;
        v25 = *(_OWORD *)v22;
        v137[1] = *((_OWORD *)v22 + 1);
        v137[0] = v25;
        if ( v144 )
        {
          v26 = *((_QWORD *)v22 + 2);
          if ( *((_QWORD *)v144 + 2) >= v26 && (*((_QWORD *)v144 + 2) > v26 || *(_QWORD *)v144 >= *(_QWORD *)v22) )
            break;
        }
        if ( v9 > Size )
          goto LABEL_122;
        v27 = &a3[2 * v9];
        v7 = 0LL;
        v28 = (char *)v146;
        v29 = (char *)v146;
        v30 = v27;
        for ( i = v141; ; i = v9 )
        {
          while ( v29 < &v28[32 * i] )
          {
            v36 = *((_QWORD *)v29 + 2);
            v37 = *((_QWORD *)v22 + 2);
            if ( v36 >= v37 )
            {
              v32 = v36 <= v37 && *(_QWORD *)v29 < *(_QWORD *)v22;
              v30 -= 2;
              v33 = v30;
              if ( v32 )
                v33 = a3;
            }
            else
            {
              v30 -= 2;
              v32 = 1;
              v33 = a3;
            }
            v34 = 2 * v7;
            v35 = *(_OWORD *)v29;
            v33[v34 + 1] = *((_OWORD *)v29 + 1);
            v33[v34] = v35;
            v7 += v32;
            v29 += 32;
          }
          if ( i == v9 )
            break;
          v38 = 2 * v7;
          v39 = *(_OWORD *)v29;
          v30[v38 - 1] = *((_OWORD *)v29 + 1);
          v30[v38 - 2] = v39;
          v30 -= 2;
          v29 += 32;
        }
        v40 = v28;
        v41 = 32 * v7;
        memcpy(v40, a3, 32 * v7);
        v42 = v9 - v7;
        if ( v9 != v7 )
        {
          if ( v9 == v7 + 1 )
          {
            v43 = 0LL;
          }
          else
          {
            v44 = &v140[(unsigned __int64)v41 / 0x10];
            v45 = &v142[2 * v9];
            v46 = 0LL;
            do
            {
              v47 = *v45;
              *(v44 - 1) = v45[1];
              *(v44 - 2) = v47;
              v43 = v46 + 2;
              v48 = 2 * (v46 ^ 0x7FFFFFFFFFFFFFELL);
              v49 = v27[v48 + 1];
              *v44 = v27[v48];
              v44[1] = v49;
              v44 += 4;
              v45 -= 4;
              v46 = v43;
            }
            while ( (v42 & 0xFFFFFFFFFFFFFFFEuLL) != v43 );
          }
          if ( (v42 & 1) != 0 )
          {
            v50 = (char *)v146 + v41;
            v51 = 2 * ~v43;
            v52 = 32 * v43;
            v53 = v27[v51];
            *(_OWORD *)&v50[v52 + 16] = v27[v51 + 1];
            *(_OWORD *)&v50[v52] = v53;
          }
        }
        if ( !v7 )
          break;
        if ( v9 < v7 )
        {
          v138[0] = &off_4479E0;
          v138[1] = 1LL;
          v138[2] = 8LL;
          v139 = 0LL;
          sub_405240(v138, &off_447A50);
        }
        a5 = v143;
        sub_428E00((_DWORD)v146 + v41, v42, (_DWORD)a3, Size, v143, (__int64)v137);
        v9 = v7;
        if ( v7 < 0x21 )
        {
          a1 = (__int128 *)v146;
          goto LABEL_69;
        }
      }
      if ( v9 > Size )
LABEL_122:
        BUG();
      v54 = &a3[2 * v9];
      v55 = 0LL;
      v56 = (char *)v146;
      v57 = v54;
      for ( j = v141; ; j = v9 )
      {
        v59 = (char *)v146 + 32 * j;
        while ( v56 < v59 )
        {
          v64 = *((_QWORD *)v56 + 2);
          v65 = *((_QWORD *)v22 + 2);
          if ( v65 >= v64 )
          {
            v60 = v65 > v64 || *(_QWORD *)v22 >= *(_QWORD *)v56;
            v57 -= 2;
            v61 = v57;
            if ( v60 )
              v61 = a3;
          }
          else
          {
            v57 -= 2;
            v60 = 0;
            v61 = v57;
          }
          v62 = 2 * v55;
          v63 = *(_OWORD *)v56;
          v61[v62 + 1] = *((_OWORD *)v56 + 1);
          v61[v62] = v63;
          v55 += v60;
          v56 += 32;
        }
        if ( j == v9 )
          break;
        v57 -= 2;
        v66 = 2 * v55;
        v67 = *(_OWORD *)v56;
        a3[v66 + 1] = *((_OWORD *)v56 + 1);
        a3[v66] = v67;
        ++v55;
        v56 += 32;
      }
      v68 = 32 * v55;
      memcpy(v146, a3, 32 * v55);
      v7 = v9 - v55;
      if ( v9 != v55 )
      {
        if ( v9 == v55 + 1 )
        {
          v69 = 0LL;
        }
        else
        {
          v70 = (char *)v146 + v68 + 32;
          v71 = &v142[2 * v9];
          v72 = 0LL;
          do
          {
            v73 = *v71;
            *(v70 - 1) = v71[1];
            *(v70 - 2) = v73;
            v69 = v72 + 2;
            v74 = 2 * (v72 ^ 0x7FFFFFFFFFFFFFELL);
            v75 = v54[v74 + 1];
            *v70 = v54[v74];
            v70[1] = v75;
            v70 += 4;
            v71 -= 4;
            v72 = v69;
          }
          while ( (v7 & 0xFFFFFFFFFFFFFFFEuLL) != v69 );
        }
        if ( (v7 & 1) != 0 )
        {
          v76 = (char *)v146 + v68;
          v77 = 2 * ~v69;
          v78 = 32 * v69;
          v79 = v54[v77];
          *(_OWORD *)&v76[v78 + 16] = v54[v77 + 1];
          *(_OWORD *)&v76[v78] = v79;
        }
      }
      if ( v9 < v55 )
        sub_4050A0(v55, v9, (__int64)&off_447A68);
      a1 = (__int128 *)((char *)v146 + v68);
      v144 = 0LL;
      a5 = v143;
    }
    while ( v7 >= 0x21 );
  }
LABEL_69:
  if ( v7 >= 2 )
  {
    v80 = v7 >> 1;
    v81 = 2 * (v7 >> 1);
    v82 = &a1[v81];
    v83 = (char *)&a3[v81];
    v146 = a1;
    if ( v7 < 8 )
    {
      v85 = *a1;
      a3[1] = a1[1];
      *a3 = v85;
      v86 = *v82;
      *((_OWORD *)v83 + 1) = v82[1];
      *(_OWORD *)v83 = v86;
      v84 = 1LL;
    }
    else
    {
      sub_429780(a1, a3);
      sub_429780(v82, v83);
      v84 = 4LL;
    }
    Size = v7 - v80;
    if ( v84 < v80 )
    {
      v87 = (unsigned int)(32 * v84) - 32LL;
      v88 = v84;
      v144 = v82;
      do
      {
        v90 = 2 * v88;
        v91 = *((_OWORD *)v146 + 2 * v88);
        a3[v90 + 1] = *((_OWORD *)v146 + 2 * v88 + 1);
        a3[v90] = v91;
        v92 = &a3[2 * v88 - 2];
        v93 = *(_QWORD *)&a3[2 * v88 + 1];
        v94 = *(_QWORD *)&a3[2 * v88];
        if ( v93 < *(_QWORD *)&a3[2 * v88 - 1] || v93 <= *(_QWORD *)&a3[2 * v88 - 1] && v94 < *(_QWORD *)v92 )
        {
          v95 = &a3[v90];
          v96 = *((_QWORD *)v95 + 1);
          v97 = *((_QWORD *)v95 + 3);
          v98 = v92[1];
          *v95 = *v92;
          v95[1] = v98;
          v89 = (char *)a3;
          if ( v92 != a3 )
          {
            v99 = v87;
            while ( 1 )
            {
              v89 = (char *)a3 + v99;
              v101 = (__int64)a3 + v99 - 32;
              if ( v93 >= *(_QWORD *)((char *)a3 + v99 - 16)
                && (v93 > *(_QWORD *)((char *)a3 + v99 - 16) || v94 >= *(_QWORD *)v101) )
              {
                break;
              }
              v100 = *(_OWORD *)v101;
              *((_OWORD *)v89 + 1) = *(_OWORD *)(v101 + 16);
              *(_OWORD *)v89 = v100;
              v99 -= 32LL;
              if ( !v99 )
              {
                v89 = (char *)a3;
                break;
              }
            }
            v82 = v144;
          }
          *(_QWORD *)v89 = v94;
          *((_QWORD *)v89 + 1) = v96;
          *((_QWORD *)v89 + 2) = v93;
          *((_QWORD *)v89 + 3) = v97;
        }
        ++v88;
        v87 += 32LL;
      }
      while ( v88 != v80 );
    }
    v102 = Size;
    if ( v84 < Size )
    {
      v103 = (unsigned int)(32 * v84) - 32LL;
      do
      {
        v105 = 32 * v84;
        v106 = v82[2 * v84];
        *(_OWORD *)&v83[v105 + 16] = v82[2 * v84 + 1];
        *(_OWORD *)&v83[v105] = v106;
        v107 = &v83[32 * v84 - 32];
        v108 = *(_QWORD *)&v83[32 * v84 + 16];
        v109 = *(_QWORD *)&v83[32 * v84];
        if ( v108 < *(_QWORD *)&v83[32 * v84 - 16] || v108 <= *(_QWORD *)&v83[32 * v84 - 16] && v109 < *(_QWORD *)v107 )
        {
          v110 = &v83[v105];
          v111 = *((_QWORD *)v110 + 1);
          v112 = *((_QWORD *)v110 + 3);
          v113 = *((_OWORD *)v107 + 1);
          *(_OWORD *)v110 = *(_OWORD *)v107;
          *((_OWORD *)v110 + 1) = v113;
          v104 = v83;
          if ( v107 != v83 )
          {
            v114 = v103;
            while ( 1 )
            {
              v104 = &v83[v114];
              v116 = (__int64)&v83[v114 - 32];
              if ( v108 >= *(_QWORD *)&v83[v114 - 16] && (v108 > *(_QWORD *)&v83[v114 - 16] || v109 >= *(_QWORD *)v116) )
                break;
              v115 = *(_OWORD *)v116;
              *((_OWORD *)v104 + 1) = *(_OWORD *)(v116 + 16);
              *(_OWORD *)v104 = v115;
              v114 -= 32LL;
              if ( !v114 )
              {
                v104 = v83;
                break;
              }
            }
            v102 = Size;
          }
          *(_QWORD *)v104 = v109;
          *((_QWORD *)v104 + 1) = v111;
          *((_QWORD *)v104 + 2) = v108;
          *((_QWORD *)v104 + 3) = v112;
        }
        ++v84;
        v103 += 32LL;
      }
      while ( v84 != v102 );
    }
    v117 = v83 - 32;
    v118 = &a3[2 * v7 - 2];
    v119 = v146;
    Size = 32 * v7;
    v120 = (char *)v146 + 32 * v7 - 32;
    v121 = (char *)a3;
    do
    {
      v124 = *((_QWORD *)v83 + 2);
      v125 = *((_QWORD *)v121 + 2);
      v126 = 1;
      v127 = 1;
      v128 = v83;
      if ( v124 >= v125 )
      {
        v128 = v83;
        v127 = v124 <= v125 && *(_QWORD *)v83 < *(_QWORD *)v121;
        if ( !v127 )
          v128 = v121;
      }
      v129 = *(_OWORD *)v128;
      v119[1] = *((_OWORD *)v128 + 1);
      *v119 = v129;
      v130 = *((_QWORD *)v118 + 2);
      v131 = *((_QWORD *)v117 + 2);
      v132 = (__int128 *)v117;
      if ( v130 >= v131 )
      {
        v132 = (__int128 *)v117;
        v126 = v130 <= v131 && *(_QWORD *)v118 < *(_QWORD *)v117;
        if ( !v126 )
          v132 = v118;
      }
      v83 += 32 * (unsigned int)v127;
      v121 += 32 * !v127;
      v119 += 2;
      v122 = *v132;
      v120[1] = v132[1];
      *v120 = v122;
      v123 = 2 * (unsigned int)v126;
      v118 = &v118[v123 - 2];
      v117 -= v123 * 16;
      v120 -= 2;
      --v80;
    }
    while ( v80 );
    v133 = v117 + 32;
    if ( (v7 & 1) != 0 )
    {
      v134 = v121 >= v133;
      v135 = v83;
      if ( v121 < v133 )
        v135 = v121;
      v136 = *(_OWORD *)v135;
      v119[1] = *((_OWORD *)v135 + 1);
      *v119 = v136;
      v121 += 32 * (unsigned int)(v121 < v133);
      v83 += (unsigned int)(32 * v134);
    }
    if ( v121 != v133 || v83 != (char *)(v118 + 2) )
      sub_408340();
  }
}
// 405240: using guessed type void __fastcall __noreturn sub_405240(_QWORD, _QWORD);
// 428690: using guessed type __int64 __fastcall sub_428690(_DWORD, _DWORD, _DWORD, _DWORD, char);
// 4479E0: using guessed type char *off_4479E0;
// 447A50: using guessed type char *off_447A50;
// 447A68: using guessed type char *off_447A68;

//----- (0000000000429780) ----------------------------------------------------
__int128 *__fastcall sub_429780(_QWORD *a1, _OWORD *a2)
{
  unsigned __int64 v2; // rax
  unsigned __int64 v3; // r9
  bool v4; // r8
  unsigned __int64 v5; // rax
  unsigned __int64 v6; // r9
  __int128 *v7; // r10
  int v8; // eax
  bool v9; // r9
  BOOL v10; // r11d
  __int128 *v11; // r8
  __int128 *v12; // r9
  __int128 *result; // rax
  unsigned __int64 v14; // rsi
  unsigned __int64 v15; // rcx
  bool v16; // bl
  unsigned __int64 v17; // r11
  unsigned __int64 v18; // rsi
  __int128 *v19; // rcx
  unsigned __int64 v20; // r10
  bool v21; // cf
  bool v22; // zf
  unsigned __int64 v23; // r10
  unsigned __int64 v24; // r11
  unsigned __int64 v25; // r10
  __int128 *v26; // r10
  __int128 v27; // xmm0
  __int128 v28; // xmm0
  __int128 v29; // xmm1
  __int128 v30; // xmm1

  v2 = a1[2];
  v3 = a1[6];
  v4 = 1;
  if ( v3 >= v2 )
    v4 = v3 <= v2 && a1[4] < *a1;
  v5 = a1[10];
  v6 = a1[14];
  if ( v6 >= v5 )
  {
    v7 = (__int128 *)(a1 + 8);
    v9 = v6 <= v5 && a1[12] < a1[8];
    if ( v9 )
      v7 = (__int128 *)(a1 + 12);
    v8 = v9 ^ 3;
  }
  else
  {
    v7 = (__int128 *)(a1 + 12);
    v8 = 2;
  }
  v10 = v4;
  v11 = (__int128 *)&a1[4 * !v4];
  v12 = (__int128 *)((char *)a1 + (unsigned int)(32 * v10));
  result = (__int128 *)((char *)a1 + (unsigned int)(32 * v8));
  v14 = *((_QWORD *)v7 + 2);
  v15 = *((_QWORD *)v12 + 2);
  v16 = 1;
  if ( v14 >= v15 )
    v16 = v14 <= v15 && *(_QWORD *)v7 < *(_QWORD *)v12;
  v17 = *((_QWORD *)result + 2);
  v18 = *((_QWORD *)v11 + 2);
  if ( v17 < v18 )
  {
    v19 = v12;
    if ( v16 )
      v19 = v7;
    else
      v12 = v7;
    v20 = *((_QWORD *)v12 + 2);
    v21 = v17 < v20;
    v22 = v17 == v20;
    if ( v17 < v20 )
      goto LABEL_32;
LABEL_28:
    v26 = v12;
    if ( *(_QWORD *)result < *(_QWORD *)v12 && (v21 || v22) )
      v26 = result;
    else
      v12 = result;
    result = v26;
    goto LABEL_32;
  }
  v19 = v12;
  if ( v16 )
    v19 = v7;
  if ( v17 > v18 || *(_QWORD *)result >= *(_QWORD *)v11 )
  {
    if ( v16 )
      v7 = v11;
    else
      v12 = v11;
    v24 = *((_QWORD *)v7 + 2);
    v11 = result;
    result = v7;
    v25 = *((_QWORD *)v12 + 2);
    v21 = v24 < v25;
    v22 = v24 == v25;
    if ( v24 >= v25 )
      goto LABEL_28;
  }
  else
  {
    if ( !v16 )
      v12 = v7;
    v23 = *((_QWORD *)v12 + 2);
    v21 = v17 < v23;
    v22 = v17 == v23;
    if ( v17 >= v23 )
      goto LABEL_28;
  }
LABEL_32:
  v27 = *v19;
  a2[1] = v19[1];
  *a2 = v27;
  v28 = *result;
  a2[3] = result[1];
  a2[2] = v28;
  v29 = v12[1];
  a2[4] = *v12;
  a2[5] = v29;
  v30 = v11[1];
  a2[6] = *v11;
  a2[7] = v30;
  return result;
}

//----- (0000000000429900) ----------------------------------------------------
unsigned __int64 *__fastcall sub_429900(
        unsigned __int64 *a1,
        unsigned __int64 *a2,
        unsigned __int64 *a3,
        unsigned __int64 a4)
{
  unsigned __int64 v6; // r9
  unsigned __int64 v7; // rbx
  __int64 v8; // r14
  __int64 v9; // r12
  unsigned __int64 v10; // r11
  unsigned __int64 v11; // rbx
  unsigned __int64 v12; // rax
  unsigned __int64 v13; // r8
  unsigned __int64 v14; // r9
  unsigned __int64 v15; // r10
  char v16; // dl
  bool v17; // zf
  char v18; // cl

  if ( a4 >= 8 )
  {
    v6 = a4 >> 3;
    v7 = v6 << 7;
    v8 = 28 * v6;
    v9 = sub_429900(a1, &a1[16 * v6], &a1[28 * v6]);
    a2 = (unsigned __int64 *)sub_429900(a2, (char *)a2 + v7, &a2[v8]);
    a3 = (unsigned __int64 *)sub_429900(a3, (char *)a3 + v7, &a3[v8]);
    a1 = (unsigned __int64 *)v9;
  }
  v10 = *a1;
  v11 = a1[2];
  v12 = *a2;
  v13 = a2[2];
  if ( v11 >= v13 )
  {
    v16 = v11 <= v13 && v10 < v12;
    v14 = *a3;
    v15 = a3[2];
    if ( v11 >= v15 )
    {
      if ( v16 != (v11 <= v15 && v10 < v14) )
        return a1;
    }
    else
    {
      v17 = v16 == 0;
      v16 = 1;
      if ( v17 )
        return a1;
    }
  }
  else
  {
    v14 = *a3;
    v15 = a3[2];
    v16 = 1;
    if ( v11 >= v15 && (v11 > v15 || v10 >= v14) )
      return a1;
  }
  v18 = 1;
  if ( v13 >= v15 )
    v18 = v13 <= v15 && v12 < v14;
  if ( v18 != v16 )
    return a3;
  return a2;
}

//----- (0000000000429A10) ----------------------------------------------------
__int64 __fastcall sub_429A10(unsigned __int64 *a1, __int64 a2)
{
  unsigned __int128 v2; // rax
  unsigned __int64 v3; // r8
  unsigned __int64 v5; // rax
  unsigned __int64 v6; // rdi
  __int64 v7; // rcx
  __int64 v8; // rcx
  __int64 result; // rax
  _QWORD v10[3]; // [rsp+20h] [rbp-30h] BYREF
  __int64 v11; // [rsp+38h] [rbp-18h] BYREF
  __int64 v12; // [rsp+40h] [rbp-10h]
  __int64 v13; // [rsp+48h] [rbp-8h]

  *((_QWORD *)&v2 + 1) = a2;
  v3 = *a1;
  if ( *a1 == -1LL )
    goto LABEL_13;
  v5 = v3 + 1;
  if ( 2 * v3 > v3 + 1 )
    v5 = 2 * v3;
  v6 = 4LL;
  if ( v5 >= 5 )
    v6 = v5;
  v7 = 0LL;
  v2 = 0x30 * (unsigned __int128)v6;
  if ( !is_mul_ok(0x30uLL, v6) )
LABEL_13:
    sub_40408F(0LL, *((__int64 *)&v2 + 1), (__int64)&off_448470);
  if ( (unsigned __int64)v2 > 0x7FFFFFFFFFFFFFF8LL )
LABEL_15:
    sub_40408F(v7, *((__int64 *)&v2 + 1), (__int64)&off_448470);
  if ( v3 )
  {
    v10[0] = a1[1];
    v10[2] = 48 * v3;
    v8 = 8LL;
  }
  else
  {
    v8 = 0LL;
  }
  v10[1] = v8;
  sub_413370(&v11, (void *)8, v2, (__int64)v10);
  if ( (_DWORD)v11 == 1 )
  {
    v7 = v12;
    *((_QWORD *)&v2 + 1) = v13;
    goto LABEL_15;
  }
  result = v12;
  a1[1] = v12;
  *a1 = v6;
  return result;
}
// 448470: using guessed type char *off_448470;

//----- (0000000000429AE0) ----------------------------------------------------
void __fastcall sub_429AE0(_QWORD *a1, unsigned __int64 a2, _OWORD *a3, _QWORD *a4, char a5)
{
  _OWORD *v5; // r12
  unsigned __int64 v6; // rax
  __int64 v7; // rax
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // r15
  unsigned __int64 v10; // rsi
  unsigned __int64 v11; // r11
  unsigned __int64 v12; // rbx
  unsigned __int64 *v13; // rcx
  unsigned __int64 v14; // rdi
  unsigned __int64 v15; // rcx
  unsigned __int64 v16; // rcx
  unsigned __int64 v17; // r8
  unsigned __int64 v18; // rcx
  unsigned __int64 v19; // r8
  unsigned __int64 v20; // rdi
  unsigned __int64 v21; // rax
  __int64 v22; // rcx
  _QWORD *v23; // rdx
  _QWORD *v24; // r8
  __int128 v25; // xmm0
  __int64 v26; // r11
  __int64 v27; // r10
  unsigned __int64 *v28; // r9
  unsigned __int64 v29; // r10
  unsigned __int64 v30; // r11
  unsigned __int64 *v31; // r9
  unsigned __int64 v32; // r10
  unsigned __int64 v33; // r11
  unsigned __int64 v34; // rax
  unsigned __int64 v35; // rcx
  char *v36; // rsi
  char *v37; // rdx
  unsigned __int64 v38; // r13
  unsigned __int64 v39; // rbx
  unsigned __int64 v40; // r14
  unsigned __int64 v41; // rdi
  unsigned __int64 v42; // rax
  unsigned __int64 v43; // rax
  unsigned __int64 v44; // r12
  char *v45; // r13
  char *v46; // rdx
  char *v47; // r15
  _QWORD *v48; // rax
  char *v49; // r11
  char *v50; // rdx
  unsigned __int64 v51; // r8
  _BOOL8 v52; // r9
  _BOOL8 v53; // r10
  char *v54; // r11
  __int64 v55; // rax
  bool v56; // cl
  _BOOL8 v57; // r8
  char *v58; // r9
  unsigned __int64 v59; // rax
  _QWORD v60[75]; // [rsp+30h] [rbp-50h]
  unsigned __int64 v61; // [rsp+288h] [rbp+208h]
  _QWORD *v62; // [rsp+290h] [rbp+210h]
  char *v63; // [rsp+298h] [rbp+218h]
  _QWORD *v64; // [rsp+2A0h] [rbp+220h]
  _QWORD *v65; // [rsp+2A8h] [rbp+228h]
  _QWORD *v66; // [rsp+2B0h] [rbp+230h]
  unsigned __int64 v67; // [rsp+2B8h] [rbp+238h]
  unsigned __int64 v68; // [rsp+2C0h] [rbp+240h]
  unsigned __int64 v69; // [rsp+2C8h] [rbp+248h]
  _QWORD *v70; // [rsp+2D0h] [rbp+250h]
  unsigned __int64 v71; // [rsp+2D8h] [rbp+258h]
  unsigned __int64 v72; // [rsp+2E0h] [rbp+260h]
  unsigned __int64 v73; // [rsp+2E8h] [rbp+268h]
  _QWORD *v74; // [rsp+2F0h] [rbp+270h]
  _QWORD *v75; // [rsp+2F8h] [rbp+278h]
  void *Src; // [rsp+300h] [rbp+280h]

  v5 = a3;
  v75 = a1;
  if ( (a2 | (a2 + 0x3FFFFFFFFFFFFFFFLL)) >> 32 )
    v6 = (a2 + 0x3FFFFFFFFFFFFFFFLL) / a2;
  else
    v6 = ((int)a2 - 1) / (unsigned int)a2;
  v69 = v6;
  v72 = a2;
  if ( a2 >= 0x1001 )
  {
    _BitScanReverse64(&v8, a2 | 1);
    v73 = ((1LL << ((((unsigned int)v8 ^ 0xFFFFFFC0) + 65) >> 1)) + (a2 >> ((((unsigned int)v8 ^ 0xFFFFFFC0) + 65) >> 1))) >> 1;
  }
  else
  {
    v7 = 64LL;
    if ( a2 - (a2 >> 1) < 0x40 )
      v7 = a2 - (a2 >> 1);
    v73 = v7;
  }
  v70 = v75 + 6;
  v65 = v75 + 2;
  v66 = v75 - 1;
  v64 = v75 - 3;
  v9 = 1LL;
  v10 = 0LL;
  v11 = 0LL;
  v74 = a4;
  Src = a3;
  v12 = v72;
  if ( !v72 )
    goto LABEL_15;
LABEL_10:
  v13 = &v75[3 * v10];
  if ( v12 < v73 )
    goto LABEL_11;
  if ( v12 < 2 )
  {
    v15 = 2 * v12 + 1;
    goto LABEL_43;
  }
  v19 = v13[3];
  if ( v19 >= *v13 )
  {
    v27 = 2LL;
    if ( v12 == 2 )
      goto LABEL_42;
    v20 = v11;
    v28 = &v70[3 * v10];
    v21 = 2LL;
    v29 = v13[3];
    while ( 1 )
    {
      v30 = v29;
      v29 = *v28;
      if ( *v28 < v30 )
        break;
      ++v21;
      v28 += 3;
      if ( v12 == v21 )
      {
LABEL_36:
        v21 = v12;
        break;
      }
    }
  }
  else
  {
    v20 = v11;
    if ( v12 == 2 )
    {
      v21 = 2LL;
      v22 = 1LL;
      goto LABEL_25;
    }
    v31 = &v70[3 * v10];
    v21 = 2LL;
    v32 = v13[3];
    while ( 1 )
    {
      v33 = v32;
      v32 = *v31;
      if ( *v31 >= v33 )
        break;
      ++v21;
      v31 += 3;
      if ( v12 == v21 )
        goto LABEL_36;
    }
  }
  a4 = v74;
  v11 = v20;
  if ( v21 >= v73 )
  {
    if ( v19 >= *v13 )
    {
      v27 = v21;
    }
    else
    {
      v27 = 1LL;
      if ( v21 >= 2 )
      {
        v22 = v21 >> 1;
LABEL_25:
        v23 = &v65[3 * v10];
        v24 = &v66[3 * v10 + 3 * v21];
        do
        {
          v25 = *((_OWORD *)v23 - 1);
          *((_OWORD *)v23 - 1) = *((_OWORD *)v24 - 1);
          *((_OWORD *)v24 - 1) = v25;
          v26 = *v23;
          *v23 = *v24;
          *v24 = v26;
          v23 += 3;
          v24 -= 3;
          --v22;
        }
        while ( v22 );
        v11 = v20;
        v15 = 2 * v21 + 1;
        goto LABEL_43;
      }
    }
LABEL_42:
    v15 = 2 * v27 + 1;
    goto LABEL_43;
  }
LABEL_11:
  if ( a5 )
  {
    if ( v12 >= 0x20 )
      v12 = 32LL;
    v14 = v11;
    sub_42A1F0(v13, v12, v5, a4, 0, 0LL);
    v11 = v14;
    a4 = v74;
    v15 = 2LL * (unsigned int)v12 + 1;
  }
  else
  {
    v18 = v12;
    if ( v73 < v12 )
      v18 = v73;
    v15 = 2 * v18;
  }
LABEL_43:
  v17 = v15;
  v34 = (v69 * (2 * v10 - (v9 >> 1))) ^ (v69 * ((v15 >> 1) + 2 * v10));
  if ( !v34 )
  {
    v16 = 64LL;
    if ( v11 < 2 )
      goto LABEL_85;
    goto LABEL_47;
  }
  _BitScanReverse64(&v35, v34);
  v16 = v35 ^ 0x3F;
  if ( v11 >= 2 )
  {
LABEL_47:
    v68 = v17;
    v63 = (char *)&v75[3 * v10];
    v62 = &v64[3 * v10];
    v61 = v10;
    v67 = v16;
    while ( 1 )
    {
      while ( 1 )
      {
        if ( *((_BYTE *)&v60[66] + v11 + 5) < (unsigned __int8)v16 )
        {
LABEL_84:
          v17 = v68;
          goto LABEL_85;
        }
        v38 = v60[--v11];
        v39 = v38 >> 1;
        v40 = v9 >> 1;
        v41 = (v38 >> 1) + (v9 >> 1);
        if ( v41 > (unsigned __int64)a4 || (((unsigned __int8)v9 | (unsigned __int8)v38) & 1) != 0 )
          break;
        v9 = 2 * v41;
        if ( v11 <= 1 )
        {
LABEL_83:
          v11 = 1LL;
          goto LABEL_84;
        }
      }
      v36 = (char *)&v75[3 * (v10 - v41)];
      v71 = v11;
      if ( (v38 & 1) != 0 )
      {
        if ( (v9 & 1) != 0 )
          goto LABEL_58;
      }
      else
      {
        _BitScanReverse64(&v42, v39 | 1);
        sub_42A1F0(v36, v39, v5, a4, (2 * (v42 ^ 0x3F)) ^ 0x7E, 0LL);
        v11 = v71;
        a4 = v74;
        if ( (v9 & 1) != 0 )
        {
LABEL_58:
          LOBYTE(v16) = v67;
          if ( v9 >= 2 )
            goto LABEL_62;
          goto LABEL_50;
        }
      }
      _BitScanReverse64(&v43, v40 | 1);
      sub_42A1F0(&v36[24 * v39], v9 >> 1, v5, a4, (2 * (v43 ^ 0x3F)) ^ 0x7E, 0LL);
      v11 = v71;
      a4 = v74;
      LOBYTE(v16) = v67;
      if ( v9 >= 2 )
      {
LABEL_62:
        if ( v38 >= 2 )
        {
          v44 = v9 >> 1;
          if ( v39 < v40 )
            v44 = v38 >> 1;
          if ( v44 <= (unsigned __int64)a4 )
          {
            v45 = &v36[24 * v39];
            v46 = v36;
            if ( v40 < v39 )
              v46 = &v36[24 * v39];
            memcpy(Src, v46, 24 * v44);
            v47 = (char *)Src + 24 * v44;
            if ( v40 >= v39 )
            {
              if ( v44 )
              {
                v37 = (char *)Src;
                v54 = v63;
                do
                {
                  v55 = 0LL;
                  v56 = *(_QWORD *)v45 < *(_QWORD *)v37;
                  v57 = *(_QWORD *)v45 >= *(_QWORD *)v37;
                  v58 = v37;
                  if ( *(_QWORD *)v45 < *(_QWORD *)v37 )
                    v58 = v45;
                  *((_QWORD *)v36 + 2) = *((_QWORD *)v58 + 2);
                  *(_OWORD *)v36 = *(_OWORD *)v58;
                  v37 += 24 * v57;
                  v36 += 24;
                  if ( v37 == v47 )
                    break;
                  LOBYTE(v55) = v56;
                  v45 += 24 * v55;
                }
                while ( v45 != v54 );
              }
              else
              {
                v37 = (char *)Src;
              }
            }
            else
            {
              v48 = v62;
              v49 = (char *)Src;
              do
              {
                v50 = v47 - 24;
                v51 = *((_QWORD *)v47 - 3);
                v52 = v51 < *((_QWORD *)v45 - 3);
                v53 = v51 >= *((_QWORD *)v45 - 3);
                if ( v51 < *((_QWORD *)v45 - 3) )
                  v50 = v45 - 24;
                v48[2] = *((_QWORD *)v50 + 2);
                *(_OWORD *)v48 = *(_OWORD *)v50;
                v45 = &v45[24 * v53 - 24];
                v47 = &v47[24 * v52 - 24];
                if ( v45 == v36 )
                  break;
                v48 -= 3;
              }
              while ( v47 != v49 );
              v36 = v45;
              v37 = v49;
            }
            memcpy(v36, v37, v47 - v37);
            a4 = v74;
            v11 = v71;
            LOBYTE(v16) = v67;
          }
        }
      }
LABEL_50:
      v9 = 2 * v41 + 1;
      v5 = Src;
      v10 = v61;
      if ( v11 <= 1 )
        goto LABEL_83;
    }
  }
LABEL_85:
  while ( 1 )
  {
    v60[v11] = v9;
    *((_BYTE *)&v60[66] + v11 + 6) = v16;
    if ( v72 <= v10 )
      break;
    ++v11;
    v9 = v17;
    v10 += v17 >> 1;
    v12 = v72 - v10;
    if ( v72 > v10 )
      goto LABEL_10;
LABEL_15:
    v16 = 0LL;
    v17 = 1LL;
    if ( v11 >= 2 )
      goto LABEL_47;
  }
  if ( (v9 & 1) == 0 )
  {
    _BitScanReverse64(&v59, v72 | 1);
    sub_42A1F0(v75, v72, v5, a4, (2 * (v59 ^ 0x3F)) ^ 0x7E, 0LL);
  }
}

//----- (000000000042A1F0) ----------------------------------------------------
void __fastcall sub_42A1F0(_QWORD *a1, unsigned __int64 a2, _OWORD *a3, _QWORD *a4, int a5, unsigned __int64 *a6)
{
  unsigned __int64 v7; // rbx
  unsigned __int64 v9; // r15
  unsigned __int64 v10; // rcx
  _BOOL8 v11; // r8
  unsigned __int64 *v12; // r9
  __int64 v13; // r10
  unsigned __int64 *v14; // r12
  __int64 v15; // r11
  unsigned __int64 *v16; // rdx
  unsigned __int64 *v17; // r8
  unsigned __int64 v18; // rax
  unsigned __int64 v19; // rdi
  unsigned __int64 v20; // r11
  unsigned __int64 *v21; // r14
  bool v22; // cf
  bool v23; // cf
  unsigned __int64 *v24; // rax
  __int64 v25; // r9
  _QWORD *v26; // r13
  unsigned __int64 v27; // r11
  _BOOL8 v28; // rdi
  _BOOL8 v29; // r14
  unsigned __int64 *v30; // r15
  __int64 v31; // rcx
  __int64 v32; // rdi
  unsigned __int64 *v33; // r11
  unsigned __int64 *v34; // r14
  unsigned __int64 v35; // rdi
  unsigned __int64 *v36; // r12
  unsigned __int64 *v37; // r13
  bool v38; // cf
  unsigned __int64 *v39; // rcx
  _OWORD *v40; // rcx
  bool v41; // cf
  unsigned __int64 *v42; // rax
  __int128 v43; // xmm0
  __int128 v44; // xmm0
  __int128 v45; // xmm0
  unsigned __int64 v46; // rdx
  unsigned __int64 v47; // r8
  unsigned __int64 v48; // r13
  unsigned __int64 v50; // r15
  int v51; // r14d
  char *v52; // r12
  _QWORD *v53; // r8
  bool v54; // dl
  unsigned __int64 v55; // r14
  char *v56; // r13
  _QWORD *v57; // rax
  _OWORD *v58; // rcx
  unsigned __int64 i; // rdx
  _QWORD *j; // r8
  bool v61; // cf
  _OWORD *v62; // r10
  __int64 v63; // r11
  __int64 v64; // rdx
  unsigned __int64 v65; // rdx
  _QWORD *v66; // r10
  __int64 v67; // r9
  char *v68; // r8
  __int64 v69; // r11
  __int64 v70; // r11
  __int64 v71; // rcx
  _QWORD *v72; // rax
  unsigned __int64 *v73; // rcx
  unsigned __int64 v74; // r13
  _QWORD *v75; // rax
  _QWORD *k; // rdx
  bool v77; // cf
  unsigned __int64 *v78; // r8
  __int64 v79; // r9
  __int64 v80; // rdx
  unsigned __int64 *v81; // r12
  _QWORD *v82; // rax
  __int64 v83; // r8
  char *v84; // rdx
  _QWORD *v85; // r9
  __int64 v86; // r10
  __int64 v87; // r10
  __int64 v88; // rcx
  __int64 v89; // rax
  __int64 v90; // rcx
  unsigned __int64 v91; // r9
  char *v92; // rax
  __int64 v93; // rax
  unsigned __int64 v94; // r10
  __int64 v95; // r11
  __int64 v96; // rax
  _QWORD *v97; // rcx
  _QWORD *v98; // r9
  __int64 v99; // r10
  char *v100; // rax
  __int64 v101; // rax
  unsigned __int64 v102; // r11
  __int64 v103; // rdi
  __int64 v104; // rax
  _QWORD *v105; // r10
  _QWORD *v106; // rdi
  _QWORD *v107; // rdx
  __int64 v108; // r11
  _QWORD *v109; // r9
  __int64 v110; // r14
  __int64 v111; // r15
  _QWORD *v112; // r8
  __int64 v113; // r13
  _QWORD *v114; // r8
  bool v115; // cf
  _QWORD *v116; // rdi
  _BOOL8 v117; // rax
  _QWORD *v118; // r11
  __int128 v119; // [rsp+30h] [rbp-50h] BYREF
  __int64 v120; // [rsp+40h] [rbp-40h]
  __int128 v121; // [rsp+50h] [rbp-30h] BYREF
  __int64 v122; // [rsp+60h] [rbp-20h]
  __int128 v123; // [rsp+68h] [rbp-18h]
  _QWORD *v124; // [rsp+88h] [rbp+8h]
  char *v125; // [rsp+90h] [rbp+10h]
  unsigned __int64 v126; // [rsp+98h] [rbp+18h]
  __int64 v127; // [rsp+A0h] [rbp+20h]
  unsigned __int64 *v128; // [rsp+A8h] [rbp+28h]
  _QWORD *v129; // [rsp+B0h] [rbp+30h]

  v7 = a2;
  if ( a2 >= 0x21 )
  {
    v48 = (unsigned __int64)a4;
    v128 = a6;
    v125 = (char *)a3 - 24;
    v129 = a4;
    do
    {
      v50 = v7;
      while ( 1 )
      {
        v22 = a5 == 0;
        v51 = a5 - 1;
        if ( v22 )
        {
          sub_429AE0((_DWORD)a1, v50, (_DWORD)a3, v48, 1);
          return;
        }
        v52 = (char *)&a1[12 * (v50 >> 3)];
        v53 = &a1[21 * (v50 >> 3)];
        LODWORD(v126) = v51;
        if ( v50 >= 0x40 )
        {
          v52 = (char *)sub_42ABB0(a1, &a1[12 * (v50 >> 3)], v53, v50 >> 3);
        }
        else
        {
          v54 = *a1 < *(_QWORD *)v52;
          if ( v54 != *(_QWORD *)v52 < *v53 )
            v52 = (char *)&a1[21 * (v50 >> 3)];
          if ( v54 != *a1 < *v53 )
            v52 = (char *)a1;
        }
        v55 = 0xAAAAAAAAAAAAAAABuLL * ((unsigned __int64)(v52 - (char *)a1) >> 3);
        v120 = *((_QWORD *)v52 + 2);
        v119 = *(_OWORD *)v52;
        if ( v128 )
        {
          if ( *v128 >= *(_QWORD *)v52 )
            break;
        }
        if ( v50 > v48 )
          goto LABEL_122;
        v127 = 3 * v50;
        v56 = (char *)a3 + 24 * v50;
        v7 = 0LL;
        v57 = a1;
        v58 = v56;
        for ( i = 0xAAAAAAAAAAAAAAABuLL * ((unsigned __int64)(v52 - (char *)a1) >> 3); ; i = v50 )
        {
          for ( j = &a1[3 * i]; v57 < j; v57 += 3 )
          {
            v58 = (_OWORD *)((char *)v58 - 24);
            v61 = *v57 < *(_QWORD *)v52;
            v62 = v58;
            if ( *v57 < *(_QWORD *)v52 )
              v62 = a3;
            v63 = 3 * v7;
            *((_QWORD *)v62 + v63 + 2) = v57[2];
            *(_OWORD *)((char *)v62 + 8 * v63) = *(_OWORD *)v57;
            v7 += v61;
          }
          if ( i == v50 )
            break;
          v64 = 3 * v7;
          *((_QWORD *)v58 + v64 - 1) = v57[2];
          *(_OWORD *)((char *)v58 + 8 * v64 - 24) = *(_OWORD *)v57;
          v58 = (_OWORD *)((char *)v58 - 24);
          v57 += 3;
        }
        memcpy(a1, a3, 24 * v7);
        v65 = v50 - v7;
        if ( v50 != v7 )
        {
          v66 = &a1[3 * v7];
          v124 = v66;
          if ( v50 == v7 + 1 )
          {
            v67 = 0LL;
          }
          else
          {
            v68 = &v125[8 * v127];
            v69 = 0LL;
            do
            {
              v66[2] = *((_QWORD *)v68 + 2);
              *(_OWORD *)v66 = *(_OWORD *)v68;
              v67 = v69 + 2;
              v70 = 3 * (v69 ^ 0x1FFFFFFFFFFFFFFELL);
              *(_OWORD *)(v66 + 3) = *(_OWORD *)&v56[8 * v70];
              v66[5] = *(_QWORD *)&v56[8 * v70 + 16];
              v66 += 6;
              v68 -= 48;
              v69 = v67;
            }
            while ( (v65 & 0xFFFFFFFFFFFFFFFEuLL) != v67 );
          }
          if ( (v65 & 1) != 0 )
          {
            v71 = 3 * v67;
            v72 = v124;
            v124[v71 + 2] = *(_QWORD *)&v56[24 * ~v67 + 16];
            *(_OWORD *)&v72[v71] = *(_OWORD *)&v56[24 * ~v67];
          }
        }
        v48 = (unsigned __int64)v129;
        if ( !v7 )
          break;
        if ( v50 < v7 )
        {
          *(_QWORD *)&v121 = &off_4479E0;
          *((_QWORD *)&v121 + 1) = 1LL;
          v122 = 8LL;
          v123 = 0LL;
          sub_405240(&v121, &off_447A50);
        }
        a5 = v126;
        sub_42A1F0((_DWORD)a1 + 24 * v7, v65, (_DWORD)a3, (_DWORD)v129, v126, (__int64)&v119);
        v50 = v7;
        if ( v7 < 0x21 )
          goto LABEL_2;
      }
      if ( v50 > v48 )
LABEL_122:
        BUG();
      v127 = 3 * v50;
      v73 = (unsigned __int64 *)a3 + 3 * v50;
      v74 = 0LL;
      v75 = a1;
      v128 = v73;
      while ( 1 )
      {
        for ( k = &a1[3 * v55]; v75 < k; v75 += 3 )
        {
          v73 -= 3;
          v77 = *(_QWORD *)v52 < *v75;
          v78 = v73;
          if ( *(_QWORD *)v52 >= *v75 )
            v78 = (unsigned __int64 *)a3;
          v79 = 3 * v74;
          v78[v79 + 2] = v75[2];
          *(_OWORD *)&v78[v79] = *(_OWORD *)v75;
          v74 -= v77 - 1LL;
        }
        if ( v55 == v50 )
          break;
        v73 -= 3;
        v80 = 3 * v74;
        *((_QWORD *)a3 + v80 + 2) = v75[2];
        *(_OWORD *)((char *)a3 + 8 * v80) = *(_OWORD *)v75;
        ++v74;
        v75 += 3;
        v55 = v50;
      }
      memcpy(a1, a3, 24 * v74);
      v7 = v50 - v74;
      a5 = v126;
      v81 = v128;
      if ( v50 != v74 )
      {
        v82 = &a1[3 * v74];
        if ( v50 == v74 + 1 )
        {
          v83 = 0LL;
        }
        else
        {
          v84 = &v125[8 * v127];
          v85 = &a1[3 * v74];
          v86 = 0LL;
          do
          {
            v85[2] = *((_QWORD *)v84 + 2);
            *(_OWORD *)v85 = *(_OWORD *)v84;
            v83 = v86 + 2;
            v87 = 3 * (v86 ^ 0x1FFFFFFFFFFFFFFELL);
            *(_OWORD *)(v85 + 3) = *(_OWORD *)&v81[v87];
            v85[5] = v81[v87 + 2];
            v85 += 6;
            v84 -= 48;
            v86 = v83;
          }
          while ( (v7 & 0xFFFFFFFFFFFFFFFEuLL) != v83 );
        }
        if ( (v7 & 1) != 0 )
        {
          v88 = 3 * v83;
          v82[v88 + 2] = v81[3 * ~v83 + 2];
          *(_OWORD *)&v82[v88] = *(_OWORD *)&v81[3 * ~v83];
        }
      }
      if ( v50 < v74 )
        sub_4050A0(v74, v50, (__int64)&off_447A68);
      a1 += 3 * v74;
      v128 = 0LL;
      v48 = (unsigned __int64)v129;
    }
    while ( v7 >= 0x21 );
  }
LABEL_2:
  if ( v7 >= 2 )
  {
    v9 = v7 >> 1;
    v129 = a1;
    if ( v7 < 8 )
    {
      *((_QWORD *)a3 + 2) = a1[2];
      *a3 = *(_OWORD *)a1;
      v89 = 24 * v9;
      *(_QWORD *)((char *)a3 + v89 + 16) = a1[3 * v9 + 2];
      *(_OWORD *)((char *)a3 + v89) = *(_OWORD *)&a1[3 * v9];
      v46 = 1LL;
      v47 = v7 - v9;
      if ( v9 <= 1 )
      {
LABEL_97:
        v97 = (_QWORD *)a3 + 3 * v9;
        if ( v46 < v47 )
        {
          v98 = &a1[3 * v9];
          v99 = 3LL * (unsigned int)(8 * v46);
          do
          {
            v101 = 3 * v46;
            *(_OWORD *)&v97[v101] = *(_OWORD *)&v98[3 * v46];
            v97[v101 + 2] = v98[3 * v46 + 2];
            v102 = v97[3 * v46];
            if ( v102 < v97[3 * v46 - 3] )
            {
              v121 = *(_OWORD *)&v98[v101 + 1];
              v103 = v99;
              do
              {
                *(_QWORD *)((char *)v97 + v103 + 16) = *(_QWORD *)((char *)v97 + v103 - 8);
                *(_OWORD *)((char *)v97 + v103) = *(_OWORD *)((char *)v97 + v103 - 24);
                if ( v103 == 24 )
                {
                  v100 = (char *)a3 + 24 * v9;
                  goto LABEL_100;
                }
                v104 = v103 - 24;
                v22 = v102 < *(_QWORD *)((char *)v97 + v103 - 48);
                v103 -= 24LL;
              }
              while ( v22 );
              v100 = (char *)v97 + v104;
LABEL_100:
              *(_QWORD *)v100 = v102;
              *(_OWORD *)(v100 + 8) = v121;
              a1 = v129;
            }
            ++v46;
            v99 += 24LL;
          }
          while ( v46 != v47 );
        }
        v105 = a1;
        v106 = v97 - 3;
        v107 = (_QWORD *)a3 + 3 * v7 - 3;
        v108 = (__int64)&v105[3 * v7 - 3];
        v109 = a3;
        do
        {
          v126 = v9;
          v110 = 0LL;
          v111 = 0LL;
          v112 = v97;
          v22 = *v97 < *v109;
          LOBYTE(v128) = *v97 >= *v109;
          LOBYTE(v127) = v22;
          if ( !v22 )
            v112 = v109;
          v105[2] = v112[2];
          *(_OWORD *)v105 = *(_OWORD *)v112;
          v113 = (*v107 < *v106) - 1LL;
          v114 = v106;
          v115 = *v107 < *v106;
          if ( *v107 >= *v106 )
            v114 = v107;
          LOBYTE(v111) = v127;
          v97 += 3 * v111;
          LOBYTE(v110) = (_BYTE)v128;
          v109 += 3 * v110;
          v105 += 3;
          *(_QWORD *)(v108 + 16) = v114[2];
          *(_OWORD *)v108 = *(_OWORD *)v114;
          v107 += 3 * v113;
          v106 -= 3 * v115;
          v108 -= 24LL;
          v9 = v126 - 1;
        }
        while ( v126 != 1 );
        v116 = v106 + 3;
        if ( (v7 & 1) != 0 )
        {
          v117 = v109 >= v116;
          v118 = v97;
          if ( v109 < v116 )
            v118 = v109;
          v105[2] = v118[2];
          *(_OWORD *)v105 = *(_OWORD *)v118;
          v109 += 3 * (v109 < v116);
          v97 += 3 * v117;
        }
        if ( v109 != v116 || v97 != v107 + 3 )
          sub_408340();
        return;
      }
    }
    else
    {
      v10 = a1[9];
      v11 = a1[3] < *a1;
      v12 = a1 + 9;
      v13 = 3 * v11;
      v14 = &a1[3 * v11];
      v15 = 3LL * (a1[3] >= *a1);
      v16 = a1 + 6;
      if ( v10 < a1[6] )
        v16 = a1 + 9;
      v17 = &a1[3 * (a1[3] >= *a1)];
      if ( v10 < a1[6] )
        v12 = a1 + 6;
      v18 = *v16;
      v19 = *v12;
      v20 = v129[v15];
      v21 = v17;
      if ( *v12 < v20 )
        v21 = v16;
      v22 = v18 < v129[v13];
      if ( v18 < v129[v13] )
      {
        v21 = v14;
        v14 = v16;
      }
      v128 = v14;
      if ( v22 )
        v16 = v17;
      if ( v19 < v20 )
        v16 = v12;
      else
        v17 = v12;
      v23 = *v16 < *v21;
      v24 = v21;
      if ( *v16 < *v21 )
        v24 = v16;
      v127 = (__int64)v24;
      if ( v23 )
        v16 = v21;
      v25 = 24 * v9;
      v26 = &v129[3 * v9];
      v27 = v26[9];
      v28 = v26[3] >= *v26;
      v29 = v26[3] < *v26;
      v126 = v7 >> 1;
      v30 = v26 + 9;
      v22 = v27 < v129[(unsigned __int64)v25 / 8 + 6];
      v31 = 3 * v29;
      v32 = 3 * v28;
      v33 = &v26[v32];
      v34 = &v129[(unsigned __int64)v25 / 8 + 6];
      if ( v22 )
      {
        v34 = v26 + 9;
        v30 = &v129[(unsigned __int64)v25 / 8 + 6];
      }
      v35 = v26[v32];
      v36 = v33;
      if ( *v30 < v35 )
        v36 = v34;
      v22 = *v34 < v26[v31];
      v37 = &v26[v31];
      if ( v22 )
      {
        v36 = v37;
        v37 = v34;
        v34 = v33;
      }
      v38 = *v30 < v35;
      a1 = v129;
      v39 = v128;
      *((_QWORD *)a3 + 2) = v128[2];
      *a3 = *(_OWORD *)v39;
      v40 = (_OWORD *)v127;
      *((_QWORD *)a3 + 5) = *(_QWORD *)(v127 + 16);
      *(_OWORD *)((char *)a3 + 24) = *v40;
      *((_QWORD *)a3 + 8) = v16[2];
      if ( !v38 )
        v33 = v30;
      a3[3] = *(_OWORD *)v16;
      if ( v38 )
        v34 = v30;
      v9 = v126;
      *((_QWORD *)a3 + 11) = v17[2];
      v41 = *v34 < *v36;
      v42 = v36;
      if ( *v34 < *v36 )
        v42 = v34;
      *(_OWORD *)((char *)a3 + 72) = *(_OWORD *)v17;
      if ( v41 )
        v34 = v36;
      *(_QWORD *)((char *)a3 + v25 + 16) = v37[2];
      *(_OWORD *)((char *)a3 + v25) = *(_OWORD *)v37;
      v43 = *(_OWORD *)v42;
      *(_QWORD *)((char *)a3 + v25 + 40) = v42[2];
      *(_OWORD *)((char *)a3 + v25 + 24) = v43;
      v44 = *(_OWORD *)v34;
      *(_QWORD *)((char *)a3 + v25 + 64) = v34[2];
      *(_OWORD *)((char *)a3 + v25 + 48) = v44;
      v45 = *(_OWORD *)v33;
      *(_QWORD *)((char *)a3 + v25 + 88) = v33[2];
      *(_OWORD *)((char *)a3 + v25 + 72) = v45;
      v46 = 4LL;
      v47 = v7 - v9;
      if ( v9 <= 4 )
        goto LABEL_97;
    }
    v90 = 3LL * (unsigned int)(8 * v46);
    v91 = v46;
    do
    {
      v93 = 24 * v91;
      *(_OWORD *)((char *)a3 + v93) = *(_OWORD *)&a1[3 * v91];
      *(_QWORD *)((char *)a3 + v93 + 16) = a1[3 * v91 + 2];
      v94 = *((_QWORD *)a3 + 3 * v91);
      if ( v94 < *((_QWORD *)a3 + 3 * v91 - 3) )
      {
        v121 = *(_OWORD *)&a1[(unsigned __int64)v93 / 8 + 1];
        v95 = v90;
        do
        {
          *(_QWORD *)((char *)a3 + v95 + 16) = *(_QWORD *)((char *)a3 + v95 - 8);
          *(_OWORD *)((char *)a3 + v95) = *(_OWORD *)((char *)a3 + v95 - 24);
          if ( v95 == 24 )
          {
            v92 = (char *)a3;
            goto LABEL_90;
          }
          v96 = v95 - 24;
          v22 = v94 < *(_QWORD *)((char *)a3 + v95 - 48);
          v95 -= 24LL;
        }
        while ( v22 );
        v92 = (char *)a3 + v96;
LABEL_90:
        *(_QWORD *)v92 = v94;
        *(_OWORD *)(v92 + 8) = v121;
      }
      ++v91;
      v90 += 24LL;
    }
    while ( v91 != v9 );
    goto LABEL_97;
  }
}
// 405240: using guessed type void __fastcall __noreturn sub_405240(_QWORD, _QWORD);
// 429AE0: using guessed type __int64 __fastcall sub_429AE0(_DWORD, _DWORD, _DWORD, _DWORD, char);
// 4479E0: using guessed type char *off_4479E0;
// 447A50: using guessed type char *off_447A50;
// 447A68: using guessed type char *off_447A68;

//----- (000000000042ABB0) ----------------------------------------------------
_QWORD *__fastcall sub_42ABB0(_QWORD *a1, _QWORD *a2, _QWORD *a3, unsigned __int64 a4)
{
  unsigned __int64 v6; // r9
  __int64 v7; // rbx
  __int64 v8; // r14
  __int64 v9; // r12
  __int64 v10; // rax
  bool v11; // r8

  if ( a4 >= 8 )
  {
    v6 = a4 >> 3;
    v7 = 12 * v6;
    v8 = 21 * v6;
    v9 = sub_42ABB0(a1, &a1[12 * v6], &a1[21 * v6]);
    a2 = (_QWORD *)sub_42ABB0(a2, &a2[v7], &a2[v8]);
    v10 = sub_42ABB0(a3, &a3[v7], &a3[v8]);
    a1 = (_QWORD *)v9;
    a3 = (_QWORD *)v10;
  }
  v11 = *a1 < *a2;
  if ( v11 != *a2 < *a3 )
    a2 = a3;
  if ( v11 != *a1 < *a3 )
    return a1;
  return a2;
}

//----- (000000000042AC70) ----------------------------------------------------
__int64 __fastcall sub_42AC70(__int64 *a1, __int64 a2)
{
  __int64 v2; // rax
  unsigned __int64 v4; // rdx
  __int64 v5; // rdi
  __int64 v6; // rcx
  __int64 v7; // rax
  __int64 result; // rax
  _QWORD v9[3]; // [rsp+20h] [rbp-30h] BYREF
  __int64 v10; // [rsp+38h] [rbp-18h] BYREF
  __int64 v11; // [rsp+40h] [rbp-10h]
  __int64 v12; // [rsp+48h] [rbp-8h]

  v2 = *a1;
  if ( *a1 == -1 )
    goto LABEL_13;
  v4 = v2 + 1;
  if ( 2 * v2 > (unsigned __int64)(v2 + 1) )
    v4 = 2 * v2;
  v5 = 4LL;
  if ( v4 >= 5 )
    v5 = v4;
  v6 = 0LL;
  a2 = v4 >> 61;
  if ( a2 )
LABEL_13:
    sub_40408F(0LL, a2, (__int64)&off_448410);
  if ( (unsigned __int64)(8 * v5) > 0x7FFFFFFFFFFFFFF8LL )
LABEL_15:
    sub_40408F(v6, a2, (__int64)&off_448410);
  if ( v2 )
  {
    v9[0] = a1[1];
    v9[2] = 8 * v2;
    v7 = 8LL;
  }
  else
  {
    v7 = 0LL;
  }
  v9[1] = v7;
  sub_413370(&v10, (void *)8, 8 * v5, (__int64)v9);
  if ( (_DWORD)v10 == 1 )
  {
    v6 = v11;
    a2 = v12;
    goto LABEL_15;
  }
  result = v11;
  a1[1] = v11;
  *a1 = v5;
  return result;
}
// 448410: using guessed type char *off_448410;

//----- (000000000042AD40) ----------------------------------------------------
__int64 __fastcall sub_42AD40(__int64 *a1, __int64 a2)
{
  unsigned __int64 v3; // rcx
  unsigned __int64 v4; // rax
  unsigned __int64 v5; // r8
  bool v6; // cf
  __int64 result; // rax
  __int64 v8; // r8
  _QWORD *v9; // rdi
  __int64 v10; // r10
  __int64 v11; // rbx
  __int64 v12; // r9
  unsigned __int64 v13; // r11
  int v14; // ecx
  char v15; // r14
  __int64 v16; // rcx
  __int64 v17; // rax
  __int64 v18; // r12
  unsigned __int64 v19; // rdi
  __int64 v20; // r12
  _QWORD *v21; // r8
  __int64 v22; // r13
  __int64 v23; // r12
  unsigned __int64 v24; // rdi
  unsigned __int64 v25; // rax
  __int64 v26; // rbx
  __int64 v27; // rdi
  __int64 v28; // r13
  __int64 v29; // r15
  char v30; // r12
  int v31; // [rsp+20h] [rbp-60h] BYREF
  __int64 v32; // [rsp+28h] [rbp-58h]
  unsigned __int64 v33; // [rsp+30h] [rbp-50h]
  __int128 v34; // [rsp+40h] [rbp-40h] BYREF
  __int64 v35; // [rsp+58h] [rbp-28h]
  unsigned __int64 v36; // [rsp+60h] [rbp-20h] BYREF
  __int64 v37; // [rsp+68h] [rbp-18h]
  __int64 v38; // [rsp+70h] [rbp-10h]
  unsigned __int64 v39; // [rsp+78h] [rbp-8h]
  _QWORD *v40; // [rsp+80h] [rbp+0h]

  v3 = *(_QWORD *)(a2 + 32);
  if ( v3 )
  {
    if ( *(_DWORD *)(a2 + 72) == 1 )
    {
      v4 = *(_QWORD *)(a2 + 40);
      v5 = *(_QWORD *)(a2 + 80);
      v6 = v4 < v5;
      result = v4 - v5;
      if ( v6 )
      {
        result = 19LL;
LABEL_33:
        *a1 = result;
        a1[1] = v3;
        return result;
      }
      *(_QWORD *)a2 = v5 + v3;
      *(_QWORD *)(a2 + 8) = result;
      if ( !result )
        goto LABEL_28;
    }
    else
    {
      v17 = *(_QWORD *)(a2 + 40);
      v18 = *(_QWORD *)(a2 + 48);
      if ( (*(_BYTE *)v18 & 1) != 0 )
      {
        v19 = *(_QWORD *)(v18 + 24);
        v20 = *(_QWORD *)(v18 + 16);
      }
      else
      {
        v19 = *(_QWORD *)(v18 + 8);
        if ( v19 >= 6 )
          sub_405B00(*(_QWORD *)(v18 + 8), 5LL, (__int64)&off_446D68);
        v20 = v18 + 16;
      }
      v21 = (_QWORD *)(a2 + 32);
      v36 = *(_QWORD *)(a2 + 32);
      v37 = v17;
      v38 = v20;
      v39 = v19;
      v40 = (_QWORD *)(a2 + 32);
      if ( v19 )
      {
        v22 = a2;
        v23 = v20 + 16;
        v24 = v19 - 1;
        while ( 1 )
        {
          v34 = *(_OWORD *)(v23 - 16);
          sub_41D2E0((__int64)&v31, &v36, *(_DWORD *)(v40[3] + 72LL), (__int64)&v34);
          if ( v31 == 46 )
            break;
          v38 = v23;
          v39 = v24;
          v23 += 16LL;
          v6 = v24-- != 0;
          if ( !v6 )
          {
            v3 = v36;
            v21 = v40;
            a2 = v22;
            goto LABEL_25;
          }
        }
        result = v32;
        v3 = v33;
        goto LABEL_33;
      }
LABEL_25:
      if ( (v21[5] & 1) == 0 )
      {
        v25 = v3 - *v21;
        v21[5] = 1LL;
        v21[6] = v25;
      }
      result = v37;
      *(_QWORD *)a2 = v3;
      *(_QWORD *)(a2 + 8) = result;
      if ( !result )
      {
LABEL_28:
        *(_QWORD *)(a2 + 32) = 0LL;
        *(_QWORD *)(a2 + 88) = 0LL;
        *(_WORD *)a1 = 75;
        return result;
      }
    }
  }
  else
  {
    result = *(_QWORD *)(a2 + 8);
    if ( !result )
      goto LABEL_28;
  }
  v8 = *(_QWORD *)(a2 + 16);
  v9 = *(_QWORD **)(a2 + 24);
  v10 = *(_QWORD *)a2
      + *(_QWORD *)(v8 + 56)
      - *(_QWORD *)(v8 + 48)
      + 8LL * (*(_BYTE *)(v8 + 73) == 8)
      - *(_QWORD *)(v8 + 40)
      + 4;
  v11 = *(_QWORD *)a2 + result--;
  v12 = *(_QWORD *)a2 + 1LL;
  v13 = 0LL;
  v14 = 0;
  while ( 1 )
  {
    v15 = *(_BYTE *)(v12 - 1);
    if ( v14 == 63 && (unsigned __int8)v15 >= 2u )
    {
      v16 = 6LL;
      goto LABEL_15;
    }
    v13 |= (unsigned __int64)(v15 & 0x7F) << v14;
    if ( v15 >= 0 )
      break;
    v14 += 7;
    ++v12;
    v6 = result-- != 0;
    if ( !v6 )
    {
      v16 = 19LL;
LABEL_15:
      *(_QWORD *)a2 = 1LL;
      *(_QWORD *)(a2 + 8) = 0LL;
      *(_QWORD *)(a2 + 88) = 0LL;
      *(_QWORD *)(a2 + 32) = 0LL;
      *a1 = v16;
      a1[1] = v11;
      return result;
    }
  }
  *(_QWORD *)a2 = v12;
  *(_QWORD *)(a2 + 8) = result;
  if ( v13 )
  {
    if ( v13 - 1 >= v9[2] )
    {
      v11 = v9[3];
      v16 = 18LL;
      if ( v11 )
      {
        v27 = v9[4];
        while ( 1 )
        {
          v35 = *(unsigned __int16 *)(v11 + 1330);
          v28 = (unsigned int)(8 * v35);
          v29 = -1LL;
          do
          {
            if ( !v28 )
            {
              v29 = v35;
              goto LABEL_45;
            }
            v30 = *(_QWORD *)(v11 + 8 * v29 + 1248) != v13;
            if ( *(_QWORD *)(v11 + 8 * v29 + 1248) > v13 )
              v30 = -1;
            ++v29;
            v28 -= 8LL;
          }
          while ( v30 == 1 );
          if ( !v30 )
          {
            v26 = 112 * v29 + v11;
            goto LABEL_47;
          }
LABEL_45:
          v6 = v27-- == 0;
          if ( v6 )
            break;
          v11 = *(_QWORD *)(v11 + 8 * v29 + 1336);
        }
      }
      goto LABEL_15;
    }
    v26 = v9[1] + 112 * (v13 - 1);
LABEL_47:
    *(_QWORD *)(a2 + 88) = *(_BYTE *)(v26 + 106) == 1;
    *(_QWORD *)(a2 + 32) = v12;
    *(_QWORD *)(a2 + 40) = result;
    *(_QWORD *)(a2 + 48) = v26;
    *(_QWORD *)(a2 + 56) = v8;
    *(_QWORD *)(a2 + 64) = v10;
    *(_QWORD *)(a2 + 72) = 0LL;
  }
  else
  {
    *(_QWORD *)(a2 + 88) = -1LL;
    *(_QWORD *)(a2 + 32) = 0LL;
  }
  *(_WORD *)a1 = 331;
  return result;
}
// 446D68: using guessed type char *off_446D68;

//----- (000000000042B0A0) ----------------------------------------------------
void __fastcall sub_42B0A0(char *lpMem, __int64 a2, unsigned __int64 a3)
{
  __int64 v3; // rdi
  LPVOID *v5; // rbx
  HANDLE ProcessHeap; // rax

  if ( a2 )
  {
    v3 = a2;
    v5 = (LPVOID *)(lpMem + 432);
    do
    {
      if ( !_InterlockedDecrement64((volatile signed __int64 *)*(v5 - 11)) )
        sub_41D140(*(v5 - 11), a2, a3);
      sub_41D230((__int64)(v5 - 42));
      v5 += 54;
      --v3;
    }
    while ( v3 );
    ProcessHeap = GetProcessHeap();
    HeapFree(ProcessHeap, 0, lpMem);
  }
}
// 42B0F6: variable 'a2' is possibly undefined
// 42B0F6: variable 'a3' is possibly undefined

//----- (000000000042B180) ----------------------------------------------------
unsigned __int64 __fastcall sub_42B180(__int64 *a1, __int64 a2, unsigned __int64 a3)
{
  __int64 v3; // rdx
  __int64 v4; // rax
  __int64 v5; // rcx
  __int64 v6; // rdx
  unsigned __int64 v7; // r8
  unsigned __int64 result; // rax
  unsigned __int64 v9; // rax
  _QWORD v10[9]; // [rsp+20h] [rbp-60h] BYREF
  unsigned __int64 v11[2]; // [rsp+68h] [rbp-18h] BYREF
  __int64 v12; // [rsp+78h] [rbp-8h]

  v3 = *a1;
  if ( *a1 )
  {
    a3 = a1[1];
    v4 = a1[2];
    v10[1] = 0LL;
    v10[2] = v3;
    v10[3] = a3;
    v10[5] = 0LL;
    v10[6] = v3;
    v10[7] = a3;
    v5 = 1LL;
  }
  else
  {
    v5 = 0LL;
    v4 = 0LL;
  }
  v10[0] = v5;
  v10[4] = v5;
  v10[8] = v4;
  sub_42B260(v11, (__int64)v10, a3);
  for ( result = v11[0]; v11[0]; result = v11[0] )
  {
    if ( *(_BYTE *)(result + 16 * v12) == 75 )
    {
      v9 = 16 * v12 + result;
      if ( !_InterlockedDecrement64(*(volatile signed __int64 **)(v9 + 8)) )
        sub_41D140(*(LPVOID *)(v9 + 8), v6, v7);
    }
    sub_42B260(v11, (__int64)v10, v7);
  }
  return result;
}
// 42B206: variable 'v7' is possibly undefined
// 42B233: variable 'v6' is possibly undefined

//----- (000000000042B260) ----------------------------------------------------
int __fastcall sub_42B260(unsigned __int64 *a1, __int64 a2, unsigned __int64 a3)
{
  __int64 v4; // rax
  unsigned __int64 v5; // rdi
  unsigned __int64 v6; // rbx
  unsigned __int64 v7; // r14
  unsigned __int64 v8; // rax
  unsigned __int64 v9; // r15
  unsigned __int64 v10; // r9
  __int64 v11; // rcx
  unsigned __int64 v12; // r9
  _QWORD *v13; // rdi
  unsigned __int64 v14; // r8
  bool v15; // zf
  _QWORD *v16; // rax
  _QWORD *v17; // rbx
  HANDLE v18; // rax
  unsigned __int64 v19; // rcx
  unsigned __int64 v20; // r9
  __int64 v21; // r12
  HANDLE v22; // rax
  unsigned __int64 v23; // rcx
  unsigned __int64 v24; // rdx
  HANDLE v25; // rax
  HANDLE ProcessHeap; // rax

  v4 = *(_QWORD *)(a2 + 64);
  if ( v4 )
  {
    *(_QWORD *)(a2 + 64) = v4 - 1;
    if ( *(_DWORD *)a2 != 1 )
      sub_407050((__int64)&off_447CE8);
    v5 = *(_QWORD *)(a2 + 8);
    if ( v5 )
    {
      v6 = *(_QWORD *)(a2 + 16);
      v7 = *(_QWORD *)(a2 + 24);
      v8 = *(unsigned __int16 *)(v5 + 274);
      if ( v7 < v8 )
        goto LABEL_5;
    }
    else
    {
      v5 = *(_QWORD *)(a2 + 16);
      a3 = *(_QWORD *)(a2 + 24);
      if ( a3 )
      {
        v19 = *(_QWORD *)(a2 + 24);
        v20 = v19 & 7;
        if ( (a3 & 7) != 0 )
        {
          v19 = a3 & 0xFFFFFFFFFFFFFFF8uLL;
          do
          {
            v5 = *(_QWORD *)(v5 + 280);
            --v20;
          }
          while ( v20 );
        }
        if ( a3 >= 8 )
        {
          do
          {
            a3 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 280) + 280LL)
                                                                           + 280LL)
                                                               + 280LL)
                                                   + 280LL)
                                       + 280LL)
                           + 280LL);
            v5 = *(_QWORD *)(a3 + 280);
            v19 -= 8LL;
          }
          while ( v19 );
        }
      }
      *(_QWORD *)a2 = 1LL;
      *(_QWORD *)(a2 + 8) = v5;
      *(_OWORD *)(a2 + 16) = 0LL;
      v7 = 0LL;
      v6 = 0LL;
      LODWORD(v8) = *(unsigned __int16 *)(v5 + 274);
      if ( *(_WORD *)(v5 + 274) )
      {
LABEL_5:
        v9 = v5;
        v10 = v7 + 1;
        if ( v6 )
        {
LABEL_6:
          v11 = v9 + 8 * v10 + 280;
          v12 = v6 & 7;
          if ( (v6 & 7) != 0 )
          {
            v8 = v6 & 0xFFFFFFFFFFFFFFF8uLL;
            do
            {
              a3 = *(_QWORD *)v11;
              v11 = *(_QWORD *)v11 + 280LL;
              --v12;
            }
            while ( v12 );
            v10 = 0LL;
            if ( v6 < 8 )
              goto LABEL_30;
            goto LABEL_29;
          }
          v8 = v6;
          v10 = 0LL;
          if ( v6 >= 8 )
          {
            do
            {
LABEL_29:
              a3 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)v11 + 280LL)
                                                                                         + 280LL)
                                                                             + 280LL)
                                                                 + 280LL)
                                                     + 280LL)
                                         + 280LL)
                             + 280LL);
              v11 = a3 + 280;
              v8 -= 8LL;
            }
            while ( v8 );
          }
LABEL_30:
          *(_QWORD *)(a2 + 8) = a3;
          *(_QWORD *)(a2 + 16) = 0LL;
          *(_QWORD *)(a2 + 24) = v10;
          *a1 = v9;
          a1[1] = v6;
          a1[2] = v7;
          return v8;
        }
LABEL_27:
        a3 = v9;
        goto LABEL_30;
      }
    }
    v21 = a2;
    do
    {
      v9 = *(_QWORD *)(v5 + 176);
      if ( !v9 )
      {
        ProcessHeap = GetProcessHeap();
        HeapFree(ProcessHeap, 0, (LPVOID)v5);
        sub_407050((__int64)&off_447CD0);
      }
      ++v6;
      v7 = *(unsigned __int16 *)(v5 + 272);
      v22 = GetProcessHeap();
      LODWORD(v8) = HeapFree(v22, 0, (LPVOID)v5);
      v5 = v9;
    }
    while ( (unsigned __int16)v7 >= *(_WORD *)(v9 + 274) );
    a2 = v21;
    v10 = v7 + 1;
    if ( v6 )
      goto LABEL_6;
    goto LABEL_27;
  }
  v13 = *(_QWORD **)(a2 + 8);
  v8 = *(_QWORD *)(a2 + 16);
  v14 = *(_QWORD *)(a2 + 24);
  v15 = *(_QWORD *)a2 == 0LL;
  *(_QWORD *)a2 = 0LL;
  if ( !v15 )
  {
    if ( !v13 )
    {
      if ( v14 )
      {
        v23 = v14;
        v24 = v14 & 7;
        if ( (v14 & 7) != 0 )
        {
          v23 = v14 & 0xFFFFFFFFFFFFFFF8uLL;
          do
          {
            v8 = *(_QWORD *)(v8 + 280);
            --v24;
          }
          while ( v24 );
        }
        v13 = (_QWORD *)v8;
        if ( v14 >= 8 )
        {
          v13 = (_QWORD *)v8;
          do
          {
            v13 = *(_QWORD **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v13[35] + 280LL)
                                                                                         + 280LL)
                                                                             + 280LL)
                                                                 + 280LL)
                                                     + 280LL)
                                         + 280LL)
                             + 280LL);
            v23 -= 8LL;
          }
          while ( v23 );
        }
      }
      else
      {
        v13 = (_QWORD *)v8;
      }
    }
    v16 = (_QWORD *)v13[22];
    if ( v16 )
    {
      do
      {
        v17 = v16;
        v18 = GetProcessHeap();
        HeapFree(v18, 0, v13);
        v16 = (_QWORD *)v17[22];
        v13 = v17;
      }
      while ( v16 );
    }
    else
    {
      v17 = v13;
    }
    v25 = GetProcessHeap();
    LODWORD(v8) = HeapFree(v25, 0, v17);
  }
  *a1 = 0LL;
  return v8;
}
// 42B4D1: variable 'a3' is possibly undefined
// 447CD0: using guessed type char *off_447CD0;
// 447CE8: using guessed type char *off_447CE8;

//----- (000000000042B5E0) ----------------------------------------------------
unsigned __int64 __fastcall sub_42B5E0(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  __int64 v4; // rdx
  unsigned __int64 v5; // r8
  unsigned __int64 result; // rax
  unsigned __int64 v7; // rax
  __int64 v8; // [rsp+0h] [rbp-40h] BYREF
  unsigned __int64 v9; // [rsp+28h] [rbp-18h] BYREF
  __int64 v10; // [rsp+38h] [rbp-8h]

  sub_42B260((unsigned __int64 *)&v8 + 5, a1, a3);
  for ( result = v9; v9; result = v9 )
  {
    if ( *(_BYTE *)(result + 16 * v10) == 75 )
    {
      v7 = 16 * v10 + result;
      if ( !_InterlockedDecrement64(*(volatile signed __int64 **)(v7 + 8)) )
        sub_41D140(*(LPVOID *)(v7 + 8), v4, v5);
    }
    sub_42B260(&v9, a1, v5);
  }
  return result;
}
// 42B616: variable 'v5' is possibly undefined
// 42B643: variable 'v4' is possibly undefined

//----- (000000000042B660) ----------------------------------------------------
void __fastcall sub_42B660(__int128 *a1, unsigned __int64 a2, _OWORD *a3, size_t a4, char a5)
{
  _OWORD *v5; // r12
  unsigned __int64 v6; // rax
  __int64 v7; // rax
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // r15
  unsigned __int64 v10; // r13
  unsigned __int64 v11; // r11
  unsigned __int64 v12; // r14
  __int64 v13; // rax
  __int128 *v14; // rcx
  unsigned __int64 v15; // rdi
  unsigned __int64 v16; // rsi
  unsigned __int64 v17; // rcx
  unsigned __int64 v18; // rcx
  unsigned __int64 v19; // rcx
  unsigned __int64 v20; // rdi
  unsigned __int64 v21; // rdx
  __int64 v22; // rcx
  __int128 *v23; // r8
  __int128 *v24; // r10
  __int128 v25; // xmm0
  __int128 v26; // xmm0
  __int64 v27; // r10
  unsigned __int64 v28; // rbx
  __int128 *v29; // r10
  unsigned __int64 v30; // r11
  unsigned __int64 v31; // r9
  unsigned __int64 v32; // rsi
  __int128 *v33; // r10
  unsigned __int64 v34; // r11
  unsigned __int64 v35; // rsi
  unsigned __int64 v36; // rax
  unsigned __int64 v37; // rcx
  __int128 *v38; // r13
  char *v39; // rdx
  unsigned __int64 v40; // rbx
  unsigned __int64 v41; // rsi
  unsigned __int64 v42; // r14
  size_t v43; // rdi
  unsigned __int64 v44; // rax
  unsigned __int64 v45; // rax
  size_t v46; // r12
  __int128 *v47; // rbx
  __int128 *v48; // rdx
  char *v49; // r15
  __int128 *v50; // rax
  char *v51; // r11
  char *v52; // rdx
  unsigned __int64 v53; // r8
  BOOL v54; // r9d
  BOOL v55; // r10d
  __int128 v56; // xmm0
  __int128 *v57; // r10
  __int128 *v58; // r8
  int v59; // eax
  bool v60; // cl
  BOOL v61; // edx
  __int128 *v62; // r9
  __int128 v63; // xmm0
  unsigned __int64 v64; // rax
  _QWORD v65[75]; // [rsp+30h] [rbp-50h]
  unsigned __int64 v66; // [rsp+288h] [rbp+208h]
  __int128 *v67; // [rsp+290h] [rbp+210h]
  __int128 *v68; // [rsp+298h] [rbp+218h]
  __int128 *v69; // [rsp+2A0h] [rbp+220h]
  __int128 *v70; // [rsp+2A8h] [rbp+228h]
  __int128 *v71; // [rsp+2B0h] [rbp+230h]
  unsigned __int64 v72; // [rsp+2B8h] [rbp+238h]
  unsigned __int64 v73; // [rsp+2C0h] [rbp+240h]
  __int128 *v74; // [rsp+2C8h] [rbp+248h]
  unsigned __int64 v75; // [rsp+2D0h] [rbp+250h]
  unsigned __int64 v76; // [rsp+2D8h] [rbp+258h]
  unsigned __int64 v77; // [rsp+2E0h] [rbp+260h]
  unsigned __int64 v78; // [rsp+2E8h] [rbp+268h]
  size_t v79; // [rsp+2F0h] [rbp+270h]
  __int128 *v80; // [rsp+2F8h] [rbp+278h]
  void *Src; // [rsp+300h] [rbp+280h]

  v5 = a3;
  v80 = a1;
  if ( (a2 | (a2 + 0x3FFFFFFFFFFFFFFFLL)) >> 32 )
    v6 = (a2 + 0x3FFFFFFFFFFFFFFFLL) / a2;
  else
    v6 = ((int)a2 - 1) / (unsigned int)a2;
  v73 = v6;
  v77 = a2;
  if ( a2 >= 0x1001 )
  {
    _BitScanReverse64(&v8, a2 | 1);
    v78 = ((1LL << ((((unsigned int)v8 ^ 0xFFFFFFC0) + 65) >> 1)) + (a2 >> ((((unsigned int)v8 ^ 0xFFFFFFC0) + 65) >> 1))) >> 1;
  }
  else
  {
    v7 = 64LL;
    if ( a2 - (a2 >> 1) < 0x40 )
      v7 = a2 - (a2 >> 1);
    v78 = v7;
  }
  v74 = v80 + 4;
  v70 = v80 + 1;
  v71 = v80 - 1;
  v69 = v80 - 2;
  v9 = 1LL;
  v10 = 0LL;
  v11 = 0LL;
  v79 = a4;
  Src = a3;
  v12 = v77;
  if ( !v77 )
    goto LABEL_15;
LABEL_10:
  v13 = 2 * v10;
  v14 = &v80[2 * v10];
  if ( v12 < v78 )
    goto LABEL_11;
  if ( v12 < 2 )
  {
    v17 = 2 * v12 + 1;
    goto LABEL_43;
  }
  v20 = *((_QWORD *)v14 + 4);
  if ( v20 >= *(_QWORD *)v14 )
  {
    v27 = 2LL;
    if ( v12 == 2 )
      goto LABEL_42;
    v28 = v11;
    v29 = &v74[v13];
    v21 = 2LL;
    v30 = *((_QWORD *)v14 + 4);
    v31 = v12;
    while ( 1 )
    {
      v32 = v30;
      v30 = *(_QWORD *)v29;
      if ( *(_QWORD *)v29 < v32 )
        break;
      ++v21;
      v29 += 2;
      if ( v12 == v21 )
      {
LABEL_36:
        v21 = v31;
        break;
      }
    }
  }
  else
  {
    if ( v12 == 2 )
    {
      v21 = 2LL;
      v22 = 1LL;
      goto LABEL_25;
    }
    v28 = v11;
    v33 = &v74[v13];
    v21 = 2LL;
    v34 = *((_QWORD *)v14 + 4);
    v31 = v12;
    while ( 1 )
    {
      v35 = v34;
      v34 = *(_QWORD *)v33;
      if ( *(_QWORD *)v33 >= v35 )
        break;
      ++v21;
      v33 += 2;
      if ( v12 == v21 )
        goto LABEL_36;
    }
  }
  a4 = v79;
  v11 = v28;
  if ( v21 >= v78 )
  {
    if ( v20 >= *(_QWORD *)v14 )
    {
LABEL_41:
      v27 = v21;
      goto LABEL_42;
    }
    v27 = 1LL;
    if ( v21 >= 2 )
    {
      v22 = v21 >> 1;
LABEL_25:
      v23 = &v70[v13];
      v24 = &v71[2 * v21 + v13];
      do
      {
        v25 = *(v23 - 1);
        *(v23 - 1) = *(v24 - 1);
        *(v24 - 1) = v25;
        v26 = *v23;
        *v23 = *v24;
        *v24 = v26;
        v23 += 2;
        v24 -= 2;
        --v22;
      }
      while ( v22 );
      goto LABEL_41;
    }
LABEL_42:
    v17 = 2 * v27 + 1;
    goto LABEL_43;
  }
LABEL_11:
  if ( a5 )
  {
    v15 = v12;
    if ( v12 >= 0x20 )
      v15 = 32LL;
    v16 = v11;
    sub_42BD50(v14, v15, v5, a4, 0, 0LL);
    v11 = v16;
    a4 = v79;
    v17 = 2LL * (unsigned int)v15 + 1;
  }
  else
  {
    v19 = v12;
    if ( v78 < v12 )
      v19 = v78;
    v17 = 2 * v19;
  }
LABEL_43:
  v72 = v17;
  v36 = (v73 * (2 * v10 - (v9 >> 1))) ^ (v73 * ((v17 >> 1) + 2 * v10));
  if ( !v36 )
  {
    v18 = 64LL;
    if ( v11 < 2 )
      goto LABEL_84;
    goto LABEL_47;
  }
  _BitScanReverse64(&v37, v36);
  v18 = v37 ^ 0x3F;
  if ( v11 >= 2 )
  {
LABEL_47:
    v68 = &v80[2 * v10];
    v67 = &v69[2 * v10];
    v76 = v18;
    v66 = v10;
    while ( 1 )
    {
      while ( 1 )
      {
        if ( *((_BYTE *)&v65[66] + v11 + 5) < (unsigned __int8)v18 )
          goto LABEL_84;
        v40 = v65[--v11];
        v41 = v40 >> 1;
        v42 = v9 >> 1;
        v43 = (v40 >> 1) + (v9 >> 1);
        if ( v43 > a4 || (((unsigned __int8)v9 | (unsigned __int8)v40) & 1) != 0 )
          break;
        v9 = 2 * v43;
        if ( v11 <= 1 )
        {
LABEL_83:
          v11 = 1LL;
          goto LABEL_84;
        }
      }
      v38 = &v80[2 * (v10 - v43)];
      v75 = v11;
      if ( (v40 & 1) != 0 )
      {
        if ( (v9 & 1) != 0 )
          goto LABEL_58;
      }
      else
      {
        _BitScanReverse64(&v44, v41 | 1);
        sub_42BD50(v38, v41, v5, a4, (2 * (v44 ^ 0x3F)) ^ 0x7E, 0LL);
        LOBYTE(v18) = v76;
        v11 = v75;
        a4 = v79;
        if ( (v9 & 1) != 0 )
        {
LABEL_58:
          if ( v9 >= 2 )
            goto LABEL_62;
          goto LABEL_50;
        }
      }
      _BitScanReverse64(&v45, v42 | 1);
      sub_42BD50(&v38[2 * v41], v9 >> 1, v5, a4, (2 * (v45 ^ 0x3F)) ^ 0x7E, 0LL);
      LOBYTE(v18) = v76;
      v11 = v75;
      a4 = v79;
      if ( v9 >= 2 )
      {
LABEL_62:
        if ( v40 >= 2 )
        {
          v46 = v9 >> 1;
          if ( v41 < v42 )
            v46 = v40 >> 1;
          if ( v46 <= a4 )
          {
            v47 = &v38[2 * v41];
            v48 = v38;
            if ( v42 < v41 )
              v48 = &v38[2 * v41];
            memcpy(Src, v48, 32 * v46);
            v49 = (char *)Src + 32 * v46;
            if ( v42 >= v41 )
            {
              if ( v46 )
              {
                v39 = (char *)Src;
                v57 = v68;
                do
                {
                  v58 = (__int128 *)v39;
                  v59 = 0;
                  v60 = *(_QWORD *)v47 < *(_QWORD *)v39;
                  v61 = *(_QWORD *)v47 >= *(_QWORD *)v39;
                  v62 = v58;
                  if ( *(_QWORD *)v47 < *(_QWORD *)v58 )
                    v62 = v47;
                  v63 = *v62;
                  v38[1] = v62[1];
                  *v38 = v63;
                  v39 = (char *)v58 + (unsigned int)(32 * v61);
                  v38 += 2;
                  if ( v39 == v49 )
                    break;
                  LOBYTE(v59) = v60;
                  v47 = (__int128 *)((char *)v47 + (unsigned int)(32 * v59));
                }
                while ( v47 != v57 );
              }
              else
              {
                v39 = (char *)Src;
              }
            }
            else
            {
              v50 = v67;
              v51 = (char *)Src;
              do
              {
                v52 = v49 - 32;
                v53 = *((_QWORD *)v49 - 4);
                v54 = v53 < *((_QWORD *)v47 - 4);
                v55 = v53 >= *((_QWORD *)v47 - 4);
                if ( v53 < *((_QWORD *)v47 - 4) )
                  v52 = (char *)(v47 - 2);
                v56 = *(_OWORD *)v52;
                v50[1] = *((_OWORD *)v52 + 1);
                *v50 = v56;
                v47 = (__int128 *)((char *)v47 + (unsigned int)(32 * v55) - 32);
                v49 = &v49[32 * v54 - 32];
                if ( v47 == v38 )
                  break;
                v50 -= 2;
              }
              while ( v49 != v51 );
              v38 = v47;
              v39 = v51;
            }
            memcpy(v38, v39, v49 - v39);
            a4 = v79;
            v11 = v75;
            LOBYTE(v18) = v76;
          }
        }
      }
LABEL_50:
      v9 = 2 * v43 + 1;
      v5 = Src;
      v10 = v66;
      if ( v11 <= 1 )
        goto LABEL_83;
    }
  }
LABEL_84:
  while ( 1 )
  {
    v65[v11] = v9;
    *((_BYTE *)&v65[66] + v11 + 6) = v18;
    if ( v77 <= v10 )
      break;
    ++v11;
    v9 = v72;
    v10 += v72 >> 1;
    v12 = v77 - v10;
    if ( v77 > v10 )
      goto LABEL_10;
LABEL_15:
    v18 = 0LL;
    v72 = 1LL;
    if ( v11 >= 2 )
      goto LABEL_47;
  }
  if ( (v9 & 1) == 0 )
  {
    _BitScanReverse64(&v64, v77 | 1);
    sub_42BD50(v80, v77, v5, a4, (2 * (v64 ^ 0x3F)) ^ 0x7E, 0LL);
  }
}

//----- (000000000042BD50) ----------------------------------------------------
void __fastcall sub_42BD50(__int128 *a1, unsigned __int64 a2, _OWORD *a3, size_t a4, int a5, __int64 a6)
{
  unsigned __int64 v7; // rbx
  size_t v8; // r15
  unsigned __int64 v10; // r14
  int v11; // edi
  _BYTE *v12; // rdi
  char *v13; // r12
  _QWORD *v14; // r8
  bool v15; // dl
  unsigned __int64 v16; // r10
  __int128 v17; // xmm0
  _OWORD *v18; // rdi
  char *v19; // r11
  char *v20; // rax
  _OWORD *v21; // rcx
  unsigned __int64 i; // rdx
  char *j; // r8
  bool v24; // cf
  _OWORD *v25; // r9
  __int128 v26; // xmm0
  __int64 v27; // rdx
  __int128 v28; // xmm0
  __int64 v29; // r13
  unsigned __int64 v30; // rdx
  __int64 v31; // rax
  _OWORD *v32; // r8
  __int128 *v33; // r15
  __int64 v34; // r9
  __int128 v35; // xmm0
  __int64 v36; // r9
  __int128 v37; // xmm1
  char *v38; // rcx
  __int64 v39; // r8
  __int64 v40; // rax
  __int128 v41; // xmm0
  _OWORD *v42; // rcx
  unsigned __int64 v43; // r13
  char *v44; // rax
  _OWORD *v45; // rdi
  char *k; // rdx
  bool v47; // cf
  _OWORD *v48; // r8
  __int128 v49; // xmm0
  __int64 v50; // rdx
  __int128 v51; // xmm0
  __int64 v52; // r12
  __int64 v53; // rax
  _OWORD *v54; // rdx
  __int128 *v55; // r15
  __int64 v56; // r8
  __int128 v57; // xmm0
  __int64 v58; // r8
  __int128 v59; // xmm1
  char *v60; // rcx
  __int64 v61; // rdx
  __int64 v62; // rax
  __int128 v63; // xmm0
  unsigned __int64 v64; // r15
  __int64 v65; // r10
  __int64 v66; // r12
  unsigned __int64 *v67; // rdx
  __int64 v68; // r8
  __int64 v69; // r9
  unsigned __int64 v70; // rax
  unsigned __int64 v71; // rdi
  unsigned __int64 v72; // r11
  __int128 *v73; // r14
  bool v74; // cf
  __int128 *v75; // r10
  __int64 v76; // r9
  __int128 *v77; // rdi
  unsigned __int64 v78; // rax
  BOOL v79; // r13d
  BOOL v80; // r12d
  BOOL v81; // r15d
  __int64 v82; // r12
  char *v83; // r11
  __int64 v84; // r14
  __int64 v85; // r15
  unsigned __int64 v86; // rcx
  __int128 *v87; // r13
  __int128 *v88; // rdx
  bool v89; // cf
  __int128 v90; // xmm0
  __int64 v91; // rax
  __int128 v92; // xmm1
  __int128 v93; // xmm3
  __int128 v94; // xmm4
  __int128 v95; // xmm5
  __int128 v96; // xmm6
  __int128 *v97; // rax
  __int128 v98; // xmm7
  __int128 v99; // xmm8
  __int128 v100; // xmm9
  __int128 v101; // xmm10
  __int128 v102; // xmm11
  __int128 v103; // xmm12
  __int128 v104; // xmm13
  __int128 v105; // xmm14
  __int128 v106; // xmm15
  unsigned __int64 v107; // rdx
  unsigned __int64 v108; // r14
  __int128 v109; // xmm0
  __int64 v110; // rax
  __int128 v111; // xmm0
  __int64 v112; // r8
  unsigned __int64 v113; // r9
  char *v114; // rax
  __int64 v115; // rax
  __int128 v116; // xmm1
  unsigned __int64 v117; // r10
  __int128 *v118; // rax
  __int64 v119; // r11
  __int128 v120; // xmm0
  __int64 v121; // rax
  __int128 *v122; // r8
  __int128 *v123; // r9
  __int64 v124; // r10
  char *v125; // rax
  __int64 v126; // rax
  __int128 v127; // xmm1
  unsigned __int64 v128; // r11
  __int128 *v129; // rax
  __int64 v130; // rdi
  __int128 v131; // xmm0
  __int64 v132; // rax
  __int128 *v133; // r14
  __int128 *v134; // rdx
  __int128 *v135; // r11
  __int128 *v136; // r9
  __int128 *v137; // r10
  __int128 v138; // xmm0
  int v139; // edi
  int v140; // r15d
  __int128 *v141; // rcx
  __int128 v142; // xmm0
  __int64 v143; // r12
  __int128 *v144; // rcx
  bool v145; // cf
  __int128 *v146; // r14
  BOOL v147; // eax
  __int128 *v148; // r11
  __int128 v149; // xmm0
  _OWORD v150[2]; // [rsp+30h] [rbp-50h] BYREF
  _OWORD *v151; // [rsp+58h] [rbp-28h]
  __int128 v152; // [rsp+60h] [rbp-20h] BYREF
  __int64 v153; // [rsp+70h] [rbp-10h]
  __int128 v154; // [rsp+78h] [rbp-8h]
  _OWORD *v155; // [rsp+90h] [rbp+10h]
  size_t Size; // [rsp+98h] [rbp+18h]
  __int128 *v157; // [rsp+A0h] [rbp+20h]
  unsigned __int64 v158; // [rsp+A8h] [rbp+28h]
  __int64 v159; // [rsp+B0h] [rbp+30h]
  void *v160; // [rsp+B8h] [rbp+38h]

  v7 = a2;
  if ( a2 >= 0x21 )
  {
    v8 = a4;
    v159 = a6;
    v155 = a3 - 2;
    Size = a4;
    do
    {
      v160 = a1;
      v151 = a1 + 2;
      v10 = v7;
      while ( 1 )
      {
        v24 = a5 == 0;
        v11 = a5 - 1;
        if ( v24 )
        {
          sub_42B660((_DWORD)v160, v10, (_DWORD)a3, v8, 1);
          return;
        }
        LODWORD(v158) = v11;
        v12 = v160;
        v13 = (char *)v160 + 128 * (v10 >> 3);
        v14 = (char *)v160 + 224 * (v10 >> 3);
        if ( v10 >= 0x40 )
        {
          v13 = (char *)sub_42C7C0(v160, (_QWORD *)v160 + 16 * (v10 >> 3), v14, v10 >> 3);
        }
        else
        {
          v15 = *(_QWORD *)v160 < *(_QWORD *)v13;
          if ( v15 != *(_QWORD *)v13 < *v14 )
            v13 = (char *)v160 + 224 * (v10 >> 3);
          if ( v15 != *(_QWORD *)v160 < *v14 )
            v13 = (char *)v160;
        }
        v16 = (unsigned __int64)(v13 - v12) >> 5;
        v17 = *(_OWORD *)v13;
        v150[1] = *((_OWORD *)v13 + 1);
        v150[0] = v17;
        if ( v159 )
        {
          if ( *(_QWORD *)v159 >= *(_QWORD *)v13 )
            break;
        }
        if ( v10 > v8 )
          goto LABEL_115;
        v18 = &a3[2 * v10];
        v7 = 0LL;
        v19 = (char *)v160;
        v20 = (char *)v160;
        v21 = v18;
        v157 = (__int128 *)v16;
        for ( i = v16; ; i = v10 )
        {
          for ( j = &v19[32 * i]; v20 < j; v20 += 32 )
          {
            v21 -= 2;
            v24 = *(_QWORD *)v20 < *(_QWORD *)v13;
            v25 = v21;
            if ( *(_QWORD *)v20 < *(_QWORD *)v13 )
              v25 = a3;
            v26 = *(_OWORD *)v20;
            v25[2 * v7 + 1] = *((_OWORD *)v20 + 1);
            v25[2 * v7] = v26;
            v7 += v24;
          }
          if ( i == v10 )
            break;
          v27 = 2 * v7;
          v28 = *(_OWORD *)v20;
          v21[v27 - 1] = *((_OWORD *)v20 + 1);
          v21[v27 - 2] = v28;
          v21 -= 2;
          v20 += 32;
        }
        v29 = 32 * v7;
        memcpy(v19, a3, 32 * v7);
        v30 = v10 - v7;
        if ( v10 != v7 )
        {
          if ( v10 == v7 + 1 )
          {
            v31 = 0LL;
          }
          else
          {
            v32 = &v151[(unsigned __int64)v29 / 0x10];
            v33 = &v155[2 * v10];
            v34 = 0LL;
            do
            {
              v35 = *v33;
              *(v32 - 1) = v33[1];
              *(v32 - 2) = v35;
              v31 = v34 + 2;
              v36 = 2 * (v34 ^ 0x7FFFFFFFFFFFFFELL);
              v37 = v18[v36 + 1];
              *v32 = v18[v36];
              v32[1] = v37;
              v32 += 4;
              v33 -= 4;
              v34 = v31;
            }
            while ( (v30 & 0xFFFFFFFFFFFFFFFEuLL) != v31 );
          }
          if ( (v30 & 1) != 0 )
          {
            v38 = (char *)v160 + v29;
            v39 = 2 * ~v31;
            v40 = 32 * v31;
            v41 = v18[v39];
            *(_OWORD *)&v38[v40 + 16] = v18[v39 + 1];
            *(_OWORD *)&v38[v40] = v41;
          }
        }
        v8 = Size;
        v16 = (unsigned __int64)v157;
        if ( !v7 )
          break;
        if ( v10 < v7 )
        {
          *(_QWORD *)&v152 = &off_4479E0;
          *((_QWORD *)&v152 + 1) = 1LL;
          v153 = 8LL;
          v154 = 0LL;
          sub_405240(&v152, &off_447A50);
        }
        a5 = v158;
        sub_42BD50((_DWORD)v160 + v29, v30, (_DWORD)a3, Size, v158, (__int64)v150);
        v10 = v7;
        if ( v7 < 0x21 )
        {
          a1 = (__int128 *)v160;
          goto LABEL_52;
        }
      }
      if ( v10 > v8 )
LABEL_115:
        BUG();
      v42 = &a3[2 * v10];
      v43 = 0LL;
      v44 = (char *)v160;
      v45 = v42;
      while ( 1 )
      {
        for ( k = (char *)v160 + 32 * v16; v44 < k; v44 += 32 )
        {
          v42 -= 2;
          v47 = *(_QWORD *)v13 < *(_QWORD *)v44;
          v48 = v42;
          if ( *(_QWORD *)v13 >= *(_QWORD *)v44 )
            v48 = a3;
          v49 = *(_OWORD *)v44;
          v48[2 * v43 + 1] = *((_OWORD *)v44 + 1);
          v48[2 * v43] = v49;
          v43 -= v47 - 1LL;
        }
        if ( v16 == v10 )
          break;
        v42 -= 2;
        v50 = 2 * v43;
        v51 = *(_OWORD *)v44;
        a3[v50 + 1] = *((_OWORD *)v44 + 1);
        a3[v50] = v51;
        ++v43;
        v44 += 32;
        v16 = v10;
      }
      v52 = 32 * v43;
      memcpy(v160, a3, 32 * v43);
      v7 = v10 - v43;
      if ( v10 != v43 )
      {
        if ( v10 == v43 + 1 )
        {
          v53 = 0LL;
        }
        else
        {
          v54 = (char *)v160 + v52 + 32;
          v55 = &v155[2 * v10];
          v56 = 0LL;
          do
          {
            v57 = *v55;
            *(v54 - 1) = v55[1];
            *(v54 - 2) = v57;
            v53 = v56 + 2;
            v58 = 2 * (v56 ^ 0x7FFFFFFFFFFFFFELL);
            v59 = v45[v58 + 1];
            *v54 = v45[v58];
            v54[1] = v59;
            v54 += 4;
            v55 -= 4;
            v56 = v53;
          }
          while ( (v7 & 0xFFFFFFFFFFFFFFFEuLL) != v53 );
        }
        if ( (v7 & 1) != 0 )
        {
          v60 = (char *)v160 + v52;
          v61 = 2 * ~v53;
          v62 = 32 * v53;
          v63 = v45[v61];
          *(_OWORD *)&v60[v62 + 16] = v45[v61 + 1];
          *(_OWORD *)&v60[v62] = v63;
        }
      }
      if ( v10 < v43 )
        sub_4050A0(v43, v10, (__int64)&off_447A68);
      a1 = (__int128 *)((char *)v160 + v52);
      v159 = 0LL;
      v8 = Size;
      a5 = v158;
    }
    while ( v7 >= 0x21 );
  }
LABEL_52:
  if ( v7 >= 2 )
  {
    v64 = v7 >> 1;
    v160 = a1;
    if ( v7 < 8 )
    {
      v109 = *a1;
      a3[1] = a1[1];
      *a3 = v109;
      v110 = 2 * v64;
      v111 = a1[2 * v64];
      a3[v110 + 1] = a1[2 * v64 + 1];
      a3[v110] = v111;
      v107 = 1LL;
      v108 = v7 - v64;
      if ( v64 <= 1 )
      {
LABEL_90:
        v122 = &a3[2 * v64];
        if ( v107 < v108 )
        {
          v123 = &a1[2 * v64];
          v124 = (unsigned int)(32 * v107);
          do
          {
            v126 = 2 * v107;
            v127 = v123[2 * v107 + 1];
            v122[v126] = v123[2 * v107];
            v122[v126 + 1] = v127;
            v128 = *(_QWORD *)&v122[2 * v107];
            if ( v128 < *(_QWORD *)&v122[2 * v107 - 2] )
            {
              v129 = &v123[v126];
              v153 = *((_QWORD *)v129 + 3);
              v152 = *(__int128 *)((char *)v129 + 8);
              v130 = v124;
              do
              {
                v131 = *(__int128 *)((char *)v122 + v130 - 32);
                *(__int128 *)((char *)v122 + v130 + 16) = *(__int128 *)((char *)v122 + v130 - 16);
                *(__int128 *)((char *)v122 + v130) = v131;
                if ( v130 == 32 )
                {
                  v125 = (char *)&a3[2 * v64];
                  goto LABEL_93;
                }
                v132 = v130 - 32;
                v24 = v128 < *(_QWORD *)((char *)v122 + v130 - 64);
                v130 -= 32LL;
              }
              while ( v24 );
              v125 = (char *)v122 + v132;
LABEL_93:
              *(_QWORD *)v125 = v128;
              *(_OWORD *)(v125 + 8) = v152;
              *((_QWORD *)v125 + 3) = v153;
            }
            ++v107;
            v124 += 32LL;
          }
          while ( v107 != v108 );
        }
        v133 = v122 - 2;
        v134 = &a3[2 * v7 - 2];
        Size = 32 * v7;
        v135 = &a1[2 * v7 - 2];
        v136 = a3;
        v137 = a1;
        do
        {
          v158 = v64;
          v139 = 0;
          v140 = 0;
          v141 = v122;
          v24 = *(_QWORD *)v122 < *(_QWORD *)v136;
          LOBYTE(v157) = *(_QWORD *)v122 >= *(_QWORD *)v136;
          LOBYTE(v159) = v24;
          if ( !v24 )
            v141 = v136;
          v142 = *v141;
          v137[1] = v141[1];
          *v137 = v142;
          v143 = (*(_QWORD *)v134 < *(_QWORD *)v133) - 1LL;
          v144 = v133;
          v145 = *(_QWORD *)v134 < *(_QWORD *)v133;
          if ( *(_QWORD *)v134 >= *(_QWORD *)v133 )
            v144 = v134;
          LOBYTE(v140) = v159;
          v122 = (__int128 *)((char *)v122 + (unsigned int)(32 * v140));
          LOBYTE(v139) = (_BYTE)v157;
          v136 = (__int128 *)((char *)v136 + (unsigned int)(32 * v139));
          v137 += 2;
          v138 = *v144;
          v135[1] = v144[1];
          *v135 = v138;
          v134 += 2 * v143;
          v133 -= 2 * v145;
          v135 -= 2;
          v64 = v158 - 1;
        }
        while ( v158 != 1 );
        v146 = v133 + 2;
        if ( (v7 & 1) != 0 )
        {
          v147 = v136 >= v146;
          v148 = v122;
          if ( v136 < v146 )
            v148 = v136;
          v149 = *v148;
          v137[1] = v148[1];
          *v137 = v149;
          v136 += 2 * (unsigned int)(v136 < v146);
          v122 = (__int128 *)((char *)v122 + (unsigned int)(32 * v147));
        }
        if ( v136 != v146 || v122 != v134 + 2 )
          sub_408340();
        return;
      }
    }
    else
    {
      v65 = 2 * (unsigned int)(*((_QWORD *)a1 + 4) < *(_QWORD *)a1);
      v66 = (__int64)&a1[v65];
      v67 = (unsigned __int64 *)&a1[2 * (unsigned int)(*((_QWORD *)a1 + 4) >= *(_QWORD *)a1)];
      v68 = (__int64)&a1[2 * (unsigned int)(*((_QWORD *)a1 + 12) < *((_QWORD *)a1 + 8)) + 4];
      v69 = 2 * ((*((_QWORD *)a1 + 12) < *((_QWORD *)a1 + 8)) ^ 3u);
      v70 = *(_QWORD *)v68;
      v71 = *(_QWORD *)&a1[v69];
      v72 = *v67;
      v73 = (__int128 *)v67;
      if ( v71 < *v67 )
        v73 = &a1[2 * (unsigned int)(*((_QWORD *)a1 + 12) < *((_QWORD *)a1 + 8)) + 4];
      v74 = v70 < *(_QWORD *)&a1[v65];
      if ( v70 < *(_QWORD *)&a1[v65] )
      {
        v73 = &a1[v65];
        v66 = (__int64)&a1[2 * (unsigned int)(*((_QWORD *)a1 + 12) < *((_QWORD *)a1 + 8)) + 4];
      }
      v159 = v66;
      if ( v74 )
        v68 = (__int64)v67;
      if ( v71 >= v72 )
        v67 = (unsigned __int64 *)&a1[v69];
      v157 = (__int128 *)v67;
      if ( v71 < v72 )
        v68 = (__int64)&a1[v69];
      v75 = v73;
      if ( *(_QWORD *)v68 < *(_QWORD *)v73 )
      {
        v75 = (__int128 *)v68;
        v68 = (__int64)v73;
      }
      v76 = 2 * v64;
      v77 = &a1[v76];
      v78 = *((_QWORD *)v160 + 4 * v64 + 12);
      v79 = *(_QWORD *)&a1[2 * v64 + 2] >= *((_QWORD *)v160 + 4 * v64);
      v80 = *(_QWORD *)&a1[2 * v64 + 2] < *((_QWORD *)v160 + 4 * v64);
      v158 = v7 >> 1;
      v81 = v78 < *((_QWORD *)v160 + 4 * v64 + 8);
      v82 = (unsigned int)(32 * v80);
      v83 = (char *)&a1[v76] + (unsigned int)(32 * v79);
      v84 = (__int64)&a1[v76 + 4] + (unsigned int)(32 * v81);
      v85 = 2 * (v81 ^ 3u);
      v86 = *(_QWORD *)&a1[v76 + v85];
      v87 = (__int128 *)v83;
      if ( v86 < *(_QWORD *)v83 )
        v87 = (__int128 *)v84;
      v88 = (__int128 *)((char *)v77 + v82);
      if ( *(_QWORD *)v84 < *(_QWORD *)((char *)v77 + v82) )
      {
        v87 = (__int128 *)((char *)v77 + v82);
        v88 = (__int128 *)v84;
        v84 = (__int64)v83;
      }
      v89 = v86 < *(_QWORD *)v83;
      v90 = *(_OWORD *)v159;
      v91 = (__int64)&v77[v85];
      v64 = v158;
      v92 = *v75;
      if ( v86 >= *(_QWORD *)v83 )
        v83 = (char *)v91;
      v93 = v75[1];
      if ( v89 )
        v84 = v91;
      v94 = *(_OWORD *)v68;
      v95 = *(_OWORD *)(v68 + 16);
      v96 = *v157;
      v97 = v87;
      if ( *(_QWORD *)v84 < *(_QWORD *)v87 )
        v97 = (__int128 *)v84;
      v98 = v157[1];
      if ( *(_QWORD *)v84 < *(_QWORD *)v87 )
        v84 = (__int64)v87;
      a1 = (__int128 *)v160;
      v99 = *v88;
      v100 = v88[1];
      v101 = *v97;
      v102 = v97[1];
      v103 = *(_OWORD *)v84;
      v104 = *(_OWORD *)(v84 + 16);
      v105 = *(_OWORD *)v83;
      v106 = *((_OWORD *)v83 + 1);
      a3[1] = *(_OWORD *)(v159 + 16);
      *a3 = v90;
      a3[3] = v93;
      a3[2] = v92;
      a3[5] = v95;
      a3[4] = v94;
      a3[7] = v98;
      a3[6] = v96;
      a3[v76 + 1] = v100;
      a3[v76] = v99;
      a3[v76 + 2] = v101;
      a3[v76 + 3] = v102;
      a3[v76 + 4] = v103;
      a3[v76 + 5] = v104;
      a3[v76 + 6] = v105;
      a3[v76 + 7] = v106;
      v107 = 4LL;
      v108 = v7 - v64;
      if ( v64 <= 4 )
        goto LABEL_90;
    }
    v112 = (unsigned int)(32 * v107);
    v113 = v107;
    do
    {
      v115 = 2 * v113;
      v116 = a1[2 * v113 + 1];
      a3[v115] = a1[2 * v113];
      a3[v115 + 1] = v116;
      v117 = *(_QWORD *)&a3[2 * v113];
      if ( v117 < *(_QWORD *)&a3[2 * v113 - 2] )
      {
        v118 = &a1[v115];
        v153 = *((_QWORD *)v118 + 3);
        v152 = *(__int128 *)((char *)v118 + 8);
        v119 = v112;
        do
        {
          v120 = *(_OWORD *)((char *)a3 + v119 - 32);
          *(_OWORD *)((char *)a3 + v119 + 16) = *(_OWORD *)((char *)a3 + v119 - 16);
          *(_OWORD *)((char *)a3 + v119) = v120;
          if ( v119 == 32 )
          {
            v114 = (char *)a3;
            goto LABEL_83;
          }
          v121 = v119 - 32;
          v24 = v117 < *(_QWORD *)((char *)a3 + v119 - 64);
          v119 -= 32LL;
        }
        while ( v24 );
        v114 = (char *)a3 + v121;
LABEL_83:
        *(_QWORD *)v114 = v117;
        *(_OWORD *)(v114 + 8) = v152;
        *((_QWORD *)v114 + 3) = v153;
      }
      ++v113;
      v112 += 32LL;
    }
    while ( v113 != v64 );
    goto LABEL_90;
  }
}
// 405240: using guessed type void __fastcall __noreturn sub_405240(_QWORD, _QWORD);
// 42B660: using guessed type __int64 __fastcall sub_42B660(_DWORD, _DWORD, _DWORD, _DWORD, char);
// 4479E0: using guessed type char *off_4479E0;
// 447A50: using guessed type char *off_447A50;
// 447A68: using guessed type char *off_447A68;

//----- (000000000042C7C0) ----------------------------------------------------
_QWORD *__fastcall sub_42C7C0(_QWORD *a1, _QWORD *a2, _QWORD *a3, unsigned __int64 a4)
{
  unsigned __int64 v6; // r9
  unsigned __int64 v7; // rbx
  __int64 v8; // r14
  __int64 v9; // r12
  __int64 v10; // rax
  bool v11; // r8

  if ( a4 >= 8 )
  {
    v6 = a4 >> 3;
    v7 = v6 << 7;
    v8 = 28 * v6;
    v9 = sub_42C7C0(a1, &a1[16 * v6], &a1[28 * v6]);
    a2 = (_QWORD *)sub_42C7C0(a2, (char *)a2 + v7, &a2[v8]);
    v10 = sub_42C7C0(a3, (char *)a3 + v7, &a3[v8]);
    a1 = (_QWORD *)v9;
    a3 = (_QWORD *)v10;
  }
  v11 = *a1 < *a2;
  if ( v11 != *a2 < *a3 )
    a2 = a3;
  if ( v11 != *a1 < *a3 )
    return a1;
  return a2;
}

//----- (000000000042C880) ----------------------------------------------------
__int64 __fastcall sub_42C880(_QWORD *a1)
{
  __int64 result; // rax

  switch ( *a1 )
  {
    case 2LL:
      result = 1LL;
      break;
    case 3LL:
      result = 1LL;
      break;
    case 4LL:
      result = 1LL;
      break;
    case 5LL:
    case 7LL:
      result = 1LL;
      break;
    case 6LL:
      result = 1LL;
      if ( (__int64)a1[1] < 0 )
        goto LABEL_8;
      break;
    default:
LABEL_8:
      result = 0LL;
      break;
  }
  return result;
}

//----- (000000000042C8E0) ----------------------------------------------------
void __fastcall sub_42C8E0(_QWORD *a1)
{
  void *v2; // rdi
  HANDLE ProcessHeap; // rax
  void *v4; // rdi
  HANDLE v5; // rax
  void *v6; // rdi
  HANDLE v7; // rax
  void *v8; // rsi
  HANDLE v9; // rax

  if ( a1[8] )
  {
    v2 = (void *)a1[9];
    ProcessHeap = GetProcessHeap();
    HeapFree(ProcessHeap, 0, v2);
  }
  if ( a1[11] )
  {
    v4 = (void *)a1[12];
    v5 = GetProcessHeap();
    HeapFree(v5, 0, v4);
  }
  if ( a1[14] )
  {
    v6 = (void *)a1[15];
    v7 = GetProcessHeap();
    HeapFree(v7, 0, v6);
  }
  if ( a1[17] )
  {
    v8 = (void *)a1[18];
    v9 = GetProcessHeap();
    HeapFree(v9, 0, v8);
  }
}

//----- (000000000042C980) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_42C980(_QWORD *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // r8
  __int64 v3; // rsi
  _OWORD *v6; // rax
  void *v7; // rbx
  HANDLE ProcessHeap; // rax
  __int128 v9; // [rsp+28h] [rbp-58h] BYREF
  __int64 v10; // [rsp+38h] [rbp-48h]

  v2 = 250000LL;
  if ( a2 < 0x3D090 )
    v2 = a2;
  if ( a2 >> 1 > v2 )
    v2 = a2 >> 1;
  v3 = 48LL;
  if ( v2 >= 0x31 )
    v3 = v2;
  if ( v2 >= 0x81 )
  {
    if ( a2 >> 60 || (unsigned __int64)(32 * v3) >= 0x7FFFFFFFFFFFFFF9LL )
      sub_4040B0((__int64)&off_447D68);
    v6 = sub_43C4F0(32 * v3);
    if ( !v6 )
      sub_4040E9(8LL, 32 * v3);
    v7 = v6;
    *(_QWORD *)&v9 = v3;
    *((_QWORD *)&v9 + 1) = v6;
    v10 = 0LL;
    sub_42D690(a1, a2, v6, (_QWORD *)v3, a2 < 0x41);
    ProcessHeap = GetProcessHeap();
    HeapFree(ProcessHeap, 0, v7);
  }
  else
  {
    sub_42D690(a1, a2, &v9, (_QWORD *)0x80, a2 < 0x41);
  }
}
// 42C9F9: positive sp value 1028 has been found
// 447D68: using guessed type char *off_447D68;

//----- (000000000042CAB0) ----------------------------------------------------
__int64 __fastcall sub_42CAB0(_QWORD *a1, __int64 a2)
{
  _OWORD *v2; // rdx
  _OWORD *v3; // r9
  __int64 result; // rax
  _QWORD *v5; // r10
  _QWORD *v6; // r11
  _OWORD *v7; // rsi
  _OWORD *v8; // r8
  unsigned __int64 v9; // r9
  __int64 v10; // r10
  __int64 v11; // rsi
  __int64 v12; // r11
  __int128 v13; // xmm0
  __int128 v14; // [rsp+0h] [rbp-10h]

  v2 = &a1[4 * a2];
  v3 = a1 + 4;
  result = 32LL;
  v5 = a1;
  do
  {
    v8 = v3;
    v9 = v5[6];
    if ( v9 < v5[2] )
    {
      v14 = *v8;
      v10 = v5[7];
      v11 = result;
      do
      {
        v12 = v11;
        v13 = *(_OWORD *)((char *)a1 + v11 - 32);
        *(_OWORD *)((char *)a1 + v11 + 16) = *(_OWORD *)((char *)a1 + v11 - 16);
        *(_OWORD *)((char *)a1 + v11) = v13;
        if ( v11 == 32 )
        {
          v6 = a1 + 4;
          v7 = a1;
          goto LABEL_3;
        }
        v11 -= 32LL;
      }
      while ( v9 < *(_QWORD *)((char *)a1 + v12 - 48) );
      v6 = (_QWORD *)((char *)a1 + v12);
      v7 = (_OWORD *)((char *)a1 + v11);
LABEL_3:
      *v7 = v14;
      *(v6 - 2) = v9;
      *(v6 - 1) = v10;
    }
    v3 = v8 + 2;
    result += 32LL;
    v5 = v8;
  }
  while ( v8 + 2 != v2 );
  return result;
}

//----- (000000000042CB60) ----------------------------------------------------
void __fastcall sub_42CB60(_QWORD *a1)
{
  void **v2; // rsi
  __int64 v3; // r14
  void **v4; // r15
  void *v5; // rbx
  HANDLE ProcessHeap; // rax
  HANDLE v7; // rax

  v2 = (void **)a1[1];
  v3 = a1[2];
  if ( v3 )
  {
    v4 = v2 + 1;
    do
    {
      if ( *(v4 - 1) )
      {
        v5 = *v4;
        ProcessHeap = GetProcessHeap();
        HeapFree(ProcessHeap, 0, v5);
      }
      v4 += 3;
      --v3;
    }
    while ( v3 );
  }
  if ( *a1 )
  {
    v7 = GetProcessHeap();
    HeapFree(v7, 0, v2);
  }
}

//----- (000000000042CBF0) ----------------------------------------------------
int __fastcall sub_42CBF0(_QWORD *a1, __int64 a2, _QWORD *a3, __int64 a4, _QWORD *a5)
{
  __int64 v5; // r10
  __int64 v10; // rdx
  size_t v11; // r13
  void *v12; // r12
  int result; // eax
  __int64 v14; // rbx
  unsigned __int64 v15; // rax
  unsigned __int64 v16; // rax
  _QWORD *v17; // rcx
  unsigned __int64 v18; // rax
  unsigned int v19; // ecx
  unsigned __int64 v20; // rdx
  unsigned __int64 v21; // r9
  __int64 v22; // r8
  LPVOID v23; // rdx
  char *v24; // r8
  __int64 v25; // r12
  void *v26; // r15
  char *v27; // r8
  __int64 v28; // rax
  HANDLE v29; // rax
  __int64 v30; // r14
  void *v31; // rdi
  __int64 v32; // r8
  void *v33; // rsi
  HANDLE ProcessHeap; // rax
  HANDLE v35; // rax
  __int64 v36; // [rsp+30h] [rbp-50h] BYREF
  LPVOID v37; // [rsp+38h] [rbp-48h]
  __int64 v38; // [rsp+40h] [rbp-40h]
  _QWORD v39[3]; // [rsp+48h] [rbp-38h] BYREF
  __int64 v40; // [rsp+60h] [rbp-20h] BYREF
  LPVOID lpMem; // [rsp+68h] [rbp-18h]
  char *v42; // [rsp+70h] [rbp-10h]
  LPVOID v43[2]; // [rsp+78h] [rbp-8h] BYREF
  void *v44; // [rsp+88h] [rbp+8h]
  __int64 v45; // [rsp+90h] [rbp+10h] BYREF
  size_t Size[2]; // [rsp+98h] [rbp+18h]

  v10 = *(_QWORD *)(a2 + 368);
  if ( v10 )
  {
    sub_4041B0(&v45, v10, *(char **)(a2 + 376));
    v11 = Size[0];
    v12 = (void *)Size[1];
    if ( __OFSUB__(-v45, 1LL) )
    {
      if ( (Size[1] & 0x8000000000000000uLL) != 0LL )
        sub_4040B0((__int64)&off_447C90);
      if ( Size[1] )
      {
        v14 = (__int64)sub_43C4F0(Size[1]);
        if ( !v14 )
          sub_4040E9(1LL, (__int64)v12);
      }
      else
      {
        v14 = 1LL;
      }
      memcpy((void *)v14, (const void *)v11, (size_t)v12);
      v43[0] = v12;
      v11 = v14;
    }
    else
    {
      if ( v45 == 0x8000000000000001uLL )
      {
        a1[1] = Size[0];
        a1[2] = v12;
        result = 0;
        *a1 = 0x8000000000000000uLL;
        return result;
      }
      v43[0] = (LPVOID)v45;
    }
  }
  else
  {
    v43[0] = 0LL;
    v11 = 1LL;
    v12 = 0LL;
  }
  v43[1] = (LPVOID)v11;
  v44 = v12;
  v15 = a3[3];
  if ( !v15 )
  {
LABEL_68:
    v28 = *a3;
    switch ( *a3 )
    {
      case 0LL:
      case 5LL:
      case 6LL:
      case 7LL:
      case 0xALL:
      case 0xBLL:
      case 0xCLL:
      case 0xDLL:
      case 0xELL:
      case 0xFLL:
      case 0x10LL:
      case 0x11LL:
      case 0x12LL:
      case 0x13LL:
      case 0x14LL:
      case 0x15LL:
      case 0x16LL:
      case 0x17LL:
      case 0x18LL:
      case 0x19LL:
      case 0x1ALL:
      case 0x1BLL:
      case 0x1CLL:
      case 0x1DLL:
      case 0x1ELL:
      case 0x27LL:
      case 0x2CLL:
      case 0x2DLL:
        goto LABEL_69;
      case 1LL:
      case 8LL:
      case 0x1FLL:
        goto LABEL_82;
      case 2LL:
      case 9LL:
      case 0x20LL:
      case 0x21LL:
      case 0x22LL:
      case 0x23LL:
      case 0x24LL:
      case 0x25LL:
      case 0x28LL:
      case 0x29LL:
      case 0x2ALL:
      case 0x2BLL:
        goto LABEL_71;
      case 3LL:
      case 0x26LL:
        goto LABEL_83;
      case 4LL:
        goto LABEL_84;
    }
  }
  if ( *(_WORD *)(a4 + 234) < 5u )
  {
    v16 = v15 - 1;
    if ( v16 < *(_QWORD *)(a4 + 104) )
    {
      v17 = (_QWORD *)(*(_QWORD *)(a4 + 96) + 24 * v16);
      switch ( *v17 )
      {
        case 0LL:
          goto LABEL_19;
        case 1LL:
          goto LABEL_41;
        case 2LL:
          goto LABEL_37;
        case 3LL:
          goto LABEL_39;
        case 4LL:
          goto LABEL_31;
        case 5LL:
          goto LABEL_46;
        case 6LL:
          goto LABEL_49;
        case 7LL:
          goto LABEL_40;
        case 8LL:
          goto LABEL_52;
        case 9LL:
          goto LABEL_34;
        case 0xALL:
          goto LABEL_51;
        case 0xBLL:
          goto LABEL_30;
        case 0xCLL:
          goto LABEL_33;
        case 0xDLL:
          goto LABEL_48;
        case 0xELL:
          goto LABEL_28;
        case 0xFLL:
          goto LABEL_38;
        case 0x10LL:
          goto LABEL_26;
        case 0x11LL:
          goto LABEL_43;
        case 0x12LL:
          goto LABEL_50;
        case 0x13LL:
          goto LABEL_58;
        case 0x14LL:
          goto LABEL_45;
        case 0x15LL:
          goto LABEL_47;
        case 0x16LL:
          goto LABEL_56;
        case 0x17LL:
          goto LABEL_85;
        case 0x18LL:
          goto LABEL_36;
        case 0x19LL:
          goto LABEL_35;
        case 0x1ALL:
          goto LABEL_89;
        case 0x1BLL:
          goto LABEL_24;
        case 0x1CLL:
          goto LABEL_86;
        case 0x1DLL:
          goto LABEL_87;
        case 0x1ELL:
          goto LABEL_53;
        case 0x1FLL:
          goto LABEL_42;
        case 0x20LL:
          goto LABEL_54;
        case 0x21LL:
          goto LABEL_29;
        case 0x22LL:
          goto LABEL_25;
        case 0x23LL:
          goto LABEL_22;
        case 0x24LL:
          goto LABEL_23;
        case 0x25LL:
          goto LABEL_21;
        case 0x26LL:
          goto LABEL_88;
        case 0x27LL:
          goto LABEL_57;
        case 0x28LL:
          goto LABEL_32;
        case 0x29LL:
          goto LABEL_44;
        case 0x2ALL:
          goto LABEL_59;
        case 0x2BLL:
          goto LABEL_20;
        case 0x2CLL:
          goto LABEL_27;
        case 0x2DLL:
          goto LABEL_55;
      }
    }
    goto LABEL_68;
  }
  if ( *(_QWORD *)(a4 + 104) <= v15 )
    goto LABEL_68;
  v17 = (_QWORD *)(*(_QWORD *)(a4 + 96) + 24 * v15);
  switch ( *v17 )
  {
    case 0LL:
LABEL_19:
      v18 = v17[1];
      v19 = (unsigned int)v18 >> 8;
      v20 = v18 >> 16;
      v21 = v18 & 0xFFFFFFFF00000000uLL;
      v22 = 0LL;
      break;
    case 1LL:
LABEL_41:
      v18 = v17[1];
      v5 = v17[2];
      v19 = (unsigned int)v18 >> 8;
      v20 = v18 >> 16;
      v21 = v18 & 0xFFFFFFFF00000000uLL;
      v22 = 1LL;
      break;
    case 2LL:
LABEL_37:
      LOBYTE(v18) = *((_BYTE *)v17 + 8);
      v22 = 2LL;
      goto LABEL_60;
    case 3LL:
LABEL_39:
      LOWORD(v18) = *((_WORD *)v17 + 4);
      v19 = BYTE1(v18);
      v22 = 3LL;
      goto LABEL_61;
    case 4LL:
LABEL_31:
      LODWORD(v18) = *((_DWORD *)v17 + 2);
      v19 = (unsigned int)v18 >> 8;
      LODWORD(v20) = WORD1(v18);
      v22 = 4LL;
      goto LABEL_62;
    case 5LL:
LABEL_46:
      v18 = v17[1];
      v19 = (unsigned int)v18 >> 8;
      v20 = v18 >> 16;
      v21 = v18 & 0xFFFFFFFF00000000uLL;
      v22 = 5LL;
      break;
    case 6LL:
LABEL_49:
      v18 = v17[1];
      v19 = (unsigned int)v18 >> 8;
      v20 = v18 >> 16;
      v21 = v18 & 0xFFFFFFFF00000000uLL;
      v22 = 6LL;
      break;
    case 7LL:
LABEL_40:
      v18 = v17[1];
      v19 = (unsigned int)v18 >> 8;
      v20 = v18 >> 16;
      v21 = v18 & 0xFFFFFFFF00000000uLL;
      v22 = 7LL;
      break;
    case 8LL:
LABEL_52:
      v18 = v17[1];
      v5 = v17[2];
      v19 = (unsigned int)v18 >> 8;
      v20 = v18 >> 16;
      v21 = v18 & 0xFFFFFFFF00000000uLL;
      v22 = 8LL;
      break;
    case 9LL:
LABEL_34:
      LOBYTE(v18) = *((_BYTE *)v17 + 8);
      v22 = 9LL;
      goto LABEL_60;
    case 0xALL:
LABEL_51:
      v18 = v17[1];
      v19 = (unsigned int)v18 >> 8;
      v20 = v18 >> 16;
      v21 = v18 & 0xFFFFFFFF00000000uLL;
      v22 = 10LL;
      break;
    case 0xBLL:
LABEL_30:
      v18 = v17[1];
      v19 = (unsigned int)v18 >> 8;
      v20 = v18 >> 16;
      v21 = v18 & 0xFFFFFFFF00000000uLL;
      v22 = 11LL;
      break;
    case 0xCLL:
LABEL_33:
      v18 = v17[1];
      v19 = (unsigned int)v18 >> 8;
      v20 = v18 >> 16;
      v21 = v18 & 0xFFFFFFFF00000000uLL;
      v22 = 12LL;
      break;
    case 0xDLL:
LABEL_48:
      v18 = v17[1];
      v19 = (unsigned int)v18 >> 8;
      v20 = v18 >> 16;
      v21 = v18 & 0xFFFFFFFF00000000uLL;
      v22 = 13LL;
      break;
    case 0xELL:
LABEL_28:
      v18 = v17[1];
      v19 = (unsigned int)v18 >> 8;
      v20 = v18 >> 16;
      v21 = v18 & 0xFFFFFFFF00000000uLL;
      v22 = 14LL;
      break;
    case 0xFLL:
LABEL_38:
      v18 = v17[1];
      v19 = (unsigned int)v18 >> 8;
      v20 = v18 >> 16;
      v21 = v18 & 0xFFFFFFFF00000000uLL;
      v22 = 15LL;
      break;
    case 0x10LL:
LABEL_26:
      v18 = v17[1];
      v19 = (unsigned int)v18 >> 8;
      v20 = v18 >> 16;
      v21 = v18 & 0xFFFFFFFF00000000uLL;
      v22 = 16LL;
      break;
    case 0x11LL:
LABEL_43:
      v18 = v17[1];
      v19 = (unsigned int)v18 >> 8;
      v20 = v18 >> 16;
      v21 = v18 & 0xFFFFFFFF00000000uLL;
      v22 = 17LL;
      break;
    case 0x12LL:
LABEL_50:
      v18 = v17[1];
      v19 = (unsigned int)v18 >> 8;
      v20 = v18 >> 16;
      v21 = v18 & 0xFFFFFFFF00000000uLL;
      v22 = 18LL;
      break;
    case 0x13LL:
LABEL_58:
      v18 = v17[1];
      v19 = (unsigned int)v18 >> 8;
      v20 = v18 >> 16;
      v21 = v18 & 0xFFFFFFFF00000000uLL;
      v22 = 19LL;
      break;
    case 0x14LL:
LABEL_45:
      v18 = v17[1];
      v19 = (unsigned int)v18 >> 8;
      v20 = v18 >> 16;
      v21 = v18 & 0xFFFFFFFF00000000uLL;
      v22 = 20LL;
      break;
    case 0x15LL:
LABEL_47:
      v18 = v17[1];
      v19 = (unsigned int)v18 >> 8;
      v20 = v18 >> 16;
      v21 = v18 & 0xFFFFFFFF00000000uLL;
      v22 = 21LL;
      break;
    case 0x16LL:
LABEL_56:
      v18 = v17[1];
      v19 = (unsigned int)v18 >> 8;
      v20 = v18 >> 16;
      v21 = v18 & 0xFFFFFFFF00000000uLL;
      v22 = 22LL;
      break;
    case 0x17LL:
LABEL_85:
      v18 = v17[1];
      v19 = (unsigned int)v18 >> 8;
      v20 = v18 >> 16;
      v21 = v18 & 0xFFFFFFFF00000000uLL;
      v22 = 23LL;
      break;
    case 0x18LL:
LABEL_36:
      v18 = v17[1];
      v19 = (unsigned int)v18 >> 8;
      v20 = v18 >> 16;
      v21 = v18 & 0xFFFFFFFF00000000uLL;
      v22 = 24LL;
      break;
    case 0x19LL:
LABEL_35:
      v18 = v17[1];
      v19 = (unsigned int)v18 >> 8;
      v20 = v18 >> 16;
      v21 = v18 & 0xFFFFFFFF00000000uLL;
      v22 = 25LL;
      break;
    case 0x1ALL:
LABEL_89:
      v18 = v17[1];
      v19 = (unsigned int)v18 >> 8;
      v20 = v18 >> 16;
      v21 = v18 & 0xFFFFFFFF00000000uLL;
      v22 = 26LL;
      break;
    case 0x1BLL:
LABEL_24:
      v18 = v17[1];
      v19 = (unsigned int)v18 >> 8;
      v20 = v18 >> 16;
      v21 = v18 & 0xFFFFFFFF00000000uLL;
      v22 = 27LL;
      break;
    case 0x1CLL:
LABEL_86:
      v18 = v17[1];
      v19 = (unsigned int)v18 >> 8;
      v20 = v18 >> 16;
      v21 = v18 & 0xFFFFFFFF00000000uLL;
      v22 = 28LL;
      break;
    case 0x1DLL:
LABEL_87:
      v18 = v17[1];
      v19 = (unsigned int)v18 >> 8;
      v20 = v18 >> 16;
      v21 = v18 & 0xFFFFFFFF00000000uLL;
      v22 = 29LL;
      break;
    case 0x1ELL:
LABEL_53:
      v18 = v17[1];
      v19 = (unsigned int)v18 >> 8;
      v20 = v18 >> 16;
      v21 = v18 & 0xFFFFFFFF00000000uLL;
      v22 = 30LL;
      break;
    case 0x1FLL:
LABEL_42:
      v18 = v17[1];
      v5 = v17[2];
      v19 = (unsigned int)v18 >> 8;
      v20 = v18 >> 16;
      v21 = v18 & 0xFFFFFFFF00000000uLL;
      v22 = 31LL;
      break;
    case 0x20LL:
LABEL_54:
      LOBYTE(v18) = *((_BYTE *)v17 + 8);
      v22 = 32LL;
      goto LABEL_60;
    case 0x21LL:
LABEL_29:
      LOBYTE(v18) = *((_BYTE *)v17 + 8);
      v22 = 33LL;
      goto LABEL_60;
    case 0x22LL:
LABEL_25:
      LOBYTE(v18) = *((_BYTE *)v17 + 8);
      v22 = 34LL;
      goto LABEL_60;
    case 0x23LL:
LABEL_22:
      LOBYTE(v18) = *((_BYTE *)v17 + 8);
      v22 = 35LL;
      goto LABEL_60;
    case 0x24LL:
LABEL_23:
      LOBYTE(v18) = *((_BYTE *)v17 + 8);
      v22 = 36LL;
      goto LABEL_60;
    case 0x25LL:
LABEL_21:
      LOBYTE(v18) = *((_BYTE *)v17 + 8);
      v22 = 37LL;
      goto LABEL_60;
    case 0x26LL:
LABEL_88:
      LOWORD(v18) = *((_WORD *)v17 + 4);
      v19 = BYTE1(v18);
      v22 = 38LL;
      goto LABEL_61;
    case 0x27LL:
LABEL_57:
      v18 = v17[1];
      v19 = (unsigned int)v18 >> 8;
      v20 = v18 >> 16;
      v21 = v18 & 0xFFFFFFFF00000000uLL;
      v22 = 39LL;
      break;
    case 0x28LL:
LABEL_32:
      LOBYTE(v18) = *((_BYTE *)v17 + 8);
      v22 = 40LL;
      goto LABEL_60;
    case 0x29LL:
LABEL_44:
      LOBYTE(v18) = *((_BYTE *)v17 + 8);
      v22 = 41LL;
      goto LABEL_60;
    case 0x2ALL:
LABEL_59:
      LOBYTE(v18) = *((_BYTE *)v17 + 8);
      v22 = 42LL;
      goto LABEL_60;
    case 0x2BLL:
LABEL_20:
      LOBYTE(v18) = *((_BYTE *)v17 + 8);
      v22 = 43LL;
LABEL_60:
      LOWORD(v19) = 0;
LABEL_61:
      LODWORD(v20) = 0;
LABEL_62:
      v21 = 0LL;
      break;
    case 0x2CLL:
LABEL_27:
      v18 = v17[1];
      v19 = (unsigned int)v18 >> 8;
      v20 = v18 >> 16;
      v21 = v18 & 0xFFFFFFFF00000000uLL;
      v22 = 44LL;
      break;
    case 0x2DLL:
LABEL_55:
      v18 = v17[1];
      v19 = (unsigned int)v18 >> 8;
      v20 = v18 >> 16;
      v21 = v18 & 0xFFFFFFFF00000000uLL;
      v22 = 45LL;
      break;
  }
  v39[0] = v22;
  v39[1] = v21 | ((_DWORD)v20 << 16) | (unsigned int)(unsigned __int16)(((_WORD)v19 << 8) | (unsigned __int8)v18);
  v39[2] = v5;
  result = sub_427DD0(&v45, a5, *(unsigned __int8 *)(a2 + 73), *(_QWORD *)(a2 + 392), v39);
  v23 = (LPVOID)Size[0];
  v24 = (char *)Size[1];
  if ( (v45 & 1) != 0 )
    goto LABEL_73;
  sub_4041B0(&v40, Size[0], (char *)Size[1]);
  v25 = v40;
  v26 = lpMem;
  v27 = v42;
  result = 1;
  if ( v40 == 0x8000000000000001uLL )
  {
    a1[1] = lpMem;
    a1[2] = v27;
    *a1 = 0x8000000000000000uLL;
    if ( !v43[0] )
      return result;
LABEL_77:
    v33 = v43[1];
    ProcessHeap = GetProcessHeap();
    return HeapFree(ProcessHeap, 0, v33);
  }
  sub_403DFD((signed __int64 *)v43, lpMem, (__int64)v42);
  if ( !(2 * v25) )
    goto LABEL_68;
  v29 = GetProcessHeap();
  HeapFree(v29, 0, v26);
  v28 = *a3;
  switch ( *a3 )
  {
    case 0LL:
    case 5LL:
    case 6LL:
    case 7LL:
    case 0xALL:
    case 0xBLL:
    case 0xCLL:
    case 0xDLL:
    case 0xELL:
    case 0xFLL:
    case 0x10LL:
    case 0x11LL:
    case 0x12LL:
    case 0x13LL:
    case 0x14LL:
    case 0x15LL:
    case 0x16LL:
    case 0x17LL:
    case 0x18LL:
    case 0x19LL:
    case 0x1ALL:
    case 0x1BLL:
    case 0x1CLL:
    case 0x1DLL:
    case 0x1ELL:
    case 0x27LL:
    case 0x2CLL:
    case 0x2DLL:
LABEL_69:
      Size[0] = a3[1];
      break;
    case 1LL:
    case 8LL:
    case 0x1FLL:
LABEL_82:
      *(_OWORD *)Size = *(_OWORD *)(a3 + 1);
      break;
    case 2LL:
    case 9LL:
    case 0x20LL:
    case 0x21LL:
    case 0x22LL:
    case 0x23LL:
    case 0x24LL:
    case 0x25LL:
    case 0x28LL:
    case 0x29LL:
    case 0x2ALL:
    case 0x2BLL:
LABEL_71:
      LOBYTE(Size[0]) = *((_BYTE *)a3 + 8);
      break;
    case 3LL:
    case 0x26LL:
LABEL_83:
      LOWORD(Size[0]) = *((_WORD *)a3 + 4);
      break;
    case 4LL:
LABEL_84:
      LODWORD(Size[0]) = *((_DWORD *)a3 + 2);
      break;
  }
  v45 = v28;
  result = sub_427DD0(&v40, a5, *(unsigned __int8 *)(a2 + 73), *(_QWORD *)(a2 + 392), &v45);
  v23 = lpMem;
  v24 = v42;
  if ( (v40 & 1) != 0 )
  {
LABEL_73:
    a1[1] = v23;
    a1[2] = v24;
    *a1 = 0x8000000000000000uLL;
    if ( v43[0] )
      goto LABEL_77;
  }
  else
  {
    sub_4041B0(&v36, (__int64)lpMem, v42);
    v30 = v36;
    v31 = v37;
    v32 = v38;
    result = 1;
    if ( v36 == 0x8000000000000001uLL )
    {
      a1[1] = v37;
      a1[2] = v32;
      *a1 = 0x8000000000000000uLL;
      if ( v43[0] )
        goto LABEL_77;
    }
    else
    {
      sub_403DFD((signed __int64 *)v43, v37, v38);
      if ( 2 * v30 )
      {
        v35 = GetProcessHeap();
        HeapFree(v35, 0, v31);
      }
      result = (int)v44;
      a1[2] = v44;
      *(_OWORD *)a1 = *(_OWORD *)v43;
    }
  }
  return result;
}
// 42D288: variable 'v5' is possibly undefined
// 447C90: using guessed type char *off_447C90;

//----- (000000000042D590) ----------------------------------------------------
void __fastcall sub_42D590(_QWORD *a1)
{
  _QWORD *v2; // rsi
  __int64 v3; // r14
  _QWORD *v4; // r15
  void *v5; // rbx
  HANDLE ProcessHeap; // rax
  HANDLE v7; // rax

  v2 = (_QWORD *)a1[1];
  v3 = a1[2];
  if ( v3 )
  {
    v4 = v2 + 1;
    do
    {
      if ( *v4 )
      {
        v5 = (void *)*(v4 - 1);
        ProcessHeap = GetProcessHeap();
        HeapFree(ProcessHeap, 0, v5);
      }
      v4 += 4;
      --v3;
    }
    while ( v3 );
  }
  if ( *a1 )
  {
    v7 = GetProcessHeap();
    HeapFree(v7, 0, v2);
  }
}

//----- (000000000042D620) ----------------------------------------------------
void __fastcall sub_42D620(void **lpMem, __int64 a2)
{
  __int64 v2; // rdi
  void **v4; // r14
  void *v5; // rbx
  HANDLE ProcessHeap; // rax
  HANDLE v7; // rax

  if ( a2 )
  {
    v2 = a2;
    v4 = lpMem + 1;
    do
    {
      if ( *(v4 - 1) )
      {
        v5 = *v4;
        ProcessHeap = GetProcessHeap();
        HeapFree(ProcessHeap, 0, v5);
      }
      v4 += 3;
      --v2;
    }
    while ( v2 );
    v7 = GetProcessHeap();
    HeapFree(v7, 0, lpMem);
  }
}

//----- (000000000042D690) ----------------------------------------------------
void __fastcall sub_42D690(_QWORD *a1, unsigned __int64 a2, _OWORD *a3, _QWORD *a4, char a5)
{
  _OWORD *v5; // r12
  unsigned __int64 v6; // rax
  __int64 v7; // rax
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // r15
  unsigned __int64 v10; // r13
  unsigned __int64 v11; // r11
  unsigned __int64 v12; // r14
  __int64 v13; // rax
  _QWORD *v14; // rcx
  unsigned __int64 v15; // rdi
  unsigned __int64 v16; // rsi
  unsigned __int64 v17; // rcx
  unsigned __int64 v18; // rcx
  unsigned __int64 v19; // rcx
  unsigned __int64 v20; // r8
  unsigned __int64 v21; // rdi
  unsigned __int64 v22; // rdx
  __int64 v23; // rcx
  __int128 *v24; // r8
  __int128 *v25; // r10
  __int128 v26; // xmm0
  __int128 v27; // xmm0
  __int64 v28; // r10
  unsigned __int64 v29; // rbx
  unsigned __int64 *v30; // r10
  unsigned __int64 v31; // r11
  unsigned __int64 v32; // r9
  unsigned __int64 v33; // rsi
  unsigned __int64 *v34; // r10
  unsigned __int64 v35; // r11
  unsigned __int64 v36; // rsi
  unsigned __int64 v37; // rax
  unsigned __int64 v38; // rcx
  _QWORD *v39; // r13
  char *v40; // rdx
  unsigned __int64 v41; // rbx
  unsigned __int64 v42; // rsi
  unsigned __int64 v43; // r14
  unsigned __int64 v44; // rdi
  unsigned __int64 v45; // rax
  unsigned __int64 v46; // rax
  unsigned __int64 v47; // r12
  __int64 v48; // rbx
  _QWORD *v49; // rdx
  char *v50; // r15
  _OWORD *v51; // rax
  char *v52; // r11
  char *v53; // rdx
  unsigned __int64 v54; // r8
  BOOL v55; // r9d
  BOOL v56; // r10d
  __int128 v57; // xmm0
  _QWORD *v58; // r10
  __int128 *v59; // r8
  int v60; // eax
  bool v61; // cl
  BOOL v62; // edx
  __int128 *v63; // r9
  __int128 v64; // xmm0
  unsigned __int64 v65; // rax
  _QWORD v66[75]; // [rsp+30h] [rbp-50h]
  unsigned __int64 v67; // [rsp+288h] [rbp+208h]
  _OWORD *v68; // [rsp+290h] [rbp+210h]
  _QWORD *v69; // [rsp+298h] [rbp+218h]
  _QWORD *v70; // [rsp+2A0h] [rbp+220h]
  _QWORD *v71; // [rsp+2A8h] [rbp+228h]
  _QWORD *v72; // [rsp+2B0h] [rbp+230h]
  unsigned __int64 v73; // [rsp+2B8h] [rbp+238h]
  unsigned __int64 v74; // [rsp+2C0h] [rbp+240h]
  _QWORD *v75; // [rsp+2C8h] [rbp+248h]
  unsigned __int64 v76; // [rsp+2D0h] [rbp+250h]
  unsigned __int64 v77; // [rsp+2D8h] [rbp+258h]
  unsigned __int64 v78; // [rsp+2E0h] [rbp+260h]
  unsigned __int64 v79; // [rsp+2E8h] [rbp+268h]
  _QWORD *v80; // [rsp+2F0h] [rbp+270h]
  _QWORD *v81; // [rsp+2F8h] [rbp+278h]
  void *Src; // [rsp+300h] [rbp+280h]

  v5 = a3;
  v81 = a1;
  if ( (a2 | (a2 + 0x3FFFFFFFFFFFFFFFLL)) >> 32 )
    v6 = (a2 + 0x3FFFFFFFFFFFFFFFLL) / a2;
  else
    v6 = ((int)a2 - 1) / (unsigned int)a2;
  v74 = v6;
  v78 = a2;
  if ( a2 >= 0x1001 )
  {
    _BitScanReverse64(&v8, a2 | 1);
    v79 = ((1LL << ((((unsigned int)v8 ^ 0xFFFFFFC0) + 65) >> 1)) + (a2 >> ((((unsigned int)v8 ^ 0xFFFFFFC0) + 65) >> 1))) >> 1;
  }
  else
  {
    v7 = 64LL;
    if ( a2 - (a2 >> 1) < 0x40 )
      v7 = a2 - (a2 >> 1);
    v79 = v7;
  }
  v75 = v81 + 10;
  v71 = v81 + 2;
  v72 = v81 - 2;
  v70 = v81 - 4;
  v9 = 1LL;
  v10 = 0LL;
  v11 = 0LL;
  v80 = a4;
  Src = a3;
  v12 = v78;
  if ( !v78 )
    goto LABEL_15;
LABEL_10:
  v13 = 4 * v10;
  v14 = &v81[4 * v10];
  if ( v12 < v79 )
    goto LABEL_11;
  if ( v12 < 2 )
  {
    v17 = 2 * v12 + 1;
    goto LABEL_43;
  }
  v20 = v14[2];
  v21 = v14[6];
  if ( v21 >= v20 )
  {
    v28 = 2LL;
    if ( v12 == 2 )
      goto LABEL_42;
    v29 = v11;
    v30 = &v75[v13];
    v22 = 2LL;
    v31 = v14[6];
    v32 = v12;
    while ( 1 )
    {
      v33 = v31;
      v31 = *v30;
      if ( *v30 < v33 )
        break;
      ++v22;
      v30 += 4;
      if ( v12 == v22 )
      {
LABEL_36:
        v22 = v32;
        break;
      }
    }
  }
  else
  {
    if ( v12 == 2 )
    {
      v22 = 2LL;
      v23 = 1LL;
      goto LABEL_25;
    }
    v29 = v11;
    v34 = &v75[v13];
    v22 = 2LL;
    v35 = v14[6];
    v32 = v12;
    while ( 1 )
    {
      v36 = v35;
      v35 = *v34;
      if ( *v34 >= v36 )
        break;
      ++v22;
      v34 += 4;
      if ( v12 == v22 )
        goto LABEL_36;
    }
  }
  a4 = v80;
  v11 = v29;
  if ( v22 >= v79 )
  {
    if ( v21 >= v20 )
    {
LABEL_41:
      v28 = v22;
      goto LABEL_42;
    }
    v28 = 1LL;
    if ( v22 >= 2 )
    {
      v23 = v22 >> 1;
LABEL_25:
      v24 = (__int128 *)&v71[v13];
      v25 = (__int128 *)&v72[4 * v22 + v13];
      do
      {
        v26 = *(v24 - 1);
        *(v24 - 1) = *(v25 - 1);
        *(v25 - 1) = v26;
        v27 = *v24;
        *v24 = *v25;
        *v25 = v27;
        v24 += 2;
        v25 -= 2;
        --v23;
      }
      while ( v23 );
      goto LABEL_41;
    }
LABEL_42:
    v17 = 2 * v28 + 1;
    goto LABEL_43;
  }
LABEL_11:
  if ( a5 )
  {
    v15 = v12;
    if ( v12 >= 0x20 )
      v15 = 32LL;
    v16 = v11;
    sub_42DD80(v14, v15, v5, a4, 0, 0LL);
    v11 = v16;
    a4 = v80;
    v17 = 2LL * (unsigned int)v15 + 1;
  }
  else
  {
    v19 = v12;
    if ( v79 < v12 )
      v19 = v79;
    v17 = 2 * v19;
  }
LABEL_43:
  v73 = v17;
  v37 = (v74 * (2 * v10 - (v9 >> 1))) ^ (v74 * ((v17 >> 1) + 2 * v10));
  if ( !v37 )
  {
    v18 = 64LL;
    if ( v11 < 2 )
      goto LABEL_84;
    goto LABEL_47;
  }
  _BitScanReverse64(&v38, v37);
  v18 = v38 ^ 0x3F;
  if ( v11 >= 2 )
  {
LABEL_47:
    v69 = &v81[4 * v10];
    v68 = &v70[4 * v10];
    v77 = v18;
    v67 = v10;
    while ( 1 )
    {
      while ( 1 )
      {
        if ( *((_BYTE *)&v66[66] + v11 + 5) < (unsigned __int8)v18 )
          goto LABEL_84;
        v41 = v66[--v11];
        v42 = v41 >> 1;
        v43 = v9 >> 1;
        v44 = (v41 >> 1) + (v9 >> 1);
        if ( v44 > (unsigned __int64)a4 || (((unsigned __int8)v9 | (unsigned __int8)v41) & 1) != 0 )
          break;
        v9 = 2 * v44;
        if ( v11 <= 1 )
        {
LABEL_83:
          v11 = 1LL;
          goto LABEL_84;
        }
      }
      v39 = &v81[4 * (v10 - v44)];
      v76 = v11;
      if ( (v41 & 1) != 0 )
      {
        if ( (v9 & 1) != 0 )
          goto LABEL_58;
      }
      else
      {
        _BitScanReverse64(&v45, v42 | 1);
        sub_42DD80(v39, v42, v5, a4, (2 * (v45 ^ 0x3F)) ^ 0x7E, 0LL);
        LOBYTE(v18) = v77;
        v11 = v76;
        a4 = v80;
        if ( (v9 & 1) != 0 )
        {
LABEL_58:
          if ( v9 >= 2 )
            goto LABEL_62;
          goto LABEL_50;
        }
      }
      _BitScanReverse64(&v46, v43 | 1);
      sub_42DD80(&v39[4 * v42], v9 >> 1, v5, a4, (2 * (v46 ^ 0x3F)) ^ 0x7E, 0LL);
      LOBYTE(v18) = v77;
      v11 = v76;
      a4 = v80;
      if ( v9 >= 2 )
      {
LABEL_62:
        if ( v41 >= 2 )
        {
          v47 = v9 >> 1;
          if ( v42 < v43 )
            v47 = v41 >> 1;
          if ( v47 <= (unsigned __int64)a4 )
          {
            v48 = (__int64)&v39[4 * v42];
            v49 = v39;
            if ( v43 < v42 )
              v49 = &v39[4 * v42];
            memcpy(Src, v49, 32 * v47);
            v50 = (char *)Src + 32 * v47;
            if ( v43 >= v42 )
            {
              if ( v47 )
              {
                v40 = (char *)Src;
                v58 = v69;
                do
                {
                  v59 = (__int128 *)v40;
                  v60 = 0;
                  v61 = *(_QWORD *)(v48 + 16) < *((_QWORD *)v40 + 2);
                  v62 = *(_QWORD *)(v48 + 16) >= *((_QWORD *)v40 + 2);
                  v63 = v59;
                  if ( v61 )
                    v63 = (__int128 *)v48;
                  v64 = *v63;
                  *((_OWORD *)v39 + 1) = v63[1];
                  *(_OWORD *)v39 = v64;
                  v40 = (char *)v59 + (unsigned int)(32 * v62);
                  v39 += 4;
                  if ( v40 == v50 )
                    break;
                  LOBYTE(v60) = v61;
                  v48 += (unsigned int)(32 * v60);
                }
                while ( (_QWORD *)v48 != v58 );
              }
              else
              {
                v40 = (char *)Src;
              }
            }
            else
            {
              v51 = v68;
              v52 = (char *)Src;
              do
              {
                v53 = v50 - 32;
                v54 = *((_QWORD *)v50 - 2);
                v55 = v54 < *(_QWORD *)(v48 - 16);
                v56 = v54 >= *(_QWORD *)(v48 - 16);
                if ( v54 < *(_QWORD *)(v48 - 16) )
                  v53 = (char *)(v48 - 32);
                v57 = *(_OWORD *)v53;
                v51[1] = *((_OWORD *)v53 + 1);
                *v51 = v57;
                v48 = (unsigned int)(32 * v56) + v48 - 32;
                v50 = &v50[32 * v55 - 32];
                if ( (_QWORD *)v48 == v39 )
                  break;
                v51 -= 2;
              }
              while ( v50 != v52 );
              v39 = (_QWORD *)v48;
              v40 = v52;
            }
            memcpy(v39, v40, v50 - v40);
            a4 = v80;
            v11 = v76;
            LOBYTE(v18) = v77;
          }
        }
      }
LABEL_50:
      v9 = 2 * v44 + 1;
      v5 = Src;
      v10 = v67;
      if ( v11 <= 1 )
        goto LABEL_83;
    }
  }
LABEL_84:
  while ( 1 )
  {
    v66[v11] = v9;
    *((_BYTE *)&v66[66] + v11 + 6) = v18;
    if ( v78 <= v10 )
      break;
    ++v11;
    v9 = v73;
    v10 += v73 >> 1;
    v12 = v78 - v10;
    if ( v78 > v10 )
      goto LABEL_10;
LABEL_15:
    v18 = 0LL;
    v73 = 1LL;
    if ( v11 >= 2 )
      goto LABEL_47;
  }
  if ( (v9 & 1) == 0 )
  {
    _BitScanReverse64(&v65, v78 | 1);
    sub_42DD80(v81, v78, v5, a4, (2 * (v65 ^ 0x3F)) ^ 0x7E, 0LL);
  }
}

//----- (000000000042DD80) ----------------------------------------------------
void __fastcall sub_42DD80(_QWORD *a1, unsigned __int64 a2, _OWORD *a3, _QWORD *a4, int a5, __int64 a6)
{
  unsigned __int64 v7; // rbx
  unsigned __int64 v9; // r13
  unsigned __int64 v10; // rdx
  __int64 v11; // r10
  _QWORD *v12; // r15
  _QWORD *v13; // r14
  __int64 v14; // rax
  __int64 v15; // r8
  __int64 v16; // r9
  unsigned __int64 v17; // rax
  unsigned __int64 v18; // r11
  unsigned __int64 v19; // rcx
  __int64 v20; // rdi
  bool v21; // cf
  __int128 *v22; // r10
  __int64 v23; // r9
  _QWORD *v24; // r14
  unsigned __int64 v25; // rax
  BOOL v26; // r12d
  __int64 v27; // r13
  __int128 *v28; // r11
  __int64 v29; // rax
  __int64 v30; // r15
  __int64 v31; // r12
  unsigned __int64 v32; // rdx
  unsigned __int64 v33; // rdi
  unsigned __int64 v34; // rax
  __int128 *v35; // rcx
  __int128 *v36; // rdx
  bool v37; // cf
  __int128 v38; // xmm0
  __int128 v39; // xmm1
  __int128 v40; // xmm3
  __int128 v41; // xmm4
  __int128 v42; // xmm5
  __int128 v43; // xmm6
  __int128 *v44; // rax
  __int128 v45; // xmm7
  __int128 v46; // xmm8
  __int128 v47; // xmm9
  __int128 v48; // xmm10
  __int128 v49; // xmm11
  __int128 v50; // xmm12
  __int128 v51; // xmm13
  __int128 v52; // xmm14
  __int128 v53; // xmm15
  unsigned __int64 v54; // rdx
  unsigned __int64 v55; // r8
  unsigned __int64 v56; // r15
  unsigned __int64 v58; // r14
  int v59; // r13d
  __int64 v60; // rax
  __int64 v61; // r8
  unsigned __int64 v62; // rcx
  unsigned __int64 v63; // rdx
  bool v64; // r9
  unsigned __int64 v65; // r10
  char v66; // cl
  __int64 v67; // r11
  __int128 v68; // xmm0
  _OWORD *v69; // r13
  _QWORD *v70; // rax
  _QWORD *v71; // rcx
  _OWORD *v72; // rdx
  unsigned __int64 i; // r8
  _QWORD *j; // r9
  bool v75; // cf
  _OWORD *v76; // r10
  __int128 v77; // xmm0
  __int64 v78; // r8
  __int128 v79; // xmm0
  __int64 v80; // r12
  unsigned __int64 v81; // rdx
  __int64 v82; // rax
  _OWORD *v83; // r8
  __int128 *v84; // r15
  __int64 v85; // r9
  __int128 v86; // xmm0
  __int64 v87; // r9
  __int128 v88; // xmm1
  _QWORD *v89; // rcx
  __int64 v90; // r8
  __int64 v91; // rax
  __int128 v92; // xmm0
  _OWORD *v93; // rdx
  _QWORD *v94; // rax
  unsigned __int64 v95; // r12
  _QWORD *v96; // rcx
  _QWORD *k; // r8
  bool v98; // cf
  _OWORD *v99; // r9
  __int128 v100; // xmm0
  __int64 v101; // r8
  __int128 v102; // xmm0
  __int64 v103; // r10
  __int64 v104; // rax
  _OWORD *v105; // rdx
  __int128 *v106; // r13
  __int64 v107; // r8
  __int128 v108; // xmm0
  __int64 v109; // r8
  __int128 v110; // xmm1
  char *v111; // rcx
  __int64 v112; // rdx
  __int64 v113; // rax
  __int128 v114; // xmm0
  __int128 v115; // xmm0
  __int64 v116; // rax
  __int128 v117; // xmm0
  __int64 v118; // rcx
  unsigned __int64 v119; // r9
  _OWORD *v120; // r15
  _OWORD *v121; // rax
  __int64 v122; // rax
  __int128 v123; // xmm0
  unsigned __int64 v124; // r10
  _OWORD *v125; // r11
  __int64 v126; // r14
  __int64 v127; // rax
  __int64 v128; // r15
  __int128 v129; // xmm0
  _OWORD *v130; // rcx
  _QWORD *v131; // r9
  __int64 v132; // r10
  _OWORD *v133; // r12
  _OWORD *v134; // rax
  __int64 v135; // rax
  __int128 v136; // xmm0
  unsigned __int64 v137; // r11
  _OWORD *v138; // r14
  __int64 v139; // r15
  __int64 v140; // rax
  __int64 v141; // r12
  __int128 v142; // xmm0
  _OWORD *v143; // rax
  __int64 v144; // rdx
  _OWORD *v145; // r11
  _OWORD *v146; // r9
  _OWORD *v147; // r10
  __int128 v148; // xmm0
  unsigned __int64 v149; // rdi
  int v150; // r15d
  int v151; // r12d
  __int128 *v152; // r8
  __int128 v153; // xmm0
  unsigned __int64 v154; // r14
  unsigned __int64 v155; // rdi
  __int128 *v156; // r8
  _OWORD *v157; // rax
  BOOL v158; // r8d
  __int128 *v159; // rdi
  __int128 v160; // xmm0
  _OWORD v161[2]; // [rsp+30h] [rbp-50h] BYREF
  _QWORD v162[3]; // [rsp+50h] [rbp-30h] BYREF
  __int128 v163; // [rsp+68h] [rbp-18h]
  _OWORD *v164; // [rsp+80h] [rbp+0h]
  size_t Size; // [rsp+88h] [rbp+8h]
  unsigned __int64 v166; // [rsp+90h] [rbp+10h]
  __int64 v167; // [rsp+98h] [rbp+18h]
  __int64 v168; // [rsp+A0h] [rbp+20h]
  _QWORD *v169; // [rsp+A8h] [rbp+28h]

  v7 = a2;
  if ( a2 >= 0x21 )
  {
    v56 = (unsigned __int64)a4;
    v168 = a6;
    v164 = a3 - 2;
    v169 = a4;
    do
    {
      Size = (size_t)(a1 + 4);
      v58 = v7;
      while ( 1 )
      {
        v21 = a5 == 0;
        v59 = a5 - 1;
        if ( v21 )
        {
          sub_42D690((_DWORD)a1, v58, (_DWORD)a3, v56, 1);
          return;
        }
        v60 = (__int64)&a1[16 * (v58 >> 3)];
        v61 = (__int64)&a1[28 * (v58 >> 3)];
        if ( v58 >= 0x40 )
        {
          v60 = sub_42E840((__int64)a1, (__int64)&a1[16 * (v58 >> 3)], v61, v58 >> 3);
        }
        else
        {
          v62 = a1[2];
          v63 = *(_QWORD *)(v60 + 16);
          v64 = v62 < v63;
          v65 = *(_QWORD *)(v61 + 16);
          v66 = (v62 < v63) ^ (v62 < v65);
          if ( v64 != v63 < v65 )
            v60 = (__int64)&a1[28 * (v58 >> 3)];
          if ( v66 )
            v60 = (__int64)a1;
        }
        v67 = (unsigned __int64)(v60 - (_QWORD)a1) >> 5;
        v68 = *(_OWORD *)v60;
        v161[1] = *(_OWORD *)(v60 + 16);
        v161[0] = v68;
        LODWORD(v166) = v59;
        if ( v168 )
        {
          if ( *(_QWORD *)(v168 + 16) >= *(_QWORD *)(v60 + 16) )
            break;
        }
        if ( v58 > v56 )
          goto LABEL_115;
        v69 = &a3[2 * v58];
        v70 = &a1[4 * v67 + 2];
        v7 = 0LL;
        v71 = a1;
        v72 = v69;
        v167 = v67;
        for ( i = v67; ; i = v58 )
        {
          for ( j = &a1[4 * i]; v71 < j; v71 += 4 )
          {
            v72 -= 2;
            v75 = v71[2] < *v70;
            v76 = v72;
            if ( v71[2] < *v70 )
              v76 = a3;
            v77 = *(_OWORD *)v71;
            v76[2 * v7 + 1] = *((_OWORD *)v71 + 1);
            v76[2 * v7] = v77;
            v7 += v75;
          }
          if ( i == v58 )
            break;
          v78 = 2 * v7;
          v79 = *(_OWORD *)v71;
          v72[v78 - 1] = *((_OWORD *)v71 + 1);
          v72[v78 - 2] = v79;
          v72 -= 2;
          v71 += 4;
        }
        v80 = 32 * v7;
        memcpy(a1, a3, 32 * v7);
        v81 = v58 - v7;
        v67 = v167;
        if ( v58 != v7 )
        {
          if ( v58 == v7 + 1 )
          {
            v82 = 0LL;
          }
          else
          {
            v83 = (_OWORD *)(Size + v80);
            v84 = &v164[2 * v58];
            v85 = 0LL;
            do
            {
              v86 = *v84;
              *(v83 - 1) = v84[1];
              *(v83 - 2) = v86;
              v82 = v85 + 2;
              v87 = 2 * (v85 ^ 0x7FFFFFFFFFFFFFELL);
              v88 = v69[v87 + 1];
              *v83 = v69[v87];
              v83[1] = v88;
              v83 += 4;
              v84 -= 4;
              v85 = v82;
            }
            while ( (v81 & 0xFFFFFFFFFFFFFFFEuLL) != v82 );
          }
          if ( (v81 & 1) != 0 )
          {
            v89 = &a1[(unsigned __int64)v80 / 8];
            v90 = 2 * ~v82;
            v91 = 4 * v82;
            v92 = v69[v90];
            *(_OWORD *)&v89[v91 + 2] = v69[v90 + 1];
            *(_OWORD *)&v89[v91] = v92;
          }
        }
        v56 = (unsigned __int64)v169;
        a5 = v166;
        if ( !v7 )
          break;
        if ( v58 < v7 )
        {
          v162[0] = &off_4479E0;
          v162[1] = 1LL;
          v162[2] = 8LL;
          v163 = 0LL;
          sub_405240(v162, &off_447A50);
        }
        sub_42DD80((_DWORD)a1 + v80, v81, (_DWORD)a3, (_DWORD)v169, v166, (__int64)v161);
        v58 = v7;
        if ( v7 < 0x21 )
          goto LABEL_2;
      }
      if ( v58 > v56 )
LABEL_115:
        BUG();
      v93 = &a3[2 * v58];
      v94 = &a1[4 * v67 + 2];
      v95 = 0LL;
      v96 = a1;
      v168 = (__int64)v93;
      while ( 1 )
      {
        for ( k = &a1[4 * v67]; v96 < k; v96 += 4 )
        {
          v93 -= 2;
          v98 = *v94 < v96[2];
          v99 = v93;
          if ( *v94 >= v96[2] )
            v99 = a3;
          v100 = *(_OWORD *)v96;
          v99[2 * v95 + 1] = *((_OWORD *)v96 + 1);
          v99[2 * v95] = v100;
          v95 -= v98 - 1LL;
        }
        if ( v67 == v58 )
          break;
        v93 -= 2;
        v101 = 2 * v95;
        v102 = *(_OWORD *)v96;
        a3[v101 + 1] = *((_OWORD *)v96 + 1);
        a3[v101] = v102;
        ++v95;
        v96 += 4;
        v67 = v58;
      }
      v167 = 32 * v95;
      memcpy(a1, a3, 32 * v95);
      v7 = v58 - v95;
      v103 = v168;
      if ( v58 != v95 )
      {
        if ( v58 == v95 + 1 )
        {
          v104 = 0LL;
        }
        else
        {
          v105 = (_OWORD *)((char *)a1 + v167 + 32);
          v106 = &v164[2 * v58];
          v107 = 0LL;
          do
          {
            v108 = *v106;
            *(v105 - 1) = v106[1];
            *(v105 - 2) = v108;
            v104 = v107 + 2;
            v109 = 32 * (v107 ^ 0x7FFFFFFFFFFFFFELL);
            v110 = *(_OWORD *)(v103 + v109 + 16);
            *v105 = *(_OWORD *)(v103 + v109);
            v105[1] = v110;
            v105 += 4;
            v106 -= 4;
            v107 = v104;
          }
          while ( (v7 & 0xFFFFFFFFFFFFFFFEuLL) != v104 );
        }
        if ( (v7 & 1) != 0 )
        {
          v111 = (char *)a1 + v167;
          v112 = 32 * ~v104;
          v113 = 32 * v104;
          v114 = *(_OWORD *)(v103 + v112);
          *(_OWORD *)&v111[v113 + 16] = *(_OWORD *)(v103 + v112 + 16);
          *(_OWORD *)&v111[v113] = v114;
        }
      }
      if ( v58 < v95 )
        sub_4050A0(v95, v58, (__int64)&off_447A68);
      a1 = (_QWORD *)((char *)a1 + v167);
      v168 = 0LL;
      a5 = v166;
    }
    while ( v7 >= 0x21 );
  }
LABEL_2:
  if ( v7 >= 2 )
  {
    v9 = v7 >> 1;
    v169 = a1;
    if ( v7 < 8 )
    {
      v115 = *(_OWORD *)a1;
      a3[1] = *((_OWORD *)a1 + 1);
      *a3 = v115;
      v116 = 2 * v9;
      v117 = *(_OWORD *)&a1[4 * v9];
      a3[v116 + 1] = *(_OWORD *)&a1[4 * v9 + 2];
      a3[v116] = v117;
      v54 = 1LL;
      v55 = v7 - v9;
      if ( v9 <= 1 )
      {
LABEL_90:
        v130 = &a3[2 * v9];
        if ( v54 < v55 )
        {
          v131 = &a1[4 * v9];
          v132 = (unsigned int)(32 * v54);
          do
          {
            v135 = 32 * v54;
            v136 = *(_OWORD *)&v131[4 * v54];
            v130[(unsigned __int64)v135 / 0x10 + 1] = *(_OWORD *)&v131[4 * v54 + 2];
            v130[(unsigned __int64)v135 / 0x10] = v136;
            v137 = *(_QWORD *)&v130[2 * v54 + 1];
            if ( v137 < *(_QWORD *)&v130[2 * v54 - 1] )
            {
              v138 = &v131[(unsigned __int64)v135 / 8];
              v139 = *((_QWORD *)&v130[(unsigned __int64)v135 / 0x10 + 1] + 1);
              v140 = v132;
              do
              {
                v141 = v140;
                v142 = *(_OWORD *)((char *)v130 + v140 - 32);
                *(_OWORD *)((char *)v130 + v140 + 16) = *(_OWORD *)((char *)v130 + v140 - 16);
                *(_OWORD *)((char *)v130 + v140) = v142;
                if ( v140 == 32 )
                {
                  v133 = v130 + 2;
                  v134 = &a3[2 * v9];
                  goto LABEL_93;
                }
                v140 -= 32LL;
              }
              while ( v137 < *(_QWORD *)((char *)v130 + v141 - 48) );
              v133 = (_OWORD *)((char *)v130 + v141);
              v134 = (_OWORD *)((char *)v130 + v140);
LABEL_93:
              *v134 = *v138;
              *((_QWORD *)v133 - 2) = v137;
              *((_QWORD *)v133 - 1) = v139;
            }
            ++v54;
            v132 += 32LL;
          }
          while ( v54 != v55 );
        }
        v143 = v130 - 2;
        v144 = (__int64)&a3[2 * v7 - 2];
        Size = 32 * v7;
        v145 = &a1[4 * v7 - 4];
        v146 = a3;
        v147 = a1;
        do
        {
          v166 = v9;
          v149 = *((_QWORD *)v130 + 2);
          v150 = 0;
          v151 = 0;
          v152 = v130;
          v21 = v149 < *((_QWORD *)v146 + 2);
          LOBYTE(v167) = v149 >= *((_QWORD *)v146 + 2);
          LOBYTE(v168) = v21;
          if ( !v21 )
            v152 = v146;
          v153 = *v152;
          v147[1] = v152[1];
          *v147 = v153;
          v154 = *(_QWORD *)(v144 + 16);
          v155 = *((_QWORD *)v143 + 2);
          v156 = v143;
          if ( v154 >= v155 )
            v156 = (__int128 *)v144;
          LOBYTE(v151) = v168;
          v130 = (_OWORD *)((char *)v130 + (unsigned int)(32 * v151));
          LOBYTE(v150) = v167;
          v146 = (_OWORD *)((char *)v146 + (unsigned int)(32 * v150));
          v147 += 2;
          v148 = *v156;
          v145[1] = v156[1];
          *v145 = v148;
          v144 += 32 * ((v154 < v155) - 1LL);
          v143 -= 2 * (v154 < v155);
          v145 -= 2;
          v9 = v166 - 1;
        }
        while ( v166 != 1 );
        v157 = v143 + 2;
        if ( (v7 & 1) != 0 )
        {
          v158 = v146 >= v157;
          v159 = v130;
          if ( v146 < v157 )
            v159 = v146;
          v160 = *v159;
          v147[1] = v159[1];
          *v147 = v160;
          v146 += 2 * (unsigned int)(v146 < v157);
          v130 = (_OWORD *)((char *)v130 + (unsigned int)(32 * v158));
        }
        if ( v146 != v157 || v130 != (_OWORD *)(v144 + 32) )
          sub_408340();
        return;
      }
    }
    else
    {
      v10 = a1[14];
      v11 = 4 * (unsigned int)(a1[6] < a1[2]);
      v12 = &a1[v11];
      v13 = &a1[4 * (unsigned int)(a1[6] >= a1[2])];
      v14 = 4 * (unsigned int)(v10 < a1[10]);
      v15 = (__int64)&a1[v14 + 8];
      v16 = 4 * ((v10 < a1[10]) ^ 3u);
      v17 = a1[v14 + 10];
      v18 = a1[v16 + 2];
      v19 = v13[2];
      v20 = (__int64)v13;
      if ( v18 < v19 )
        v20 = v15;
      v21 = v17 < v169[v11 + 2];
      if ( v17 < v169[v11 + 2] )
      {
        v20 = (__int64)v12;
        v12 = (_QWORD *)v15;
      }
      v168 = (__int64)v12;
      if ( v21 )
        v15 = (__int64)v13;
      if ( v18 >= v19 )
        v13 = &v169[v16];
      v167 = (__int64)v13;
      if ( v18 < v19 )
        v15 = (__int64)&v169[v16];
      v22 = (__int128 *)v20;
      if ( *(_QWORD *)(v15 + 16) < *(_QWORD *)(v20 + 16) )
      {
        v22 = (__int128 *)v15;
        v15 = v20;
      }
      v23 = 2 * v9;
      v24 = &v169[4 * v9];
      v25 = v24[6];
      v166 = v7 >> 1;
      v26 = v24[14] < v24[10];
      v27 = 4 * (unsigned int)(v25 < v24[2]);
      v28 = (__int128 *)&v24[4 * (unsigned int)(v25 >= v24[2])];
      v29 = (unsigned int)(32 * v26);
      v30 = (__int64)v24 + v29 + 64;
      v31 = 4 * (v26 ^ 3u);
      v32 = *(_QWORD *)((char *)v24 + v29 + 80);
      v33 = v24[v31 + 2];
      v34 = *((_QWORD *)v28 + 2);
      v35 = v28;
      if ( v33 < v34 )
        v35 = (__int128 *)v30;
      v21 = v32 < v24[v27 + 2];
      v36 = (__int128 *)&v24[v27];
      v9 = v166;
      if ( v21 )
      {
        v35 = v36;
        v36 = (__int128 *)v30;
        v30 = (__int64)v28;
      }
      v37 = v33 < v34;
      a1 = v169;
      v38 = *(_OWORD *)v168;
      v39 = *v22;
      if ( !v37 )
        v28 = (__int128 *)&v24[v31];
      v40 = v22[1];
      if ( v37 )
        v30 = (__int64)&v24[v31];
      v41 = *(_OWORD *)v15;
      v42 = *(_OWORD *)(v15 + 16);
      v43 = *(_OWORD *)v167;
      v44 = v35;
      if ( *(_QWORD *)(v30 + 16) < *((_QWORD *)v35 + 2) )
        v44 = (__int128 *)v30;
      v45 = *(_OWORD *)(v167 + 16);
      if ( *(_QWORD *)(v30 + 16) < *((_QWORD *)v35 + 2) )
        v30 = (__int64)v35;
      v46 = *v36;
      v47 = v36[1];
      v48 = *v44;
      v49 = v44[1];
      v50 = *(_OWORD *)v30;
      v51 = *(_OWORD *)(v30 + 16);
      v52 = *v28;
      v53 = v28[1];
      a3[1] = *(_OWORD *)(v168 + 16);
      *a3 = v38;
      a3[3] = v40;
      a3[2] = v39;
      a3[5] = v42;
      a3[4] = v41;
      a3[7] = v45;
      a3[6] = v43;
      a3[v23 + 1] = v47;
      a3[v23] = v46;
      a3[v23 + 2] = v48;
      a3[v23 + 3] = v49;
      a3[v23 + 4] = v50;
      a3[v23 + 5] = v51;
      a3[v23 + 6] = v52;
      a3[v23 + 7] = v53;
      v54 = 4LL;
      v55 = v7 - v9;
      if ( v9 <= 4 )
        goto LABEL_90;
    }
    v118 = (unsigned int)(32 * v54);
    v119 = v54;
    do
    {
      v122 = 32 * v119;
      v123 = *(_OWORD *)&a1[4 * v119];
      a3[(unsigned __int64)v122 / 0x10 + 1] = *(_OWORD *)&a1[4 * v119 + 2];
      a3[(unsigned __int64)v122 / 0x10] = v123;
      v124 = *(_QWORD *)&a3[2 * v119 + 1];
      if ( v124 < *(_QWORD *)&a3[2 * v119 - 1] )
      {
        v125 = &a1[(unsigned __int64)v122 / 8];
        v126 = *((_QWORD *)&a3[(unsigned __int64)v122 / 0x10 + 1] + 1);
        v127 = v118;
        do
        {
          v128 = v127;
          v129 = *(_OWORD *)((char *)a3 + v127 - 32);
          *(_OWORD *)((char *)a3 + v127 + 16) = *(_OWORD *)((char *)a3 + v127 - 16);
          *(_OWORD *)((char *)a3 + v127) = v129;
          if ( v127 == 32 )
          {
            v120 = a3 + 2;
            v121 = a3;
            goto LABEL_83;
          }
          v127 -= 32LL;
        }
        while ( v124 < *(_QWORD *)((char *)a3 + v128 - 48) );
        v120 = (_OWORD *)((char *)a3 + v128);
        v121 = (_OWORD *)((char *)a3 + v127);
LABEL_83:
        *v121 = *v125;
        *((_QWORD *)v120 - 2) = v124;
        *((_QWORD *)v120 - 1) = v126;
      }
      ++v119;
      v118 += 32LL;
    }
    while ( v119 != v9 );
    goto LABEL_90;
  }
}
// 405240: using guessed type void __fastcall __noreturn sub_405240(_QWORD, _QWORD);
// 42D690: using guessed type __int64 __fastcall sub_42D690(_DWORD, _DWORD, _DWORD, _DWORD, char);
// 4479E0: using guessed type char *off_4479E0;
// 447A50: using guessed type char *off_447A50;
// 447A68: using guessed type char *off_447A68;

//----- (000000000042E840) ----------------------------------------------------
__int64 __fastcall sub_42E840(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4)
{
  unsigned __int64 v6; // r9
  unsigned __int64 v7; // rbx
  __int64 v8; // r14
  __int64 v9; // r12
  __int64 v10; // rax
  unsigned __int64 v11; // rax
  unsigned __int64 v12; // rdx
  bool v13; // r8
  unsigned __int64 v14; // r9
  char v15; // al

  if ( a4 >= 8 )
  {
    v6 = a4 >> 3;
    v7 = v6 << 7;
    v8 = 224 * v6;
    v9 = sub_42E840(a1, a1 + (v6 << 7), a1 + 224 * v6);
    a2 = sub_42E840(a2, a2 + v7, a2 + v8);
    v10 = sub_42E840(a3, a3 + v7, a3 + v8);
    a1 = v9;
    a3 = v10;
  }
  v11 = *(_QWORD *)(a1 + 16);
  v12 = *(_QWORD *)(a2 + 16);
  v13 = v11 < v12;
  v14 = *(_QWORD *)(a3 + 16);
  v15 = (v11 < v12) ^ (v11 < v14);
  if ( v13 != v12 < v14 )
    a2 = a3;
  if ( v15 )
    return a1;
  return a2;
}

//----- (000000000042E900) ----------------------------------------------------
bool __fastcall sub_42E900(char a1, __int64 a2, unsigned __int64 a3)
{
  bool result; // al
  HANDLE ProcessHeap; // rax

  result = a1 != 75;
  if ( a1 == 75 && a2 != 0 )
  {
    if ( !_InterlockedDecrement64(*(volatile signed __int64 **)a2) )
      sub_422320((__int64 *)a2, a2, a3);
    if ( !_InterlockedDecrement64(*(volatile signed __int64 **)(a2 + 352)) )
      sub_41D140(*(LPVOID *)(a2 + 352), a2, a3);
    sub_41D230(a2 + 104);
    ProcessHeap = GetProcessHeap();
    return HeapFree(ProcessHeap, 0, (LPVOID)a2);
  }
  return result;
}
// 42E94C: variable 'a2' is possibly undefined
// 42E94C: variable 'a3' is possibly undefined

//----- (000000000042E9B0) ----------------------------------------------------
unsigned __int64 __fastcall sub_42E9B0(__int64 a1, unsigned __int64 *a2, unsigned __int8 a3)
{
  char v3; // r9
  unsigned __int64 result; // rax
  unsigned __int64 v5; // r8
  unsigned __int64 v6; // r8
  unsigned __int64 v7; // r8
  unsigned __int64 v8; // r8
  __int128 v9; // rt0

  v3 = 24;
  result = (unsigned int)a3 - 1;
  switch ( a3 )
  {
    case 1u:
      result = *a2;
      v5 = a2[1];
      if ( !v5 )
        goto LABEL_11;
      *a2 = result + 1;
      a2[1] = v5 - 1;
      result = *(unsigned __int8 *)result;
      goto LABEL_10;
    case 2u:
      result = *a2;
      v7 = a2[1];
      if ( v7 <= 1 )
        goto LABEL_11;
      *a2 = result + 2;
      a2[1] = v7 - 2;
      result = *(unsigned __int16 *)result;
      goto LABEL_10;
    case 4u:
      result = *a2;
      v6 = a2[1];
      if ( v6 <= 3 )
        goto LABEL_11;
      *a2 = result + 4;
      a2[1] = v6 - 4;
      result = *(unsigned int *)result;
      goto LABEL_10;
    case 8u:
      result = *a2;
      v8 = a2[1];
      if ( v8 < 8 )
      {
LABEL_11:
        v3 = 19;
        a3 = 0;
LABEL_12:
        *(_BYTE *)a1 = v3;
        *(_DWORD *)(a1 + 1) = a3;
        *(_BYTE *)(a1 + 7) = 0;
        *(_WORD *)(a1 + 5) = 0;
        *(_QWORD *)(a1 + 8) = result;
      }
      else
      {
        *a2 = result + 8;
        a2[1] = v8 - 8;
        *(_QWORD *)&v9 = ((unsigned __int64)(*(unsigned __int16 *)(result + 4) | (*(unsigned __int8 *)(result + 6) << 16)) << 40) | ((unsigned __int64)*(unsigned int *)result << 8);
        *((_QWORD *)&v9 + 1) = *(unsigned __int8 *)(result + 7);
        result = v9 >> 8;
LABEL_10:
        *(_QWORD *)(a1 + 8) = result;
        *(_BYTE *)a1 = 75;
      }
      return result;
    default:
      goto LABEL_12;
  }
}

//----- (000000000042EAB0) ----------------------------------------------------
unsigned __int64 __fastcall sub_42EAB0(__int64 a1, unsigned __int64 *a2, char a3)
{
  unsigned __int64 result; // rax
  unsigned __int64 v4; // r8
  __int128 v5; // rt0
  unsigned __int64 v6; // r8
  char v7; // dl

  if ( a3 == 8 )
  {
    result = *a2;
    v4 = a2[1];
    if ( v4 <= 7 )
    {
      *(_BYTE *)a1 = 19;
      *(_BYTE *)(a1 + 7) = 0;
      *(_WORD *)(a1 + 5) = 0;
      *(_DWORD *)(a1 + 1) = 0;
      *(_QWORD *)(a1 + 8) = result;
    }
    else
    {
      *a2 = result + 8;
      a2[1] = v4 - 8;
      *(_QWORD *)&v5 = ((unsigned __int64)(*(unsigned __int16 *)(result + 4) | (*(unsigned __int8 *)(result + 6) << 16)) << 40) | ((unsigned __int64)*(unsigned int *)result << 8);
      *((_QWORD *)&v5 + 1) = *(unsigned __int8 *)(result + 7);
      result = v5 >> 8;
      *(_QWORD *)(a1 + 8) = result;
      *(_BYTE *)a1 = 75;
    }
  }
  else
  {
    result = *a2;
    v6 = a2[1];
    if ( v6 <= 3 )
    {
      *(_DWORD *)(a1 + 1) = 0;
      *(_BYTE *)(a1 + 7) = 0;
      *(_WORD *)(a1 + 5) = 0;
      v7 = 19;
    }
    else
    {
      *a2 = result + 4;
      a2[1] = v6 - 4;
      result = *(unsigned int *)result;
      v7 = 75;
    }
    *(_QWORD *)(a1 + 8) = result;
    *(_BYTE *)a1 = v7;
  }
  return result;
}

//----- (000000000042EB60) ----------------------------------------------------
unsigned __int64 __fastcall sub_42EB60(__int64 *a1, __int64 a2, unsigned __int64 a3)
{
  __int64 v3; // rdx
  __int64 v4; // rax
  __int64 v5; // rcx
  unsigned __int64 v6; // r8
  unsigned __int64 result; // rax
  unsigned __int64 v8; // rax
  void *v9; // rbx
  HANDLE ProcessHeap; // rax
  _QWORD v11[9]; // [rsp+28h] [rbp-58h] BYREF
  unsigned __int64 v12[2]; // [rsp+70h] [rbp-10h] BYREF
  __int64 v13; // [rsp+80h] [rbp+0h]

  v3 = *a1;
  if ( *a1 )
  {
    a3 = a1[1];
    v4 = a1[2];
    v11[1] = 0LL;
    v11[2] = v3;
    v11[3] = a3;
    v11[5] = 0LL;
    v11[6] = v3;
    v11[7] = a3;
    v5 = 1LL;
  }
  else
  {
    v5 = 0LL;
    v4 = 0LL;
  }
  v11[0] = v5;
  v11[4] = v5;
  v11[8] = v4;
  sub_42EC30(v12, (__int64)v11, a3);
  for ( result = v12[0]; v12[0]; result = v12[0] )
  {
    if ( *(_QWORD *)(result + 112 * v13) )
    {
      v8 = 112 * v13 + result;
      if ( *(_QWORD *)(v8 + 8) )
      {
        v9 = *(void **)(v8 + 16);
        ProcessHeap = GetProcessHeap();
        HeapFree(ProcessHeap, 0, v9);
      }
    }
    sub_42EC30(v12, (__int64)v11, v6);
  }
  return result;
}
// 42EBE6: variable 'v6' is possibly undefined

//----- (000000000042EC30) ----------------------------------------------------
int __fastcall sub_42EC30(unsigned __int64 *a1, __int64 a2, unsigned __int64 a3)
{
  __int64 v4; // rax
  unsigned __int64 v5; // rdi
  unsigned __int64 v6; // rbx
  unsigned __int64 v7; // r14
  unsigned __int64 v8; // rax
  unsigned __int64 v9; // r15
  unsigned __int64 v10; // r9
  __int64 v11; // rcx
  unsigned __int64 v12; // r9
  _QWORD *v13; // rdi
  unsigned __int64 v14; // r8
  bool v15; // zf
  _QWORD *v16; // rax
  _QWORD *v17; // rbx
  HANDLE v18; // rax
  unsigned __int64 v19; // rcx
  unsigned __int64 v20; // r9
  __int64 v21; // r12
  HANDLE v22; // rax
  unsigned __int64 v23; // rcx
  unsigned __int64 v24; // rdx
  HANDLE v25; // rax
  HANDLE ProcessHeap; // rax

  v4 = *(_QWORD *)(a2 + 64);
  if ( v4 )
  {
    *(_QWORD *)(a2 + 64) = v4 - 1;
    if ( *(_DWORD *)a2 != 1 )
      sub_407050((__int64)&off_447CE8);
    v5 = *(_QWORD *)(a2 + 8);
    if ( v5 )
    {
      v6 = *(_QWORD *)(a2 + 16);
      v7 = *(_QWORD *)(a2 + 24);
      v8 = *(unsigned __int16 *)(v5 + 1330);
      if ( v7 < v8 )
        goto LABEL_5;
    }
    else
    {
      v5 = *(_QWORD *)(a2 + 16);
      a3 = *(_QWORD *)(a2 + 24);
      if ( a3 )
      {
        v19 = *(_QWORD *)(a2 + 24);
        v20 = v19 & 7;
        if ( (a3 & 7) != 0 )
        {
          v19 = a3 & 0xFFFFFFFFFFFFFFF8uLL;
          do
          {
            v5 = *(_QWORD *)(v5 + 1336);
            --v20;
          }
          while ( v20 );
        }
        if ( a3 >= 8 )
        {
          do
          {
            a3 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 1336) + 1336LL)
                                                                           + 1336LL)
                                                               + 1336LL)
                                                   + 1336LL)
                                       + 1336LL)
                           + 1336LL);
            v5 = *(_QWORD *)(a3 + 1336);
            v19 -= 8LL;
          }
          while ( v19 );
        }
      }
      *(_QWORD *)a2 = 1LL;
      *(_QWORD *)(a2 + 8) = v5;
      *(_OWORD *)(a2 + 16) = 0LL;
      v7 = 0LL;
      v6 = 0LL;
      LODWORD(v8) = *(unsigned __int16 *)(v5 + 1330);
      if ( *(_WORD *)(v5 + 1330) )
      {
LABEL_5:
        v9 = v5;
        v10 = v7 + 1;
        if ( v6 )
        {
LABEL_6:
          v11 = v9 + 8 * v10 + 1336;
          v12 = v6 & 7;
          if ( (v6 & 7) != 0 )
          {
            v8 = v6 & 0xFFFFFFFFFFFFFFF8uLL;
            do
            {
              a3 = *(_QWORD *)v11;
              v11 = *(_QWORD *)v11 + 1336LL;
              --v12;
            }
            while ( v12 );
            v10 = 0LL;
            if ( v6 < 8 )
              goto LABEL_30;
            goto LABEL_29;
          }
          v8 = v6;
          v10 = 0LL;
          if ( v6 >= 8 )
          {
            do
            {
LABEL_29:
              a3 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)v11 + 1336LL)
                                                                                         + 1336LL)
                                                                             + 1336LL)
                                                                 + 1336LL)
                                                     + 1336LL)
                                         + 1336LL)
                             + 1336LL);
              v11 = a3 + 1336;
              v8 -= 8LL;
            }
            while ( v8 );
          }
LABEL_30:
          *(_QWORD *)(a2 + 8) = a3;
          *(_QWORD *)(a2 + 16) = 0LL;
          *(_QWORD *)(a2 + 24) = v10;
          *a1 = v9;
          a1[1] = v6;
          a1[2] = v7;
          return v8;
        }
LABEL_27:
        a3 = v9;
        goto LABEL_30;
      }
    }
    v21 = a2;
    do
    {
      v9 = *(_QWORD *)(v5 + 1232);
      if ( !v9 )
      {
        ProcessHeap = GetProcessHeap();
        HeapFree(ProcessHeap, 0, (LPVOID)v5);
        sub_407050((__int64)&off_447CD0);
      }
      ++v6;
      v7 = *(unsigned __int16 *)(v5 + 1328);
      v22 = GetProcessHeap();
      LODWORD(v8) = HeapFree(v22, 0, (LPVOID)v5);
      v5 = v9;
    }
    while ( (unsigned __int16)v7 >= *(_WORD *)(v9 + 1330) );
    a2 = v21;
    v10 = v7 + 1;
    if ( v6 )
      goto LABEL_6;
    goto LABEL_27;
  }
  v13 = *(_QWORD **)(a2 + 8);
  v8 = *(_QWORD *)(a2 + 16);
  v14 = *(_QWORD *)(a2 + 24);
  v15 = *(_QWORD *)a2 == 0LL;
  *(_QWORD *)a2 = 0LL;
  if ( !v15 )
  {
    if ( !v13 )
    {
      if ( v14 )
      {
        v23 = v14;
        v24 = v14 & 7;
        if ( (v14 & 7) != 0 )
        {
          v23 = v14 & 0xFFFFFFFFFFFFFFF8uLL;
          do
          {
            v8 = *(_QWORD *)(v8 + 1336);
            --v24;
          }
          while ( v24 );
        }
        v13 = (_QWORD *)v8;
        if ( v14 >= 8 )
        {
          v13 = (_QWORD *)v8;
          do
          {
            v13 = *(_QWORD **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v13[167] + 1336LL)
                                                                                         + 1336LL)
                                                                             + 1336LL)
                                                                 + 1336LL)
                                                     + 1336LL)
                                         + 1336LL)
                             + 1336LL);
            v23 -= 8LL;
          }
          while ( v23 );
        }
      }
      else
      {
        v13 = (_QWORD *)v8;
      }
    }
    v16 = (_QWORD *)v13[154];
    if ( v16 )
    {
      do
      {
        v17 = v16;
        v18 = GetProcessHeap();
        HeapFree(v18, 0, v13);
        v16 = (_QWORD *)v17[154];
        v13 = v17;
      }
      while ( v16 );
    }
    else
    {
      v17 = v13;
    }
    v25 = GetProcessHeap();
    LODWORD(v8) = HeapFree(v25, 0, v17);
  }
  *a1 = 0LL;
  return v8;
}
// 42EEA1: variable 'a3' is possibly undefined
// 447CD0: using guessed type char *off_447CD0;
// 447CE8: using guessed type char *off_447CE8;

//----- (000000000042EFB0) ----------------------------------------------------
unsigned __int64 __fastcall sub_42EFB0(_QWORD *a1, __int64 a2, unsigned __int64 a3)
{
  void **v4; // rdi
  __int64 v5; // r14
  void **v6; // r15
  void *v7; // rbx
  HANDLE ProcessHeap; // rax
  HANDLE v9; // rax

  v4 = (void **)a1[1];
  v5 = a1[2];
  if ( v5 )
  {
    v6 = v4 + 2;
    do
    {
      if ( *(v6 - 2) && *(v6 - 1) )
      {
        v7 = *v6;
        ProcessHeap = GetProcessHeap();
        HeapFree(ProcessHeap, 0, v7);
      }
      v6 += 14;
      --v5;
    }
    while ( v5 );
  }
  if ( *a1 )
  {
    v9 = GetProcessHeap();
    HeapFree(v9, 0, v4);
  }
  return sub_42EB60(a1 + 3, a2, a3);
}
// 42F039: variable 'a2' is possibly undefined
// 42F039: variable 'a3' is possibly undefined

//----- (000000000042F040) ----------------------------------------------------
unsigned __int64 __fastcall sub_42F040(_QWORD *a1, __int64 a2, unsigned __int64 a3)
{
  void **v4; // rdi
  __int64 v5; // r14
  void **v6; // r15
  void *v7; // rbx
  HANDLE ProcessHeap; // rax
  HANDLE v9; // rax

  v4 = (void **)a1[3];
  v5 = a1[4];
  if ( v5 )
  {
    v6 = v4 + 2;
    do
    {
      if ( *(v6 - 2) && *(v6 - 1) )
      {
        v7 = *v6;
        ProcessHeap = GetProcessHeap();
        HeapFree(ProcessHeap, 0, v7);
      }
      v6 += 14;
      --v5;
    }
    while ( v5 );
  }
  if ( a1[2] )
  {
    v9 = GetProcessHeap();
    HeapFree(v9, 0, v4);
  }
  return sub_42EB60(a1 + 5, a2, a3);
}
// 42F0CA: variable 'a2' is possibly undefined
// 42F0CA: variable 'a3' is possibly undefined

//----- (000000000042F0D0) ----------------------------------------------------
BOOL __fastcall sub_42F0D0(__int64 a1, __int64 a2)
{
  _BYTE *v3; // rax
  __int64 v4; // r12
  __int64 v6; // r12
  char *v7; // r14
  unsigned __int64 v8; // r15
  void *v9; // rax
  int v10; // ecx
  unsigned __int64 v11; // r9
  char *v12; // rdx
  unsigned __int64 v13; // rbx
  int v14; // ecx
  __int64 v15; // rdx
  char *v16; // r8
  __int64 v17; // r11
  char *v18; // r10
  char v19; // r15
  __int16 v20; // r15
  int v21; // r13d
  int v22; // ecx
  unsigned __int16 v23; // r8
  BOOL result; // eax
  char v25; // al
  void *v26; // rsi
  HANDLE ProcessHeap; // rax
  char v28; // al
  __int16 v29; // cx
  char *v30; // [rsp+28h] [rbp-38h]
  unsigned __int64 v31; // [rsp+30h] [rbp-30h]
  char *v32; // [rsp+38h] [rbp-28h]
  LPVOID lpMem[2]; // [rsp+40h] [rbp-20h] BYREF
  _BOOL8 v34; // [rsp+50h] [rbp-10h]
  int v35; // [rsp+5Ch] [rbp-4h]
  int v36; // [rsp+60h] [rbp+0h]
  bool v37; // [rsp+67h] [rbp+7h]

  v3 = *(_BYTE **)a2;
  v4 = *(_QWORD *)(a2 + 8);
  if ( !v4 )
  {
    *(_WORD *)(a1 + 8) = 19;
    *(_WORD *)(a1 + 14) = 0;
    *(_DWORD *)(a1 + 10) = 0;
    *(_QWORD *)(a1 + 16) = v3;
    result = 0;
    *(_QWORD *)a1 = 0x8000000000000000uLL;
    return result;
  }
  v6 = v4 - 1;
  v7 = v3 + 1;
  *(_QWORD *)a2 = v3 + 1;
  *(_QWORD *)(a2 + 8) = v6;
  v8 = (unsigned __int8)*v3;
  if ( !*v3 )
  {
    lpMem[0] = 0LL;
    lpMem[1] = (LPVOID)2;
    v34 = 0LL;
    goto LABEL_28;
  }
  v9 = sub_43C4F0((unsigned int)(4 * v8));
  if ( !v9 )
    sub_4040E9(2LL, (unsigned int)(4 * v8));
  lpMem[0] = (LPVOID)v8;
  lpMem[1] = v9;
  v34 = 0LL;
  v12 = 0LL;
  v35 = 0;
  v36 = v10;
  v31 = v8;
  while ( 2 )
  {
    if ( !v6 )
    {
LABEL_31:
      v25 = 19;
      v11 = (unsigned __int64)v7;
LABEL_32:
      *(_BYTE *)(a1 + 8) = v25;
      *(_BYTE *)(a1 + 9) = 0;
      *(_WORD *)(a1 + 14) = 0;
      *(_DWORD *)(a1 + 10) = 0;
      *(_QWORD *)(a1 + 16) = v11;
      result = 0;
      *(_QWORD *)a1 = 0x8000000000000000uLL;
      if ( !lpMem[0] )
        return result;
LABEL_33:
      v26 = lpMem[1];
      ProcessHeap = GetProcessHeap();
      return HeapFree(ProcessHeap, 0, v26);
    }
    v32 = v12;
    v30 = v12 + 1;
    v13 = 0LL;
    v14 = 0;
    v15 = v6;
    v16 = v7;
    while ( 1 )
    {
      v17 = v15 - 1;
      v18 = v16 + 1;
      v19 = *v16;
      if ( v14 == 63 && (unsigned __int8)v19 >= 2u )
      {
        *(_QWORD *)a2 = v18;
        *(_QWORD *)(a2 + 8) = v17;
        v25 = 6;
        goto LABEL_32;
      }
      v13 |= (unsigned __int64)(*v16 & 0x7F) << v14;
      if ( v19 >= 0 )
        break;
      v14 += 7;
      --v15;
      ++v16;
      if ( !v17 )
      {
        v7 += v6;
        *(_QWORD *)a2 = v7;
        *(_QWORD *)(a2 + 8) = 0LL;
        goto LABEL_31;
      }
    }
    *(_QWORD *)a2 = v18;
    *(_QWORD *)(a2 + 8) = v17;
    v20 = -1;
    if ( v13 < 0xFFFF )
      v20 = v13;
    v21 = 0;
    if ( v15 == 1 )
    {
      v28 = 19;
      v29 = 0;
    }
    else
    {
      v37 = v13 == 1;
      v6 = v15 - 2;
      v7 = v16 + 2;
      *(_QWORD *)a2 = v16 + 2;
      *(_QWORD *)(a2 + 8) = v15 - 2;
      v22 = v16[1] & 0x7F;
      if ( v16[1] >= 0 )
        goto LABEL_18;
      if ( v15 == 2 )
        goto LABEL_38;
      v6 = v15 - 3;
      v7 = v16 + 3;
      *(_QWORD *)a2 = v16 + 3;
      *(_QWORD *)(a2 + 8) = v15 - 3;
      v18 = (char *)((unsigned __int8)(v16[2] & 0x7F) << 7);
      v22 = (unsigned int)v18 | (unsigned __int16)v22;
      if ( v16[2] >= 0 )
      {
LABEL_18:
        v36 = v22;
        if ( v32 != lpMem[0] )
          goto LABEL_20;
        goto LABEL_19;
      }
      if ( v15 == 3 )
      {
LABEL_38:
        v28 = 19;
        v29 = 0;
        v18 = v7;
      }
      else
      {
        v15 -= 4LL;
        v7 = v16 + 4;
        *(_QWORD *)a2 = v16 + 4;
        *(_QWORD *)(a2 + 8) = v15;
        v23 = (unsigned __int8)v16[3];
        if ( v23 <= 3u )
        {
          v36 = (v23 << 14) | (unsigned __int16)v22;
          v6 = v15;
          if ( v32 != lpMem[0] )
          {
LABEL_20:
            LOBYTE(v21) = v37;
            v35 += v21;
            *((_WORD *)v9 + 2 * (_QWORD)v32) = v20;
            *((_WORD *)v9 + 2 * (_QWORD)v32 + 1) = v36;
            v34 = (_BOOL8)v30;
            v12 = v30;
            v11 = v13;
            if ( v30 != (char *)v31 )
              continue;
            if ( v35 == 1 )
            {
              result = v34;
              *(_QWORD *)(a1 + 16) = v34;
              *(_OWORD *)a1 = *(_OWORD *)lpMem;
              return result;
            }
LABEL_28:
            *(_BYTE *)(a1 + 8) = 68;
            result = 0;
            *(_QWORD *)a1 = 0x8000000000000000uLL;
            if ( !lpMem[0] )
              return result;
            goto LABEL_33;
          }
LABEL_19:
          sub_430550((__int64 *)lpMem, v15);
          v9 = lpMem[1];
          goto LABEL_20;
        }
        v28 = 6;
        v29 = v36;
      }
    }
    break;
  }
  *(_BYTE *)(a1 + 8) = v28;
  *(_BYTE *)(a1 + 9) = 0;
  *(_WORD *)(a1 + 10) = v29;
  *(_DWORD *)(a1 + 12) = 0;
  *(_QWORD *)(a1 + 16) = v18;
  result = 0;
  *(_QWORD *)a1 = 0x8000000000000000uLL;
  if ( lpMem[0] )
    goto LABEL_33;
  return result;
}
// 42F14F: variable 'v10' is possibly undefined
// 42F376: variable 'v11' is possibly undefined

//----- (000000000042F450) ----------------------------------------------------
__int64 __fastcall sub_42F450(__int64 a1, __int64 *a2)
{
  __int64 result; // rax
  __int64 v3; // r9
  __int64 v4; // r10
  __int64 v5; // r8
  __int64 v6; // r10
  __int64 v7; // r9
  __int64 v8; // r11
  int v9; // ecx
  char v10; // bl

  result = a1;
  v3 = *a2;
  v4 = a2[1];
  if ( v4 )
  {
    v5 = v3 + v4;
    v6 = v4 - 1;
    v7 = v3 + 1;
    v8 = 0LL;
    v9 = 0;
    while ( 1 )
    {
      v10 = *(_BYTE *)(v7 - 1);
      if ( v9 == 63 && (unsigned __int8)v10 >= 2u )
      {
        *a2 = v7;
        a2[1] = v6;
        *(_BYTE *)result = 6;
        return result;
      }
      v8 |= (unsigned __int64)(v10 & 0x7F) << v9;
      if ( v10 >= 0 )
        break;
      v9 += 7;
      ++v7;
      if ( v6-- == 0 )
      {
        *a2 = v5;
        a2[1] = 0LL;
        goto LABEL_9;
      }
    }
    *a2 = v7;
    a2[1] = v6;
    *(_QWORD *)(result + 8) = v8;
    *(_BYTE *)result = 75;
  }
  else
  {
    v5 = *a2;
LABEL_9:
    *(_WORD *)result = 19;
    *(_WORD *)(result + 6) = 0;
    *(_DWORD *)(result + 2) = 0;
    *(_QWORD *)(result + 8) = v5;
  }
  return result;
}

//----- (000000000042F500) ----------------------------------------------------
__int64 *__fastcall sub_42F500(__int64 a1, unsigned __int64 *a2, unsigned int a3, __int64 a4, __int64 a5)
{
  __int64 v8; // r13
  __int64 v9; // rsi
  __int64 *result; // rax
  __int64 v11; // [rsp+28h] [rbp-48h] BYREF
  __int128 v12; // [rsp+30h] [rbp-40h]
  __int128 v13; // [rsp+40h] [rbp-30h]
  __int128 v14; // [rsp+50h] [rbp-20h]
  __int128 v15; // [rsp+60h] [rbp-10h]
  __int64 v16; // [rsp+70h] [rbp+0h]

  v16 = a1;
  if ( !a5 )
    goto LABEL_10;
  v8 = 46LL;
  v9 = 0LL;
  do
  {
    sub_42FB10((__int64)&v11, a2, a3, *(_WORD *)(a4 + v9 + 2));
    v15 = v12;
    if ( v11 == 46 )
    {
      result = (__int64 *)v16;
      *(_OWORD *)(v16 + 8) = v15;
      *result = 46LL;
      return result;
    }
    v13 = v15;
    if ( *(_WORD *)(a4 + v9) == 1 )
    {
      v14 = v13;
      v8 = v11;
    }
    v9 += 4LL;
  }
  while ( 4 * a5 != v9 );
  if ( v8 == 46 )
LABEL_10:
    sub_407050((__int64)&off_447EC8);
  result = (__int64 *)v16;
  *(_OWORD *)(v16 + 8) = v14;
  *result = v8;
  return result;
}
// 447EC8: using guessed type char *off_447EC8;

//----- (000000000042F5F0) ----------------------------------------------------
__int64 __fastcall sub_42F5F0(__int64 a1, unsigned __int64 *a2, unsigned int a3, __int64 a4, __int64 a5)
{
  __int64 v8; // r13
  __int64 result; // rax
  __int64 v10; // rdx
  int v11; // ecx
  _QWORD *v12; // rcx
  __int64 v13; // r8
  int v14; // eax
  __int64 v15; // rdx
  __int64 v16; // [rsp+20h] [rbp-60h] BYREF
  __int64 v17; // [rsp+28h] [rbp-58h]
  __int64 v18; // [rsp+30h] [rbp-50h]
  __int64 v19; // [rsp+38h] [rbp-48h]
  __int64 v20; // [rsp+40h] [rbp-40h]
  __int64 v21; // [rsp+48h] [rbp-38h]
  __int64 v22; // [rsp+50h] [rbp-30h]
  __int64 v23; // [rsp+58h] [rbp-28h]
  __int64 v24; // [rsp+60h] [rbp-20h]
  _DWORD v25[2]; // [rsp+68h] [rbp-18h] BYREF
  __int64 v26; // [rsp+70h] [rbp-10h]
  __int64 v27; // [rsp+78h] [rbp-8h]
  __int64 v28; // [rsp+80h] [rbp+0h]

  v24 = a1;
  memset(v25, 0, 7);
  if ( !a5 )
    goto LABEL_30;
  v21 = 46LL;
  v8 = 0LL;
  v28 = 0LL;
  v27 = 0LL;
  v26 = 0LL;
  v22 = 0LL;
  v23 = 0LL;
  do
  {
    sub_42FB10((__int64)&v16, a2, a3, *(_WORD *)(a4 + v8 + 2));
    result = v17;
    v10 = v18;
    if ( v16 == 46 )
    {
      v12 = (_QWORD *)v24;
      *(_QWORD *)(v24 + 8) = v17;
      v12[2] = v10;
      *v12 = 46LL;
      return result;
    }
    switch ( *(_WORD *)(a4 + v8) )
    {
      case 1:
        v20 = v17;
        v19 = v18;
        v21 = v16;
        break;
      case 2:
        switch ( v16 )
        {
          case 2LL:
            v28 = (unsigned __int8)v17;
            break;
          case 3LL:
            v28 = (unsigned __int16)v17;
            break;
          case 4LL:
            v28 = (unsigned int)v17;
            break;
          case 5LL:
          case 7LL:
            goto LABEL_26;
          case 6LL:
            if ( v17 >= 0 )
LABEL_26:
              v28 = v17;
            break;
          default:
            goto LABEL_4;
        }
        break;
      case 3:
        switch ( v16 )
        {
          case 2LL:
            v27 = (unsigned __int8)v17;
            break;
          case 3LL:
            v27 = (unsigned __int16)v17;
            break;
          case 4LL:
            v27 = (unsigned int)v17;
            break;
          case 5LL:
          case 7LL:
            goto LABEL_20;
          case 6LL:
            if ( v17 >= 0 )
LABEL_20:
              v27 = v17;
            break;
          default:
            goto LABEL_4;
        }
        break;
      case 4:
        switch ( v16 )
        {
          case 2LL:
            v26 = (unsigned __int8)v17;
            break;
          case 3LL:
            v26 = (unsigned __int16)v17;
            break;
          case 4LL:
            v26 = (unsigned int)v17;
            break;
          case 5LL:
          case 7LL:
            goto LABEL_24;
          case 6LL:
            if ( v17 >= 0 )
LABEL_24:
              v26 = v17;
            break;
          default:
            goto LABEL_4;
        }
        break;
      case 5:
        if ( !(v16 ^ 1 | v18 ^ 0x10) )
        {
          v11 = *(_DWORD *)v17;
          *(_DWORD *)((char *)v25 + 3) = *(_DWORD *)(v17 + 3);
          v25[0] = v11;
          v22 = *(_QWORD *)(v17 + 7);
          v23 = *(unsigned __int8 *)(v17 + 15);
        }
        break;
      default:
        break;
    }
LABEL_4:
    v8 += 4LL;
  }
  while ( 4 * a5 != v8 );
  v13 = v21;
  if ( v21 == 46 )
LABEL_30:
    sub_407050((__int64)&off_447E98);
  v14 = v25[0];
  v15 = v24;
  *(_DWORD *)(v24 + 51) = *(_DWORD *)((char *)v25 + 3);
  *(_DWORD *)(v15 + 48) = v14;
  *(_QWORD *)v15 = v13;
  *(_QWORD *)(v15 + 8) = v20;
  *(_QWORD *)(v15 + 16) = v19;
  *(_QWORD *)(v15 + 24) = v28;
  *(_QWORD *)(v15 + 32) = v27;
  *(_QWORD *)(v15 + 40) = v26;
  *(_QWORD *)(v15 + 55) = v22;
  result = v23;
  *(_BYTE *)(v15 + 63) = v23;
  return result;
}
// 447E98: using guessed type char *off_447E98;

//----- (000000000042F890) ----------------------------------------------------
__int64 __fastcall sub_42F890(__int64 a1, __int64 *a2, __int64 a3, __int64 a4)
{
  __int64 result; // rax
  __int64 v5; // rsi
  __int64 v6; // r10
  __int64 v7; // rbx
  __int64 v8; // rdi
  __int64 v9; // r11
  int v10; // ecx
  __int64 v11; // r14
  __int64 v12; // r15
  __int64 v13; // r9
  unsigned __int64 v14; // r8
  char v15; // cl
  __int64 v16; // r13
  __int64 v17; // r12
  __int64 v18; // r14
  __int64 v19; // rbx
  int v20; // ecx
  __int64 v21; // rax
  char v22; // r8
  char v23; // cl
  __int64 v24; // r14
  __int64 v25; // r10
  __int64 v26; // rdi
  __int64 v27; // rsi
  int v28; // ecx
  char v29; // r8
  char v31; // cl
  __int64 v34; // [rsp+18h] [rbp-8h]

  result = a1;
  v5 = *a2;
  v6 = a2[1];
  if ( !v6 )
  {
    v7 = *a2;
    v15 = 19;
LABEL_9:
    *(_BYTE *)(result + 8) = v15;
    *(_BYTE *)(result + 9) = 0;
    *(_WORD *)(result + 14) = 0;
    *(_DWORD *)(result + 10) = 0;
    *(_QWORD *)(result + 16) = v7;
    goto LABEL_10;
  }
  v7 = v5 + v6;
  v8 = 0LL;
  v9 = 0LL;
  v10 = 0;
  v11 = a2[1];
  while ( 1 )
  {
    v12 = v11 - 1;
    v13 = v5 + v8 + 1;
    v14 = *(unsigned __int8 *)(v5 + v8);
    if ( v14 >= 2 && v10 == 63 )
    {
      *a2 = v13;
      a2[1] = v12;
      v15 = 6;
      goto LABEL_9;
    }
    v9 |= (v14 & 0x7F) << v10;
    if ( (v14 & 0x80u) == 0LL )
      break;
    v10 += 7;
    ++v8;
    --v11;
    if ( v6 == v8 )
    {
      *a2 = v7;
      a2[1] = 0LL;
      v15 = 19;
      goto LABEL_9;
    }
  }
  *a2 = v13;
  a2[1] = v12;
  if ( v11 == 1 )
  {
LABEL_18:
    v23 = 19;
LABEL_20:
    *(_BYTE *)(result + 8) = v23;
    *(_BYTE *)(result + 9) = 0;
    *(_WORD *)(result + 14) = 0;
    *(_DWORD *)(result + 10) = 0;
    *(_QWORD *)(result + 16) = v13;
    goto LABEL_10;
  }
  v34 = result;
  v16 = -2 - v8;
  v17 = ~v8;
  v18 = v8 + v5 + v11;
  v19 = 0LL;
  v20 = 0;
  while ( 1 )
  {
    v13 = v6 + v16;
    v21 = v5 + v8 + 2;
    v22 = *(_BYTE *)(v5 + v8 + 1);
    if ( v20 == 63 && (unsigned __int8)v22 >= 2u )
    {
      *a2 = v21;
      a2[1] = v13;
      v23 = 6;
      result = v34;
      goto LABEL_20;
    }
    v19 |= (unsigned __int64)(*(_BYTE *)(v5 + v8 + 1) & 0x7F) << v20;
    if ( v22 >= 0 )
      break;
    v20 += 7;
    ++v8;
    --v17;
    --v16;
    if ( v6 - 1 == v8 )
    {
      *a2 = v18;
      a2[1] = 0LL;
      v13 = v18;
      result = v34;
      goto LABEL_18;
    }
  }
  v24 = v5 + v8 + 2;
  *a2 = v21;
  a2[1] = v13;
  if ( !v13 )
  {
LABEL_28:
    v31 = 19;
LABEL_30:
    result = v34;
    *(_BYTE *)(v34 + 8) = v31;
    *(_BYTE *)(v34 + 9) = 0;
    *(_WORD *)(v34 + 14) = 0;
    *(_DWORD *)(v34 + 10) = 0;
    *(_QWORD *)(v34 + 16) = v24;
LABEL_10:
    *(_QWORD *)result = 46LL;
    return result;
  }
  v24 = v6 + v17 + v5 + v8 + 1;
  v25 = v6 - v8 - 3;
  v26 = v5 + v8 + 3;
  v27 = 0LL;
  v28 = 0;
  while ( 1 )
  {
    v29 = *(_BYTE *)(v26 - 1);
    if ( v28 == 63 && (unsigned __int8)v29 >= 2u )
    {
      *a2 = v26;
      a2[1] = v25;
      v31 = 6;
      goto LABEL_30;
    }
    v27 |= (unsigned __int64)(v29 & 0x7F) << v28;
    if ( v29 >= 0 )
      break;
    v28 += 7;
    ++v26;
    if ( v25-- == 0 )
    {
      *a2 = v24;
      a2[1] = 0LL;
      goto LABEL_28;
    }
  }
  *a2 = v26;
  a2[1] = v25;
  result = v34;
  *(_OWORD *)(v34 + 48) = 0LL;
  *(_QWORD *)v34 = 31LL;
  *(_QWORD *)(v34 + 8) = a3;
  *(_QWORD *)(v34 + 16) = a4;
  *(_QWORD *)(v34 + 24) = v9;
  *(_QWORD *)(v34 + 32) = v19;
  *(_QWORD *)(v34 + 40) = v27;
  return result;
}

//----- (000000000042FB10) ----------------------------------------------------
__int64 __fastcall sub_42FB10(__int64 a1, unsigned __int64 *a2, unsigned int a3, __int16 a4)
{
  __int64 result; // rax
  unsigned int v5; // r8d
  unsigned __int16 *v6; // r9
  unsigned __int64 v7; // rcx
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // r8
  unsigned __int64 v10; // r9
  bool v11; // cf
  unsigned __int64 v12; // rcx
  unsigned __int16 *v13; // rcx
  unsigned __int64 v14; // r8
  __int128 v15; // rt0
  unsigned __int64 v16; // r10
  unsigned __int64 v17; // r11
  unsigned __int64 v18; // r11
  unsigned __int64 v19; // r10
  int v20; // ecx
  char v21; // bl
  unsigned int v22; // ecx
  __int64 v23; // r11
  unsigned __int64 v24; // r10
  unsigned __int64 v25; // rcx
  unsigned __int8 *v26; // r10
  __int64 v27; // r9
  int v28; // ecx
  __int64 v29; // r8
  unsigned __int8 *v30; // r11
  char v31; // cl
  unsigned __int64 v32; // r11
  int v33; // ecx
  char v34; // bl
  char v35; // cl
  unsigned __int64 v36; // r8
  __int128 v37; // rt0
  unsigned __int64 v38; // rcx
  unsigned __int64 v39; // r8
  __int128 v40; // rt0
  unsigned __int64 v41; // rcx
  unsigned __int64 v42; // rcx
  unsigned __int64 v43; // rcx
  unsigned __int64 v44; // rcx
  unsigned __int64 v45; // r8
  unsigned __int64 v46; // r11
  unsigned __int64 v47; // r10
  unsigned __int64 v48; // r11
  int v49; // ecx
  char v50; // bl
  char v51; // cl
  unsigned __int64 v52; // r8
  __int128 v53; // rt0
  unsigned __int64 v54; // r8
  __int128 v55; // rt0
  unsigned __int64 v56; // r8
  unsigned __int64 v57; // r8
  unsigned __int64 v58; // r8
  unsigned __int64 v59; // r8
  __int64 v60; // rdx
  unsigned __int64 v61; // r11

  result = a1;
  v5 = a3 >> 8;
  switch ( a4 )
  {
    case 3:
      v6 = (unsigned __int16 *)*a2;
      v7 = a2[1];
      if ( v7 <= 1 )
      {
        *(_WORD *)(result + 9) = 0;
        *(_BYTE *)(result + 15) = 0;
        *(_DWORD *)(result + 11) = 0;
        goto LABEL_99;
      }
      v8 = v7 - 2;
      v9 = (unsigned __int64)(v6 + 1);
      *a2 = (unsigned __int64)(v6 + 1);
      a2[1] = v8;
      v10 = *v6;
      v11 = v8 < v10;
      v12 = v8 - v10;
      if ( !v11 )
        goto LABEL_60;
      goto LABEL_127;
    case 4:
      v6 = (unsigned __int16 *)*a2;
      v41 = a2[1];
      if ( v41 <= 3 )
      {
        *(_DWORD *)(result + 9) = 0;
        *(_BYTE *)(result + 15) = 0;
        *(_WORD *)(result + 13) = 0;
LABEL_99:
        *(_BYTE *)(result + 8) = 19;
        *(_QWORD *)(result + 16) = v6;
        goto LABEL_128;
      }
      v42 = v41 - 4;
      v9 = (unsigned __int64)(v6 + 2);
      *a2 = (unsigned __int64)(v6 + 2);
      a2[1] = v42;
      v10 = *(unsigned int *)v6;
      v11 = v42 < v10;
      v12 = v42 - v10;
      if ( !v11 )
        goto LABEL_60;
      goto LABEL_127;
    case 5:
      v13 = (unsigned __int16 *)*a2;
      v9 = a2[1];
      if ( v9 > 1 )
      {
        v10 = (unsigned __int64)(v13 + 1);
        *a2 = (unsigned __int64)(v13 + 1);
        a2[1] = v9 - 2;
        LOWORD(v9) = *v13;
        v22 = HIBYTE(*v13);
        v23 = 3LL;
        goto LABEL_78;
      }
      *(_WORD *)(result + 8) = 19;
      *(_WORD *)(result + 10) = 0;
      *(_DWORD *)(result + 12) = 0;
      goto LABEL_110;
    case 6:
      v13 = (unsigned __int16 *)*a2;
      v9 = a2[1];
      if ( v9 > 3 )
      {
        v10 = (unsigned __int64)(v13 + 2);
        *a2 = (unsigned __int64)(v13 + 2);
        a2[1] = v9 - 4;
        LODWORD(v9) = *(_DWORD *)v13;
        v22 = *(_DWORD *)v13 >> 8;
        LODWORD(a2) = WORD1(v9);
        v23 = 4LL;
        v24 = 0LL;
        goto LABEL_125;
      }
      *(_BYTE *)(result + 11) = 0;
      *(_WORD *)(result + 9) = 0;
      *(_BYTE *)(result + 8) = 19;
      *(_DWORD *)(result + 12) = 0;
      goto LABEL_110;
    case 7:
      v13 = (unsigned __int16 *)*a2;
      v39 = a2[1];
      if ( v39 <= 7 )
        goto LABEL_109;
      *a2 = (unsigned __int64)(v13 + 4);
      a2[1] = v39 - 8;
      v10 = (unsigned __int64)(v13[2] | (*((unsigned __int8 *)v13 + 6) << 16)) << 40;
      *(_QWORD *)&v40 = v10 | ((unsigned __int64)*(unsigned int *)v13 << 8);
      *((_QWORD *)&v40 + 1) = *((unsigned __int8 *)v13 + 7);
      v9 = v40 >> 8;
      v22 = (unsigned int)((__int64)v40 >> 8) >> 8;
      a2 = (unsigned __int64 *)(v9 >> 16);
      v24 = v9 & 0xFFFFFFFF00000000uLL;
      v23 = 5LL;
      goto LABEL_125;
    case 8:
      v9 = *a2;
      v38 = a2[1];
      if ( !v38 )
        goto LABEL_127;
      v10 = 0LL;
      while ( *(_BYTE *)(v9 + v10) )
      {
        if ( v38 == ++v10 )
          goto LABEL_127;
      }
      *a2 = v9 + v10 + 1;
      a2[1] = ~v10 + v38;
      v22 = (unsigned int)v9 >> 8;
      a2 = (unsigned __int64 *)(v9 >> 16);
      v24 = v9 & 0xFFFFFFFF00000000uLL;
      v23 = 31LL;
      goto LABEL_125;
    case 9:
      v45 = *a2;
      v46 = a2[1];
      if ( !v46 )
      {
        v47 = *a2;
        v51 = 19;
        goto LABEL_123;
      }
      v47 = v45 + v46;
      v48 = v46 - 1;
      v9 = v45 + 1;
      v10 = 0LL;
      v49 = 0;
      while ( 1 )
      {
        v50 = *(_BYTE *)(v9 - 1);
        if ( v49 == 63 && (unsigned __int8)v50 >= 2u )
        {
          *a2 = v9;
          a2[1] = v48;
          v51 = 6;
          goto LABEL_123;
        }
        v10 |= (unsigned __int64)(v50 & 0x7F) << v49;
        if ( v50 >= 0 )
          break;
        v49 += 7;
        ++v9;
        v11 = v48-- != 0;
        if ( !v11 )
        {
          *a2 = v47;
          a2[1] = 0LL;
          v51 = 19;
LABEL_123:
          *(_BYTE *)(result + 8) = v51;
          *(_BYTE *)(result + 9) = 0;
          *(_WORD *)(result + 14) = 0;
          *(_DWORD *)(result + 10) = 0;
          *(_QWORD *)(result + 16) = v47;
          goto LABEL_128;
        }
      }
      *a2 = v9;
      a2[1] = v48;
      v11 = v48 < v10;
      v61 = v48 - v10;
      if ( v11 )
      {
LABEL_127:
        *(_QWORD *)(result + 8) = 19LL;
        *(_QWORD *)(result + 16) = v9;
        goto LABEL_128;
      }
      *a2 = v9 + v10;
      a2[1] = v61;
LABEL_61:
      v22 = (unsigned int)v9 >> 8;
      a2 = (unsigned __int64 *)(v9 >> 16);
      v24 = v9 & 0xFFFFFFFF00000000uLL;
      v23 = 1LL;
      goto LABEL_125;
    case 10:
      v10 = *a2;
      v43 = a2[1];
      if ( !v43 )
      {
        *(_WORD *)(result + 8) = 19;
        goto LABEL_91;
      }
      v44 = v43 - 1;
      v9 = v10 + 1;
      *a2 = v10 + 1;
      a2[1] = v44;
      v10 = *(unsigned __int8 *)v10;
      v11 = v44 < v10;
      v12 = v44 - v10;
      if ( v11 )
        goto LABEL_127;
LABEL_60:
      *a2 = v9 + v10;
      a2[1] = v12;
      goto LABEL_61;
    case 11:
      v13 = (unsigned __int16 *)*a2;
      v9 = a2[1];
      if ( !v9 )
        goto LABEL_79;
      v10 = (unsigned __int64)v13 + 1;
      *a2 = (unsigned __int64)v13 + 1;
      a2[1] = v9 - 1;
      LOBYTE(v9) = *(_BYTE *)v13;
      v23 = 2LL;
      goto LABEL_77;
    case 12:
      v13 = (unsigned __int16 *)*a2;
      v9 = a2[1];
      if ( !v9 )
        goto LABEL_79;
      v10 = (unsigned __int64)v13 + 1;
      *a2 = (unsigned __int64)v13 + 1;
      a2[1] = v9 - 1;
      LOBYTE(v9) = *(_BYTE *)v13 != 0;
      v23 = 9LL;
      goto LABEL_77;
    case 13:
      v26 = (unsigned __int8 *)*a2;
      v27 = a2[1] - 1;
      v28 = 0;
      v29 = 0LL;
      do
      {
        v30 = v26;
        if ( v27 == -1 )
        {
          v31 = 19;
          goto LABEL_112;
        }
        ++v26;
        *a2 = (unsigned __int64)(v30 + 1);
        a2[1] = v27;
        v30 = (unsigned __int8 *)*v30;
        if ( v28 == 63 && (_DWORD)v30 != 127 && (_DWORD)v30 )
        {
          v31 = 7;
LABEL_112:
          *(_BYTE *)(result + 8) = v31;
          *(_BYTE *)(result + 9) = 0;
          *(_WORD *)(result + 14) = 0;
          *(_DWORD *)(result + 10) = 0;
          *(_QWORD *)(result + 16) = v30;
          goto LABEL_128;
        }
        v29 |= (unsigned __int64)((unsigned __int8)v30 & 0x7F) << v28;
        v28 += 7;
        --v27;
      }
      while ( (char)v30 < 0 );
      v60 = -1LL << v28;
      v10 = 0LL;
      if ( (unsigned __int8)v30 < 0x40u )
        v60 = 0LL;
      if ( v28 >= 64 )
        v60 = 0LL;
      v9 = v60 | v29;
      v22 = (unsigned int)v9 >> 8;
      a2 = (unsigned __int64 *)(v9 >> 16);
      v24 = v9 & 0xFFFFFFFF00000000uLL;
      v23 = 6LL;
      goto LABEL_125;
    case 14:
      if ( (_BYTE)v5 == 8 )
      {
        v13 = (unsigned __int16 *)*a2;
        v36 = a2[1];
        if ( v36 <= 7 )
          goto LABEL_109;
        *a2 = (unsigned __int64)(v13 + 4);
        a2[1] = v36 - 8;
        v10 = (unsigned __int64)(v13[2] | (*((unsigned __int8 *)v13 + 6) << 16)) << 40;
        *(_QWORD *)&v37 = v10 | ((unsigned __int64)*(unsigned int *)v13 << 8);
        *((_QWORD *)&v37 + 1) = *((unsigned __int8 *)v13 + 7);
        v9 = v37 >> 8;
      }
      else
      {
        v13 = (unsigned __int16 *)*a2;
        v57 = a2[1];
        if ( v57 <= 3 )
          goto LABEL_109;
        v10 = (unsigned __int64)(v13 + 2);
        *a2 = (unsigned __int64)(v13 + 2);
        a2[1] = v57 - 4;
        v9 = *(unsigned int *)v13;
      }
      v22 = (unsigned int)v9 >> 8;
      a2 = (unsigned __int64 *)(v9 >> 16);
      v24 = v9 & 0xFFFFFFFF00000000uLL;
      v23 = 26LL;
      goto LABEL_125;
    case 15:
      v16 = *a2;
      v32 = a2[1];
      if ( !v32 )
        goto LABEL_41;
      v10 = v16 + v32;
      v18 = v32 - 1;
      v19 = v16 + 1;
      v9 = 0LL;
      v33 = 0;
      while ( 1 )
      {
        v34 = *(_BYTE *)(v19 - 1);
        if ( v33 == 63 && (unsigned __int8)v34 >= 2u )
          goto LABEL_89;
        v9 |= (unsigned __int64)(v34 & 0x7F) << v33;
        if ( v34 >= 0 )
        {
          *a2 = v19;
          a2[1] = v18;
          v22 = (unsigned int)v9 >> 8;
          a2 = (unsigned __int64 *)(v9 >> 16);
          v24 = v9 & 0xFFFFFFFF00000000uLL;
          v23 = 7LL;
          goto LABEL_125;
        }
        v33 += 7;
        ++v19;
        v11 = v18-- != 0;
        if ( !v11 )
        {
LABEL_40:
          *a2 = v10;
          a2[1] = 0LL;
LABEL_42:
          v35 = 19;
          goto LABEL_90;
        }
      }
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 24:
    case 25:
    case 27:
    case 28:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
      goto LABEL_17;
    case 23:
      if ( (_BYTE)v5 == 8 )
      {
        v13 = (unsigned __int16 *)*a2;
        v54 = a2[1];
        if ( v54 <= 7 )
          goto LABEL_109;
        *a2 = (unsigned __int64)(v13 + 4);
        a2[1] = v54 - 8;
        v10 = (unsigned __int64)(v13[2] | (*((unsigned __int8 *)v13 + 6) << 16)) << 40;
        *(_QWORD *)&v55 = v10 | ((unsigned __int64)*(unsigned int *)v13 << 8);
        *((_QWORD *)&v55 + 1) = *((unsigned __int8 *)v13 + 7);
        v9 = v55 >> 8;
      }
      else
      {
        v13 = (unsigned __int16 *)*a2;
        v59 = a2[1];
        if ( v59 <= 3 )
          goto LABEL_109;
        v10 = (unsigned __int64)(v13 + 2);
        *a2 = (unsigned __int64)(v13 + 2);
        a2[1] = v59 - 4;
        v9 = *(unsigned int *)v13;
      }
      v22 = (unsigned int)v9 >> 8;
      a2 = (unsigned __int64 *)(v9 >> 16);
      v24 = v9 & 0xFFFFFFFF00000000uLL;
      v23 = 10LL;
      goto LABEL_125;
    case 26:
      goto LABEL_10;
    case 29:
      goto LABEL_7;
    case 30:
      v9 = *a2;
      v25 = a2[1];
      if ( v25 < 0x10 )
        goto LABEL_127;
      *a2 = v9 + 16;
      a2[1] = v25 - 16;
      v22 = (unsigned int)v9 >> 8;
      a2 = (unsigned __int64 *)(v9 >> 16);
      v24 = v9 & 0xFFFFFFFF00000000uLL;
      v23 = 1LL;
      v10 = 16LL;
      goto LABEL_125;
    case 31:
      if ( (_BYTE)v5 == 8 )
      {
        v13 = (unsigned __int16 *)*a2;
        v52 = a2[1];
        if ( v52 <= 7 )
          goto LABEL_109;
        *a2 = (unsigned __int64)(v13 + 4);
        a2[1] = v52 - 8;
        v10 = (unsigned __int64)(v13[2] | (*((unsigned __int8 *)v13 + 6) << 16)) << 40;
        *(_QWORD *)&v53 = v10 | ((unsigned __int64)*(unsigned int *)v13 << 8);
        *((_QWORD *)&v53 + 1) = *((unsigned __int8 *)v13 + 7);
        v9 = v53 >> 8;
      }
      else
      {
        v13 = (unsigned __int16 *)*a2;
        v58 = a2[1];
        if ( v58 <= 3 )
          goto LABEL_109;
        v10 = (unsigned __int64)(v13 + 2);
        *a2 = (unsigned __int64)(v13 + 2);
        a2[1] = v58 - 4;
        v9 = *(unsigned int *)v13;
      }
      v22 = (unsigned int)v9 >> 8;
      a2 = (unsigned __int64 *)(v9 >> 16);
      v24 = v9 & 0xFFFFFFFF00000000uLL;
      v23 = 30LL;
      goto LABEL_125;
    case 37:
      v13 = (unsigned __int16 *)*a2;
      v9 = a2[1];
      if ( !v9 )
      {
LABEL_79:
        *(_WORD *)(result + 8) = 19;
        *(_WORD *)(result + 14) = 0;
        *(_DWORD *)(result + 10) = 0;
        goto LABEL_110;
      }
      v10 = (unsigned __int64)v13 + 1;
      *a2 = (unsigned __int64)v13 + 1;
      a2[1] = v9 - 1;
      LOBYTE(v9) = *(_BYTE *)v13;
      v23 = 29LL;
LABEL_77:
      LOWORD(v22) = 0;
      goto LABEL_78;
    case 38:
      v13 = (unsigned __int16 *)*a2;
      v9 = a2[1];
      if ( v9 <= 1 )
      {
        *(_WORD *)(result + 9) = 0;
        *(_BYTE *)(result + 15) = 0;
        *(_DWORD *)(result + 11) = 0;
        goto LABEL_101;
      }
      v10 = (unsigned __int64)(v13 + 1);
      *a2 = (unsigned __int64)(v13 + 1);
      a2[1] = v9 - 2;
      LOWORD(v9) = *v13;
      v22 = HIBYTE(*v13);
      v23 = 29LL;
LABEL_78:
      LODWORD(a2) = 0;
      v24 = 0LL;
      goto LABEL_125;
    case 39:
      v13 = (unsigned __int16 *)*a2;
      v9 = a2[1];
      if ( v9 <= 2 )
        goto LABEL_109;
      v10 = (unsigned __int64)v13 + 3;
      *a2 = (unsigned __int64)v13 + 3;
      a2[1] = v9 - 3;
      LODWORD(v9) = *v13;
      LODWORD(a2) = *((unsigned __int8 *)v13 + 2);
      v22 = ((unsigned int)v9 | ((_DWORD)a2 << 16)) >> 8;
      goto LABEL_22;
    case 40:
      v13 = (unsigned __int16 *)*a2;
      v9 = a2[1];
      if ( v9 > 3 )
      {
        v10 = (unsigned __int64)(v13 + 2);
        *a2 = (unsigned __int64)(v13 + 2);
        a2[1] = v9 - 4;
        LODWORD(v9) = *(_DWORD *)v13;
        v22 = *(_DWORD *)v13 >> 8;
        LODWORD(a2) = WORD1(v9);
LABEL_22:
        v23 = 29LL;
        v24 = 0LL;
        goto LABEL_125;
      }
      *(_DWORD *)(result + 9) = 0;
      *(_BYTE *)(result + 15) = 0;
      *(_WORD *)(result + 13) = 0;
LABEL_101:
      *(_BYTE *)(result + 8) = 19;
      goto LABEL_110;
    default:
      if ( a4 == 7938 )
      {
LABEL_10:
        v16 = *a2;
        v17 = a2[1];
        if ( !v17 )
        {
LABEL_41:
          v10 = v16;
          goto LABEL_42;
        }
        v10 = v16 + v17;
        v18 = v17 - 1;
        v19 = v16 + 1;
        v9 = 0LL;
        v20 = 0;
        while ( 1 )
        {
          v21 = *(_BYTE *)(v19 - 1);
          if ( v20 == 63 && (unsigned __int8)v21 >= 2u )
            break;
          v9 |= (unsigned __int64)(v21 & 0x7F) << v20;
          if ( v21 >= 0 )
          {
            *a2 = v19;
            a2[1] = v18;
            v22 = (unsigned int)v9 >> 8;
            a2 = (unsigned __int64 *)(v9 >> 16);
            v24 = v9 & 0xFFFFFFFF00000000uLL;
            v23 = 29LL;
LABEL_125:
            *(_QWORD *)result = v23;
            *(_QWORD *)(result + 8) = v24 | ((_DWORD)a2 << 16) | (unsigned int)(unsigned __int16)(((_WORD)v22 << 8) | (unsigned __int8)v9);
            *(_QWORD *)(result + 16) = v10;
            return result;
          }
          v20 += 7;
          ++v19;
          v11 = v18-- != 0;
          if ( !v11 )
            goto LABEL_40;
        }
LABEL_89:
        *a2 = v19;
        a2[1] = v18;
        v35 = 6;
LABEL_90:
        *(_BYTE *)(result + 8) = v35;
        *(_BYTE *)(result + 9) = 0;
LABEL_91:
        *(_WORD *)(result + 14) = 0;
        *(_DWORD *)(result + 10) = 0;
        *(_QWORD *)(result + 16) = v10;
      }
      else
      {
        if ( a4 != 7969 )
        {
LABEL_17:
          *(_BYTE *)(a1 + 8) = 12;
          goto LABEL_128;
        }
LABEL_7:
        if ( (_BYTE)v5 == 8 )
        {
          v13 = (unsigned __int16 *)*a2;
          v14 = a2[1];
          if ( v14 > 7 )
          {
            *a2 = (unsigned __int64)(v13 + 4);
            a2[1] = v14 - 8;
            v10 = (unsigned __int64)(v13[2] | (*((unsigned __int8 *)v13 + 6) << 16)) << 40;
            *(_QWORD *)&v15 = v10 | ((unsigned __int64)*(unsigned int *)v13 << 8);
            *((_QWORD *)&v15 + 1) = *((unsigned __int8 *)v13 + 7);
            v9 = v15 >> 8;
LABEL_88:
            v22 = (unsigned int)v9 >> 8;
            a2 = (unsigned __int64 *)(v9 >> 16);
            v24 = v9 & 0xFFFFFFFF00000000uLL;
            v23 = 27LL;
            goto LABEL_125;
          }
        }
        else
        {
          v13 = (unsigned __int16 *)*a2;
          v56 = a2[1];
          if ( v56 > 3 )
          {
            v10 = (unsigned __int64)(v13 + 2);
            *a2 = (unsigned __int64)(v13 + 2);
            a2[1] = v56 - 4;
            v9 = *(unsigned int *)v13;
            goto LABEL_88;
          }
        }
LABEL_109:
        *(_BYTE *)(result + 8) = 19;
        *(_BYTE *)(result + 15) = 0;
        *(_WORD *)(result + 13) = 0;
        *(_DWORD *)(result + 9) = 0;
LABEL_110:
        *(_QWORD *)(result + 16) = v13;
      }
LABEL_128:
      *(_QWORD *)result = 46LL;
      return result;
  }
}

//----- (0000000000430550) ----------------------------------------------------
__int64 __fastcall sub_430550(__int64 *a1, __int64 a2)
{
  __int64 v2; // rax
  unsigned __int64 v4; // rdx
  __int64 v5; // rdi
  __int64 v6; // rcx
  __int64 v7; // rax
  __int64 result; // rax
  _QWORD v9[3]; // [rsp+20h] [rbp-30h] BYREF
  __int64 v10; // [rsp+38h] [rbp-18h] BYREF
  __int64 v11; // [rsp+40h] [rbp-10h]
  __int64 v12; // [rsp+48h] [rbp-8h]

  v2 = *a1;
  if ( *a1 == -1 )
    goto LABEL_13;
  v4 = v2 + 1;
  if ( 2 * v2 > (unsigned __int64)(v2 + 1) )
    v4 = 2 * v2;
  v5 = 4LL;
  if ( v4 >= 5 )
    v5 = v4;
  v6 = 0LL;
  a2 = v4 >> 62;
  if ( a2 )
LABEL_13:
    sub_40408F(0LL, a2, (__int64)&off_447EB0);
  if ( (unsigned __int64)(4 * v5) > 0x7FFFFFFFFFFFFFFELL )
LABEL_15:
    sub_40408F(v6, a2, (__int64)&off_447EB0);
  if ( v2 )
  {
    v9[0] = a1[1];
    v9[2] = 4 * v2;
    v7 = 2LL;
  }
  else
  {
    v7 = 0LL;
  }
  v9[1] = v7;
  sub_413370(&v10, (void *)2, 4 * v5, (__int64)v9);
  if ( (_DWORD)v10 == 1 )
  {
    v6 = v11;
    a2 = v12;
    goto LABEL_15;
  }
  result = v11;
  a1[1] = v11;
  *a1 = v5;
  return result;
}
// 447EB0: using guessed type char *off_447EB0;

//----- (0000000000430620) ----------------------------------------------------
void __fastcall sub_430620(__m128i *a1, unsigned __int64 a2, __m128i *a3, size_t a4, char a5)
{
  __m128i *v5; // rsi
  unsigned __int64 v6; // rax
  __int64 v7; // rax
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // r15
  unsigned __int64 v10; // r13
  unsigned __int64 v11; // r11
  unsigned __int64 v12; // r14
  unsigned __int64 v13; // rcx
  __int64 v14; // rdx
  __m128i *v15; // rcx
  unsigned __int64 v16; // rbx
  unsigned __int64 v17; // rdi
  unsigned __int64 v18; // rcx
  unsigned __int64 v19; // rcx
  unsigned __int64 v20; // rdi
  __m128i *v21; // r8
  unsigned __int64 v22; // rax
  __int64 v23; // rdx
  __int64 v24; // r10
  __int64 v25; // rdx
  __m128i v26; // xmm0
  __int64 v27; // r10
  unsigned __int64 v28; // rbx
  __m128i *v29; // r10
  __int64 v30; // r11
  unsigned __int64 v31; // r9
  unsigned __int64 v32; // rsi
  __m128i *v33; // r10
  __int64 v34; // r11
  unsigned __int64 v35; // rsi
  __m128i *v36; // r11
  __m128i *v37; // r10
  __m128i v38; // xmm0
  __int64 v39; // rsi
  __m128i v40; // xmm0
  unsigned __int64 v41; // rax
  unsigned __int64 v42; // rcx
  __m128i *v43; // r13
  char *v44; // rdx
  unsigned __int64 v45; // rbx
  unsigned __int64 v46; // rdi
  unsigned __int64 v47; // r14
  size_t v48; // r12
  unsigned __int64 v49; // rax
  unsigned __int64 v50; // rax
  size_t v51; // rsi
  __m128i *v52; // rbx
  __m128i *v53; // rdx
  char *v54; // r15
  __m128i *v55; // rax
  char *v56; // r10
  int v57; // r9d
  char *m128i_i8; // rdx
  BOOL v59; // r8d
  __m128i *v60; // r10
  __m128i *v61; // r8
  int v62; // eax
  bool v63; // cl
  BOOL v64; // edx
  __m128i *v65; // r9
  unsigned __int64 v66; // rax
  _QWORD v67[75]; // [rsp+38h] [rbp-48h]
  unsigned __int64 v68; // [rsp+290h] [rbp+210h]
  __m128i *v69; // [rsp+298h] [rbp+218h]
  __m128i *v70; // [rsp+2A0h] [rbp+220h]
  __m128i *v71; // [rsp+2A8h] [rbp+228h]
  unsigned __int64 v72; // [rsp+2B0h] [rbp+230h]
  __m128i *v73; // [rsp+2B8h] [rbp+238h]
  unsigned __int64 v74; // [rsp+2C0h] [rbp+240h]
  __m128i *v75; // [rsp+2C8h] [rbp+248h]
  unsigned __int64 v76; // [rsp+2D0h] [rbp+250h]
  unsigned __int64 v77; // [rsp+2D8h] [rbp+258h]
  unsigned __int64 v78; // [rsp+2E0h] [rbp+260h]
  unsigned __int64 v79; // [rsp+2E8h] [rbp+268h]
  __m128i *v80; // [rsp+2F0h] [rbp+270h]
  size_t v81; // [rsp+2F8h] [rbp+278h]
  void *Src; // [rsp+300h] [rbp+280h]

  v5 = a3;
  v80 = a1;
  if ( (a2 | (a2 + 0x3FFFFFFFFFFFFFFFLL)) >> 32 )
    v6 = (a2 + 0x3FFFFFFFFFFFFFFFLL) / a2;
  else
    v6 = ((int)a2 - 1) / (unsigned int)a2;
  v74 = v6;
  v78 = a2;
  if ( a2 >= 0x1001 )
  {
    _BitScanReverse64(&v8, a2 | 1);
    v79 = ((1LL << ((((unsigned int)v8 ^ 0xFFFFFFC0) + 65) >> 1)) + (a2 >> ((((unsigned int)v8 ^ 0xFFFFFFC0) + 65) >> 1))) >> 1;
  }
  else
  {
    v7 = 64LL;
    if ( a2 - (a2 >> 1) < 0x40 )
      v7 = a2 - (a2 >> 1);
    v79 = v7;
  }
  v75 = v80 + 2;
  v71 = v80 + 1;
  v73 = v80 - 1;
  v9 = 1LL;
  v10 = 0LL;
  v11 = 0LL;
  v81 = a4;
  Src = a3;
  v12 = v78;
  if ( !v78 )
    goto LABEL_12;
LABEL_14:
  v14 = v10;
  v15 = &v80[v10];
  if ( v12 < v79 )
    goto LABEL_15;
  if ( v12 < 2 )
  {
    v18 = 2 * v12 + 1;
    goto LABEL_48;
  }
  v20 = v15[1].m128i_u64[0];
  if ( v20 >= v15->m128i_i64[0] )
  {
    v27 = 2LL;
    if ( v12 == 2 )
      goto LABEL_47;
    v28 = v11;
    v29 = &v75[v14];
    v22 = 2LL;
    v30 = v15[1].m128i_i64[0];
    v31 = v12;
    while ( 1 )
    {
      v32 = v30;
      v30 = v29->m128i_i64[0];
      if ( v29->m128i_i64[0] < v32 )
        break;
      ++v22;
      ++v29;
      if ( v12 == v22 )
      {
LABEL_37:
        v22 = v31;
        break;
      }
    }
  }
  else
  {
    if ( v12 == 2 )
    {
      v21 = v15 + 2;
      v22 = 2LL;
      goto LABEL_27;
    }
    v28 = v11;
    v33 = &v75[v14];
    v22 = 2LL;
    v34 = v15[1].m128i_i64[0];
    v31 = v12;
    while ( 1 )
    {
      v35 = v34;
      v34 = v33->m128i_i64[0];
      if ( v33->m128i_i64[0] >= v35 )
        break;
      ++v22;
      ++v33;
      if ( v12 == v22 )
        goto LABEL_37;
    }
  }
  a4 = v81;
  v5 = (__m128i *)Src;
  v11 = v28;
  if ( v22 >= v79 )
  {
    if ( v20 >= v15->m128i_i64[0] )
      goto LABEL_46;
    v27 = 1LL;
    if ( v22 >= 2 )
    {
      v21 = &v15[v22];
      if ( v22 >> 1 != 1 )
      {
        v36 = &v71[v14];
        v37 = &v73[v22 + v14];
        v23 = 0LL;
        do
        {
          v38 = v36[-1];
          v36[-1] = *v37;
          *v37 = v38;
          v39 = v23 ^ 0xFFFFFFFFFFFFFFELL;
          v40 = *v36;
          *v36 = v21[v39];
          v21[v39] = v40;
          v23 += 2LL;
          v36 += 2;
          v37 -= 2;
        }
        while ( ((v22 >> 1) & 0xFFFFFFFFFFFFFFFEuLL) != v23 );
        v27 = v22;
        a4 = v81;
        v5 = (__m128i *)Src;
        v11 = v28;
        if ( (v22 & 2) == 0 )
          goto LABEL_47;
        goto LABEL_28;
      }
LABEL_27:
      v23 = 0LL;
LABEL_28:
      v24 = ~v23;
      v25 = v23;
      v24 *= 16LL;
      v26 = v15[v25];
      v15[v25] = *(__m128i *)((char *)v21 + v24);
      *(__m128i *)((char *)v21 + v24) = v26;
LABEL_46:
      v27 = v22;
    }
LABEL_47:
    v18 = 2 * v27 + 1;
    goto LABEL_48;
  }
LABEL_15:
  if ( a5 )
  {
    v16 = v12;
    if ( v12 >= 0x20 )
      v16 = 32LL;
    v17 = v11;
    sub_430D80(v15, v16, v5, a4, 0, 0LL);
    v11 = v17;
    a4 = v81;
    v18 = 2LL * (unsigned int)v16 + 1;
  }
  else
  {
    v19 = v12;
    if ( v79 < v12 )
      v19 = v79;
    v18 = 2 * v19;
  }
LABEL_48:
  v72 = v18;
  v41 = (v74 * (2 * v10 - (v9 >> 1))) ^ (v74 * ((v18 >> 1) + 2 * v10));
  if ( !v41 )
  {
    v13 = 64LL;
    if ( v11 < 2 )
      goto LABEL_89;
    goto LABEL_52;
  }
  _BitScanReverse64(&v42, v41);
  v13 = v42 ^ 0x3F;
  if ( v11 >= 2 )
  {
LABEL_52:
    v70 = &v80[v10];
    v69 = &v73[v10];
    v77 = v13;
    v68 = v10;
    while ( 1 )
    {
      while ( 1 )
      {
        if ( *((_BYTE *)&v67[66] + v11 + 5) < (unsigned __int8)v13 )
          goto LABEL_89;
        v45 = v67[--v11];
        v46 = v45 >> 1;
        v47 = v9 >> 1;
        v48 = (v45 >> 1) + (v9 >> 1);
        if ( v48 > a4 || (((unsigned __int8)v9 | (unsigned __int8)v45) & 1) != 0 )
          break;
        v9 = 2 * v48;
        if ( v11 <= 1 )
        {
LABEL_88:
          v11 = 1LL;
          goto LABEL_89;
        }
      }
      v43 = &v80[v10 - v48];
      v76 = v11;
      if ( (v45 & 1) != 0 )
      {
        if ( (v9 & 1) != 0 )
        {
LABEL_63:
          if ( v9 >= 2 )
            goto LABEL_67;
          goto LABEL_55;
        }
      }
      else
      {
        _BitScanReverse64(&v49, v46 | 1);
        sub_430D80(v43, v46, v5, a4, (2 * (v49 ^ 0x3F)) ^ 0x7E, 0LL);
        LOBYTE(v13) = v77;
        v11 = v76;
        a4 = v81;
        if ( (v9 & 1) != 0 )
          goto LABEL_63;
      }
      _BitScanReverse64(&v50, v47 | 1);
      sub_430D80(&v43[v46], v9 >> 1, v5, a4, (2 * (v50 ^ 0x3F)) ^ 0x7E, 0LL);
      LOBYTE(v13) = v77;
      v11 = v76;
      a4 = v81;
      if ( v9 >= 2 )
      {
LABEL_67:
        if ( v45 >= 2 )
        {
          v51 = v9 >> 1;
          if ( v46 < v47 )
            v51 = v45 >> 1;
          if ( v51 <= a4 )
          {
            v52 = &v43[v46];
            v53 = v43;
            if ( v47 < v46 )
              v53 = &v43[v46];
            memcpy(Src, v53, 16 * v51);
            v54 = (char *)Src + 16 * v51;
            if ( v47 >= v46 )
            {
              if ( v51 )
              {
                v44 = (char *)Src;
                v60 = v70;
                do
                {
                  v61 = (__m128i *)v44;
                  v62 = 0;
                  v63 = v52->m128i_i64[0] < *(_QWORD *)v44;
                  v64 = v52->m128i_i64[0] >= *(_QWORD *)v44;
                  v65 = v61;
                  if ( v52->m128i_i64[0] < (unsigned __int64)v61->m128i_i64[0] )
                    v65 = v52;
                  *v43 = *v65;
                  v44 = &v61->m128i_i8[16 * v64];
                  ++v43;
                  if ( v44 == v54 )
                    break;
                  LOBYTE(v62) = v63;
                  v52 = (__m128i *)((char *)v52 + (unsigned int)(16 * v62));
                }
                while ( v52 != v60 );
              }
              else
              {
                v44 = (char *)Src;
              }
            }
            else
            {
              v55 = v69;
              v56 = (char *)Src;
              do
              {
                v57 = 0;
                m128i_i8 = v54 - 16;
                v59 = *((_QWORD *)v54 - 2) < v52[-1].m128i_i64[0];
                if ( *((_QWORD *)v54 - 2) < v52[-1].m128i_i64[0] )
                  m128i_i8 = v52[-1].m128i_i8;
                LOBYTE(v57) = *((_QWORD *)v54 - 2) >= v52[-1].m128i_i64[0];
                *v55 = *(__m128i *)m128i_i8;
                v52 = (__m128i *)((char *)v52 + (unsigned int)(16 * v57) - 16);
                v54 = &v54[16 * v59 - 16];
                if ( v52 == v43 )
                  break;
                --v55;
              }
              while ( v54 != v56 );
              v43 = v52;
              v44 = v56;
            }
            memcpy(v43, v44, v54 - v44);
            a4 = v81;
            v11 = v76;
            LOBYTE(v13) = v77;
          }
        }
      }
LABEL_55:
      v9 = 2 * v48 + 1;
      v5 = (__m128i *)Src;
      v10 = v68;
      if ( v11 <= 1 )
        goto LABEL_88;
    }
  }
LABEL_89:
  while ( 1 )
  {
    v67[v11] = v9;
    *((_BYTE *)&v67[66] + v11 + 6) = v13;
    if ( v78 <= v10 )
      break;
    ++v11;
    v9 = v72;
    v10 += v72 >> 1;
    v12 = v78 - v10;
    if ( v78 > v10 )
      goto LABEL_14;
LABEL_12:
    v13 = 0LL;
    v72 = 1LL;
    if ( v11 >= 2 )
      goto LABEL_52;
  }
  if ( (v9 & 1) == 0 )
  {
    _BitScanReverse64(&v66, v78 | 1);
    sub_430D80(v80, v78, v5, a4, (2 * (v66 ^ 0x3F)) ^ 0x7E, 0LL);
  }
}

//----- (0000000000430D80) ----------------------------------------------------
void __fastcall sub_430D80(__m128i *a1, unsigned __int64 a2, __m128i *a3, size_t a4, int a5, __int64 *a6)
{
  unsigned __int64 v7; // rbx
  unsigned __int64 v9; // r12
  unsigned __int64 v10; // rcx
  unsigned __int64 v11; // rdx
  size_t v12; // r14
  unsigned __int64 v14; // r11
  int v15; // r15d
  const __m128i *v16; // r12
  __m128i *v17; // r8
  bool v18; // dl
  const __m128i *v19; // rax
  __m128i v20; // xmm0
  __int64 v21; // r11
  const __m128i *v22; // rax
  __m128i *v23; // rcx
  unsigned __int64 v24; // rdx
  __int64 v25; // r15
  unsigned __int64 v26; // r8
  __m128i *v27; // r14
  __m128i *i; // r8
  __m128i *v29; // r10
  __int64 v30; // r11
  __int64 v31; // rdi
  bool v32; // cf
  __m128i *v33; // r13
  __int64 v34; // rbx
  unsigned __int64 v35; // r9
  __m128i *v36; // r10
  __int64 v37; // r11
  bool v38; // cf
  __m128i *v39; // r10
  const __m128i *j; // r8
  bool v41; // cf
  __m128i *v42; // r9
  unsigned __int64 v43; // r8
  __int64 v44; // r13
  unsigned __int64 v45; // rdx
  __int64 v46; // rax
  __m128i *v47; // r8
  __m128i *v48; // r15
  __int64 v49; // r9
  __int8 *v50; // r14
  __int64 v51; // r15
  __m128i *v52; // r9
  unsigned __int64 v53; // r13
  const __m128i *v54; // rax
  __m128i *v55; // rcx
  unsigned __int64 k; // rbx
  __m128i *v57; // r14
  unsigned __int64 v58; // rdx
  __m128i *m; // rdx
  __m128i *v60; // r9
  __int64 v61; // r10
  unsigned __int64 v62; // r13
  __int64 v63; // r11
  bool v64; // cf
  __m128i *v65; // r8
  __int64 v66; // r13
  __int64 v67; // r10
  bool v68; // cf
  __m128i *v69; // r9
  __int64 v70; // r13
  bool v71; // cf
  __m128i *v72; // r8
  __m128i *n; // rdx
  bool v74; // cf
  __m128i *v75; // r8
  unsigned __int64 v76; // r8
  __int64 v77; // r12
  unsigned __int64 v78; // rdx
  __int64 v79; // rax
  __m128i *v80; // r10
  __m128i *v81; // r15
  __int64 v82; // r8
  _BOOL8 v83; // r9
  const __m128i *v84; // r15
  __m128i *v85; // rcx
  __m128i *v86; // rdx
  __int64 v87; // r8
  unsigned __int64 v88; // r10
  unsigned __int64 v89; // r11
  unsigned __int64 v90; // rax
  __m128i *v91; // r14
  bool v92; // cf
  __m128i *v93; // r8
  bool v94; // cf
  __int64 *v95; // rax
  __int64 v96; // r8
  __m128i *v97; // r10
  BOOL v98; // r14d
  _BOOL8 v99; // r13
  __m128i *v100; // rcx
  __int64 v101; // r15
  __m128i *v102; // r12
  __int64 v103; // r14
  unsigned __int64 v104; // r15
  unsigned __int64 v105; // r9
  __m128i *v106; // r11
  __m128i *v107; // r15
  __m128i v108; // xmm0
  __m128i v109; // xmm1
  __m128i v110; // xmm2
  __m128i *v111; // rax
  __m128i v112; // xmm3
  __m128i v113; // xmm4
  __m128i v114; // xmm5
  __m128i v115; // xmm6
  __m128i v116; // xmm7
  __int64 v117; // rax
  unsigned __int64 v118; // r8
  __int64 *v119; // r11
  unsigned __int64 v120; // r9
  __int64 v121; // r10
  __int64 v122; // r14
  __int64 v123; // r11
  __m128i *v124; // rax
  __int64 v125; // r9
  __m128i *v126; // r14
  unsigned __int64 v127; // r10
  __int64 v128; // r11
  __int64 v129; // r15
  __int64 v130; // r14
  const __m128i *v131; // rdx
  const __m128i *v132; // r15
  __m128i *v133; // r10
  const __m128i *v134; // r8
  __m128i *v135; // r9
  int v136; // r11d
  int v137; // r12d
  __m128i *v138; // rcx
  __int64 v139; // r13
  const __m128i *v140; // rcx
  bool v141; // cf
  const __m128i *v142; // rdx
  BOOL v143; // ecx
  const __m128i *v144; // r11
  _QWORD v145[3]; // [rsp+30h] [rbp-50h] BYREF
  __int128 v146; // [rsp+48h] [rbp-38h]
  __m128i v147; // [rsp+60h] [rbp-20h] BYREF
  __m128i *v148; // [rsp+70h] [rbp-10h]
  __int8 *v149; // [rsp+78h] [rbp-8h]
  __m128i *v150; // [rsp+80h] [rbp+0h]
  size_t Size; // [rsp+88h] [rbp+8h]
  __m128i *v152; // [rsp+90h] [rbp+10h]
  const __m128i *v153; // [rsp+98h] [rbp+18h]
  __int64 *v154; // [rsp+A0h] [rbp+20h]
  unsigned __int64 v155; // [rsp+A8h] [rbp+28h]

  v7 = a2;
  if ( a2 >= 0x21 )
  {
    v12 = a4;
    v154 = a6;
    v150 = a3 - 1;
    Size = a4;
    do
    {
      v148 = a1 + 1;
      v14 = v7;
      while ( 1 )
      {
        v32 = a5 == 0;
        v15 = a5 - 1;
        if ( v32 )
        {
          sub_430620((_DWORD)a1, v14, (_DWORD)a3, v12, 1);
          return;
        }
        LODWORD(v153) = v15;
        v16 = &a1[4 * (v14 >> 3)];
        v17 = &a1[7 * (v14 >> 3)];
        v155 = v14;
        if ( v14 >= 0x40 )
        {
          v19 = (const __m128i *)sub_431BC0(a1, (__m128i *)a1[4 * (v14 >> 3)].m128i_i64, v17, v14 >> 3);
          v14 = v155;
          v16 = v19;
        }
        else
        {
          v18 = a1->m128i_i64[0] < (unsigned __int64)v16->m128i_i64[0];
          if ( v18 != v16->m128i_i64[0] < (unsigned __int64)v17->m128i_i64[0] )
            v16 = &a1[7 * (v14 >> 3)];
          if ( v18 != a1->m128i_i64[0] < (unsigned __int64)v17->m128i_i64[0] )
            v16 = a1;
        }
        v152 = (__m128i *)((unsigned __int64)((char *)v16 - (char *)a1) >> 4);
        v20 = _mm_loadu_si128(v16);
        v147 = v20;
        if ( v154 )
        {
          if ( (unsigned __int64)*v154 >= v20.m128i_i64[0] )
            break;
        }
        if ( v14 > v12 )
          goto LABEL_143;
        v21 = 16 * v14;
        v7 = 0LL;
        v22 = a1;
        v23 = (__m128i *)((char *)a3 + v21);
        v24 = (unsigned __int64)v152;
        v149 = &a3->m128i_i8[v21];
        while ( 1 )
        {
          v25 = v21;
          v26 = 0LL;
          if ( v24 >= 3 )
            v26 = v24 - 3;
          v27 = a1;
          for ( i = &a1[v26]; v22 < i; v22 += 4 )
          {
            v29 = v23 - 1;
            v30 = 0LL;
            if ( v22->m128i_i64[0] < (unsigned __int64)v16->m128i_i64[0] )
              v29 = a3;
            LOBYTE(v30) = v22->m128i_i64[0] < (unsigned __int64)v16->m128i_i64[0];
            v31 = v7 + v30;
            v32 = v22[1].m128i_i64[0] < (unsigned __int64)v16->m128i_i64[0];
            v33 = v23 - 2;
            if ( v22[1].m128i_i64[0] < (unsigned __int64)v16->m128i_i64[0] )
              v33 = a3;
            v29[v7] = *v22;
            v34 = v30 + v32 + v7;
            v33[v31] = v22[1];
            v35 = v22[2].m128i_u64[0];
            v36 = v23 - 3;
            v37 = 0LL;
            if ( v35 < v16->m128i_i64[0] )
              v36 = a3;
            LOBYTE(v37) = v35 < v16->m128i_i64[0];
            v36[v34] = v22[2];
            v23 -= 4;
            v38 = v22[3].m128i_i64[0] < (unsigned __int64)v16->m128i_i64[0];
            v39 = v23;
            if ( v22[3].m128i_i64[0] < (unsigned __int64)v16->m128i_i64[0] )
              v39 = a3;
            v39[v34 + v37] = _mm_loadu_si128(v22 + 3);
            v7 = v37 + v38 + v34;
          }
          a1 = v27;
          for ( j = &v27[v24]; v22 < j; ++v22 )
          {
            --v23;
            v41 = v22->m128i_i64[0] < (unsigned __int64)v16->m128i_i64[0];
            v42 = v23;
            if ( v22->m128i_i64[0] < (unsigned __int64)v16->m128i_i64[0] )
              v42 = a3;
            v42[v7] = _mm_loadu_si128(v22);
            v7 += v41;
          }
          v43 = v155;
          if ( v24 == v155 )
            break;
          v21 = v25;
          v23[v7 - 1] = _mm_loadu_si128(v22);
          --v23;
          ++v22;
          v24 = v43;
        }
        v44 = v7;
        memcpy(v27, a3, 16 * v7);
        v14 = v155;
        v45 = v155 - v7;
        v12 = Size;
        if ( v155 != v7 )
        {
          if ( v155 == v7 + 1 )
          {
            v46 = 0LL;
          }
          else
          {
            v47 = &v148[v44];
            v48 = (__m128i *)((char *)v150 + v25);
            v49 = 0LL;
            v50 = v149;
            do
            {
              v47[-1] = *v48;
              v46 = v49 + 2;
              *v47 = _mm_loadu_si128((const __m128i *)&v50[16 * (v49 ^ 0xFFFFFFFFFFFFFFELL)]);
              v47 += 2;
              v48 -= 2;
              v49 = v46;
            }
            while ( (v45 & 0xFFFFFFFFFFFFFFFEuLL) != v46 );
          }
          v12 = Size;
          if ( (v45 & 1) != 0 )
            a1[v44 + v46] = _mm_loadu_si128((const __m128i *)&v149[16 * ~v46]);
        }
        if ( !v7 )
          break;
        if ( v14 < v7 )
        {
          v145[0] = &off_4479E0;
          v145[1] = 1LL;
          v145[2] = 8LL;
          v146 = 0LL;
          sub_405240(v145, &off_447A50);
        }
        a5 = (int)v153;
        sub_430D80((_DWORD)a1 + v44 * 16, v45, (_DWORD)a3, v12, (_DWORD)v153, (__int64)&v147);
        v14 = v7;
        if ( v7 < 0x21 )
          goto LABEL_2;
      }
      if ( v14 > v12 )
LABEL_143:
        BUG();
      v51 = v14;
      v52 = &a3[v14];
      v53 = 0LL;
      v54 = a1;
      v55 = v52;
      for ( k = (unsigned __int64)v152; ; k = v76 )
      {
        v57 = v52;
        v58 = 0LL;
        if ( k >= 3 )
          v58 = k - 3;
        for ( m = &a1[v58]; v54 < m; v54 += 4 )
        {
          v60 = v55 - 1;
          v61 = v53;
          if ( v16->m128i_i64[0] >= (unsigned __int64)v54->m128i_i64[0] )
            v60 = a3;
          v62 = v53 - ((v16->m128i_i64[0] < (unsigned __int64)v54->m128i_i64[0]) - 1LL);
          v63 = v62;
          v64 = v16->m128i_i64[0] < (unsigned __int64)v54[1].m128i_i64[0];
          v65 = v55 - 2;
          if ( v16->m128i_i64[0] >= (unsigned __int64)v54[1].m128i_i64[0] )
            v65 = a3;
          v60[v61] = *v54;
          v66 = v62 - (v64 - 1LL);
          v67 = v66;
          v68 = v16->m128i_i64[0] < (unsigned __int64)v54[2].m128i_i64[0];
          v69 = v55 - 3;
          if ( v16->m128i_i64[0] >= (unsigned __int64)v54[2].m128i_i64[0] )
            v69 = a3;
          v65[v63] = v54[1];
          v70 = v66 - (v68 - 1LL);
          v69[v67] = v54[2];
          v55 -= 4;
          v71 = v16->m128i_i64[0] < (unsigned __int64)v54[3].m128i_i64[0];
          v72 = v55;
          if ( v16->m128i_i64[0] >= (unsigned __int64)v54[3].m128i_i64[0] )
            v72 = a3;
          v72[v70] = _mm_loadu_si128(v54 + 3);
          v53 = v70 - (v71 - 1LL);
        }
        for ( n = &a1[k]; v54 < n; ++v54 )
        {
          --v55;
          v74 = v16->m128i_i64[0] < (unsigned __int64)v54->m128i_i64[0];
          v75 = v55;
          if ( v16->m128i_i64[0] >= (unsigned __int64)v54->m128i_i64[0] )
            v75 = a3;
          v75[v53] = _mm_loadu_si128(v54);
          v53 -= v74 - 1LL;
        }
        v76 = v155;
        if ( k == v155 )
          break;
        v52 = v57;
        --v55;
        a3[v53++] = _mm_loadu_si128(v54++);
      }
      v77 = v53;
      memcpy(a1, a3, 16 * v53);
      v78 = v155;
      v7 = v155 - v53;
      if ( v155 != v53 )
      {
        if ( v155 == v53 + 1 )
        {
          v79 = 0LL;
        }
        else
        {
          v80 = &a1[v77 + 1];
          v81 = &v150[v51];
          v82 = 0LL;
          do
          {
            v80[-1] = *v81;
            v79 = v82 + 2;
            *v80 = _mm_loadu_si128(&v57[v82 ^ 0xFFFFFFFFFFFFFFELL]);
            v80 += 2;
            v81 -= 2;
            v82 = v79;
          }
          while ( (v7 & 0xFFFFFFFFFFFFFFFEuLL) != v79 );
        }
        if ( (v7 & 1) != 0 )
          a1[v77 + v79] = _mm_loadu_si128(&v57[~v79]);
      }
      v12 = Size;
      if ( v78 < v53 )
        sub_4050A0(v53, v78, (__int64)&off_447A68);
      a1 = (__m128i *)((char *)a1 + v77 * 16);
      v154 = 0LL;
      a5 = (int)v153;
    }
    while ( v7 >= 0x21 );
  }
LABEL_2:
  if ( v7 >= 2 )
  {
    v9 = v7 >> 1;
    if ( v7 <= 0xF )
    {
      if ( v7 <= 7 )
      {
        *a3 = *a1;
        a3[v9] = _mm_loadu_si128(&a1[v9]);
        v10 = 1LL;
        v11 = v7 - v9;
        if ( v9 <= 1 )
        {
LABEL_118:
          v124 = &a3[v9];
          if ( v10 < v11 )
          {
            v125 = (unsigned int)(16 * v10);
            do
            {
              v124[v10] = _mm_loadu_si128(&a1[v9 + v10]);
              v127 = v124[v10].m128i_u64[0];
              if ( v127 < v124[v10 - 1].m128i_i64[0] )
              {
                v128 = v124[v10].m128i_i64[1];
                v129 = v125;
                do
                {
                  *(__m128i *)((char *)v124 + v129) = _mm_loadu_si128((__m128i *)((char *)v124 + v129 - 16));
                  if ( v129 == 16 )
                  {
                    v126 = &a3[v9];
                    goto LABEL_121;
                  }
                  v130 = v129 - 16;
                  v32 = v127 < *(__int64 *)((char *)v124[-2].m128i_i64 + v129);
                  v129 -= 16LL;
                }
                while ( v32 );
                v126 = (__m128i *)((char *)v124 + v130);
LABEL_121:
                v126->m128i_i64[0] = v127;
                v126->m128i_i64[1] = v128;
              }
              ++v10;
              v125 += 16LL;
            }
            while ( v10 != v11 );
          }
          v131 = v124 - 1;
          v132 = &a3[v7 - 1];
          Size = 16 * v7;
          v133 = &a1[v7 - 1];
          v134 = a3;
          v154 = (__int64 *)a1;
          v135 = a1;
          do
          {
            v155 = v9;
            v136 = 0;
            v137 = 0;
            v138 = v124;
            v32 = v124->m128i_i64[0] < (unsigned __int64)v134->m128i_i64[0];
            LOBYTE(v152) = v124->m128i_i64[0] >= (unsigned __int64)v134->m128i_i64[0];
            LOBYTE(v153) = v32;
            if ( !v32 )
              v138 = (__m128i *)v134;
            *v135 = *v138;
            v139 = (v132->m128i_i64[0] < (unsigned __int64)v131->m128i_i64[0]) - 1LL;
            v140 = v131;
            v141 = v132->m128i_i64[0] < (unsigned __int64)v131->m128i_i64[0];
            if ( v132->m128i_i64[0] >= (unsigned __int64)v131->m128i_i64[0] )
              v140 = v132;
            LOBYTE(v137) = (_BYTE)v153;
            v124 = (__m128i *)((char *)v124 + (unsigned int)(16 * v137));
            LOBYTE(v136) = (_BYTE)v152;
            v134 = (const __m128i *)((char *)v134 + (unsigned int)(16 * v136));
            ++v135;
            *v133 = _mm_loadu_si128(v140);
            v132 += v139;
            v131 -= v141;
            --v133;
            v9 = v155 - 1;
          }
          while ( v155 != 1 );
          v142 = v131 + 1;
          if ( (v7 & 1) != 0 )
          {
            v143 = v134 >= v142;
            v144 = v124;
            if ( v134 < v142 )
              v144 = v134;
            *v135 = _mm_loadu_si128(v144);
            v134 += v134 < v142;
            v124 = (__m128i *)((char *)v124 + (unsigned int)(16 * v143));
          }
          if ( v134 != v142 || v124 != &v132[1] )
            sub_408340();
          return;
        }
      }
      else
      {
        v83 = a1[1].m128i_i64[0] < (unsigned __int64)a1->m128i_i64[0];
        v84 = &a1[v83];
        v85 = &a1[a1[1].m128i_i64[0] >= (unsigned __int64)a1->m128i_i64[0]];
        v86 = &a1[(unsigned int)(a1[3].m128i_i64[0] < (unsigned __int64)a1[2].m128i_i64[0]) + 2];
        v87 = (a1[3].m128i_i64[0] < (unsigned __int64)a1[2].m128i_i64[0]) ^ 3u;
        v88 = v86->m128i_i64[0];
        v89 = a1[v87].m128i_u64[0];
        v90 = v85->m128i_i64[0];
        v91 = v85;
        if ( v89 < v85->m128i_i64[0] )
          v91 = &a1[(unsigned int)(a1[3].m128i_i64[0] < (unsigned __int64)a1[2].m128i_i64[0]) + 2];
        v92 = v88 < a1[v83].m128i_i64[0];
        if ( v88 < a1[v83].m128i_i64[0] )
        {
          v91 = &a1[v83];
          v84 = &a1[(unsigned int)(a1[3].m128i_i64[0] < (unsigned __int64)a1[2].m128i_i64[0]) + 2];
        }
        v153 = v84;
        v93 = &a1[v87];
        if ( v92 )
          v86 = v85;
        if ( v89 >= v90 )
          v85 = v93;
        v152 = v85;
        if ( v89 < v90 )
          v86 = v93;
        v94 = v86->m128i_i64[0] < (unsigned __int64)v91->m128i_i64[0];
        v95 = (__int64 *)v91;
        if ( v86->m128i_i64[0] < (unsigned __int64)v91->m128i_i64[0] )
          v95 = (__int64 *)v86;
        v154 = v95;
        if ( v94 )
          v86 = v91;
        v96 = v9;
        v97 = &a1[v96];
        v98 = a1[v9 + 3].m128i_i64[0] < (unsigned __int64)a1[v9 + 2].m128i_i64[0];
        v99 = a1[v9 + 1].m128i_i64[0] < (unsigned __int64)a1[v9].m128i_i64[0];
        v100 = &a1[v9 + (a1[v9 + 1].m128i_i64[0] >= (unsigned __int64)a1[v9].m128i_i64[0])];
        v101 = (unsigned int)(16 * v98);
        v155 = v7 >> 1;
        v102 = (__m128i *)((char *)&a1[v9 + 2] + v101);
        v103 = v98 ^ 3u;
        v104 = *(unsigned __int64 *)((char *)a1[v96 + 2].m128i_u64 + v101);
        v105 = a1[v96 + v103].m128i_u64[0];
        v106 = v100;
        if ( v105 < v100->m128i_i64[0] )
          v106 = v102;
        v32 = v104 < v97[v99].m128i_i64[0];
        v107 = &v97[v99];
        if ( v32 )
        {
          v106 = &v97[v99];
          v107 = v102;
          v102 = v100;
        }
        v108 = _mm_loadu_si128(v153);
        if ( v105 < v100->m128i_i64[0] )
          v102 = &v97[v103];
        else
          v100 = &v97[v103];
        v109 = *(__m128i *)v154;
        v110 = *v86;
        v111 = v106;
        if ( v102->m128i_i64[0] < (unsigned __int64)v106->m128i_i64[0] )
          v111 = v102;
        v112 = *v152;
        if ( v102->m128i_i64[0] < (unsigned __int64)v106->m128i_i64[0] )
          v102 = v106;
        v113 = *v107;
        v114 = *v111;
        v115 = *v102;
        v9 = v155;
        v116 = *v100;
        *a3 = v108;
        a3[1] = v109;
        a3[2] = v110;
        a3[3] = v112;
        a3[v96] = v113;
        a3[v96 + 1] = v114;
        a3[v96 + 2] = v115;
        a3[v96 + 3] = v116;
        v10 = 4LL;
        v11 = v7 - v9;
        if ( v9 <= 4 )
          goto LABEL_118;
      }
    }
    else
    {
      sub_431840(a1, a3, (__m128i *)a3[v7].m128i_i8);
      sub_431840((__m128i *)a1[v9].m128i_i64, (__m128i *)a3[v9].m128i_i8, (__m128i *)a3[v7 + 8].m128i_i8);
      v10 = 8LL;
      v11 = v7 - v9;
      if ( v9 <= 8 )
        goto LABEL_118;
    }
    v117 = (unsigned int)(16 * v10);
    v118 = v10;
    do
    {
      a3[v118] = _mm_loadu_si128(&a1[v118]);
      v120 = a3[v118].m128i_u64[0];
      if ( v120 < a3[v118 - 1].m128i_i64[0] )
      {
        v121 = a3[v118].m128i_i64[1];
        v122 = v117;
        do
        {
          *(__m128i *)((char *)a3 + v122) = _mm_loadu_si128((__m128i *)((char *)a3 + v122 - 16));
          if ( v122 == 16 )
          {
            v119 = (__int64 *)a3;
            goto LABEL_111;
          }
          v123 = v122 - 16;
          v32 = v120 < *(__int64 *)((char *)a3[-2].m128i_i64 + v122);
          v122 -= 16LL;
        }
        while ( v32 );
        v119 = (__int64 *)((char *)a3->m128i_i64 + v123);
LABEL_111:
        *v119 = v120;
        v119[1] = v121;
      }
      ++v118;
      v117 += 16LL;
    }
    while ( v118 != v9 );
    goto LABEL_118;
  }
}
// 405240: using guessed type void __fastcall __noreturn sub_405240(_QWORD, _QWORD);
// 430620: using guessed type __int64 __fastcall sub_430620(_DWORD, _DWORD, _DWORD, _DWORD, char);
// 4479E0: using guessed type char *off_4479E0;
// 447A50: using guessed type char *off_447A50;
// 447A68: using guessed type char *off_447A68;

//----- (0000000000431840) ----------------------------------------------------
__int64 __fastcall sub_431840(_QWORD *a1, _OWORD *a2, _OWORD *a3)
{
  __int64 v3; // r11
  _OWORD *v4; // rax
  unsigned __int64 *v5; // r9
  unsigned __int64 *v6; // rsi
  __int64 v7; // r10
  unsigned __int64 v8; // rbx
  unsigned __int64 v9; // r14
  unsigned __int64 *v10; // r15
  unsigned __int64 *v11; // r10
  unsigned __int64 *v12; // r10
  __int64 v13; // r11
  _OWORD *v14; // rax
  unsigned __int64 *v15; // r9
  unsigned __int64 *v16; // rsi
  __int64 v17; // r10
  unsigned __int64 v18; // r14
  unsigned __int64 *v19; // r15
  __int64 v20; // rcx
  unsigned __int64 *v21; // rcx
  _OWORD *v22; // r10
  unsigned __int64 v23; // rax
  BOOL v24; // ecx
  BOOL v25; // esi
  unsigned __int64 v26; // r9
  unsigned __int64 v27; // rdi
  __int64 v28; // r10
  __int64 v29; // r11
  _OWORD *v30; // r14
  _QWORD *v31; // r9
  __int64 v32; // rcx
  __int64 v33; // r10
  __int64 v34; // r11
  char *v35; // r12
  BOOL v36; // r14d
  BOOL v37; // edi
  _OWORD *v38; // rcx
  unsigned __int64 v39; // rsi
  unsigned __int64 v40; // rbx
  __int64 v41; // rcx
  bool v42; // cf
  __int64 v43; // rbx
  __int64 v44; // r11
  _OWORD *v45; // r10
  char *v46; // rsi
  __int64 v47; // r14
  __int64 v48; // rcx
  __int64 v49; // r8
  bool v50; // cf
  char *v51; // r14
  char *v52; // r9
  unsigned __int64 v53; // r12
  unsigned __int64 v54; // r13
  _OWORD *v55; // rcx
  _OWORD *v56; // r8
  _OWORD *v57; // rbx
  char *v58; // r11
  char *v59; // rbx
  __int64 v60; // r9
  __int64 v61; // r10
  int v62; // esi
  BOOL v63; // r15d
  bool v64; // di
  char *v65; // r14
  unsigned __int64 v66; // r12
  unsigned __int64 v67; // r13
  _OWORD *v68; // r9
  _OWORD *v69; // r10
  _OWORD *v70; // rcx
  __int64 result; // rax

  v3 = 2 * (unsigned int)(a1[2] < *a1);
  v4 = &a1[v3];
  v5 = &a1[2 * (unsigned int)(a1[2] >= *a1)];
  v6 = &a1[2 * (unsigned int)(a1[6] < a1[4]) + 4];
  v7 = 2 * ((a1[6] < a1[4]) ^ 3u);
  v8 = *v6;
  v9 = a1[v7];
  v10 = v5;
  if ( v9 < *v5 )
    v10 = &a1[2 * (unsigned int)(a1[6] < a1[4]) + 4];
  if ( v8 < a1[v3] )
  {
    v10 = &a1[v3];
    v4 = &a1[2 * (unsigned int)(a1[6] < a1[4]) + 4];
  }
  v11 = &a1[v7];
  if ( v8 < a1[v3] )
    v6 = &a1[2 * (unsigned int)(a1[2] >= *a1)];
  if ( v9 < *v5 )
    v6 = v11;
  else
    v5 = v11;
  v12 = v10;
  if ( *v6 < *v10 )
  {
    v12 = v6;
    v6 = v10;
  }
  *a3 = *v4;
  a3[1] = *(_OWORD *)v12;
  a3[2] = *(_OWORD *)v6;
  a3[3] = *(_OWORD *)v5;
  v13 = 2 * (unsigned int)(a1[10] < a1[8]);
  v14 = &a1[v13 + 8];
  v15 = &a1[2 * (unsigned int)(a1[10] >= a1[8]) + 8];
  v16 = &a1[2 * (unsigned int)(a1[14] < a1[12]) + 12];
  v17 = 2 * ((a1[14] < a1[12]) ^ 3u);
  v18 = a1[v17 + 8];
  v19 = v15;
  if ( v18 < *v15 )
    v19 = &a1[2 * (unsigned int)(a1[14] < a1[12]) + 12];
  if ( *v16 < a1[v13 + 8] )
  {
    v19 = &a1[v13 + 8];
    v14 = &a1[2 * (unsigned int)(a1[14] < a1[12]) + 12];
    v16 = &a1[2 * (unsigned int)(a1[10] >= a1[8]) + 8];
  }
  v20 = (__int64)&a1[v17 + 8];
  if ( v18 < *v15 )
    v16 = (unsigned __int64 *)v20;
  else
    v15 = (unsigned __int64 *)v20;
  v21 = v19;
  if ( *v16 < *v19 )
  {
    v21 = v16;
    v16 = v19;
  }
  v22 = a3 + 4;
  a3[4] = *v14;
  a3[5] = *(_OWORD *)v21;
  a3[6] = *(_OWORD *)v16;
  a3[7] = *(_OWORD *)v15;
  v23 = *((_QWORD *)a3 + 8);
  v24 = v23 >= *(_QWORD *)a3;
  v25 = v23 < *(_QWORD *)a3;
  if ( v23 >= *(_QWORD *)a3 )
    v22 = a3;
  *a2 = *v22;
  v26 = *((_QWORD *)a3 + 14);
  v27 = *((_QWORD *)a3 + 6);
  v28 = (v26 < v27) - 1LL;
  v29 = -(__int64)(v26 < v27);
  v30 = a3 + 7;
  if ( v26 < v27 )
    v30 = a3 + 3;
  v31 = (_QWORD *)((char *)a3 + (unsigned int)(16 * v25) + 64);
  v32 = (unsigned int)(16 * v24);
  a2[7] = *v30;
  v33 = v28;
  v34 = v29;
  v42 = *v31 < *(_QWORD *)((char *)a3 + v32);
  v35 = (char *)a3 + v32;
  v36 = *v31 >= *(_QWORD *)((char *)a3 + v32);
  v37 = v42;
  v38 = (_OWORD *)((char *)a3 + v32);
  if ( v42 )
    v38 = (_OWORD *)((char *)a3 + (unsigned int)(16 * v25) + 64);
  a2[1] = *v38;
  v39 = *(_QWORD *)&a3[v33 + 7];
  v40 = *(_QWORD *)&a3[v34 + 3];
  v41 = (v39 < v40) - 1LL;
  v42 = v39 < v40;
  v43 = (__int64)&a3[v33 + 7];
  v44 = (__int64)&a3[v34 + 3];
  v45 = (_OWORD *)v43;
  if ( v42 )
    v45 = (_OWORD *)v44;
  v46 = (char *)v31 + (unsigned int)(16 * v37);
  v47 = (unsigned int)(16 * v36);
  a2[6] = *v45;
  v48 = 16 * v41;
  v49 = -16LL * v42;
  v50 = *(_QWORD *)v46 < *(_QWORD *)&v35[v47];
  v51 = &v35[v47];
  v52 = v51;
  if ( v50 )
    v52 = v46;
  a2[2] = *(_OWORD *)v52;
  v53 = *(_QWORD *)(v48 + v43);
  v54 = *(_QWORD *)(v49 + v44);
  v55 = (_OWORD *)(v43 + v48);
  v56 = (_OWORD *)(v44 + v49);
  v57 = v55;
  if ( v53 < v54 )
    v57 = v56;
  v58 = &v46[16 * v50];
  a2[5] = *v57;
  v59 = &v51[16 * !v50];
  v60 = (v53 < v54) - 1LL;
  v61 = 0xFFFFFFFFFFFFFFFLL * (v53 < v54);
  v62 = 0;
  v63 = *(_QWORD *)v58 >= *(_QWORD *)v59;
  v64 = *(_QWORD *)v58 < *(_QWORD *)v59;
  v65 = v59;
  if ( *(_QWORD *)v58 < *(_QWORD *)v59 )
    v65 = v58;
  a2[3] = *(_OWORD *)v65;
  v66 = *(_QWORD *)&v55[v60];
  v67 = *(_QWORD *)&v56[v61];
  v68 = &v55[v60];
  v69 = &v56[v61];
  v70 = v68;
  if ( v66 < v67 )
    v70 = v69;
  a2[4] = *v70;
  if ( &v59[16 * v63] != (char *)&v69[-(v66 < v67) + 1]
    || (LOBYTE(v62) = v64, result = (__int64)&v68[v66 < v67], &v58[16 * v62] != (char *)result) )
  {
    sub_408340();
  }
  return result;
}

//----- (0000000000431BC0) ----------------------------------------------------
_QWORD *__fastcall sub_431BC0(_QWORD *a1, _QWORD *a2, _QWORD *a3, unsigned __int64 a4)
{
  unsigned __int64 v6; // r9
  unsigned __int64 v7; // rbx
  __int64 v8; // r14
  __int64 v9; // r12
  __int64 v10; // rax
  bool v11; // r8

  if ( a4 >= 8 )
  {
    v6 = a4 >> 3;
    v7 = v6 << 6;
    v8 = 14 * v6;
    v9 = sub_431BC0(a1, &a1[8 * v6], &a1[14 * v6]);
    a2 = (_QWORD *)sub_431BC0(a2, (char *)a2 + v7, &a2[v8]);
    v10 = sub_431BC0(a3, (char *)a3 + v7, &a3[v8]);
    a1 = (_QWORD *)v9;
    a3 = (_QWORD *)v10;
  }
  v11 = *a1 < *a2;
  if ( v11 != *a2 < *a3 )
    a2 = a3;
  if ( v11 != *a1 < *a3 )
    return a1;
  return a2;
}

//----- (0000000000431C80) ----------------------------------------------------
void __fastcall sub_431C80(__int128 *a1, unsigned __int64 a2, __int128 *a3, unsigned int a4)
{
  unsigned __int64 v4; // r12
  unsigned __int64 v6; // r14
  unsigned __int64 v7; // rcx
  unsigned __int64 v8; // rdx
  __int64 v11; // r10
  unsigned __int64 v12; // rdx
  __int128 *v13; // rsi
  char *v14; // rax
  __int128 *v15; // r8
  bool v16; // r9
  unsigned __int64 v17; // rax
  __int64 v18; // rax
  _OWORD *v19; // rax
  unsigned __int64 v20; // r9
  unsigned __int64 v21; // rcx
  __int64 v22; // r8
  __int64 v23; // r10
  unsigned __int64 v24; // r15
  __int128 *v25; // r11
  __int64 v26; // rdx
  _BOOL8 v27; // rsi
  __int64 v28; // rdi
  __int128 *v29; // r15
  __int128 *v30; // r10
  __int64 v31; // rsi
  __int128 *v32; // rcx
  _OWORD *v33; // rcx
  unsigned __int64 v34; // r9
  unsigned __int64 v35; // rdx
  __int64 v36; // r8
  __int64 v37; // r10
  unsigned __int64 v38; // r14
  __int128 *v39; // r11
  __int64 v40; // rax
  __int64 v41; // rax
  __int128 *v42; // r14
  __int128 *v43; // r10
  __int64 v44; // rsi
  __int64 v45; // r10
  unsigned __int64 v46; // rax
  unsigned __int64 v47; // rax
  _BOOL8 v48; // r8
  __int128 *v49; // rcx
  __int128 *v50; // rax
  __int128 *v51; // r9
  __int64 v52; // rdx
  unsigned __int64 v53; // r11
  unsigned __int64 v54; // rdi
  __int128 *v55; // rbx
  __int128 *v56; // rdx
  __int128 *v57; // rdx
  __int128 v58; // xmm0
  __int128 *v59; // r11
  _BOOL8 v60; // r10
  unsigned __int64 *v61; // rdx
  _BOOL8 v62; // rdi
  __int128 *v63; // r9
  __int64 v64; // r8
  unsigned __int64 v65; // r15
  unsigned __int64 v66; // rsi
  __int128 *v67; // r12
  bool v68; // cf
  __int128 *v69; // r10
  __int128 *v70; // r8
  bool v71; // cf
  __int128 v72; // xmm0
  __int128 *v73; // rax
  __int64 v74; // rax
  unsigned __int64 v75; // r9
  __int128 *p_Src; // rdi
  unsigned __int64 v77; // r10
  __int64 v78; // r11
  __int64 v79; // rdi
  __int64 v80; // rbx
  __int128 *v81; // rax
  __int64 v82; // r9
  __int128 *v83; // rdi
  unsigned __int64 v84; // r10
  __int64 v85; // r11
  __int64 v86; // rbx
  __int64 v87; // rdi
  __int128 *v88; // rdx
  __int128 *v89; // r8
  size_t v90; // r12
  __int128 *v91; // rbx
  __int128 *v92; // r10
  __int128 *v93; // r9
  int v94; // r11d
  int v95; // r15d
  __int128 *v96; // rcx
  bool v97; // r13
  bool v98; // di
  __int64 v99; // r12
  __int128 *v100; // rcx
  bool v101; // cf
  __int128 *v102; // r8
  BOOL v103; // ecx
  __int128 *v104; // r11
  _QWORD v105[4]; // [rsp+0h] [rbp-80h] BYREF
  __int128 Src; // [rsp+20h] [rbp-60h] BYREF
  __int128 v107; // [rsp+30h] [rbp-50h]
  __int128 v108; // [rsp+40h] [rbp-40h]
  _OWORD v109[45]; // [rsp+50h] [rbp-30h] BYREF
  unsigned __int64 v110; // [rsp+328h] [rbp+2A8h]
  __int128 *v111; // [rsp+330h] [rbp+2B0h]
  unsigned __int64 v112; // [rsp+338h] [rbp+2B8h]
  size_t Size; // [rsp+340h] [rbp+2C0h]

  v4 = a2;
  while ( v4 >= 0x21 )
  {
    while ( 1 )
    {
      v68 = a4-- == 0;
      if ( v68 )
      {
        sub_432510(a1, v4);
        return;
      }
      v14 = (char *)&a1[4 * (v4 >> 3)];
      v15 = &a1[7 * (v4 >> 3)];
      if ( v4 < 0x40 )
        break;
      v17 = (unsigned __int64)((char *)sub_431BC0(a1, &a1[4 * (v4 >> 3)], v15, v4 >> 3) - (char *)a1) >> 4;
      if ( !a3 )
        goto LABEL_19;
LABEL_18:
      if ( *(_QWORD *)a3 < *(_QWORD *)&a1[v17] )
        goto LABEL_19;
      v32 = &a1[v17];
      Src = *a1;
      *a1 = *v32;
      *v32 = Src;
      v33 = a1 + 1;
      v34 = *(_QWORD *)a1;
      v35 = *((_QWORD *)a1 + 2);
      v36 = *((_QWORD *)a1 + 3);
      v37 = v4;
      v38 = (unsigned __int64)&a1[v4 - 1];
      v39 = a1 + 2;
      if ( (unsigned __int64)(a1 + 2) >= v38 )
      {
        v42 = a1 + 1;
        v40 = 0LL;
        v43 = &a1[v37];
        if ( v39 != v43 )
          goto LABEL_34;
      }
      else
      {
        v40 = 0LL;
        do
        {
          v68 = v34 < *(_QWORD *)v39;
          *(v39 - 1) = v33[v40];
          v33[v40] = *v39;
          v41 = v40 - (v68 - 1LL);
          v68 = v34 < *((_QWORD *)v39 + 2);
          *v39 = v33[v41];
          v33[v41] = v39[1];
          v40 = v41 - (v68 - 1LL);
          v39 += 2;
        }
        while ( (unsigned __int64)v39 < v38 );
        v42 = v39 - 1;
        v43 = &a1[v37];
        if ( v39 != v43 )
        {
          do
          {
LABEL_34:
            v44 = v40;
            v68 = v34 < *(_QWORD *)v39;
            *v42 = v33[v40];
            v40 -= v68 - 1LL;
            v33[v44] = *v39;
            v42 = v39++;
          }
          while ( v39 != v43 );
          v42 = v39 - 1;
        }
      }
      v45 = v40;
      *v42 = v33[v40];
      *(_QWORD *)&v33[v45] = v35;
      *((_QWORD *)&v33[v45] + 1) = v36;
      v46 = v40 - ((v34 < v35) - 1LL);
      if ( v46 >= v4 )
LABEL_101:
        BUG();
      Src = *a1;
      *a1 = a1[v46];
      a1[v46] = Src;
      v47 = v46 + 1;
      v4 -= v47;
      a1 += v47;
      a3 = 0LL;
      if ( v4 < 0x21 )
        goto LABEL_2;
    }
    v16 = *(_QWORD *)a1 < *(_QWORD *)v14;
    if ( v16 != *(_QWORD *)v14 < *(_QWORD *)v15 )
      v14 = (char *)&a1[7 * (v4 >> 3)];
    if ( v16 != *(_QWORD *)a1 < *(_QWORD *)v15 )
      v14 = (char *)a1;
    v17 = (unsigned __int64)(v14 - (char *)a1) >> 4;
    if ( a3 )
      goto LABEL_18;
LABEL_19:
    if ( v17 >= v4 )
      goto LABEL_101;
    v18 = v17;
    Src = *a1;
    *a1 = a1[v18];
    a1[v18] = Src;
    v19 = a1 + 1;
    v20 = *(_QWORD *)a1;
    v21 = *((_QWORD *)a1 + 2);
    v22 = *((_QWORD *)a1 + 3);
    v23 = v4;
    v24 = (unsigned __int64)&a1[v4 - 1];
    v25 = a1 + 2;
    if ( (unsigned __int64)(a1 + 2) >= v24 )
    {
      v29 = a1 + 1;
      v26 = 0LL;
      v30 = &a1[v23];
      if ( v25 != v30 )
        goto LABEL_26;
    }
    else
    {
      v26 = 0LL;
      do
      {
        v27 = *(_QWORD *)v25 < v20;
        *(v25 - 1) = v19[v26];
        v19[v26] = *v25;
        v28 = v26 + v27;
        v68 = *((_QWORD *)v25 + 2) < v20;
        *v25 = v19[v28];
        v19[v28] = v25[1];
        v26 += v27 + v68;
        v25 += 2;
      }
      while ( (unsigned __int64)v25 < v24 );
      v29 = v25 - 1;
      v30 = &a1[v23];
      if ( v25 != v30 )
      {
        do
        {
LABEL_26:
          v31 = v26;
          v68 = *(_QWORD *)v25 < v20;
          *v29 = v19[v26];
          v26 += v68;
          v19[v31] = *v25;
          v29 = v25++;
        }
        while ( v25 != v30 );
        v29 = v25 - 1;
      }
    }
    v11 = v26;
    *v29 = v19[v26];
    *(_QWORD *)&v19[v11] = v21;
    *((_QWORD *)&v19[v11] + 1) = v22;
    v12 = (v21 < v20) + v26;
    if ( v12 >= v4 )
      goto LABEL_101;
    v13 = &a1[v12];
    Src = *a1;
    *a1 = *v13;
    *v13 = Src;
    v4 += ~v12;
    sub_431C80(a1, v12, a3, a4, Src, *((_QWORD *)&Src + 1));
    a3 = v13;
    a1 = v13 + 1;
  }
LABEL_2:
  if ( v4 < 2 )
    return;
  v6 = v4 >> 1;
  if ( v4 > 0xF )
  {
    sub_431840(a1, &Src, &Src + v4);
    sub_431840(&a1[v6], &Src + v6, &v109[v4 + 5]);
    v7 = 8LL;
    v8 = v4 - v6;
    if ( v6 <= 8 )
      goto LABEL_77;
LABEL_68:
    v74 = (unsigned int)(16 * v7);
    v75 = v7;
    do
    {
      *(&Src + v75) = a1[v75];
      v77 = *((_QWORD *)&Src + 2 * v75);
      if ( v77 < v105[2 * v75 + 2] )
      {
        v78 = *((_QWORD *)&Src + 2 * v75 + 1);
        v79 = v74;
        do
        {
          *(__int128 *)((char *)&Src + v79) = *(_OWORD *)((char *)&v105[2] + v79);
          if ( v79 == 16 )
          {
            p_Src = &Src;
            goto LABEL_70;
          }
          v80 = v79 - 16;
          v68 = v77 < *(_QWORD *)((char *)v105 + v79);
          v79 -= 16LL;
        }
        while ( v68 );
        p_Src = (__int128 *)((char *)&Src + v80);
LABEL_70:
        *(_QWORD *)p_Src = v77;
        *((_QWORD *)p_Src + 1) = v78;
      }
      ++v75;
      v74 += 16LL;
    }
    while ( v75 != v6 );
    goto LABEL_77;
  }
  if ( v4 > 7 )
  {
    v48 = *((_QWORD *)a1 + 2) < *(_QWORD *)a1;
    v49 = &a1[v48];
    v50 = &a1[*((_QWORD *)a1 + 2) >= *(_QWORD *)a1];
    v51 = &a1[(unsigned int)(*((_QWORD *)a1 + 6) < *((_QWORD *)a1 + 4)) + 2];
    v52 = (*((_QWORD *)a1 + 6) < *((_QWORD *)a1 + 4)) ^ 3u;
    v53 = *(_QWORD *)v51;
    v54 = *(_QWORD *)&a1[v52];
    v55 = v50;
    if ( v54 < *(_QWORD *)v50 )
      v55 = &a1[(unsigned int)(*((_QWORD *)a1 + 6) < *((_QWORD *)a1 + 4)) + 2];
    if ( v53 < *(_QWORD *)&a1[v48] )
    {
      v55 = &a1[v48];
      v49 = &a1[(unsigned int)(*((_QWORD *)a1 + 6) < *((_QWORD *)a1 + 4)) + 2];
    }
    v56 = &a1[v52];
    if ( v53 < *(_QWORD *)&a1[v48] )
      v51 = &a1[*((_QWORD *)a1 + 2) >= *(_QWORD *)a1];
    if ( v54 < *(_QWORD *)v50 )
      v51 = v56;
    else
      v50 = v56;
    v57 = v55;
    if ( *(_QWORD *)v51 < *(_QWORD *)v55 )
    {
      v57 = v51;
      v51 = v55;
    }
    Src = *v49;
    v107 = *v57;
    v58 = *v51;
    v59 = &a1[v6];
    v60 = *((_QWORD *)v59 + 2) < *(_QWORD *)v59;
    v61 = (unsigned __int64 *)&v59[*((_QWORD *)v59 + 2) >= *(_QWORD *)v59];
    v62 = *((_QWORD *)v59 + 6) < *((_QWORD *)v59 + 4);
    v63 = &v59[v62 + 2];
    v64 = (*((_QWORD *)v59 + 6) < *((_QWORD *)v59 + 4)) ^ 3u;
    v65 = *(_QWORD *)&v59[v64];
    v66 = v4;
    v67 = (__int128 *)v61;
    if ( v65 < *v61 )
      v67 = &v59[v62 + 2];
    v68 = *(_QWORD *)&v59[v62 + 2] < *(_QWORD *)&v59[v60];
    v69 = &v59[v60];
    if ( v68 )
    {
      v67 = v69;
      v69 = &v59[v62 + 2];
    }
    v70 = &v59[v64];
    if ( v68 )
      v63 = &v59[*(_QWORD *)&a1[v6 + 1] >= *(_QWORD *)&a1[v6]];
    if ( v65 < *v61 )
      v63 = v70;
    else
      v61 = (unsigned __int64 *)v70;
    v108 = v58;
    v71 = *(_QWORD *)v63 < *(_QWORD *)v67;
    v72 = *v50;
    v73 = v67;
    if ( *(_QWORD *)v63 < *(_QWORD *)v67 )
      v73 = v63;
    v109[0] = v72;
    if ( v71 )
      v63 = v67;
    v4 = v66;
    *(&Src + v6) = *v69;
    *(&v107 + v6) = *v73;
    v109[v6 - 1] = *v63;
    v109[v6] = *(_OWORD *)v61;
    v7 = 4LL;
    v8 = v66 - v6;
    if ( v6 <= 4 )
      goto LABEL_77;
    goto LABEL_68;
  }
  Src = *a1;
  *(&Src + v6) = a1[v6];
  v7 = 1LL;
  v8 = v4 - v6;
  if ( v6 > 1 )
    goto LABEL_68;
LABEL_77:
  v81 = &Src + v6;
  if ( v7 < v8 )
  {
    v82 = (unsigned int)(16 * v7);
    do
    {
      v81[v7] = a1[v6 + v7];
      v84 = *(_QWORD *)&v81[v7];
      if ( v84 < *(_QWORD *)&v81[v7 - 1] )
      {
        v85 = *((_QWORD *)&v81[v7] + 1);
        v86 = v82;
        do
        {
          *(__int128 *)((char *)v81 + v86) = *(__int128 *)((char *)v81 + v86 - 16);
          if ( v86 == 16 )
          {
            v83 = &Src + v6;
            goto LABEL_80;
          }
          v87 = v86 - 16;
          v68 = v84 < *(_QWORD *)((char *)v81 + v86 - 32);
          v86 -= 16LL;
        }
        while ( v68 );
        v83 = (__int128 *)((char *)v81 + v87);
LABEL_80:
        *(_QWORD *)v83 = v84;
        *((_QWORD *)v83 + 1) = v85;
      }
      ++v7;
      v82 += 16LL;
    }
    while ( v7 != v8 );
  }
  v88 = &Src;
  v89 = v81 - 1;
  v112 = v4;
  v90 = 16 * v4;
  v91 = (__int128 *)&v105[v90 / 8 + 2];
  Size = v90;
  v92 = &a1[v90 / 0x10 - 1];
  v111 = a1;
  v93 = a1;
  do
  {
    v110 = v6;
    v94 = 0;
    v95 = 0;
    v96 = v81;
    v97 = *(_QWORD *)v81 >= *(_QWORD *)v88;
    v98 = *(_QWORD *)v81 < *(_QWORD *)v88;
    if ( *(_QWORD *)v81 >= *(_QWORD *)v88 )
      v96 = v88;
    *v93 = *v96;
    v99 = (*(_QWORD *)v91 < *(_QWORD *)v89) - 1LL;
    v100 = v89;
    v101 = *(_QWORD *)v91 < *(_QWORD *)v89;
    if ( *(_QWORD *)v91 >= *(_QWORD *)v89 )
      v100 = v91;
    LOBYTE(v95) = v98;
    v81 = (__int128 *)((char *)v81 + (unsigned int)(16 * v95));
    LOBYTE(v94) = v97;
    v88 = (__int128 *)((char *)v88 + (unsigned int)(16 * v94));
    ++v93;
    *v92 = *v100;
    v91 += v99;
    v89 -= v101;
    --v92;
    v6 = v110 - 1;
  }
  while ( v110 != 1 );
  v102 = v89 + 1;
  if ( (v112 & 1) != 0 )
  {
    v103 = v88 >= v102;
    v104 = v81;
    if ( v88 < v102 )
      v104 = v88;
    *v93 = *v104;
    v88 += v88 < v102;
    v81 = (__int128 *)((char *)v81 + (unsigned int)(16 * v103));
  }
  if ( v88 != v102 || v81 != v91 + 1 )
    sub_408340();
}

//----- (0000000000432510) ----------------------------------------------------
unsigned __int64 __fastcall sub_432510(__int128 *a1, unsigned __int64 a2)
{
  unsigned __int64 result; // rax
  __int64 v3; // r8
  unsigned __int64 v4; // r9
  unsigned __int64 v5; // r10
  __int64 v6; // rsi
  unsigned __int64 v7; // rsi
  unsigned __int64 v8; // r11
  __int64 v9; // r8
  __int64 v10; // r10
  unsigned __int64 v11; // rsi
  unsigned __int64 v12; // rdi
  unsigned __int64 *v13; // r8
  unsigned __int64 *v14; // r10
  unsigned __int64 v15; // rbx
  unsigned __int64 v16; // r14
  __int128 v17; // [rsp+0h] [rbp-10h]

  result = a2 + (a2 >> 1);
  while ( result )
  {
    v3 = --result - a2;
    if ( result < a2 )
    {
      v17 = *a1;
      *a1 = a1[result];
      a1[result] = v17;
      v3 = 0LL;
    }
    v4 = a2;
    if ( result < a2 )
      v4 = result;
    v5 = 2 * v3 + 1;
    if ( v5 < v4 )
    {
      v6 = 2 * v3;
      do
      {
        v7 = v6 + 2;
        if ( v7 < v4 )
          v5 += *(_QWORD *)&a1[v5] < *(_QWORD *)&a1[v7];
        v8 = v5;
        v9 = v3;
        v10 = v5;
        v11 = *(_QWORD *)&a1[v9];
        v12 = *(_QWORD *)&a1[v10];
        if ( v11 >= v12 )
          break;
        v13 = (unsigned __int64 *)&a1[v9];
        v14 = (unsigned __int64 *)&a1[v10];
        v15 = v13[1];
        v16 = v14[1];
        *v13 = v12;
        v13[1] = v16;
        *v14 = v11;
        v14[1] = v15;
        v6 = 2 * v8;
        v5 = 2 * v8 + 1;
        v3 = v8;
      }
      while ( v5 < v4 );
    }
  }
  return result;
}

//----- (0000000000432610) ----------------------------------------------------
__int64 __fastcall sub_432610(unsigned __int8 *a1, __int64 a2, __int64 a3)
{
  __int64 result; // rax
  __int64 v5; // r14
  WCHAR *v6; // rsi
  unsigned __int8 v7; // dl
  char v8; // cl
  unsigned __int8 v9; // r10
  DWORD dwCreationDisposition; // r15d
  DWORD v11; // edx
  unsigned int v12; // eax
  HANDLE FileW; // rax
  void *v14; // rbx
  __int64 v15; // rdi
  HANDLE v16; // rax
  HANDLE ProcessHeap; // rax
  HANDLE v18; // rax
  __int64 v19; // [rsp+0h] [rbp-80h] BYREF
  __int64 v20; // [rsp+40h] [rbp-40h] BYREF
  LPCWSTR lpFileName; // [rsp+48h] [rbp-38h]
  __int128 v22; // [rsp+58h] [rbp-28h] BYREF
  __int64 v23; // [rsp+68h] [rbp-18h]
  __int128 FileInformation; // [rsp+70h] [rbp-10h] BYREF
  __int64 v25; // [rsp+80h] [rbp+0h]

  sub_4329C0((__int64)(&v19 + 14), a1, a2);
  if ( __OFSUB__(-(__int64)FileInformation, 1LL) )
    return 1LL;
  v22 = FileInformation;
  v23 = v25;
  sub_432CE0(&v20, &v22);
  v5 = v20;
  v6 = (WCHAR *)lpFileName;
  result = 1LL;
  if ( v20 == 0x8000000000000000uLL )
    return result;
  v7 = *(_BYTE *)(a3 + 33);
  v8 = *(_BYTE *)(a3 + 34);
  if ( v7 )
  {
    if ( !v8 )
      goto LABEL_10;
    goto LABEL_8;
  }
  if ( v8 )
  {
LABEL_8:
    if ( *(_BYTE *)(a3 + 35) && !*(_BYTE *)(a3 + 37) )
      goto LABEL_40;
    goto LABEL_10;
  }
  if ( *(_BYTE *)(a3 + 35) || *(_BYTE *)(a3 + 36) || *(_BYTE *)(a3 + 37) )
    goto LABEL_40;
LABEL_10:
  v9 = *(_BYTE *)(a3 + 37);
  if ( !*(_BYTE *)(a3 + 36) )
  {
    if ( !v9 )
    {
      dwCreationDisposition = 2 * *(unsigned __int8 *)(a3 + 35) + 3;
      if ( (*(_BYTE *)a3 & 1) != 0 )
        goto LABEL_13;
      goto LABEL_16;
    }
    goto LABEL_15;
  }
  dwCreationDisposition = 4;
  if ( v9 )
  {
LABEL_15:
    dwCreationDisposition = 1;
    if ( (*(_BYTE *)a3 & 1) != 0 )
      goto LABEL_13;
    goto LABEL_16;
  }
  if ( (*(_BYTE *)a3 & 1) != 0 )
  {
LABEL_13:
    v11 = *(_DWORD *)(a3 + 4);
    goto LABEL_31;
  }
LABEL_16:
  if ( !*(_BYTE *)(a3 + 32) )
  {
    if ( v7 )
    {
      v11 = 0x40000000;
      if ( !v8 )
        goto LABEL_31;
LABEL_30:
      v11 = 1179924;
      goto LABEL_31;
    }
    if ( v8 )
      goto LABEL_30;
LABEL_40:
    if ( v20 )
    {
      ProcessHeap = GetProcessHeap();
      HeapFree(ProcessHeap, 0, v6);
      return 1LL;
    }
    return result;
  }
  v12 = (v7 | 0xFFFFFFFE) << 30;
  v11 = -2146303724;
  if ( !v8 )
    v11 = v12;
LABEL_31:
  FileW = CreateFileW(
            lpFileName,
            v11,
            *(_DWORD *)(a3 + 24),
            *(LPSECURITY_ATTRIBUTES *)(a3 + 8),
            dwCreationDisposition,
            *(_DWORD *)(a3 + 28) | *(_DWORD *)(a3 + 16) | *(_DWORD *)(a3 + 20) | (v9 << 21),
            0LL);
  if ( FileW == (HANDLE)-1LL )
  {
    GetLastError();
    result = 1LL;
    if ( v5 )
    {
LABEL_38:
      v15 = result;
      v16 = GetProcessHeap();
      HeapFree(v16, 0, v6);
      return v15;
    }
  }
  else
  {
    v14 = FileW;
    if ( dwCreationDisposition != 4
      || !*(_BYTE *)(a3 + 35)
      || GetLastError() != 183
      || (*(_QWORD *)&FileInformation = 0LL, SetFileInformationByHandle(v14, FileAllocationInfo, &FileInformation, 8u))
      || (*(_QWORD *)&v22 = 0LL, SetFileInformationByHandle(v14, FileEndOfFileInfo, &v22, 8u)) )
    {
      result = 0LL;
      if ( !v5 )
        return result;
      goto LABEL_38;
    }
    GetLastError();
    CloseHandle(v14);
    if ( v5 )
    {
      v18 = GetProcessHeap();
      HeapFree(v18, 0, v6);
    }
    return 1LL;
  }
  return result;
}

//----- (00000000004328B0) ----------------------------------------------------
__int64 __fastcall sub_4328B0(__int64 a1, void *a2)
{
  DWORD dwFileAttributes; // ecx
  __int64 result; // rax
  DWORD dwVolumeSerialNumber; // r8d
  unsigned __int64 v7; // r9
  DWORD nNumberOfLinks; // edx
  unsigned __int64 v9; // r11
  __int64 v10; // rax
  __int64 v11; // [rsp+0h] [rbp-60h] BYREF
  _BY_HANDLE_FILE_INFORMATION FileInformation; // [rsp+20h] [rbp-40h] BYREF
  __int64 v13; // [rsp+58h] [rbp-8h] BYREF

  memset(&FileInformation, 0, sizeof(FileInformation));
  if ( GetFileInformationByHandle(a2, (LPBY_HANDLE_FILE_INFORMATION)(&v11 + 4)) )
  {
    dwFileAttributes = FileInformation.dwFileAttributes;
    result = 0LL;
    if ( (FileInformation.dwFileAttributes & 0x400) == 0 )
    {
LABEL_5:
      dwVolumeSerialNumber = FileInformation.dwVolumeSerialNumber;
      v7 = FileInformation.nFileSizeLow | ((unsigned __int64)FileInformation.nFileSizeHigh << 32);
      nNumberOfLinks = FileInformation.nNumberOfLinks;
      v9 = FileInformation.nFileIndexLow | ((unsigned __int64)FileInformation.nFileIndexHigh << 32);
      *(_QWORD *)a1 = 1LL;
      *(_QWORD *)(a1 + 8) = v9;
      *(_DWORD *)(a1 + 16) = 1;
      *(_DWORD *)(a1 + 20) = dwVolumeSerialNumber;
      *(_DWORD *)(a1 + 24) = 1;
      *(_DWORD *)(a1 + 28) = nNumberOfLinks;
      *(_OWORD *)(a1 + 32) = *(_OWORD *)&FileInformation.ftCreationTime.dwLowDateTime;
      *(FILETIME *)(a1 + 48) = FileInformation.ftLastWriteTime;
      *(_QWORD *)(a1 + 56) = v7;
      *(_DWORD *)(a1 + 64) = 0;
      *(_DWORD *)(a1 + 76) = dwFileAttributes;
      *(_DWORD *)(a1 + 80) = result;
      return result;
    }
    v13 = 0LL;
    if ( GetFileInformationByHandleEx(a2, FileAttributeTagInfo, &v13, 8u) )
    {
      result = HIDWORD(v13) & (unsigned int)((int)((_DWORD)v13 << 21) >> 31);
      dwFileAttributes = FileInformation.dwFileAttributes;
      goto LABEL_5;
    }
  }
  LODWORD(v10) = GetLastError();
  result = (v10 << 32) | 2;
  *(_QWORD *)(a1 + 8) = result;
  *(_QWORD *)a1 = 2LL;
  return result;
}
// 432997: variable 'v10' is possibly undefined

//----- (00000000004329C0) ----------------------------------------------------
int __fastcall sub_4329C0(__int64 a1, unsigned __int8 *a2, __int64 a3)
{
  void *v3; // rsi
  unsigned __int64 v5; // rdi
  __int64 v7; // rax
  unsigned __int8 *v8; // rbx
  unsigned __int64 v9; // rdi
  __int16 v10; // r12
  __int16 v11; // cx
  int v12; // r8d
  int v13; // edx
  unsigned __int8 v14; // cl
  unsigned __int64 v15; // r8
  _WORD *v16; // rbx
  unsigned __int64 v17; // rax
  _WORD *v18; // rcx
  __int64 v19; // rax
  unsigned __int64 v20; // rdx
  bool v21; // zf
  HANDLE ProcessHeap; // rax
  LPVOID lpMem[2]; // [rsp+30h] [rbp-10h] BYREF
  unsigned __int64 v26; // [rsp+40h] [rbp+0h]

  v3 = (void *)(a3 + 1);
  if ( a3 + 1 < 0 || (v5 = 2 * a3 + 2, v5 > 0x7FFFFFFFFFFFFFFELL) )
    sub_4040B0((__int64)&off_449F30);
  if ( 2 * a3 == -2 )
  {
    v7 = 2LL;
    v3 = 0LL;
  }
  else
  {
    v7 = (__int64)sub_43C4F0(2 * a3 + 2);
    if ( !v7 )
      sub_4040E9(2LL, v5);
  }
  lpMem[0] = v3;
  lpMem[1] = (LPVOID)v7;
  v26 = 0LL;
  v8 = &a2[a3];
  v9 = 0LL;
  for ( LOWORD(v3) = 0; ; LOWORD(v3) = v10 )
  {
    if ( (_WORD)v3 )
      goto LABEL_10;
    if ( a2 == v8 )
      break;
    v11 = *a2;
    if ( (v11 & 0x80u) == 0 )
    {
      ++a2;
      LOWORD(v3) = v11;
      v10 = 0;
      if ( (LPVOID)v9 != lpMem[0] )
        goto LABEL_8;
      goto LABEL_24;
    }
    LODWORD(v3) = v11 & 0x1F;
    v12 = a2[1] & 0x3F;
    if ( (unsigned __int8)v11 <= 0xDFu )
    {
      a2 += 2;
      LOWORD(v3) = v12 | ((_WORD)v3 << 6);
      v10 = 0;
      if ( (LPVOID)v9 != lpMem[0] )
        goto LABEL_8;
      goto LABEL_24;
    }
    v13 = (v12 << 6) | a2[2] & 0x3F;
    if ( (unsigned __int8)v11 < 0xF0u )
    {
      a2 += 3;
      LODWORD(v3) = v13 | ((_DWORD)v3 << 12);
      if ( (unsigned int)v3 > 0xFFFF )
      {
LABEL_23:
        v10 = (unsigned __int16)v3 & 0x3FF | 0xDC00;
        LODWORD(v3) = ((unsigned int)((_DWORD)v3 + 16711680) >> 10) | 0xD800;
        if ( (LPVOID)v9 != lpMem[0] )
          goto LABEL_8;
        goto LABEL_24;
      }
    }
    else
    {
      v14 = a2[3];
      a2 += 4;
      LODWORD(v3) = (v13 << 6) | v14 & 0x3F | (((unsigned __int8)v3 & 7) << 18);
      if ( (unsigned int)v3 > 0xFFFF )
        goto LABEL_23;
    }
LABEL_10:
    v10 = 0;
    if ( (LPVOID)v9 != lpMem[0] )
      goto LABEL_8;
LABEL_24:
    v15 = v8 - a2 + 3;
    if ( (unsigned __int64)(v8 - a2) >= 0xFFFFFFFFFFFFFFFDuLL )
      v15 = -1LL;
    sub_413290((unsigned __int64 *)lpMem, v9, (v15 >> 2) - (v10 == 0) + 2, 2LL, 2LL);
    v7 = (__int64)lpMem[1];
LABEL_8:
    *(_WORD *)(v7 + 2 * v9++) = (_WORD)v3;
    v26 = v9;
  }
  v16 = lpMem[1];
  v17 = v9;
  v18 = lpMem[1];
  if ( v9 < 8 )
  {
LABEL_38:
    v19 = 2 * v17;
    v20 = 0LL;
    while ( v19 != v20 )
    {
      v21 = v18[v20 / 2] == 0;
      v20 += 2LL;
      if ( v21 )
        goto LABEL_41;
    }
    if ( (LPVOID)v9 == lpMem[0] )
    {
      LODWORD(v19) = sub_4332D0((__int64 *)lpMem, (__int64)&off_449F90);
      v16 = lpMem[1];
    }
    v16[v9] = 0;
    v26 = v9 + 1;
    *(_QWORD *)(a1 + 16) = v9 + 1;
    *(_OWORD *)a1 = *(_OWORD *)lpMem;
  }
  else
  {
    v18 = lpMem[1];
    v17 = v9;
    while ( *v18 && v18[1] && v18[2] && v18[3] && v18[4] && v18[5] && v18[6] && v18[7] )
    {
      v17 -= 8LL;
      v18 += 8;
      if ( v17 <= 7 )
        goto LABEL_38;
    }
LABEL_41:
    *(_QWORD *)(a1 + 8) = &off_449F78;
    LODWORD(v19) = 0;
    *(_QWORD *)a1 = 0x8000000000000000uLL;
    if ( lpMem[0] )
    {
      ProcessHeap = GetProcessHeap();
      LODWORD(v19) = HeapFree(ProcessHeap, 0, v16);
    }
  }
  return v19;
}
// 449F30: using guessed type char *off_449F30;
// 449F78: using guessed type char *off_449F78;
// 449F90: using guessed type char *off_449F90;

//----- (0000000000432CE0) ----------------------------------------------------
int __fastcall sub_432CE0(_QWORD *a1, __int128 *a2)
{
  unsigned __int16 *v2; // r10
  unsigned __int64 v3; // rax
  unsigned __int16 v4; // ax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  unsigned __int64 v8; // rax
  __int128 v9; // xmm0
  unsigned __int64 v10; // rdi
  unsigned __int64 v11; // r15
  unsigned __int64 v12; // rbx
  __int64 v13; // r13
  unsigned __int64 v14; // r12
  WCHAR *p_Buffer; // rsi
  unsigned __int64 i; // r14
  unsigned __int64 v17; // rdi
  DWORD FullPathNameW; // esi
  unsigned __int64 v19; // r14
  unsigned __int64 *v20; // r14
  unsigned __int16 v21; // ax
  WCHAR *v22; // rcx
  __int64 v23; // rdx
  __int64 v24; // r12
  __int64 LastError; // rsi
  void *v26; // rdi
  HANDLE v27; // rax
  _QWORD *v28; // rcx
  void *v29; // rsi
  HANDLE v30; // rax
  char *v31; // r8
  bool v32; // al
  int v33; // eax
  unsigned __int64 v34; // rsi
  unsigned __int64 v35; // rax
  unsigned __int64 v36; // rbx
  unsigned __int64 v37; // r12
  void *v38; // rsi
  HANDLE ProcessHeap; // rax
  __int64 v40; // rbx
  __int64 v41; // rax
  WCHAR Buffer; // [rsp+28h] [rbp-58h] BYREF
  _QWORD v44[3]; // [rsp+428h] [rbp+3A8h] BYREF
  __int64 v45; // [rsp+440h] [rbp+3C0h] BYREF
  WCHAR *v46; // [rsp+448h] [rbp+3C8h]
  __int64 v47; // [rsp+450h] [rbp+3D0h]
  __int64 v48; // [rsp+458h] [rbp+3D8h]
  _QWORD *v49; // [rsp+460h] [rbp+3E0h]
  LPCWSTR lpFileName; // [rsp+468h] [rbp+3E8h]
  unsigned __int64 v51; // [rsp+470h] [rbp+3F0h] BYREF
  LPVOID lpMem; // [rsp+478h] [rbp+3F8h]
  __int64 v53; // [rsp+480h] [rbp+400h]
  unsigned __int64 *v54; // [rsp+488h] [rbp+408h]
  void *Src; // [rsp+490h] [rbp+410h]

  v2 = (unsigned __int16 *)*((_QWORD *)a2 + 1);
  v3 = *((_QWORD *)a2 + 2);
  if ( v3 <= 3 )
  {
    if ( !v3 )
      goto LABEL_27;
    if ( v3 != 3 )
    {
      if ( v3 == 1 )
      {
        if ( !*v2 )
          goto LABEL_26;
        goto LABEL_27;
      }
      goto LABEL_21;
    }
    if ( v2[1] != 58 )
    {
LABEL_21:
      LOWORD(v5) = *v2;
      goto LABEL_22;
    }
    v4 = v2[2];
    if ( !v4 )
    {
      v6 = *v2;
      if ( v6 != 47 && v6 != 92 )
        goto LABEL_26;
      goto LABEL_21;
    }
  }
  else
  {
    if ( *(_QWORD *)v2 == 0x5C003F005C005CLL || *(_QWORD *)v2 == 0x5C003F003F005CLL )
      goto LABEL_26;
    if ( v3 >= 0xF8 )
      goto LABEL_27;
    if ( v2[1] != 58 )
      goto LABEL_21;
    v4 = v2[2];
  }
  if ( v4 != 47 && v4 != 92 )
    goto LABEL_21;
  v5 = *v2;
  if ( v5 != 47 && v5 != 92 )
    goto LABEL_26;
LABEL_22:
  if ( (_WORD)v5 == 92 || (unsigned __int16)v5 == 47 )
  {
    v7 = v2[1];
    if ( v7 == 92 || v7 == 47 )
    {
LABEL_26:
      v8 = *((_QWORD *)a2 + 2);
      a1[2] = v8;
      v9 = *a2;
LABEL_78:
      *(_OWORD *)a1 = v9;
      return v8;
    }
  }
LABEL_27:
  lpFileName = (LPCWSTR)*((_QWORD *)a2 + 1);
  v49 = a1;
  v54 = (unsigned __int64 *)a2;
  v51 = 0LL;
  lpMem = (LPVOID)2;
  v53 = 0LL;
  v10 = 512LL;
  v48 = 2LL;
  v11 = 0LL;
  v12 = 0LL;
  v13 = 0LL;
LABEL_30:
  v14 = 512LL;
  p_Buffer = &Buffer;
  for ( i = v10; ; i = v13 )
  {
    SetLastError(0);
    Src = p_Buffer;
    FullPathNameW = GetFullPathNameW(lpFileName, i, p_Buffer, 0LL);
    if ( !FullPathNameW )
    {
      if ( GetLastError() )
        break;
    }
    v10 = FullPathNameW;
    if ( i == FullPathNameW )
    {
      if ( GetLastError() != 122 )
        sub_405FC0((__int64)"internal error: entered unreachable code", 40LL, (__int64)&off_449FC0);
      v19 = 2 * i;
      if ( v19 >= 0xFFFFFFFF )
        v19 = 0xFFFFFFFFLL;
      v10 = v19;
      if ( v19 < 0x201 )
        goto LABEL_30;
    }
    else
    {
      if ( i >= FullPathNameW )
      {
        if ( v14 < FullPathNameW )
          sub_405B00(FullPathNameW, v14, (__int64)&off_449FA8);
        v20 = v54;
        v54[2] = 0LL;
        if ( FullPathNameW <= 2 )
        {
          v22 = (WCHAR *)lpFileName;
          if ( FullPathNameW != 2 )
          {
LABEL_60:
            v23 = 2LL;
            v24 = 0LL;
            goto LABEL_69;
          }
          v24 = 0LL;
          v31 = (char *)Src;
          v23 = 2LL;
          if ( *(_WORD *)Src != 92 || *((_WORD *)Src + 1) != 92 )
          {
            v10 = 2LL;
            goto LABEL_69;
          }
        }
        else
        {
          v21 = *((_WORD *)Src + 1);
          v22 = (WCHAR *)lpFileName;
          if ( v21 == 58 && *((_WORD *)Src + 2) == 92 )
          {
LABEL_48:
            v23 = (__int64)asc_44A0B0;
            v24 = 4LL;
LABEL_69:
            v34 = v10 + v24 + 1;
            v35 = *v20;
            if ( *v20 < v34 )
            {
              v40 = v23;
              if ( v35 )
              {
                v44[0] = v22;
                v44[2] = 2 * v35;
                v41 = 2LL;
              }
              else
              {
                v41 = 0LL;
              }
              v44[1] = v41;
              sub_413370(&v45, (void *)2, 2 * v34, (__int64)v44);
              if ( (v45 & 1) != 0 )
                sub_40408F((__int64)v46, v47, (__int64)&off_44A120);
              v22 = v46;
              v20[1] = (unsigned __int64)v46;
              *v20 = v34;
              v23 = v40;
            }
            else
            {
              v34 = *v20;
            }
            memcpy(v22, (const void *)v23, (unsigned int)(2 * v24));
            v20[2] = v24;
            if ( v34 - v24 < v10 )
            {
              sub_413290(v20, v24, v10, 2LL, 2LL);
              v34 = *v20;
              v24 = v20[2];
            }
            v36 = v20[1];
            memcpy((void *)(v36 + 2 * v24), Src, 2 * v10);
            v37 = v10 + v24;
            v20[2] = v37;
            if ( v37 == v34 )
            {
              sub_4332D0((__int64 *)v20, (__int64)&off_44A138);
              v36 = v20[1];
            }
            *(_WORD *)(v36 + 2 * v37) = 0;
            v20[2] = v37 + 1;
            if ( v51 )
            {
              v38 = lpMem;
              ProcessHeap = GetProcessHeap();
              HeapFree(ProcessHeap, 0, v38);
            }
            v8 = v20[2];
            a1 = v49;
            v49[2] = v8;
            v9 = *(_OWORD *)v20;
            goto LABEL_78;
          }
          v32 = (*(_WORD *)Src ^ 0x5C | v21 ^ 0x5C) == 0;
          if ( FullPathNameW == 3 )
          {
            v31 = (char *)Src;
            if ( !v32 )
            {
              v10 = 3LL;
              goto LABEL_60;
            }
          }
          else
          {
            v23 = 2LL;
            if ( !v32 )
              goto LABEL_67;
            v31 = (char *)Src;
            v33 = *((unsigned __int16 *)Src + 2);
            if ( v33 != 63 )
            {
              if ( v33 == 46 && *((_WORD *)Src + 3) == 92 )
              {
                v10 = FullPathNameW - 4LL;
                Src = (char *)Src + 8;
                goto LABEL_48;
              }
              goto LABEL_68;
            }
            if ( *((_WORD *)Src + 3) == 92 )
            {
LABEL_67:
              v24 = 0LL;
              goto LABEL_69;
            }
          }
        }
LABEL_68:
        v10 = FullPathNameW - 2LL;
        Src = v31 + 4;
        v23 = (__int64)L"\\\\?\\UNC\\";
        v24 = 8LL;
        goto LABEL_69;
      }
      if ( FullPathNameW < 0x201uLL )
        goto LABEL_30;
    }
    v17 = v10 - v13;
    if ( v12 - v13 < v17 )
    {
      sub_413290(&v51, v13, v17, 2LL, 2LL);
      v11 = v51;
      v48 = (__int64)lpMem;
    }
    v13 = 0xFFFFFFFFLL;
    if ( v11 < 0xFFFFFFFF )
      v13 = v11;
    v53 = v13;
    v12 = v11;
    v14 = v13;
    p_Buffer = (WCHAR *)v48;
  }
  LastError = GetLastError();
  if ( v51 )
  {
    v26 = lpMem;
    v27 = GetProcessHeap();
    HeapFree(v27, 0, v26);
  }
  v28 = v49;
  v49[1] = (LastError << 32) | 2;
  *v28 = 0x8000000000000000uLL;
  LODWORD(v8) = (_DWORD)v54;
  if ( *v54 )
  {
    v29 = (void *)v54[1];
    v30 = GetProcessHeap();
    LODWORD(v8) = HeapFree(v30, 0, v29);
  }
  return v8;
}
// 449FA8: using guessed type char *off_449FA8;
// 449FC0: using guessed type char *off_449FC0;
// 44A0B0: using guessed type wchar_t asc_44A0B0[4];
// 44A110: using guessed type wchar_t aUnc[8];
// 44A120: using guessed type char *off_44A120;
// 44A138: using guessed type char *off_44A138;

//----- (00000000004332D0) ----------------------------------------------------
__int64 __fastcall sub_4332D0(__int64 *a1, __int64 a2)
{
  __int64 v2; // rsi
  __int64 v3; // rax
  unsigned __int64 v5; // rcx
  __int64 v6; // rbx
  __int64 v7; // rcx
  __int64 v8; // rax
  __int64 result; // rax
  _QWORD v10[3]; // [rsp+28h] [rbp-28h] BYREF
  __int64 v11; // [rsp+40h] [rbp-10h] BYREF
  __int64 v12; // [rsp+48h] [rbp-8h]
  __int64 v13; // [rsp+50h] [rbp+0h]

  v2 = a2;
  v3 = *a1;
  if ( *a1 == -1 )
    goto LABEL_13;
  v5 = v3 + 1;
  if ( 2 * v3 > (unsigned __int64)(v3 + 1) )
    v5 = 2 * v3;
  v6 = 4LL;
  if ( v5 >= 5 )
    v6 = v5;
  v7 = 0LL;
  if ( v6 < 0 )
LABEL_13:
    sub_40408F(0LL, a2, a2);
  if ( (unsigned __int64)(2 * v6) > 0x7FFFFFFFFFFFFFFELL )
LABEL_15:
    sub_40408F(v7, a2, v2);
  if ( v3 )
  {
    v10[0] = a1[1];
    v10[2] = 2 * v3;
    v8 = 2LL;
  }
  else
  {
    v8 = 0LL;
  }
  v10[1] = v8;
  sub_413370(&v11, (void *)2, 2 * v6, (__int64)v10);
  if ( (_DWORD)v11 == 1 )
  {
    v7 = v12;
    a2 = v13;
    goto LABEL_15;
  }
  result = v12;
  a1[1] = v12;
  *a1 = v6;
  return result;
}

//----- (0000000000433390) ----------------------------------------------------
_BYTE *__fastcall sub_433390(__int64 a1, __int64 a2)
{
  return sub_4333A0(a1, a2);
}

//----- (00000000004333A0) ----------------------------------------------------
_BYTE *__fastcall sub_4333A0(__int64 a1, __int64 a2)
{
  _BYTE *result; // rax
  __int64 *v5; // rbx
  __int64 v6; // rax
  _BYTE *v7; // r14
  __int64 v8; // rdx
  __int64 v9; // r8
  __int64 v10; // rbx
  unsigned int v11; // eax
  __int64 (__fastcall *v12)(unsigned __int64 *, __int64); // rcx
  __int64 *v13; // rdx
  char *v14; // rbx
  unsigned __int64 v15; // r14
  int v16; // ecx
  char *v17; // r15
  char v18; // al
  __int128 v19; // [rsp+48h] [rbp-38h] BYREF
  __int64 *v20; // [rsp+58h] [rbp-28h]
  __int64 v21; // [rsp+60h] [rbp-20h]
  void *Buf2; // [rsp+68h] [rbp-18h]
  unsigned __int64 v23; // [rsp+70h] [rbp-10h]
  __int64 v24; // [rsp+88h] [rbp+8h]
  unsigned __int64 v25; // [rsp+90h] [rbp+10h]
  __int64 v26; // [rsp+98h] [rbp+18h] BYREF
  __int64 (__fastcall *v27)(unsigned __int64 *, __int64); // [rsp+A0h] [rbp+20h]
  __int64 *v28; // [rsp+A8h] [rbp+28h]
  char (__fastcall *v29)(__int64, __int64); // [rsp+B0h] [rbp+30h]
  __int64 v30; // [rsp+B8h] [rbp+38h] BYREF
  _BOOL8 v31; // [rsp+C0h] [rbp+40h]

  **(_BYTE **)a1 = 1;
  if ( !**(_BYTE **)(a1 + 8) )
  {
    sub_433610((__int64)&v19, a2);
    if ( (_QWORD)v19 == 2LL )
    {
      sub_406850((__int64)&v26, v24, v25);
      if ( (v26 & 1) != 0 )
        goto LABEL_2;
      v14 = (char *)v27;
      v15 = (unsigned __int64)v28;
    }
    else
    {
      if ( (_DWORD)v19 == 3 )
        goto LABEL_2;
      v14 = (char *)Buf2;
      if ( !Buf2 )
        goto LABEL_2;
      v15 = v23;
    }
    result = (_BYTE *)sub_4336E0(aRustEndShortBa, 0x1AuLL, v14, v15);
    v17 = *(char **)(a1 + 16);
    if ( (_BYTE)result )
    {
      *v17 = 1;
      return result;
    }
    v18 = *v17;
    if ( *v17 )
    {
      result = (_BYTE *)sub_4336E0(aRustBeginShort, 0x1CuLL, v14, v15);
      if ( (_BYTE)result )
      {
        *v17 = 0;
        return result;
      }
      v18 = *v17;
    }
    if ( (v18 & 1) == 0 )
      ++**(_QWORD **)(a1 + 24);
  }
LABEL_2:
  result = *(_BYTE **)(a1 + 16);
  if ( *result )
  {
    v5 = *(__int64 **)(a1 + 24);
    v6 = *v5;
    if ( *v5 )
    {
      v7 = *(_BYTE **)(a1 + 32);
      if ( !*v7 )
      {
        v8 = **(_QWORD **)(a1 + 40);
        v9 = (__int64)aS;
        if ( v6 == 1 )
          v9 = 1LL;
        v30 = v9;
        v31 = v6 != 1;
        v26 = (__int64)v5;
        v27 = sub_405120;
        v28 = &v30;
        v29 = sub_4123C0;
        *(_QWORD *)&v19 = &off_4491F0;
        *((_QWORD *)&v19 + 1) = 3LL;
        Buf2 = 0LL;
        v20 = &v26;
        v21 = 2LL;
        sub_406180(*(_QWORD *)(v8 + 48), *(_QWORD *)(v8 + 56), &v19);
      }
      *v7 = 0;
      *v5 = 0LL;
    }
    v30 = *(_QWORD *)(a1 + 40);
    v31 = 0LL;
    v10 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8LL);
    sub_433610((__int64)&v19, a2);
    v11 = *(_DWORD *)a2;
    if ( *(_DWORD *)a2 == 2
      || v11 == 3
      || (v12 = *(__int64 (__fastcall **)(unsigned __int64 *, __int64))(a2 + 16)) == 0LL )
    {
      v26 = 2LL;
    }
    else
    {
      v13 = *(__int64 **)(a2 + 24);
      v26 = 0LL;
      v27 = v12;
      v28 = v13;
    }
    LOBYTE(v16) = 0;
    if ( v11 < 2 )
      v16 = *(_DWORD *)(a2 + 8);
    else
      LOBYTE(v11) = 0;
    **(_BYTE **)(a1 + 48) = sub_414350(
                              (__int64)&v30,
                              v10,
                              &v19,
                              (__int64)&v26,
                              v11,
                              *(_DWORD *)(a2 + 4),
                              v16,
                              *(_DWORD *)(a2 + 12));
    result = (_BYTE *)v30;
    ++*(_QWORD *)(v30 + 24);
  }
  return result;
}
// 4491CE: using guessed type char aS;
// 4491F0: using guessed type char *off_4491F0;

//----- (0000000000433610) ----------------------------------------------------
void __fastcall sub_433610(__int64 a1, __int64 a2)
{
  __int64 v3; // rdi
  unsigned __int64 v4; // rbx
  __int64 v5; // rax
  __int128 v6; // [rsp+20h] [rbp-60h]
  __int128 v7; // [rsp+30h] [rbp-50h]
  __int128 v8; // [rsp+40h] [rbp-40h]
  __int64 v9; // [rsp+50h] [rbp-30h]
  __int64 v10; // [rsp+58h] [rbp-28h] BYREF
  __int128 v11; // [rsp+60h] [rbp-20h]
  __int128 v12; // [rsp+70h] [rbp-10h]
  __int128 v13; // [rsp+80h] [rbp+0h]
  __int64 v14; // [rsp+90h] [rbp+10h]

  if ( *(_DWORD *)a2 == 3 )
  {
    v3 = *(_QWORD *)(a2 + 8);
    v4 = *(_QWORD *)(a2 + 16);
  }
  else
  {
    v3 = *(_QWORD *)(a2 + 40);
    if ( !v3 )
    {
      *(_QWORD *)a1 = 3LL;
      return;
    }
    v4 = *(_QWORD *)(a2 + 48);
  }
  sub_406850((__int64)&v10, v3, v4);
  v5 = 2LL;
  if ( (v10 & 1) == 0 )
  {
    sub_40FA50(&v10, v11, *((__int64 *)&v11 + 1));
    v5 = v10;
    if ( v10 != 2 )
    {
      v9 = v14;
      v8 = v13;
      v7 = v12;
      v6 = v11;
    }
  }
  *(_QWORD *)a1 = v5;
  *(_OWORD *)(a1 + 8) = v6;
  *(_OWORD *)(a1 + 24) = v7;
  *(_OWORD *)(a1 + 40) = v8;
  *(_QWORD *)(a1 + 56) = v9;
  *(_QWORD *)(a1 + 64) = v3;
  *(_QWORD *)(a1 + 72) = v4;
}
// 4336AA: variable 'v6' is possibly undefined
// 4336AE: variable 'v7' is possibly undefined
// 4336B2: variable 'v8' is possibly undefined
// 4336BA: variable 'v9' is possibly undefined

//----- (00000000004336E0) ----------------------------------------------------
__int64 __fastcall sub_4336E0(char *Buf1, size_t Size, char *Buf2, unsigned __int64 a4)
{
  unsigned __int64 v4; // rsi
  unsigned __int8 v9; // al
  size_t v10; // rcx
  size_t v11; // r8
  __int64 v12; // r14
  unsigned __int8 v13; // dl
  size_t v14; // rcx
  char *v15; // rbx
  size_t v16; // rdi
  int v17; // eax
  char *v18; // rbx
  unsigned __int64 v19; // r11
  __int64 v20; // rcx
  unsigned __int64 v21; // r9
  __int64 v22; // r14
  unsigned __int64 v23; // r12
  unsigned __int64 v24; // r9
  unsigned __int64 v25; // r10
  __int64 v26; // r9
  unsigned __int64 v27; // r8
  unsigned int v28; // eax
  __int64 v29; // r9
  int v30; // r9d
  int v31; // r11d
  int v32; // r10d
  __m128i v33; // xmm0
  __m128i v34; // xmm6
  __m128i v35; // xmm0
  __m128i v36; // xmm7
  unsigned __int64 v37; // r15
  char *v38; // rdx
  char *v39; // r9
  __int64 v40; // r12
  __m128i v41; // xmm12
  __m128i v42; // xmm10
  __m128i v43; // xmm8
  int v44; // r8d
  __m128i v45; // xmm13
  __m128i v46; // xmm11
  __m128i v47; // xmm9
  int v48; // r8d
  int v49; // r8d
  int v50; // r8d
  unsigned __int64 v51; // rax
  int v52; // eax
  char v53; // al
  int v54; // eax
  char v55; // al
  int v56; // eax
  char v57; // al
  int v58; // eax
  const __m128i *v59; // r13
  int v60; // r8d
  unsigned __int64 v61; // rax
  int v62; // eax
  __int64 v63; // rdi
  int v64; // r8d
  int v65; // eax
  __int64 v66; // rcx
  unsigned __int64 v67; // r9
  __int64 v68; // r14
  unsigned __int64 v70; // r10
  unsigned __int64 v72; // rcx
  unsigned __int64 v73; // rcx
  size_t v74; // [rsp+28h] [rbp-58h]
  char *v75; // [rsp+30h] [rbp-50h] BYREF
  unsigned __int64 v76; // [rsp+38h] [rbp-48h]
  char *v77; // [rsp+40h] [rbp-40h]
  size_t v78; // [rsp+48h] [rbp-38h]
  __int64 v79; // [rsp+50h] [rbp-30h]
  __int64 v80; // [rsp+58h] [rbp-28h]
  char *v81; // [rsp+68h] [rbp-18h]
  _BYTE *v82; // [rsp+78h] [rbp-8h]
  unsigned __int64 v83; // [rsp+80h] [rbp+0h]
  __int64 v84; // [rsp+88h] [rbp+8h]
  unsigned __int64 v85; // [rsp+90h] [rbp+10h]
  char *v86; // [rsp+98h] [rbp+18h]
  char *v87; // [rsp+A0h] [rbp+20h]
  size_t v88; // [rsp+A8h] [rbp+28h]

  if ( Size >= a4 )
  {
    if ( Size != a4 )
      goto LABEL_84;
    LOBYTE(v4) = memcmp(Buf1, Buf2, Size) == 0;
  }
  else
  {
    v9 = *Buf1;
    v10 = 0LL;
    if ( Size >= 4 )
      v10 = Size - 4;
    v11 = Size;
    while ( v10 < v11 )
    {
      v12 = v11 - 1;
      if ( v11 - 1 >= Size )
        sub_4050B0(v12, Size, (__int64)&off_447970);
      v13 = Buf1[--v11];
      if ( v13 != v9 )
      {
        v14 = Size + 15;
        if ( Size + 15 <= a4 )
        {
          v33 = _mm_cvtsi32_si128(v9);
          v34 = _mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v33, v33), 0), 0);
          v35 = _mm_cvtsi32_si128(v13);
          v36 = _mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(v35, v35), 0), 0);
          v75 = Buf2;
          v76 = a4;
          v77 = Buf1 + 1;
          v74 = Size - 1;
          v78 = Size - 1;
          v37 = Size + 63;
          v88 = v14;
          if ( v37 >= a4 )
          {
            LODWORD(v4) = 0;
            v40 = 0LL;
          }
          else
          {
            v38 = Buf2 + 16;
            v39 = Buf2 + 32;
            LODWORD(v4) = 0;
            v40 = 0LL;
            v87 = Buf2 + 16;
            v86 = Buf2 + 32;
            do
            {
              if ( (v4 & 1) != 0 )
                break;
              v41 = _mm_loadu_si128((const __m128i *)&Buf2[v40 + 16]);
              v42 = _mm_loadu_si128((const __m128i *)&Buf2[v40 + 32]);
              v43 = _mm_loadu_si128((const __m128i *)&Buf2[v40 + 48]);
              v44 = _mm_movemask_epi8(
                      _mm_and_si128(
                        _mm_cmpeq_epi8(_mm_loadu_si128((const __m128i *)&Buf2[v40 + v12]), v36),
                        _mm_cmpeq_epi8(_mm_loadu_si128((const __m128i *)&Buf2[v40]), v34)));
              v45 = _mm_loadu_si128((const __m128i *)&v38[v40 + v12]);
              v46 = _mm_loadu_si128((const __m128i *)&v39[v40 + v12]);
              v47 = _mm_loadu_si128((const __m128i *)&Buf2[v40 + 48 + v12]);
              if ( v44 )
              {
                LOBYTE(v52) = sub_433E60(&v75, v40, v44, 0);
                v39 = v86;
                v38 = v87;
                v14 = v88;
                LODWORD(v4) = v52;
              }
              v48 = _mm_movemask_epi8(_mm_and_si128(_mm_cmpeq_epi8(v45, v36), _mm_cmpeq_epi8(v41, v34)));
              if ( (_WORD)v48 )
              {
                v53 = sub_433E60(&v75, v40 | 0x10, v48, v4 & 1);
                v39 = v86;
                v38 = v87;
                v14 = v88;
                LOBYTE(v54) = (v4 | v53) & 1;
                LODWORD(v4) = v54;
              }
              v49 = _mm_movemask_epi8(_mm_and_si128(_mm_cmpeq_epi8(v46, v36), _mm_cmpeq_epi8(v42, v34)));
              if ( (_WORD)v49 )
              {
                v55 = sub_433E60(&v75, v40 | 0x20, v49, v4 & 1);
                v39 = v86;
                v38 = v87;
                v14 = v88;
                LOBYTE(v56) = (v4 | v55) & 1;
                LODWORD(v4) = v56;
              }
              v50 = _mm_movemask_epi8(_mm_and_si128(_mm_cmpeq_epi8(v47, v36), _mm_cmpeq_epi8(v43, v34)));
              if ( (_WORD)v50 )
              {
                v57 = sub_433E60(&v75, v40 | 0x30, v50, v4 & 1);
                v39 = v86;
                v38 = v87;
                v14 = v88;
                LOBYTE(v58) = (v4 | v57) & 1;
                LODWORD(v4) = v58;
              }
              v51 = v40 + v37 + 64;
              v40 += 64LL;
            }
            while ( v51 < a4 );
          }
          if ( v40 + v14 < a4 )
          {
            v59 = (const __m128i *)&Buf2[v40];
            do
            {
              if ( (v4 & 1) != 0 )
                break;
              v60 = _mm_movemask_epi8(
                      _mm_and_si128(
                        _mm_cmpeq_epi8(_mm_loadu_si128((const __m128i *)&Buf2[v40 + v12]), v36),
                        _mm_cmpeq_epi8(_mm_loadu_si128(v59), v34)));
              if ( v60 )
              {
                LOBYTE(v62) = sub_433E60(&v75, v40, v60, 0);
                v14 = v88;
                LODWORD(v4) = v62;
              }
              v61 = v14 + v40 + 16;
              v40 += 16LL;
              ++v59;
            }
            while ( v61 < a4 );
          }
          v63 = a4 - v74;
          v64 = _mm_movemask_epi8(
                  _mm_and_si128(
                    _mm_cmpeq_epi8(_mm_loadu_si128((const __m128i *)&Buf2[v63 - 16 + v12]), v36),
                    _mm_cmpeq_epi8(_mm_loadu_si128((const __m128i *)&Buf2[v63 - 16]), v34)));
          if ( v64 )
          {
            LOBYTE(v65) = (v4 | sub_433E60(&v75, v63 - 16, v64, v4 & 1)) & 1;
            LODWORD(v4) = v65;
          }
        }
        else
        {
          LOBYTE(v4) = 1;
          if ( !memcmp(Buf2, Buf1, Size) )
            goto LABEL_85;
          v15 = Buf2 + 1;
          v16 = a4 - 1;
          while ( v16 >= Size )
          {
            v17 = memcmp(v15++, Buf1, Size);
            --v16;
            if ( !v17 )
              goto LABEL_85;
          }
LABEL_84:
          LODWORD(v4) = 0;
        }
        goto LABEL_85;
      }
    }
    sub_4083C0(&v75, (__int64)Buf2, a4, Buf1, Size);
    if ( ((unsigned __int8)v75 & 1) != 0 )
    {
      v18 = v81;
      v19 = v85 - 1;
      if ( v81 == (char *)-1LL )
      {
        v66 = v80;
        v67 = v80 + v19;
        if ( v80 + v19 >= v83 )
          goto LABEL_84;
        v68 = v79;
        while ( !_bittest64(&v68, (unsigned __int8)v82[v67]) )
        {
          v66 += v85;
LABEL_87:
          v67 = v66 + v19;
          LODWORD(v4) = 0;
          if ( v66 + v19 >= v83 )
            goto LABEL_85;
        }
        v4 = v76;
        while ( v4 < v85 )
        {
          v70 = v4;
          if ( v66 + v4 >= v83 )
          {
            v73 = v76 + v66;
            if ( v83 > v73 )
              v73 = v83;
            sub_4050B0(v73, v83, (__int64)&off_4479B8);
          }
          ++v4;
          if ( *(_BYTE *)(v84 + v70) != v82[v66 + v70] )
          {
            v66 = v70 + v66 - v76 + 1;
            goto LABEL_87;
          }
        }
        v25 = v76;
        while ( v25-- != 0 )
        {
          if ( v76 - 1 >= v85 )
LABEL_104:
            sub_4050B0(v25, v85, (__int64)&off_447988);
          v26 = v25 + v66;
          if ( v25 + v66 >= v83 )
LABEL_105:
            sub_4050B0(v26, v83, (__int64)&off_4479A0);
          LODWORD(v4) = *(unsigned __int8 *)(v84 + v25);
          if ( (_BYTE)v4 != v82[v26] )
          {
            v66 += v78;
            goto LABEL_87;
          }
        }
      }
      else
      {
        v20 = v80;
        v21 = v80 + v19;
        if ( v80 + v19 >= v83 )
          goto LABEL_84;
        v22 = v79;
        v88 = v78;
        LODWORD(v4) = v85 - v78;
        v87 = (char *)(v85 - v78);
        while ( !_bittest64(&v22, (unsigned __int8)v82[v21]) )
        {
          v20 += v85;
LABEL_29:
          v18 = 0LL;
LABEL_30:
          v21 = v20 + v19;
          LODWORD(v4) = 0;
          if ( v20 + v19 >= v83 )
            goto LABEL_85;
        }
        v23 = (unsigned __int64)v18;
        if ( v76 > (unsigned __int64)v18 )
          v23 = v76;
        v24 = v23;
        while ( v24 < v85 )
        {
          v4 = v24;
          if ( v20 + v24 >= v83 )
          {
            v72 = v23 + v20;
            if ( v83 > v72 )
              v72 = v83;
            sub_4050B0(v72, v83, (__int64)&off_4479B8);
          }
          ++v24;
          if ( *(_BYTE *)(v84 + v4) != v82[v20 + v4] )
          {
            v20 = v4 + v20 - v76 + 1;
            goto LABEL_29;
          }
        }
        v25 = v76;
        while ( (unsigned __int64)v18 < v25 )
        {
          if ( --v25 >= v85 )
            goto LABEL_104;
          v26 = v25 + v20;
          if ( v25 + v20 >= v83 )
            goto LABEL_105;
          LODWORD(v4) = *(unsigned __int8 *)(v84 + v25);
          if ( (_BYTE)v4 != v82[v26] )
          {
            v20 += v88;
            v18 = v87;
            goto LABEL_30;
          }
        }
      }
LABEL_59:
      LOBYTE(v4) = 1;
      goto LABEL_85;
    }
    if ( BYTE2(v78) )
      goto LABEL_84;
    v27 = v76;
    LODWORD(v4) = (unsigned __int8)v78;
    while ( 1 )
    {
      if ( v27 )
      {
        if ( v27 >= v83 )
        {
          if ( v27 != v83 )
LABEL_109:
            sub_4079A0(v82, v83, v27, v83, (__int64)&off_448238);
        }
        else if ( (char)v82[v27] <= -65 )
        {
          goto LABEL_109;
        }
      }
      if ( v27 == v83 )
        break;
      v28 = (unsigned __int8)v82[v27];
      if ( (v28 & 0x80u) != 0 )
      {
        v30 = v28 & 0x1F;
        v31 = v82[v27 + 1] & 0x3F;
        if ( (unsigned __int8)v28 <= 0xDFu )
        {
          v28 = v31 | (v30 << 6);
          if ( (v4 & 1) != 0 )
            goto LABEL_59;
        }
        else
        {
          v32 = (v31 << 6) | v82[v27 + 2] & 0x3F;
          if ( (unsigned __int8)v28 < 0xF0u )
          {
            v28 = (v30 << 12) | v32;
            if ( (v4 & 1) != 0 )
              goto LABEL_59;
          }
          else
          {
            v28 = ((v28 & 7) << 18) | (v32 << 6) | v82[v27 + 3] & 0x3F;
            if ( (v4 & 1) != 0 )
              goto LABEL_59;
          }
        }
      }
      else if ( (v4 & 1) != 0 )
      {
        goto LABEL_59;
      }
      v29 = 1LL;
      if ( v28 >= 0x80 )
      {
        v29 = 2LL;
        if ( v28 >= 0x800 )
          v29 = 4LL - (v28 < 0x10000);
      }
      LOBYTE(v4) = v4 ^ 1;
      v27 += v29;
    }
  }
LABEL_85:
  LOBYTE(v4) = v4 & 1;
  return (unsigned int)v4;
}
// 433B8E: variable 'v52' is possibly undefined
// 433BBD: variable 'v54' is possibly undefined
// 433BEC: variable 'v56' is possibly undefined
// 433C1B: variable 'v58' is possibly undefined
// 433C95: variable 'v62' is possibly undefined
// 433CE3: variable 'v65' is possibly undefined
// 433D0C: variable 'v4' is possibly undefined
// 447970: using guessed type char *off_447970;
// 447988: using guessed type char *off_447988;
// 4479A0: using guessed type char *off_4479A0;
// 4479B8: using guessed type char *off_4479B8;
// 448238: using guessed type char *off_448238;

//----- (0000000000433E60) ----------------------------------------------------
char __fastcall sub_433E60(_QWORD *_RCX, __int64 a2, int _R8D, char a4)
{
  char result; // al
  _BYTE *v5; // r9
  __int64 v6; // rdx
  unsigned __int64 v7; // r10
  _DWORD *v8; // r11
  _DWORD *v9; // rax
  _DWORD *v10; // rsi

  if ( a4 )
    return 0;
  v5 = (_BYTE *)_RCX[2];
  v6 = *_RCX + a2 + 1;
  v7 = _RCX[3];
  if ( v7 >= 4 )
  {
    while ( 1 )
    {
      __asm { tzcnt   ecx, r8d }
      v8 = (_DWORD *)((char *)_RCX + v6);
      v9 = (_DWORD *)((char *)_RCX + v6 + v7 - 4);
      if ( v9 <= (_DWORD *)((char *)_RCX + v6) )
      {
LABEL_6:
        if ( *v9 == *(_DWORD *)&v5[v7 - 4] )
          return 1;
      }
      else
      {
        v10 = v5;
        while ( *v8 == *v10 )
        {
          ++v8;
          ++v10;
          if ( v8 >= v9 )
            goto LABEL_6;
        }
      }
      LOWORD(_R8D) = __ROL2__(-2, (char)_RCX) & _R8D;
      if ( !(_WORD)_R8D )
        return 0;
    }
  }
  while ( 1 )
  {
    result = 1;
    if ( !v7 )
      break;
    __asm { tzcnt   ecx, r8d }
    if ( *((_BYTE *)_RCX + v6) == *v5
      && (v7 == 1 || *((_BYTE *)_RCX + v6 + 1) == v5[1] && (v7 == 2 || v7 == 3 && *((_BYTE *)_RCX + v6 + 2) == v5[2])) )
    {
      break;
    }
    LOWORD(_R8D) = __ROL2__(-2, (char)_RCX) & _R8D;
    if ( !(_WORD)_R8D )
      return 0;
  }
  return result;
}

//----- (0000000000433F60) ----------------------------------------------------
int __fastcall sub_433F60(_QWORD *a1)
{
  __int64 v1; // rax
  void *v2; // rsi
  HANDLE ProcessHeap; // rax

  v1 = 2LL * *a1;
  if ( v1 )
  {
    v2 = (void *)a1[1];
    ProcessHeap = GetProcessHeap();
    LODWORD(v1) = HeapFree(ProcessHeap, 0, v2);
  }
  return v1;
}

//----- (0000000000433FA0) ----------------------------------------------------
__int64 __fastcall sub_433FA0(__int64 a1, __int64 a2, __int128 *a3)
{
  __int64 v4; // rdi
  __int64 v5; // r9
  __int64 result; // rax
  void *v7; // rsi
  unsigned int v8; // ebx
  HANDLE ProcessHeap; // rax
  _QWORD v10[6]; // [rsp+0h] [rbp-40h] BYREF
  __int128 v11; // [rsp+30h] [rbp-10h]
  __int64 v12; // [rsp+40h] [rbp+0h]

  v10[5] = a2;
  v11 = *a3;
  v12 = *((_QWORD *)a3 + 2);
  v4 = *(_QWORD *)a1;
  v5 = 0LL;
  if ( !__OFSUB__(-*(_QWORD *)a1, 1LL) )
    v5 = a1;
  result = sub_434060(a2, (__int64)&v10[6], *(_BYTE *)(a1 + 32), v5);
  if ( 2 * v4 )
  {
    v7 = *(void **)(a1 + 8);
    v8 = result;
    ProcessHeap = GetProcessHeap();
    HeapFree(ProcessHeap, 0, v7);
    return v8;
  }
  return result;
}

//----- (0000000000434030) ----------------------------------------------------
__int64 __fastcall sub_434030(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r9

  v3 = 0LL;
  if ( !__OFSUB__(0LL, *(_QWORD *)a1) )
    v3 = a1;
  return sub_434060(a2, a3, *(_BYTE *)(a1 + 32), v3);
}

//----- (0000000000434060) ----------------------------------------------------
__int64 __fastcall sub_434060(__int64 a1, __int64 a2, char a3, __int64 a4)
{
  unsigned __int16 *v7; // rdx
  unsigned __int64 v8; // r8
  char *v9; // r9
  char *v10; // rcx
  unsigned __int64 v11; // r13
  unsigned __int8 *v12; // r15
  unsigned __int64 v13; // r14
  unsigned __int64 v14; // rdx
  _BYTE *v15; // r8
  unsigned __int64 v16; // rcx
  __int64 v17; // rdx
  __int64 v18; // rdx
  char *v19; // r12
  __int64 v20; // rcx
  __int64 v21; // rbx
  unsigned __int64 v22; // rax
  unsigned __int64 v23; // r14
  char *v24; // r9
  char *v25; // r8
  __int64 v26; // r10
  char v27; // r11
  char *v28; // r9
  unsigned __int8 (__fastcall *v29)(__int64, char *, unsigned __int64); // r13
  __int64 v30; // rdi
  unsigned __int64 v31; // r14
  unsigned __int64 v32; // r13
  unsigned __int16 *v33; // rdx
  int v34; // eax
  HANDLE ProcessHeap; // rax
  __int128 v37; // [rsp+140h] [rbp+C0h] BYREF
  __int128 v38; // [rsp+150h] [rbp+D0h]
  __int128 v39; // [rsp+160h] [rbp+E0h]
  __int64 v40; // [rsp+1B0h] [rbp+130h]
  unsigned __int64 v41; // [rsp+1B8h] [rbp+138h]
  unsigned __int64 v42; // [rsp+200h] [rbp+180h]
  LPVOID lpMem; // [rsp+208h] [rbp+188h]
  BOOL v44; // [rsp+214h] [rbp+194h]

  v40 = a1;
  v7 = *(unsigned __int16 **)(a2 + 8);
  v8 = *(_QWORD *)(a2 + 16);
  if ( *(_DWORD *)a2 != 1 )
  {
    v41 = 0x8000000000000000uLL;
    sub_406850((__int64)&v37, (__int64)v7, v8);
    v11 = 9LL;
    if ( !(_BYTE)v37 )
      v11 = v38;
    v10 = aUnknown;
    if ( !(_BYTE)v37 )
      v10 = (char *)*((_QWORD *)&v37 + 1);
    if ( a3 )
      goto LABEL_28;
    goto LABEL_9;
  }
  sub_414CB0(&v37, v7, v8);
  v10 = (char *)*((_QWORD *)&v37 + 1);
  v41 = v37;
  v11 = v38;
  if ( !a3 )
  {
LABEL_9:
    lpMem = v10;
    if ( !((a4 == 0) | (unsigned __int8)sub_434CA0(v10, v11) ^ 1) )
    {
      v12 = *(unsigned __int8 **)(a4 + 8);
      v13 = *(_QWORD *)(a4 + 16);
      sub_434DE0((__int64)&v37, (unsigned __int8 *)lpMem, v11);
      v14 = v11;
      v15 = lpMem;
      switch ( v11 )
      {
        case 0uLL:
        case 3uLL:
          v16 = v38 + 4;
          goto LABEL_21;
        case 1uLL:
          v17 = v39 + 1;
          if ( !(_QWORD)v39 )
            v17 = 0LL;
          v16 = v17 + v38 + 8;
          goto LABEL_21;
        case 2uLL:
          v16 = 6LL;
          goto LABEL_21;
        case 4uLL:
          v18 = v39 + 1;
          if ( !(_QWORD)v39 )
            v18 = 0LL;
          v16 = v18 + v38 + 2;
          goto LABEL_21;
        case 5uLL:
          v16 = 2LL;
LABEL_21:
          v14 = v11 - v16;
          if ( v11 < v16 )
            sub_4050A0(v16, v11, (__int64)&off_448DF0);
          v15 = (char *)lpMem + v16;
          break;
        case 6uLL:
          break;
      }
      if ( v14 )
        v44 = *v15 == 47 || *v15 == 92;
      else
        v44 = 0;
      sub_434DE0((__int64)&v37, v12, v13);
      JUMPOUT(0x43426FLL);
    }
    v10 = (char *)lpMem;
  }
LABEL_28:
  lpMem = v10;
  v19 = &v10[v11];
  v20 = *(_QWORD *)(v40 + 48);
  v21 = *(_QWORD *)(v40 + 56);
  v22 = 0LL;
  LOBYTE(a4) = 1;
  while ( v22 != v11 )
  {
    v23 = v22;
    v9 = (char *)lpMem + v22;
    while ( 1 )
    {
      v25 = v9 + 1;
      v27 = *v9;
      v26 = 1LL;
      if ( *v9 < 0 )
        break;
LABEL_34:
      v23 += v26;
      v9 = v25;
      if ( v25 == v19 )
        goto LABEL_53;
    }
    if ( (unsigned __int8)v27 < 0xE0u )
    {
      v24 = v9 + 2;
      if ( v25 != v19 )
        v25 = v24;
      v26 = 2LL;
      goto LABEL_34;
    }
    if ( v27 != -19 )
    {
      v28 = v9 + 2;
      if ( v25 == v19 )
        v28 = v25;
      v25 = &v28[v28 != v19];
      v26 = 3LL;
      if ( (unsigned __int8)v27 >= 0xF0u )
      {
        v25 += v25 != v19;
        v26 = 4LL;
      }
      goto LABEL_34;
    }
    if ( v25 == v19 || v9 + 2 == v19 )
      goto LABEL_53;
    if ( (unsigned __int8)v9[1] <= 0x9Fu )
    {
      v26 = 3LL;
      v25 = v9 + 3;
      goto LABEL_34;
    }
    if ( v23 < v22 )
      sub_406FD0(v22, v23, (__int64)&off_4492F8);
    v42 = v11;
    if ( v23 > v11 )
      sub_405B00(v23, v42, (__int64)&off_4492F8);
    v29 = *(unsigned __int8 (__fastcall **)(__int64, char *, unsigned __int64))(v21 + 24);
    v30 = v20;
    if ( v29(v20, (char *)lpMem + v22, v23 - v22) || v29(v30, (char *)word_449310, 3uLL) )
      goto LABEL_57;
    v31 = v23 + 3;
    v22 = v31;
    v11 = v42;
    v20 = v30;
    if ( v31 > v42 )
      sub_4050A0(v31, v42, (__int64)&off_449360);
  }
  v22 = v11;
LABEL_53:
  v32 = v11 - v22;
  v33 = (unsigned __int16 *)((char *)lpMem + v22);
  if ( v22 )
    v34 = (*(__int64 (__fastcall **)(__int64, unsigned __int16 *, unsigned __int64, char *))(v21 + 24))(
            v20,
            v33,
            v32,
            v9);
  else
    LOBYTE(v34) = sub_405B80(v40, v33, v32);
  LODWORD(a4) = v34;
LABEL_57:
  if ( 2 * v41 )
  {
    ProcessHeap = GetProcessHeap();
    HeapFree(ProcessHeap, 0, lpMem);
  }
  return (unsigned int)a4;
}
// 43426B: control flows out of bounds to 43426F
// 434A8C: variable 'v9' is possibly undefined
// 434AA0: variable 'v34' is possibly undefined
// 434CA0: using guessed type __int64 __fastcall sub_434CA0(_QWORD, _QWORD);
// 448DF0: using guessed type char *off_448DF0;
// 4492F8: using guessed type char *off_4492F8;
// 449310: using guessed type unsigned __int16 word_449310[4];
// 449360: using guessed type char *off_449360;

//----- (0000000000434CA0) ----------------------------------------------------
#error "434D7E: switch analysis failed: failed to propagate the switch expression (funcsize=75)"

//----- (0000000000434DE0) ----------------------------------------------------
char __fastcall sub_434DE0(__int64 a1, unsigned __int8 *a2, unsigned __int64 a3)
{
  unsigned __int8 v3; // r10
  unsigned __int8 v4; // si
  __int64 v5; // r9
  unsigned __int8 v6; // bl
  unsigned __int8 v7; // r11
  _BYTE *v8; // rax
  unsigned __int8 v9; // r14
  unsigned __int8 v10; // di
  __int64 v11; // r9
  char v12; // r15
  int v13; // r10d
  unsigned __int64 v14; // r10
  _BYTE *v15; // rdx
  unsigned __int64 v16; // r8
  __int64 v17; // r9
  int v18; // r11d
  unsigned __int64 v19; // r10
  __int64 v20; // r8
  unsigned __int64 v21; // rsi
  int v22; // edi
  bool v23; // zf
  _BYTE *v24; // rdx
  unsigned __int64 v25; // r8
  int v26; // r9d
  __int64 v27; // r9
  unsigned __int64 v28; // rsi
  _BYTE *v29; // rdx
  unsigned __int64 v30; // r8
  unsigned __int64 v31; // r11
  unsigned __int64 v32; // r10
  unsigned __int64 v33; // r9
  int v34; // r10d
  unsigned __int64 v35; // r8
  unsigned __int64 v36; // rdx
  unsigned __int64 v37; // rsi
  __int64 v38; // r8

  if ( a3 )
  {
    v3 = *a2;
    v4 = 92;
    if ( *a2 == 47 )
      v3 = 92;
    if ( a3 == 1 )
    {
      v5 = 0LL;
      v6 = 0;
      v7 = 0;
      LOBYTE(v8) = 0;
      v9 = 0;
      v10 = 0;
      v4 = 0;
    }
    else
    {
      if ( a2[1] != 47 )
        v4 = a2[1];
      if ( a3 == 2 )
      {
        v5 = 0LL;
        v6 = 0;
        v7 = 0;
        LOBYTE(v8) = 0;
        v9 = 0;
        v10 = 0;
      }
      else
      {
        v10 = a2[2];
        v9 = 92;
        if ( v10 == 47 )
          v10 = 92;
        if ( a3 == 3 )
        {
          v5 = 0LL;
          v6 = 0;
          v7 = 0;
          LOBYTE(v8) = 0;
          v9 = 0;
        }
        else
        {
          if ( a2[3] != 47 )
            v9 = a2[3];
          if ( a3 == 4 )
          {
            v5 = 0LL;
            v6 = 0;
            v7 = 0;
            LOBYTE(v8) = 0;
          }
          else
          {
            LOBYTE(v8) = a2[4];
            v7 = 92;
            if ( (_BYTE)v8 == 47 )
              LOBYTE(v8) = 92;
            if ( a3 == 5 )
            {
              v5 = 0LL;
              v6 = 0;
              v7 = 0;
            }
            else
            {
              if ( a2[5] != 47 )
                v7 = a2[5];
              if ( a3 == 6 )
              {
                v5 = 0LL;
                v6 = 0;
              }
              else
              {
                v6 = a2[6];
                v11 = 92LL;
                if ( v6 == 47 )
                  v6 = 92;
                if ( a3 == 7 )
                {
                  v5 = 0LL;
                }
                else
                {
                  if ( a2[7] != 47 )
                    v11 = a2[7];
                  v5 = v11 << 56;
                }
              }
            }
          }
        }
      }
    }
  }
  else
  {
    v5 = 0LL;
    v6 = 0;
    v7 = 0;
    LOBYTE(v8) = 0;
    v9 = 0;
    v10 = 0;
    v4 = 0;
    v3 = 0;
  }
  v12 = 8;
  if ( a3 < 8 )
    v12 = a3;
  if ( a3 >= 2 && ((v4 << 8) | v3) == 0x5C5C )
  {
    if ( (v12 & 0xE) == 2 )
      goto LABEL_51;
    v13 = (unsigned __int16)((v9 << 8) | v10);
    if ( v13 != 23598 )
    {
      if ( v13 == 23615 )
      {
        if ( a3 <= 3 )
          sub_405B00(4LL, a3, (__int64)&off_44A0E0);
        if ( *a2 == 47 || a2[1] == 47 || a2[2] == 47 || a2[3] == 47 )
        {
          v14 = a3 - 2;
LABEL_52:
          v8 = a2 + 2;
          v15 = a2 + 3;
          v16 = a3 - 4;
          v17 = 0LL;
          while ( 1 )
          {
            v18 = (unsigned __int8)*(v15 - 1);
            if ( v18 == 47 || v18 == 92 )
              break;
            ++v17;
            ++v15;
            if ( --v16 == -2LL )
              goto LABEL_66;
          }
          v19 = v14 - (v17 + 1);
          if ( v19 )
          {
            v20 = -(__int64)v16;
            v21 = 0LL;
            while ( 1 )
            {
              v22 = (unsigned __int8)v15[v21];
              if ( v22 == 47 || v22 == 92 )
                break;
              v23 = v20 + v21++ == 0;
              if ( v23 )
              {
                v21 = v19;
                break;
              }
            }
            if ( v17 && v21 )
            {
              *(_BYTE *)a1 = 4;
              *(_QWORD *)(a1 + 8) = v8;
              *(_QWORD *)(a1 + 16) = v17;
              *(_QWORD *)(a1 + 24) = &v8[v17 + 1];
              *(_QWORD *)(a1 + 32) = v21;
              return (char)v8;
            }
          }
LABEL_66:
          *(_BYTE *)a1 = 6;
          return (char)v8;
        }
        if ( (v12 & 0xC) != 4
          && (v5 | ((unsigned __int64)v6 << 48) | ((unsigned __int64)v7 << 40) | ((unsigned __int64)(unsigned __int8)v8 << 32)) == 0x5C434E5500000000LL )
        {
          if ( a3 <= 7 )
            sub_4050A0(8LL, a3, (__int64)&off_44A0F8);
          v8 = a2 + 8;
          v27 = 1LL;
          v28 = a3 - 8;
          if ( a3 == 8 )
          {
            v32 = 0LL;
          }
          else
          {
            v29 = a2 + 9;
            v30 = a3 - 10;
            v31 = 0LL;
            v32 = 0LL;
            while ( *(v29 - 1) != 92 )
            {
              ++v32;
              ++v29;
              if ( --v30 == -2LL )
              {
                v32 = v28;
                goto LABEL_104;
              }
            }
            v27 = (__int64)&v8[v32 + 1];
            v37 = v28 - (v32 + 1);
            if ( v37 )
            {
              v38 = -(__int64)v30;
              v31 = 0LL;
              while ( v29[v31] != 92 )
              {
                v23 = v38 + v31++ == 0;
                if ( v23 )
                {
                  v31 = v37;
                  goto LABEL_104;
                }
              }
              goto LABEL_104;
            }
          }
          v31 = 0LL;
LABEL_104:
          *(_BYTE *)a1 = 1;
          *(_QWORD *)(a1 + 8) = v8;
          *(_QWORD *)(a1 + 16) = v32;
          *(_QWORD *)(a1 + 24) = v27;
          *(_QWORD *)(a1 + 32) = v31;
          return (char)v8;
        }
        v8 = a2 + 4;
        v33 = a3 - 4;
        if ( a3 - 4 < 3 )
        {
          if ( a3 == 4 )
          {
LABEL_97:
            *(_BYTE *)a1 = 0;
            *(_QWORD *)(a1 + 8) = v8;
            *(_QWORD *)(a1 + 16) = v33;
            return (char)v8;
          }
          if ( a3 != 6 )
          {
LABEL_91:
            v35 = a3 - 4;
            v36 = 0LL;
            while ( v8[v36] != 92 )
            {
              if ( v35 == ++v36 )
                goto LABEL_97;
            }
            v33 = v36;
            goto LABEL_97;
          }
        }
        else
        {
          v34 = a2[6];
          if ( v34 != 47 && v34 != 92 )
            goto LABEL_91;
        }
        if ( a2[5] == 58 && (unsigned __int8)((*v8 & 0xDF) - 65) <= 0x19u )
        {
          LOBYTE(v8) = *v8 ^ (32 * (*v8 >= 0x61u));
          *(_BYTE *)a1 = 2;
          *(_BYTE *)(a1 + 1) = (_BYTE)v8;
          return (char)v8;
        }
        goto LABEL_91;
      }
LABEL_51:
      v14 = a3 - 2;
      if ( a3 == 2 )
        goto LABEL_66;
      goto LABEL_52;
    }
    if ( a3 <= 3 )
      sub_4050A0(4LL, a3, (__int64)&off_44A0F8);
    v24 = a2 + 4;
    v8 = 0LL;
    v25 = a3 - 4;
    if ( v25 )
    {
      while ( 1 )
      {
        v26 = (unsigned __int8)v8[(_QWORD)v24];
        if ( v26 == 47 || v26 == 92 )
          break;
        if ( (_BYTE *)v25 == ++v8 )
        {
          v8 = (_BYTE *)v25;
          break;
        }
      }
    }
    *(_BYTE *)a1 = 3;
    *(_QWORD *)(a1 + 8) = v24;
    *(_QWORD *)(a1 + 16) = v8;
  }
  else
  {
    if ( a3 < 2 )
      goto LABEL_66;
    if ( a2[1] != 58 )
      goto LABEL_66;
    LOBYTE(v8) = *a2;
    if ( (unsigned __int8)((*a2 & 0xDF) - 65) >= 0x1Au )
      goto LABEL_66;
    *(_BYTE *)a1 = 5;
    *(_BYTE *)(a1 + 1) = (unsigned __int8)v8 ^ (32 * ((unsigned __int8)v8 >= 0x61u));
  }
  return (char)v8;
}
// 44A0E0: using guessed type char *off_44A0E0;
// 44A0F8: using guessed type char *off_44A0F8;

//----- (0000000000435280) ----------------------------------------------------
void __fastcall sub_435280(__int64 a1, __int64 a2)
{
  unsigned __int8 v2; // bl
  unsigned __int8 v3; // r15
  unsigned int v4; // r8d
  __int64 v5; // rsi
  __int64 v6; // r9
  char v7; // r13
  __int64 v8; // rax
  unsigned __int64 v9; // rax
  _BYTE *v10; // r12
  unsigned __int64 v11; // r11
  unsigned __int64 v12; // r9
  unsigned __int64 v13; // r10
  _BYTE *v14; // rsi
  char v15; // r10
  int v16; // r10d
  int v17; // r9d
  __int64 v18; // rsi
  unsigned __int64 v19; // r10
  char v20; // di
  unsigned __int64 v21; // rsi
  __int128 v22; // xmm0
  __int64 v23; // [rsp+30h] [rbp+0h]

  v2 = *(_BYTE *)(a2 + 56);
  if ( v2 == 3 )
    goto LABEL_5;
  v3 = *(_BYTE *)(a2 + 57);
  v4 = *(unsigned __int8 *)(a2 + 16);
  v5 = *(_QWORD *)(a2 + 48);
  v6 = v5 + 1;
  if ( !v5 )
    v6 = 0LL;
  if ( v3 == 3 || v2 > v3 )
  {
LABEL_5:
    *(_BYTE *)a1 = 10;
    return;
  }
  v7 = *(_BYTE *)(a2 + 58);
  v8 = *(_QWORD *)(a2 + 32);
  v23 = v8 + v6 + 8;
  v9 = v8 + 4;
  v10 = *(_BYTE **)a2;
  v11 = *(_QWORD *)(a2 + 8);
  v12 = v11;
  while ( 1 )
  {
    if ( !v2 )
    {
      v13 = v9;
      switch ( v4 )
      {
        case 0u:
          goto LABEL_8;
        case 1u:
          v13 = v23;
LABEL_8:
          if ( v13 )
            goto LABEL_51;
          *(_BYTE *)(a2 + 56) = 1;
          v2 = 1;
          goto LABEL_10;
        case 2u:
LABEL_51:
          *(_BYTE *)(a2 + 56) = 1;
          switch ( (char)v4 )
          {
            case 0:
              v13 = v9;
              goto LABEL_61;
            case 1:
              v13 = v23;
              goto LABEL_61;
            case 2:
              v13 = 6LL;
LABEL_61:
              if ( v13 <= v12 )
              {
                switch ( (char)v4 )
                {
                  case 0:
                    goto LABEL_65;
                  case 1:
                    v9 = v23;
                    goto LABEL_65;
                  case 2:
                    v9 = 6LL;
LABEL_65:
                    if ( v12 < v9 )
                      sub_4050A0(v9, v12, (__int64)&off_448EA0);
                    *(_QWORD *)a2 = &v10[v9];
                    *(_QWORD *)(a2 + 8) = v12 - v9;
                    *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 48);
                    v22 = *(_OWORD *)(a2 + 17);
                    *(_OWORD *)(a1 + 17) = *(_OWORD *)(a2 + 33);
                    *(_OWORD *)(a1 + 1) = v22;
                    *(_BYTE *)a1 = v4;
                    *(_QWORD *)(a1 + 40) = v10;
                    *(_QWORD *)(a1 + 48) = v13;
                    return;
                  default:
                    goto LABEL_30;
                }
              }
              sub_405B00(v13, v12, (__int64)&off_448E88);
            default:
              goto LABEL_30;
          }
          goto LABEL_30;
        default:
          goto LABEL_16;
      }
    }
    if ( v2 == 1 )
      break;
    if ( !v11 )
    {
      *(_BYTE *)(a2 + 56) = 3;
      goto LABEL_5;
    }
    v13 = 0LL;
    if ( (unsigned __int8)v4 >= 3u )
    {
      do
      {
LABEL_30:
        v17 = (unsigned __int8)v10[v13];
        if ( v17 == 47 || v17 == 92 )
          goto LABEL_36;
        ++v13;
      }
      while ( v11 != v13 );
LABEL_33:
      v18 = 0LL;
      v13 = v11;
      if ( !v11 )
      {
LABEL_34:
        v19 = v18 + v13;
        v12 = v11 - v19;
        if ( v11 < v19 )
          goto LABEL_69;
        v10 += v19;
        *(_QWORD *)a2 = v10;
        *(_QWORD *)(a2 + 8) = v12;
        v2 = 2;
        v11 -= v19;
LABEL_10:
        v14 = v10;
        goto LABEL_11;
      }
    }
    else
    {
      while ( v10[v13] != 92 )
      {
        if ( v11 == ++v13 )
          goto LABEL_33;
      }
LABEL_36:
      v18 = 1LL;
      if ( !v13 )
        goto LABEL_34;
    }
    if ( v13 == 2 )
    {
      v20 = ((*v10 ^ 0x2E | v10[1] ^ 0x2E) == 0) ^ 9;
    }
    else
    {
      if ( v13 != 1 )
      {
        v21 = v13 + v18;
        if ( v11 < v21 )
        {
LABEL_68:
          v19 = v21;
LABEL_69:
          sub_4050A0(v19, v11, (__int64)&off_448EE8);
        }
        *(_QWORD *)a2 = &v10[v21];
        *(_QWORD *)(a2 + 8) = v11 - v21;
        v20 = 9;
LABEL_58:
        *(_BYTE *)a1 = v20;
        *(_QWORD *)(a1 + 8) = v10;
        *(_QWORD *)(a1 + 16) = v13;
        return;
      }
      v20 = 3 * (v4 >= 3) + 7;
      if ( *v10 != 46 )
        v20 = 9;
    }
    v21 = v13 + v18;
    v12 = v11 - v21;
    if ( v11 < v21 )
      goto LABEL_68;
    v14 = &v10[v21];
    *(_QWORD *)a2 = v14;
    *(_QWORD *)(a2 + 8) = v12;
    v2 = 2;
    v11 = v12;
    if ( v20 != 10 )
      goto LABEL_58;
LABEL_11:
    v10 = v14;
    if ( v2 > v3 )
      goto LABEL_5;
  }
  *(_BYTE *)(a2 + 56) = 2;
  if ( (v7 & 1) == 0 )
  {
    v2 = 2;
    if ( v4 >= 3 )
    {
LABEL_16:
      if ( v4 != 5 )
      {
        if ( v4 != 6 )
        {
          *(_BYTE *)a1 = 6;
          return;
        }
        if ( v11 )
        {
          v15 = *v10;
          if ( v11 == 1 || v15 != 46 )
          {
            if ( v11 == 1 && v15 == 46 )
            {
LABEL_49:
              if ( !v12 )
                sub_4050A0(1LL, 0LL, (__int64)&off_448EB8);
              *(_QWORD *)a2 = v10 + 1;
              *(_QWORD *)(a2 + 8) = v12 - 1;
              *(_BYTE *)a1 = 7;
              return;
            }
          }
          else
          {
            v16 = (unsigned __int8)v10[1];
            if ( v16 == 47 || v16 == 92 )
              goto LABEL_49;
          }
        }
        else
        {
          v11 = 0LL;
        }
      }
    }
    goto LABEL_10;
  }
  if ( !v12 )
    sub_4050A0(1LL, 0LL, (__int64)&off_448ED0);
  *(_QWORD *)a2 = v10 + 1;
  *(_QWORD *)(a2 + 8) = v12 - 1;
  *(_BYTE *)a1 = 6;
}
// 448E88: using guessed type char *off_448E88;
// 448EA0: using guessed type char *off_448EA0;
// 448EB8: using guessed type char *off_448EB8;
// 448ED0: using guessed type char *off_448ED0;
// 448EE8: using guessed type char *off_448EE8;

//----- (0000000000435670) ----------------------------------------------------
char __fastcall sub_435670(unsigned __int8 *a1, unsigned __int8 *a2)
{
  __int64 v2; // r8
  __int64 v3; // r10
  char result; // al
  unsigned __int64 v5; // r9
  unsigned __int64 v6; // r11
  size_t v7; // r8
  const void *v8; // rdx
  const void *v9; // rcx
  size_t v10; // r8

  v2 = *a1;
  v3 = v2 - 5;
  result = 0;
  if ( (unsigned __int8)(v2 - 6) >= 4u )
    v3 = 0LL;
  v5 = *a2;
  v6 = v5 - 5;
  if ( v5 < 6 )
    v6 = 0LL;
  if ( v3 == v6 )
  {
    result = 1;
    if ( v3 )
    {
      if ( v3 != 4 )
        return result;
LABEL_8:
      v7 = *((_QWORD *)a1 + 2);
      if ( v7 == *((_QWORD *)a2 + 2) )
      {
        v8 = (const void *)*((_QWORD *)a2 + 1);
        v9 = (const void *)*((_QWORD *)a1 + 1);
        return memcmp(v9, v8, v7) == 0;
      }
    }
    else
    {
      if ( (unsigned __int8)v5 > 5u )
        return result;
      if ( (_BYTE)v2 == (_BYTE)v5 )
      {
        switch ( *a1 )
        {
          case 0u:
          case 3u:
            goto LABEL_8;
          case 1u:
          case 4u:
            v10 = *((_QWORD *)a1 + 2);
            if ( v10 != *((_QWORD *)a2 + 2) )
              return 0;
            if ( memcmp(*((const void **)a1 + 1), *((const void **)a2 + 1), v10) )
              return 0;
            v7 = *((_QWORD *)a1 + 4);
            if ( v7 != *((_QWORD *)a2 + 4) )
              return 0;
            v8 = (const void *)*((_QWORD *)a2 + 3);
            v9 = (const void *)*((_QWORD *)a1 + 3);
            return memcmp(v9, v8, v7) == 0;
          case 2u:
          case 5u:
            return a1[1] == a2[1];
        }
      }
    }
    return 0;
  }
  return result;
}

//----- (0000000000435740) ----------------------------------------------------
char __fastcall sub_435740(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  unsigned __int64 v6; // rax
  unsigned __int64 v7; // rdx
  __int64 v8; // r10
  _BYTE *v9; // rcx
  unsigned __int8 v10; // r9
  __int64 v11; // r8
  __int64 v12; // r11
  _BYTE *v13; // rdi
  int v14; // ebx
  unsigned __int64 v15; // rdx
  char result; // al

  v6 = sub_435880((__int64 *)a2, a2, a3, a4);
  v7 = *(_QWORD *)(a2 + 8);
  if ( v6 > v7 )
    sub_4050A0(v6, v7, (__int64)&off_448E28);
  v8 = *(_QWORD *)a2;
  v9 = (_BYTE *)(*(_QWORD *)a2 + v6);
  if ( v6 == v7 )
  {
    v10 = *(_BYTE *)(a2 + 16);
    v11 = 0LL;
  }
  else
  {
    v10 = *(_BYTE *)(a2 + 16);
    v12 = v6 - v7 + 1;
    v13 = (_BYTE *)(v7 + v8 - 1);
    v11 = 0LL;
    if ( v10 >= 3u )
    {
      while ( 1 )
      {
        v14 = (unsigned __int8)*v13;
        if ( v14 == 47 || v14 == 92 )
          break;
        ++v12;
        --v13;
        if ( v12 == 1 )
          goto LABEL_14;
      }
    }
    else
    {
      while ( *v13 != 92 )
      {
        ++v12;
        --v13;
        if ( v12 == 1 )
          goto LABEL_14;
      }
    }
    v6 = v6 - v12 + 1;
    if ( v6 > v7 )
      sub_4050A0(v6, v7, (__int64)&off_448E40);
    v11 = 1LL;
    v9 = (_BYTE *)(v6 + v8);
  }
LABEL_14:
  v15 = v7 - v6;
  if ( v15 )
  {
    if ( v15 == 2 )
    {
      result = ((*v9 ^ 0x2E | v9[1] ^ 0x2E) == 0) ^ 9;
    }
    else
    {
      result = 9;
      if ( v15 == 1 && *v9 == 46 )
        result = 3 * (v10 >= 3u) + 7;
    }
  }
  else
  {
    result = 10;
  }
  *(_QWORD *)a1 = v15 + v11;
  *(_BYTE *)(a1 + 8) = result;
  *(_QWORD *)(a1 + 16) = v9;
  *(_QWORD *)(a1 + 24) = v15;
  return result;
}
// 448E28: using guessed type char *off_448E28;
// 448E40: using guessed type char *off_448E40;

//----- (0000000000435880) ----------------------------------------------------
unsigned __int64 __fastcall sub_435880(__int64 *a1, __int64 a2, __int64 a3, __int64 a4)
{
  unsigned __int8 v4; // r8
  unsigned __int8 v5; // al
  unsigned __int8 v6; // dl
  char v7; // dl
  bool v8; // r10
  unsigned __int64 v9; // rdx
  __int64 v10; // r10
  __int64 v11; // rcx
  _BYTE *v13; // r11
  bool v14; // dl
  char v15; // r9

  v4 = *((_BYTE *)a1 + 56);
  if ( v4 > 1u )
  {
    v5 = 0;
    v6 = 0;
LABEL_10:
    v11 = 0LL;
    return v11 + v6 + (unsigned __int64)v5;
  }
  v5 = *((_BYTE *)a1 + 58);
  if ( (v5 & 1) != 0 )
    goto LABEL_9;
  v7 = *((_BYTE *)a1 + 16);
  LOBYTE(a4) = v7 - 5;
  if ( (unsigned __int8)(v7 - 5) > 1u )
    goto LABEL_9;
  v8 = v7 == 6;
  a4 = *a1;
  v9 = a1[1];
  if ( v8 || v4 != 0 )
  {
    v10 = 0LL;
  }
  else
  {
    v10 = 2LL;
    if ( v9 <= 1 )
      sub_4050A0(2LL, v9, (__int64)&off_448E10);
  }
  if ( v10 == v9 )
  {
LABEL_9:
    v6 = 0;
    if ( v4 )
      goto LABEL_10;
  }
  else
  {
    v13 = (_BYTE *)(a4 + v10 + 1);
    v14 = v13 == (_BYTE *)(a4 + v9);
    v15 = *(_BYTE *)(a4 + v10);
    if ( v14 || v15 != 46 )
    {
      LOBYTE(a4) = v15 == 46;
      v6 = a4 & v14;
      if ( v4 )
        goto LABEL_10;
    }
    else
    {
      LOBYTE(a4) = *v13 == 92;
      v6 = a4 | (*v13 == 47);
      if ( v4 )
        goto LABEL_10;
    }
  }
  v4 = *((_BYTE *)a1 + 16);
  switch ( (char)a4 )
  {
    case 0:
      v11 = 2LL;
      break;
    case 1:
      goto LABEL_10;
    default:
      goto LABEL_9;
  }
  return v11 + v6 + (unsigned __int64)v5;
}
// 448E10: using guessed type char *off_448E10;

//----- (00000000004359E0) ----------------------------------------------------
char __fastcall sub_4359E0(__int64 *a1, char *a2, size_t a3)
{
  size_t v3; // rdi
  _QWORD *v5; // r15
  __int64 v6; // r12
  size_t v7; // r13
  size_t v8; // rax
  size_t v9; // rsi
  size_t v10; // rcx
  size_t v11; // r14
  void *v12; // rcx
  __int64 v14; // rcx

  if ( !a3 )
    return 0;
  v3 = a3;
  v5 = (_QWORD *)*a1;
  v6 = *(_QWORD *)*a1;
  v7 = *(_QWORD *)(*a1 + 8);
  v8 = *(_QWORD *)(*a1 + 16);
  while ( 1 )
  {
    v9 = v8;
    v10 = v7;
    if ( v8 < v7 )
      v10 = v8;
    v11 = v7 - v10;
    v12 = (void *)(v6 + v10);
    if ( v3 < v11 )
      v11 = v3;
    memcpy(v12, a2, v11);
    v8 = v11 + v9;
    if ( v7 <= v9 )
      break;
    a2 += v11;
    v3 -= v11;
    if ( !v3 )
    {
      v5[2] = v8;
      return 0;
    }
  }
  v5[2] = v8;
  v14 = a1[1];
  if ( v14 )
    sub_4131C0(v14);
  a1[1] = (__int64)&off_448D10;
  return 1;
}
// 448D10: using guessed type char *off_448D10;

//----- (0000000000435AB0) ----------------------------------------------------
bool __fastcall sub_435AB0(__int64 *a1, unsigned int a2)
{
  unsigned __int64 v2; // r15
  _QWORD *v3; // r13
  __int64 v4; // rsi
  size_t v5; // r14
  size_t v6; // rax
  int *p_Src; // rdi
  size_t v8; // r12
  size_t v9; // rcx
  size_t v10; // rbx
  void *v11; // rcx
  __int64 v12; // rcx
  int Src; // [rsp+34h] [rbp+4h] BYREF

  Src = 0;
  if ( a2 >= 0x80 )
  {
    if ( a2 >= 0x800 )
    {
      if ( a2 >= 0x10000 )
      {
        LOBYTE(Src) = (a2 >> 18) | 0xF0;
        BYTE1(Src) = (a2 >> 12) & 0x3F | 0x80;
        BYTE2(Src) = (a2 >> 6) & 0x3F | 0x80;
        HIBYTE(Src) = a2 & 0x3F | 0x80;
        v2 = 4LL;
      }
      else
      {
        LOBYTE(Src) = (a2 >> 12) | 0xE0;
        BYTE1(Src) = (a2 >> 6) & 0x3F | 0x80;
        BYTE2(Src) = a2 & 0x3F | 0x80;
        v2 = 3LL;
      }
    }
    else
    {
      LOBYTE(Src) = (a2 >> 6) | 0xC0;
      BYTE1(Src) = a2 & 0x3F | 0x80;
      v2 = 2LL;
    }
  }
  else
  {
    LOBYTE(Src) = a2;
    v2 = 1LL;
  }
  v3 = (_QWORD *)*a1;
  v4 = *(_QWORD *)*a1;
  v5 = *(_QWORD *)(*a1 + 8);
  v6 = *(_QWORD *)(*a1 + 16);
  p_Src = &Src;
  while ( 1 )
  {
    v8 = v6;
    v9 = v5;
    if ( v6 < v5 )
      v9 = v6;
    v10 = v5 - v9;
    v11 = (void *)(v4 + v9);
    if ( v2 < v10 )
      v10 = v2;
    memcpy(v11, p_Src, v10);
    v6 = v10 + v8;
    if ( v5 <= v8 )
      break;
    p_Src = (int *)((char *)p_Src + v10);
    v2 -= v10;
    if ( !v2 )
    {
      v3[2] = v6;
      return v5 <= v8;
    }
  }
  v3[2] = v6;
  v12 = a1[1];
  if ( v12 )
    sub_4131C0(v12);
  a1[1] = (__int64)&off_448D10;
  return v5 <= v8;
}
// 448D10: using guessed type char *off_448D10;

//----- (0000000000435C10) ----------------------------------------------------
char __fastcall sub_435C10(__int64 a1, _QWORD *a2)
{
  return sub_406180(a1, (__int64)&off_4481A8, a2);
}
// 4481A8: using guessed type __int64 (__fastcall *off_4481A8)();

//----- (0000000000435C30) ----------------------------------------------------
__int64 __fastcall sub_435C30(DWORD a1, unsigned __int8 *a2, unsigned __int64 a3, unsigned __int8 *a4)
{
  HANDLE StdHandle; // rsi
  __int64 result; // rax
  ULONG Length; // eax
  int v10; // eax
  __int64 v11; // rax
  unsigned __int8 v12; // al
  unsigned __int64 v13; // rdi
  unsigned __int64 v14; // r8
  __int128 v15; // kr00_16
  __int64 v16; // rdx
  __int64 v17; // rax
  unsigned __int64 v18; // [rsp+50h] [rbp-30h] BYREF
  __int64 v19; // [rsp+58h] [rbp-28h] BYREF
  __int128 v20; // [rsp+60h] [rbp-20h] BYREF
  DWORD Mode[2]; // [rsp+70h] [rbp-10h] BYREF
  __int128 v22; // [rsp+78h] [rbp-8h]
  __int128 v23; // [rsp+88h] [rbp+8h]
  _BYTE IoStatusBlock[24]; // [rsp+A0h] [rbp+20h] BYREF
  _QWORD v25[5]; // [rsp+B8h] [rbp+38h] BYREF

  if ( !a3 )
    return 0LL;
  StdHandle = GetStdHandle(a1);
  result = 1LL;
  if ( StdHandle )
  {
    if ( StdHandle == (HANDLE)-1LL )
    {
      GetLastError();
      return 1LL;
    }
    Mode[0] = 0;
    if ( !GetConsoleMode(StdHandle, Mode) || GetConsoleOutputCP() == 65001 )
    {
      *(_OWORD *)IoStatusBlock = xmmword_449A60;
      Length = -1;
      if ( a3 < 0xFFFFFFFF )
        Length = a3;
      v10 = NtWriteFile(StdHandle, 0LL, 0LL, 0LL, (PIO_STATUS_BLOCK)IoStatusBlock, a2, Length, 0LL, 0LL);
      if ( v10 == 259 )
      {
        WaitForSingleObject(StdHandle, 0xFFFFFFFF);
        v10 = *(_DWORD *)IoStatusBlock;
        if ( *(_DWORD *)IoStatusBlock == 259 )
        {
          LODWORD(v25[0]) = 0;
          BYTE4(v25[0]) = 0;
          *(_QWORD *)Mode = &off_449AC8;
          *(_QWORD *)&v22 = 1LL;
          *((_QWORD *)&v22 + 1) = &v19;
          v23 = 0LL;
          *(_QWORD *)&v20 = sub_412270((__int64)v25, Mode);
          sub_4123A0((__int64 *)&v20);
          __fastfail(7u);
        }
      }
      if ( v10 >= 0 )
        return 0LL;
      RtlNtStatusToDosError(v10);
      return 1LL;
    }
    v11 = a4[4];
    if ( a4[4] )
    {
      if ( (unsigned __int8)v11 >= 4u )
      {
        *(_QWORD *)Mode = &off_449DE0;
        *(_QWORD *)&v22 = 1LL;
        *((_QWORD *)&v22 + 1) = 8LL;
        v23 = 0LL;
        sub_405240(Mode, &off_449DF0);
      }
      if ( __OFSUB__(-(*a2 & 0xC0), 1) )
      {
        a4[v11] = *a2;
        v12 = a4[4] + 1;
        a4[4] = v12;
        v13 = byte_449C04[*a4];
        v18 = v13;
        if ( v12 < (unsigned __int8)v13 )
          return 0LL;
        if ( v12 >= 5u )
          sub_405B00(v12, 4LL, (__int64)&off_449E08);
        sub_406850((__int64)IoStatusBlock, (__int64)a4, v12);
        a4[4] = 0;
        if ( (IoStatusBlock[0] & 1) == 0 )
        {
          v19 = *(_QWORD *)&IoStatusBlock[16];
          if ( *(_QWORD *)&IoStatusBlock[16] != v13 )
          {
            *(_QWORD *)Mode = 0LL;
            sub_407286((__int64)&v18, (__int64)&v19, (__int128 *)Mode, (__int64)&off_449E20);
          }
          result = sub_435FE0(StdHandle, *(CHAR **)&IoStatusBlock[8], v13);
          if ( !result )
          {
            v25[0] = v16;
            *(_QWORD *)&v20 = v13;
            if ( v13 != v16 )
            {
              *(_QWORD *)Mode = 0LL;
              sub_407286((__int64)v25, (__int64)&v20, (__int128 *)Mode, (__int64)&off_449E38);
            }
          }
          return result;
        }
      }
      else
      {
        a4[4] = 0;
      }
      return 1LL;
    }
    v14 = 4096LL;
    if ( a3 < 0x1000 )
      v14 = a3;
    sub_406850((__int64)IoStatusBlock, (__int64)a2, v14);
    if ( (IoStatusBlock[0] & 1) != 0 )
    {
      if ( !*(_QWORD *)&IoStatusBlock[8] )
      {
        v17 = *a2;
        if ( byte_449C04[v17] > a3 )
        {
          *a4 = v17;
          a4[4] = 1;
          return 0LL;
        }
        return 1LL;
      }
      if ( *(_QWORD *)&IoStatusBlock[8] > a3 )
        sub_405B00(*(__int64 *)&IoStatusBlock[8], a3, (__int64)&off_449D70);
      sub_406850((__int64)Mode, (__int64)a2, *(unsigned __int64 *)&IoStatusBlock[8]);
      if ( Mode[0] == 1 )
      {
        v20 = v22;
        sub_406F40((__int64)aCalledResultUn, 43LL, (__int64)&v20, (__int64)&unk_447AE0, (__int64)&off_449D88);
      }
      v15 = v22;
    }
    else
    {
      v15 = *(_OWORD *)&IoStatusBlock[8];
    }
    return sub_435FE0(StdHandle, (CHAR *)v15, *((unsigned __int64 *)&v15 + 1));
  }
  return result;
}
// 435E67: variable 'v16' is possibly undefined
// 405240: using guessed type void __fastcall __noreturn sub_405240(_QWORD, _QWORD);
// 449A60: using guessed type __int128 xmmword_449A60;
// 449AC8: using guessed type char *off_449AC8;
// 449C04: using guessed type unsigned __int8 byte_449C04[256];
// 449D70: using guessed type char *off_449D70;
// 449D88: using guessed type char *off_449D88;
// 449DE0: using guessed type char *off_449DE0;
// 449DF0: using guessed type char *off_449DF0;
// 449E08: using guessed type char *off_449E08;
// 449E20: using guessed type char *off_449E20;
// 449E38: using guessed type char *off_449E38;

//----- (0000000000435FE0) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
__int64 __fastcall sub_435FE0(void *a1, CHAR *a2, unsigned __int64 a3)
{
  int v3; // esi
  __int64 v5; // rax
  unsigned __int64 v6; // r9
  signed int v7; // eax
  unsigned __int64 v8; // r14
  unsigned __int64 v9; // rdi
  WCHAR *v10; // rdx
  __int64 v11; // rdi
  unsigned __int64 v12; // rax
  __int64 v13; // rsi
  unsigned int v14; // ecx
  __int64 v15; // rdx
  WCHAR WideCharStr[4096]; // [rsp+30h] [rbp-50h] BYREF
  DWORD NumberOfCharsWritten[2]; // [rsp+2030h] [rbp+1FB0h] BYREF
  __int64 v19; // [rsp+2038h] [rbp+1FB8h]
  __int64 v20; // [rsp+2040h] [rbp+1FC0h]
  __int128 v21; // [rsp+2048h] [rbp+1FC8h]

  v3 = a3;
  if ( a3 >= 0x1001 )
  {
    v5 = 4096LL;
    do
      v6 = v5--;
    while ( a2[v6] < -64 );
    if ( v6 < a3 )
    {
      if ( a2[v6] > -65 )
      {
        v3 = v6;
        goto LABEL_8;
      }
LABEL_28:
      sub_4079A0(a2, a3, 0LL, v6, (__int64)&off_449E50);
    }
    if ( v6 != a3 )
      goto LABEL_28;
  }
LABEL_8:
  v7 = MultiByteToWideChar(0xFDE9u, 8u, a2, v3, WideCharStr, 4096);
  if ( !v7 )
  {
    *(_QWORD *)NumberOfCharsWritten = &off_449E90;
    v19 = 1LL;
    v20 = 8LL;
    v21 = 0LL;
    sub_405240(NumberOfCharsWritten, &off_449EA0);
  }
  v8 = v7;
  if ( (unsigned int)v7 >= 0x1001 )
    sub_405B00(v7, 4096LL, (__int64)&off_449EB8);
  NumberOfCharsWritten[0] = 0;
  if ( WriteConsoleW(a1, WideCharStr, v7, NumberOfCharsWritten, 0LL) )
  {
    v9 = NumberOfCharsWritten[0];
    if ( v8 != NumberOfCharsWritten[0] )
    {
      if ( v8 <= NumberOfCharsWritten[0] )
        ((void (__fastcall __noreturn *)(_QWORD, unsigned __int64, char **))sub_4050B0)(
          NumberOfCharsWritten[0],
          v8,
          &off_449ED0);
      if ( (unsigned __int16)(WideCharStr[NumberOfCharsWritten[0]] + 8978) < 0x312u )
      {
        v10 = &WideCharStr[NumberOfCharsWritten[0]];
        v9 = NumberOfCharsWritten[0] + 1LL;
        NumberOfCharsWritten[0] = 0;
        if ( !WriteConsoleW(a1, v10, 1u, NumberOfCharsWritten, 0LL) )
          GetLastError();
      }
      if ( v9 > v8 )
        sub_405B00(v9, v8, (__int64)&off_449EE8);
      if ( v9 )
      {
        v11 = 2 * v9;
        v12 = 0LL;
        v13 = 0LL;
        do
        {
          v14 = WideCharStr[v12 / 2];
          v15 = 1LL;
          if ( v14 >= 0x80 )
          {
            v15 = 2LL;
            if ( (unsigned __int16)v14 >= 0x800u )
              v15 = 2LL * ((unsigned __int16)(v14 + 8978) >= 0x312u) + 1;
          }
          v13 += v15;
          v12 += 2LL;
        }
        while ( v11 != v12 );
      }
    }
    return 0LL;
  }
  else
  {
    GetLastError();
    return 1LL;
  }
}
// 4361B8: positive sp value 2060 has been found
// 4050B0: using guessed type void __fastcall __noreturn sub_4050B0();
// 405240: using guessed type void __fastcall __noreturn sub_405240(_QWORD, _QWORD);
// 449E50: using guessed type char *off_449E50;
// 449E90: using guessed type char *off_449E90;
// 449EA0: using guessed type char *off_449EA0;
// 449EB8: using guessed type char *off_449EB8;
// 449ED0: using guessed type char *off_449ED0;
// 449EE8: using guessed type char *off_449EE8;

//----- (0000000000436250) ----------------------------------------------------
char __fastcall sub_436250(__int64 a1, __int64 a2)
{
  char v4; // al
  char v5; // al
  char *v6; // rdx
  __int64 v7; // r8
  __int64 v9; // [rsp+28h] [rbp-18h] BYREF
  __int64 v10; // [rsp+30h] [rbp-10h] BYREF
  char v11; // [rsp+38h] [rbp-8h]
  char v12; // [rsp+39h] [rbp-7h]

  v9 = a1 + 8;
  v4 = (*(__int64 (__fastcall **)(_QWORD, const char *, __int64))(*(_QWORD *)(a2 + 56) + 24LL))(
         *(_QWORD *)(a2 + 48),
         aUtf8error,
         9LL);
  v10 = a2;
  v11 = v4;
  v12 = 0;
  sub_406A60(&v10, (__int64)aValidUpTo, 0xBuLL, a1, (unsigned __int8 (__fastcall *)(__int64, _OWORD *))sub_436640);
  sub_406A60(
    &v10,
    (__int64)aErrorLen,
    9uLL,
    (__int64)&v9,
    (unsigned __int8 (__fastcall *)(__int64, _OWORD *))sub_436340);
  if ( v11 & 1 | ((v12 & 1) == 0) )
  {
    v5 = v11 | v12;
  }
  else
  {
    if ( (*(_BYTE *)(v10 + 36) & 4) != 0 )
    {
      v6 = "}";
      v7 = 1LL;
    }
    else
    {
      v6 = asc_447561;
      v7 = 2LL;
    }
    v5 = (*(__int64 (__fastcall **)(_QWORD, char *, __int64))(*(_QWORD *)(v10 + 56) + 24LL))(
           *(_QWORD *)(v10 + 48),
           v6,
           v7);
  }
  return v5 & 1;
}

//----- (0000000000436340) ----------------------------------------------------
__int64 __fastcall sub_436340(_QWORD *a1, __int64 a2)
{
  unsigned int v2; // ebx
  _BYTE *v4; // r14
  __int64 v5; // rsi
  __int64 v6; // r12
  unsigned __int8 (__fastcall *v7)(__int64, const char *, __int64); // r15
  unsigned __int8 *v9; // r14
  __int128 v11; // xmm1
  __int128 v12; // xmm2
  _OWORD v13[3]; // [rsp+20h] [rbp-60h] BYREF
  _QWORD *v14; // [rsp+50h] [rbp-30h]
  unsigned __int8 (__fastcall **v15)(_QWORD *, const char *, __int64); // [rsp+58h] [rbp-28h]
  _QWORD v16[3]; // [rsp+60h] [rbp-20h] BYREF
  char v17; // [rsp+7Fh] [rbp-1h] BYREF

  v4 = (_BYTE *)*a1;
  if ( *(_BYTE *)*a1 )
  {
    v5 = *(_QWORD *)(a2 + 48);
    v6 = *(_QWORD *)(a2 + 56);
    v7 = *(unsigned __int8 (__fastcall **)(__int64, const char *, __int64))(v6 + 24);
    LOBYTE(v2) = 1;
    if ( !v7(v5, aSome, 4LL) )
    {
      v9 = v4 + 1;
      if ( (*(_BYTE *)(a2 + 36) & 4) != 0 )
      {
        if ( v7(v5, asc_4428D9, 2LL) )
          return v2;
        v17 = 1;
        v16[0] = v5;
        v16[1] = v6;
        v16[2] = &v17;
        v11 = *(_OWORD *)(a2 + 16);
        v12 = *(_OWORD *)(a2 + 32);
        v13[0] = *(_OWORD *)a2;
        v13[1] = v11;
        v13[2] = v12;
        v14 = v16;
        v15 = (unsigned __int8 (__fastcall **)(_QWORD *, const char *, __int64))&unk_4428A0;
        if ( (unsigned __int8)sub_4364C0(v9, (__int64)v13) || v15[3](v14, asc_4428D7, 2LL) )
          return v2;
        return ((unsigned int (__fastcall *)(__int64, const char *, __int64))v7)(v5, asc_448BDD, 1LL);
      }
      else
      {
        if ( v7(v5, "(><&@", 1LL) || (unsigned __int8)sub_4364C0(v9, a2) )
          return v2;
        return (unsigned int)(*(__int64 (__fastcall **)(_QWORD, const char *, __int64))(*(_QWORD *)(a2 + 56) + 24LL))(
                               *(_QWORD *)(a2 + 48),
                               asc_448BDD,
                               1LL);
      }
    }
    return v2;
  }
  return (*(__int64 (__fastcall **)(_QWORD, const char *, __int64))(*(_QWORD *)(a2 + 56) + 24LL))(
           *(_QWORD *)(a2 + 48),
           aNone,
           4LL);
}
// 43638B: variable 'v2' is possibly undefined
// 448BDD: using guessed type char asc_448BDD;

//----- (00000000004364C0) ----------------------------------------------------
__int64 __fastcall sub_4364C0(unsigned __int8 *a1, __int64 a2)
{
  int v2; // eax
  unsigned __int64 v3; // rax
  __int64 v4; // rcx
  unsigned __int8 v5; // al
  __int64 v6; // r9
  unsigned __int8 v7; // r8
  __int64 v8; // rcx
  char v9; // r10
  bool v10; // cc
  unsigned __int8 v11; // al
  unsigned __int8 v12; // r8
  char v13; // r10
  _BYTE v15[3]; // [rsp+2Eh] [rbp-52h] BYREF
  __int16 v16; // [rsp+31h] [rbp-4Fh]

  v2 = *(_DWORD *)(a2 + 36);
  if ( (v2 & 0x10) != 0 )
  {
    v5 = *a1;
    v6 = 129LL;
    v7 = *a1;
    do
    {
      v8 = v6;
      v7 >>= 4;
      v9 = (v5 & 0xF) + 87;
      if ( (v5 & 0xFu) < 0xA )
        v9 = (v5 & 0xF) + 48;
      v15[v6--] = v9;
      v10 = v5 <= 0xFu;
      v5 = v7;
    }
    while ( !v10 );
    return sub_405270(a2, 1, (__int64)a0x, 2LL, (__int64)&v15[v8], 129 - v6);
  }
  if ( (v2 & 0x20) != 0 )
  {
    v11 = *a1;
    v6 = 129LL;
    v12 = *a1;
    do
    {
      v8 = v6;
      v12 >>= 4;
      v13 = (v11 & 0xF) + 55;
      if ( (v11 & 0xFu) < 0xA )
        v13 = (v11 & 0xF) + 48;
      v15[v6--] = v13;
      v10 = v11 <= 0xFu;
      v11 = v12;
    }
    while ( !v10 );
    return sub_405270(a2, 1, (__int64)a0x, 2LL, (__int64)&v15[v8], 129 - v6);
  }
  v3 = *a1;
  if ( v3 < 0x64 )
  {
    v4 = 2LL;
    if ( (unsigned __int8)v3 >= 0xAu )
    {
      v16 = a0001020304[v3];
      v4 = 1LL;
      return sub_405270(a2, 1, 1LL, 0LL, (__int64)&v15[v4 + 2], v4 ^ 3);
    }
  }
  else
  {
    v16 = a0001020304[(unsigned __int8)v3 % 0x64u];
    v4 = 0LL;
    LOBYTE(v3) = (unsigned __int8)v3 / 0x64u;
  }
  v15[v4 + 2] = v3 | 0x30;
  return sub_405270(a2, 1, 1LL, 0LL, (__int64)&v15[v4 + 2], v4 ^ 3);
}
// 4428DB: using guessed type _WORD a0001020304[100];

//----- (0000000000436640) ----------------------------------------------------
__int64 __fastcall sub_436640(unsigned __int64 *a1, __int64 a2)
{
  int v3; // eax
  unsigned __int64 v4; // rcx
  __int64 v5; // rax
  __int64 v6; // r11
  unsigned __int64 v7; // rdx
  int v8; // esi
  bool v9; // cc
  __int64 v10; // rax
  unsigned __int64 v11; // rax
  __int64 v12; // r8
  unsigned __int64 v13; // rdx
  __int64 v14; // rcx
  char v15; // r9
  unsigned __int64 v16; // rax
  unsigned __int64 v17; // rdx
  char v18; // r9
  _WORD v20[74]; // [rsp+2Ch] [rbp-54h] BYREF

  v3 = *(_DWORD *)(a2 + 36);
  if ( (v3 & 0x10) != 0 )
  {
    v11 = *a1;
    v12 = 129LL;
    v13 = *a1;
    do
    {
      v14 = v12;
      v13 >>= 4;
      v15 = (v11 & 0xF) + 87;
      if ( (v11 & 0xF) < 0xA )
        v15 = (v11 & 0xF) + 48;
      *((_BYTE *)&v20[1] + v12--) = v15;
      v9 = v11 <= 0xF;
      v11 = v13;
    }
    while ( !v9 );
    return sub_405270(a2, 1, (__int64)a0x, 2LL, (__int64)&v20[1] + v14, 129 - v12);
  }
  if ( (v3 & 0x20) != 0 )
  {
    v16 = *a1;
    v12 = 129LL;
    v17 = *a1;
    do
    {
      v14 = v12;
      v17 >>= 4;
      v18 = (v16 & 0xF) + 55;
      if ( (v16 & 0xF) < 0xA )
        v18 = (v16 & 0xF) + 48;
      *((_BYTE *)&v20[1] + v12--) = v18;
      v9 = v16 <= 0xF;
      v16 = v17;
    }
    while ( !v9 );
    return sub_405270(a2, 1, (__int64)a0x, 2LL, (__int64)&v20[1] + v14, 129 - v12);
  }
  v4 = *a1;
  v5 = 20LL;
  if ( v4 < 0x2710 )
  {
    v7 = v4;
    if ( v4 <= 0x63 )
      goto LABEL_8;
    goto LABEL_7;
  }
  v6 = 10LL;
  do
  {
    v7 = v4 / 0x2710;
    v8 = v4 % 0x2710;
    v5 = v6 * 2 - 4;
    v20[v6] = a0001020304[(unsigned int)(5243 * v8) >> 19];
    v20[v6 + 1] = a0001020304[(unsigned __int16)(v8 - 100 * ((unsigned __int16)((unsigned int)(5243 * v8) >> 16) >> 3))];
    v6 -= 2LL;
    v9 = v4 <= 0x5F5E0FF;
    v4 /= 0x2710uLL;
  }
  while ( !v9 );
  if ( v7 > 0x63 )
  {
LABEL_7:
    *(_WORD *)((char *)&v20[1] + v5) = a0001020304[(unsigned __int16)v7 % 0x64u];
    v5 -= 2LL;
    v7 = (unsigned int)(5243 * ((unsigned __int16)v7 >> 2)) >> 17;
  }
LABEL_8:
  if ( v7 >= 0xA )
  {
    *(_WORD *)((char *)&v20[1] + v5) = a0001020304[v7];
    v10 = v5 - 2;
  }
  else
  {
    *((_BYTE *)&v20[1] + v5 + 1) = v7 | 0x30;
    v10 = v5 - 1;
  }
  return sub_405270(a2, 1, 1LL, 0LL, (__int64)&v20[2] + v10, 20 - v10);
}
// 4428DB: using guessed type _WORD a0001020304[100];

//----- (0000000000436870) ----------------------------------------------------
void __fastcall sub_436870(volatile signed __int32 *Address, signed __int32 a2)
{
  signed __int32 v2; // eax
  volatile signed __int32 *v3; // rsi

  if ( (a2 & 0x3FFFFFFF) != 0 )
    sub_405FC0((__int64)aAssertionFaile_1, 36LL, (__int64)&off_44A230);
  if ( __OFSUB__(-a2, 1) )
  {
    v2 = _InterlockedCompareExchange(Address, 0, 0x80000000);
    if ( v2 == 0x80000000 )
    {
      _InterlockedIncrement(Address + 1);
      WakeByAddressSingle((PVOID)(Address + 1));
      return;
    }
    a2 = v2;
  }
  if ( a2 != -1073741824 )
  {
    if ( a2 != 0x40000000 || _InterlockedCompareExchange(Address, 0, 0x40000000) != 0x40000000 )
      return;
LABEL_12:
    WakeByAddressAll((PVOID)Address);
    return;
  }
  if ( _InterlockedCompareExchange(Address, 0x40000000, -1073741824) == -1073741824 )
  {
    _InterlockedIncrement(Address + 1);
    v3 = Address;
    WakeByAddressSingle((PVOID)(Address + 1));
    Address = v3;
    if ( _InterlockedCompareExchange(v3, 0, 0x40000000) == 0x40000000 )
      goto LABEL_12;
  }
}
// 44A230: using guessed type char *off_44A230;

//----- (0000000000436930) ----------------------------------------------------
bool __fastcall sub_436930(__int64 a1, unsigned __int8 *a2, unsigned __int64 a3)
{
  char **v4; // rdi
  __int64 v5; // rcx

  v4 = sub_412EF0(*(unsigned __int8 **)a1, a2, a3);
  if ( v4 )
  {
    v5 = *(_QWORD *)(a1 + 8);
    if ( v5 )
      sub_4131C0(v5);
    *(_QWORD *)(a1 + 8) = v4;
  }
  return v4 != 0LL;
}

//----- (0000000000436980) ----------------------------------------------------
bool __fastcall sub_436980(__int64 a1, unsigned int a2)
{
  unsigned __int64 v3; // r8
  char **v4; // rdi
  __int64 v5; // rcx
  unsigned __int8 v7[20]; // [rsp+2Ch] [rbp-4h] BYREF

  *(_DWORD *)v7 = 0;
  if ( a2 >= 0x80 )
  {
    if ( a2 >= 0x800 )
    {
      if ( a2 >= 0x10000 )
      {
        v7[0] = (a2 >> 18) | 0xF0;
        v7[1] = (a2 >> 12) & 0x3F | 0x80;
        v7[2] = (a2 >> 6) & 0x3F | 0x80;
        v7[3] = a2 & 0x3F | 0x80;
        v3 = 4LL;
      }
      else
      {
        v7[0] = (a2 >> 12) | 0xE0;
        v7[1] = (a2 >> 6) & 0x3F | 0x80;
        v7[2] = a2 & 0x3F | 0x80;
        v3 = 3LL;
      }
    }
    else
    {
      v7[0] = (a2 >> 6) | 0xC0;
      v7[1] = a2 & 0x3F | 0x80;
      v3 = 2LL;
    }
  }
  else
  {
    v7[0] = a2;
    v3 = 1LL;
  }
  v4 = sub_412EF0(*(unsigned __int8 **)a1, v7, v3);
  if ( v4 )
  {
    v5 = *(_QWORD *)(a1 + 8);
    if ( v5 )
      sub_4131C0(v5);
    *(_QWORD *)(a1 + 8) = v4;
  }
  return v4 != 0LL;
}

//----- (0000000000436A70) ----------------------------------------------------
char __fastcall sub_436A70(__int64 a1, _QWORD *a2)
{
  return sub_406180(a1, (__int64)&off_448208, a2);
}
// 448208: using guessed type __int64 (__fastcall *off_448208)();

//----- (0000000000436A90) ----------------------------------------------------
__int64 __fastcall sub_436A90(_QWORD *a1, __int64 a2)
{
  if ( !*a1 )
    __fastfail(7u);
  return (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a2 + 56) + 24LL))(
           *(_QWORD *)(a2 + 48),
           *a1,
           a1[1]);
}

//----- (0000000000436AC0) ----------------------------------------------------
_QWORD *__fastcall sub_436AC0(__int64 *a1)
{
  __int64 v1; // rsi
  __int64 v2; // rdi
  _QWORD *result; // rax

  v1 = *a1;
  v2 = a1[1];
  *a1 = 0LL;
  if ( !v1 )
    __fastfail(7u);
  result = sub_43C4F0(0x10uLL);
  if ( !result )
    sub_4040E9(8LL, 16LL);
  *result = v1;
  result[1] = v2;
  return result;
}

//----- (0000000000436B30) ----------------------------------------------------
_QWORD *__fastcall sub_436B30(_QWORD *a1)
{
  if ( !*a1 )
    __fastfail(7u);
  return a1;
}

//----- (0000000000436B50) ----------------------------------------------------
__int64 sub_436B50()
{
  return 0LL;
}

//----- (0000000000436B60) ----------------------------------------------------
unsigned __int64 sub_436B60()
{
  return 0xB98B1B7157A64178uLL;
}

//----- (0000000000436B80) ----------------------------------------------------
__int64 __fastcall sub_436B80(int a1, int a2, __int64 a3, __int64 a4, __int64 a5)
{
  unsigned int v5; // r14d
  unsigned __int8 *v6; // rsi
  __int64 v7; // rax
  unsigned __int64 v8; // r12
  unsigned int v9; // edi
  char *v10; // r15
  __int64 v11; // r10
  __int64 (__fastcall **v12)(__int64 **); // rax
  __int64 **v13; // rcx
  _QWORD *v14; // r10
  __int64 v15; // rax
  unsigned __int8 *v16; // rsi
  __int64 v17; // rax
  unsigned int v18; // ecx
  char v19; // dl
  unsigned __int64 v20; // r8
  __int64 v21; // r8
  __int64 v22; // rcx
  char v23; // dl
  unsigned __int64 v24; // r8
  char *v25; // rax
  bool v26; // zf
  _BYTE *v27; // rdx
  unsigned __int8 v29; // al
  char *v30; // rdx
  __int64 v31; // r8
  __int64 v32; // rcx
  char *v33; // r9
  char v34; // r10
  unsigned __int64 v35; // r11
  unsigned __int64 v36; // r9
  __int64 v37; // r8
  __int64 v38; // r15
  __int64 v39; // rdi
  __int64 v40; // rsi
  __int64 v41; // rcx
  char v42; // si
  unsigned __int64 v43; // rdi
  __int64 v44; // r15
  unsigned int v45; // ecx
  char v46; // si
  unsigned __int64 v47; // rdi
  __int64 v48; // rdi
  __int64 v49; // rcx
  char v50; // si
  unsigned __int64 v51; // rbx
  __int64 v52; // rbx
  __int64 v53; // rcx
  char v54; // r13
  unsigned __int64 v55; // r11
  unsigned __int64 v56; // r15
  __int64 v57; // rdi
  unsigned int v58; // ecx
  char v59; // si
  unsigned __int64 v60; // rbx
  __int64 v61; // rbx
  __int64 v62; // rcx
  char v63; // r11
  unsigned __int64 v64; // rbx
  __int64 v65; // rsi
  unsigned int v66; // ecx
  char v67; // r11
  unsigned __int64 v68; // rbx
  __int64 v69; // rbx
  char v70; // dl
  __int128 v71; // rax
  unsigned int v72; // ecx
  char v73; // r8
  unsigned __int64 v74; // r9
  __int64 *v76; // [rsp+28h] [rbp-38h] BYREF
  __int64 *v77; // [rsp+30h] [rbp-30h] BYREF
  __int64 v78; // [rsp+38h] [rbp-28h] BYREF
  __int64 v79; // [rsp+40h] [rbp-20h]
  int v80; // [rsp+4Ch] [rbp-14h]
  __int64 v81; // [rsp+50h] [rbp-10h]
  _QWORD *v82; // [rsp+58h] [rbp-8h]
  int v83[15]; // [rsp+64h] [rbp+4h] BYREF

  v5 = 3;
  if ( a1 == 1 )
  {
    v80 = a2;
    v79 = a4;
    v78 = a5;
    v6 = (unsigned __int8 *)sub_43CF60(a5);
    v83[0] = 0;
    v7 = sub_43CF40(a5, v83);
    v8 = v7 - (v83[0] == 0);
    v81 = sub_43CF70(a5);
    v77 = &v78;
    v76 = &v78;
    if ( v6 )
    {
      v9 = *v6;
      v10 = (char *)(v6 + 1);
      if ( v9 == 255 )
      {
        v14 = (_QWORD *)v81;
      }
      else
      {
        v11 = (__int64)(v6 + 1);
        switch ( (v9 >> 4) & 7 )
        {
          case 0u:
            goto LABEL_14;
          case 1u:
            goto LABEL_11;
          case 2u:
            v12 = (__int64 (__fastcall **)(__int64 **))&unk_44A050;
            v13 = &v77;
            goto LABEL_10;
          case 3u:
            v12 = (__int64 (__fastcall **)(__int64 **))&unk_44A080;
            v13 = &v76;
LABEL_10:
            v11 = v12[5](v13);
            if ( v11 )
              goto LABEL_11;
            goto LABEL_14;
          case 4u:
            v11 = v81;
            if ( !v81 )
              return v5;
LABEL_11:
            switch ( v9 & 0xF )
            {
              case 0u:
              case 4u:
              case 0xCu:
                v15 = *(_QWORD *)(v6 + 1);
                v16 = v6 + 9;
                goto LABEL_31;
              case 1u:
                v15 = 0LL;
                v22 = 0LL;
                do
                {
                  v23 = *v10;
                  v24 = (unsigned __int64)(*v10++ & 0x7F) << v22;
                  v15 |= v24;
                  v22 += 7LL;
                }
                while ( v23 < 0 );
                goto LABEL_32;
              case 2u:
                v15 = *(unsigned __int16 *)(v6 + 1);
                v16 = v6 + 3;
                goto LABEL_31;
              case 3u:
                v15 = *(unsigned int *)(v6 + 1);
                goto LABEL_30;
              case 9u:
                v17 = 0LL;
                v18 = 0;
                do
                {
                  v19 = *v10;
                  v20 = (unsigned __int64)(*v10++ & 0x7F) << v18;
                  v17 |= v20;
                  v18 += 7;
                }
                while ( v19 < 0 );
                v21 = -1LL << v18;
                if ( (unsigned __int8)v19 < 0x40u )
                  v21 = 0LL;
                if ( v18 >= 0x40 )
                  v21 = 0LL;
                v15 = v21 | v17;
                goto LABEL_32;
              case 0xAu:
                v15 = *(__int16 *)(v6 + 1);
                v16 = v6 + 3;
                goto LABEL_31;
              case 0xBu:
                v15 = *(int *)(v6 + 1);
LABEL_30:
                v16 = v6 + 5;
LABEL_31:
                v10 = (char *)v16;
LABEL_32:
                v14 = (_QWORD *)(v15 + v11);
                goto LABEL_33;
              default:
                return v5;
            }
          case 5u:
            v10 = (char *)((unsigned __int64)(v6 + 8) & 0xFFFFFFFFFFFFFFF8uLL);
LABEL_14:
            if ( (v9 & 0xF) != 0 )
              return v5;
            v14 = *(_QWORD **)v10;
            v10 += 8;
LABEL_33:
            if ( (v9 & 0x80u) != 0 )
              v14 = (_QWORD *)*v14;
            break;
          default:
            return v5;
        }
      }
      v25 = v10 + 1;
      v26 = *v10 == -1;
      v82 = v14;
      if ( v26 )
      {
        v27 = v10 + 1;
      }
      else
      {
        do
          v27 = v25 + 1;
        while ( *v25++ < 0 );
      }
      v29 = *v27;
      v30 = v27 + 1;
      v31 = 0LL;
      v32 = 0LL;
      do
      {
        v33 = v30;
        v34 = *v30;
        v35 = (unsigned __int64)(*v30++ & 0x7F) << v32;
        v31 |= v35;
        v32 += 7LL;
      }
      while ( v34 < 0 );
      if ( v29 > 0xFu )
      {
        if ( v31 > 0 )
          return v5;
        v37 = 4LL;
      }
      else
      {
        v36 = (unsigned __int64)&v33[v31 + 1];
        v37 = 4LL;
        while ( 2 )
        {
          if ( (unsigned __int64)v30 < v36 )
          {
            switch ( v29 )
            {
              case 0u:
              case 4u:
              case 0xCu:
                v38 = *(_QWORD *)v30;
                v30 += 8;
LABEL_46:
                v39 = *(_QWORD *)v30;
                v30 += 8;
LABEL_47:
                v40 = *(_QWORD *)v30;
                v30 += 8;
                goto LABEL_75;
              case 1u:
                v38 = 0LL;
                v41 = 0LL;
                do
                {
                  v42 = *v30;
                  v43 = (unsigned __int64)(*v30++ & 0x7F) << v41;
                  v38 |= v43;
                  v41 += 7LL;
                }
                while ( v42 < 0 );
                goto LABEL_64;
              case 2u:
                v38 = *(unsigned __int16 *)v30;
                v30 += 2;
LABEL_69:
                v39 = *(unsigned __int16 *)v30;
                v30 += 2;
LABEL_70:
                v40 = *(unsigned __int16 *)v30;
                goto LABEL_74;
              case 3u:
                v38 = *(unsigned int *)v30;
                v30 += 4;
LABEL_49:
                v39 = *(unsigned int *)v30;
                v30 += 4;
LABEL_50:
                v40 = *(unsigned int *)v30;
                v30 += 4;
                goto LABEL_75;
              case 9u:
                v44 = 0LL;
                v45 = 0;
                do
                {
                  v46 = *v30;
                  v47 = (unsigned __int64)(*v30++ & 0x7F) << v45;
                  v44 |= v47;
                  v45 += 7;
                }
                while ( v46 < 0 );
                v48 = -1LL << v45;
                if ( (unsigned __int8)v46 < 0x40u )
                  v48 = 0LL;
                if ( v45 >= 0x40 )
                  v48 = 0LL;
                v38 = v48 | v44;
LABEL_64:
                switch ( v29 )
                {
                  case 0u:
                  case 4u:
                  case 0xCu:
                    goto LABEL_46;
                  case 1u:
                    v39 = 0LL;
                    v49 = 0LL;
                    do
                    {
                      v50 = *v30;
                      v51 = (unsigned __int64)(*v30++ & 0x7F) << v49;
                      v39 |= v51;
                      v49 += 7LL;
                    }
                    while ( v50 < 0 );
                    goto LABEL_87;
                  case 2u:
                    goto LABEL_69;
                  case 3u:
                    goto LABEL_49;
                  case 9u:
                    v57 = 0LL;
                    v58 = 0;
                    do
                    {
                      v59 = *v30;
                      v60 = (unsigned __int64)(*v30++ & 0x7F) << v58;
                      v57 |= v60;
                      v58 += 7;
                    }
                    while ( v59 < 0 );
                    v61 = -1LL << v58;
                    if ( (unsigned __int8)v59 < 0x40u )
                      v61 = 0LL;
                    if ( v58 >= 0x40 )
                      v61 = 0LL;
                    v39 = v61 | v57;
LABEL_87:
                    switch ( v29 )
                    {
                      case 0u:
                      case 4u:
                      case 0xCu:
                        goto LABEL_47;
                      case 1u:
                        v40 = 0LL;
                        v62 = 0LL;
                        do
                        {
                          v63 = *v30;
                          v64 = (unsigned __int64)(*v30++ & 0x7F) << v62;
                          v40 |= v64;
                          v62 += 7LL;
                        }
                        while ( v63 < 0 );
                        goto LABEL_75;
                      case 2u:
                        goto LABEL_70;
                      case 3u:
                        goto LABEL_50;
                      case 9u:
                        v65 = 0LL;
                        v66 = 0;
                        do
                        {
                          v67 = *v30;
                          v68 = (unsigned __int64)(*v30++ & 0x7F) << v66;
                          v65 |= v68;
                          v66 += 7;
                        }
                        while ( v67 < 0 );
                        v69 = -1LL << v66;
                        if ( (unsigned __int8)v67 < 0x40u )
                          v69 = 0LL;
                        if ( v66 >= 0x40 )
                          v69 = 0LL;
                        v40 = v69 | v65;
                        goto LABEL_75;
                      case 0xAu:
                        goto LABEL_73;
                      case 0xBu:
                        goto LABEL_56;
                      default:
                        return v5;
                    }
                  case 0xAu:
                    goto LABEL_72;
                  case 0xBu:
                    goto LABEL_55;
                  default:
                    return v5;
                }
                return v5;
              case 0xAu:
                v38 = *(__int16 *)v30;
                v30 += 2;
LABEL_72:
                v39 = *(__int16 *)v30;
                v30 += 2;
LABEL_73:
                v40 = *(__int16 *)v30;
LABEL_74:
                v30 += 2;
                goto LABEL_75;
              case 0xBu:
                v38 = *(int *)v30;
                v30 += 4;
LABEL_55:
                v39 = *(int *)v30;
                v30 += 4;
LABEL_56:
                v40 = *(int *)v30;
                v30 += 4;
LABEL_75:
                v52 = 0LL;
                v53 = 0LL;
                do
                {
                  v54 = *v30;
                  v55 = (unsigned __int64)(*v30++ & 0x7F) << v53;
                  v52 |= v55;
                  v53 += 7LL;
                }
                while ( v54 < 0 );
                v56 = v81 + v38;
                if ( v8 < v56 )
                  goto LABEL_115;
                if ( v8 >= v39 + v56 )
                  continue;
                if ( !v40 )
                  goto LABEL_114;
                v82 = (_QWORD *)((char *)v82 + v40);
                if ( v52 )
                {
                  *((_QWORD *)&v71 + 1) = v36 + v52 - 1;
                  *(_QWORD *)&v71 = 0LL;
                  v72 = 0;
                  do
                  {
                    v73 = **((_BYTE **)&v71 + 1);
                    v74 = (unsigned __int64)(**((_BYTE **)&v71 + 1) & 0x7F) << v72;
                    ++*((_QWORD *)&v71 + 1);
                    *(_QWORD *)&v71 = v74 | v71;
                    v72 += 7;
                  }
                  while ( v73 < 0 );
                  *((_QWORD *)&v71 + 1) = -1LL << v72;
                  if ( (unsigned __int8)v73 < 0x40u )
                    *((_QWORD *)&v71 + 1) = 0LL;
                  if ( v72 >= 0x40 )
                    *((_QWORD *)&v71 + 1) = 0LL;
                  v37 = 1LL;
                  if ( v71 != 0 )
                    v37 = ((__int64)(*((_QWORD *)&v71 + 1) | v71) >= 0 && v71 != 0) ^ 3LL;
                  v70 = v80;
                  if ( (v80 & 1) == 0 )
                    goto LABEL_116;
                }
                else
                {
                  v37 = 1LL;
                  v70 = v80;
                  if ( (v80 & 1) == 0 )
                    goto LABEL_116;
                }
                break;
              default:
                return v5;
            }
            return dword_44A988[v37];
          }
          break;
        }
      }
      v70 = v80;
      if ( (v80 & 1) != 0 )
        return dword_44A988[v37];
    }
    else
    {
LABEL_114:
      v37 = 0LL;
LABEL_115:
      v70 = v80;
      if ( (v80 & 1) != 0 )
        return dword_44A988[v37];
    }
LABEL_116:
    v5 = 8;
    switch ( v37 )
    {
      case 0LL:
        return v5;
      case 1LL:
      case 2LL:
        goto LABEL_117;
      case 3LL:
        if ( (v70 & 8) == 0 )
        {
LABEL_117:
          sub_43CF00(a5, 0, v79);
          sub_43CF00(a5, 1u, 0LL);
          sub_43CF50(a5, (__int64)v82);
          v5 = 7;
        }
        break;
      case 4LL:
        v5 = 2;
        break;
    }
  }
  return v5;
}
// 44A988: using guessed type unsigned int dword_44A988[6];

//----- (0000000000437180) ----------------------------------------------------
__int64 __fastcall sub_437180(__int64 **a1)
{
  return sub_43CFC0(**a1);
}

//----- (0000000000437190) ----------------------------------------------------
__int64 __fastcall sub_437190(__int64 **a1)
{
  return sub_43CFC0(**a1);
}

//----- (00000000004371A0) ----------------------------------------------------
__int64 sub_4371A0()
{
  return sub_43CFB0();
}

//----- (00000000004371B0) ----------------------------------------------------
__int64 sub_4371B0()
{
  return sub_43CFB0();
}

//----- (00000000004371C0) ----------------------------------------------------
void __fastcall sub_4371C0(LPVOID lpMem)
{
  void *v2; // rdi
  HANDLE ProcessHeap; // rax
  HANDLE v4; // rax

  if ( *((_QWORD *)lpMem + 2) )
  {
    v2 = (void *)*((_QWORD *)lpMem + 3);
    ProcessHeap = GetProcessHeap();
    HeapFree(ProcessHeap, 0, v2);
  }
  if ( lpMem != (LPVOID)-1LL && !_InterlockedDecrement64((volatile signed __int64 *)lpMem + 1) )
  {
    v4 = GetProcessHeap();
    HeapFree(v4, 0, lpMem);
  }
}

//----- (0000000000437220) ----------------------------------------------------
__int64 __fastcall sub_437220(unsigned __int64 *a1, __int64 a2)
{
  unsigned __int128 v2; // rax
  __int64 v3; // rsi
  unsigned __int64 v4; // r8
  unsigned __int64 v6; // rax
  unsigned __int64 v7; // rbx
  __int64 v8; // rcx
  __int64 v9; // rcx
  __int64 result; // rax
  _QWORD v11[3]; // [rsp+28h] [rbp-28h] BYREF
  __int64 v12; // [rsp+40h] [rbp-10h] BYREF
  __int64 v13; // [rsp+48h] [rbp-8h]
  __int64 v14; // [rsp+50h] [rbp+0h]

  *((_QWORD *)&v2 + 1) = a2;
  v3 = *((_QWORD *)&v2 + 1);
  v4 = *a1;
  if ( *a1 == -1LL )
    goto LABEL_13;
  v6 = v4 + 1;
  if ( 2 * v4 > v4 + 1 )
    v6 = 2 * v4;
  v7 = 4LL;
  if ( v6 >= 5 )
    v7 = v6;
  v8 = 0LL;
  v2 = 0x38 * (unsigned __int128)v7;
  if ( !is_mul_ok(0x38uLL, v7) )
LABEL_13:
    sub_40408F(0LL, *((__int64 *)&v2 + 1), v3);
  if ( (unsigned __int64)v2 > 0x7FFFFFFFFFFFFFF8LL )
LABEL_15:
    sub_40408F(v8, *((__int64 *)&v2 + 1), v3);
  if ( v4 )
  {
    v11[0] = a1[1];
    v11[2] = 56 * v4;
    v9 = 8LL;
  }
  else
  {
    v9 = 0LL;
  }
  v11[1] = v9;
  sub_413370(&v12, (void *)8, v2, (__int64)v11);
  if ( (_DWORD)v12 == 1 )
  {
    v8 = v13;
    *((_QWORD *)&v2 + 1) = v14;
    goto LABEL_15;
  }
  result = v13;
  a1[1] = v13;
  *a1 = v7;
  return result;
}

//----- (00000000004372F0) ----------------------------------------------------
__int64 __fastcall Handler(struct _EXCEPTION_POINTERS *ExceptionInfo)
{
  __int64 *Value; // rax
  __int64 *v2; // rsi
  __int64 v3; // rt0
  __int64 v4; // rdi
  const char *v5; // rax
  __int64 v6; // rcx
  __int64 v7; // rax
  void *v8; // r14
  _QWORD *v9; // r15
  __int64 v10; // r12
  HANDLE ProcessHeap; // rax
  HANDLE v12; // rax
  DWORD v14; // eax
  __int64 *v15; // rdx
  _QWORD v16[6]; // [rsp+28h] [rbp-58h] BYREF
  __int64 v17; // [rsp+58h] [rbp-28h]
  __int64 *v18; // [rsp+60h] [rbp-20h] BYREF
  _QWORD v19[2]; // [rsp+68h] [rbp-18h] BYREF
  _QWORD v20[2]; // [rsp+78h] [rbp-8h] BYREF
  int v21; // [rsp+88h] [rbp+8h] BYREF
  char v22; // [rsp+8Ch] [rbp+Ch]

  if ( ExceptionInfo->ExceptionRecord->ExceptionCode != -1073741571 )
    return 0LL;
  v21 = 0;
  v22 = 0;
  if ( dword_450120 )
  {
    Value = (__int64 *)TlsGetValue(dword_450120 - 1);
    if ( (unsigned __int64)Value > 2 )
    {
LABEL_4:
      v2 = &qword_450038;
      if ( Value != &qword_450038 )
      {
        v2 = Value - 2;
        v3 = _InterlockedIncrement64(Value - 2);
        v4 = 1LL;
        if ( (v3 < 0) ^ __OFSUB__(Value, &qword_450038) | (v3 == 0) )
          BUG();
        v17 = 1LL;
        v18 = Value - 2;
        goto LABEL_7;
      }
      v4 = 0LL;
      v17 = 0LL;
      v18 = &qword_450038;
      goto LABEL_10;
    }
  }
  else
  {
    v14 = sub_412510((signed __int64)&unk_450108);
    Value = (__int64 *)TlsGetValue(v14);
    if ( (unsigned __int64)Value > 2 )
      goto LABEL_4;
  }
  v4 = (__int64)sub_437F30((__int64)Value);
  v2 = v15;
  v17 = v4;
  v18 = v15;
  if ( (v4 & 1) != 0 )
  {
LABEL_7:
    v5 = (const char *)v2[3];
    if ( v5 )
    {
      v6 = v2[4] - 1;
    }
    else
    {
      v6 = 9LL;
      v5 = aUnknown;
    }
    goto LABEL_12;
  }
LABEL_10:
  v6 = 4LL;
  v5 = aMain_0;
LABEL_12:
  v19[0] = v5;
  v19[1] = v6;
  v20[0] = v19;
  v20[1] = sub_4123C0;
  v16[0] = &off_44A030;
  v16[1] = 2LL;
  v16[4] = 0LL;
  v16[2] = v20;
  v16[3] = 1LL;
  v7 = sub_412270((__int64)&v21, v16);
  if ( (v7 & 3) == 1 )
  {
    v8 = (void *)(v7 - 1);
    v9 = *(_QWORD **)(v7 - 1);
    v10 = *(_QWORD *)(v7 + 7);
    if ( *(_QWORD *)v10 )
      (*(void (__fastcall **)(_QWORD *))v10)(v9);
    if ( *(_QWORD *)(v10 + 8) )
    {
      if ( *(_QWORD *)(v10 + 16) >= 0x11uLL )
        v9 = (_QWORD *)*(v9 - 1);
      ProcessHeap = GetProcessHeap();
      HeapFree(ProcessHeap, 0, v9);
    }
    v12 = GetProcessHeap();
    HeapFree(v12, 0, v8);
  }
  if ( v4 && !_InterlockedDecrement64(v2) )
    sub_412BC0((__int64 *)&v18);
  return 0LL;
}
// 4374B3: variable 'v15' is possibly undefined
// 44A030: using guessed type char *off_44A030;
// 450038: using guessed type __int64 qword_450038;
// 450120: using guessed type int dword_450120;

//----- (0000000000437520) ----------------------------------------------------
void *sub_437520()
{
  signed __int64 v0; // rax
  void *v1; // rsi
  signed __int64 v2; // rtt
  DWORD v3; // ecx

  v0 = qword_4500D8;
  do
  {
    if ( v0 == -1 )
      sub_437E70();
    v1 = (void *)(v0 + 1);
    v2 = v0;
    v0 = _InterlockedCompareExchange64(&qword_4500D8, v0 + 1, v0);
  }
  while ( v2 != v0 );
  if ( dword_450100 )
    v3 = dword_450100 - 1;
  else
    v3 = sub_412510((signed __int64)&unk_4500E8);
  TlsSetValue(v3, v1);
  return v1;
}
// 4500D8: using guessed type __int64 qword_4500D8;
// 450100: using guessed type int dword_450100;

//----- (0000000000437590) ----------------------------------------------------
void __fastcall sub_437590(volatile signed __int32 *Address, char a2, __int64 a3, __int64 a4, __int64 a5)
{
  signed __int32 v8; // eax
  signed __int32 v9; // ett
  unsigned int v10; // ecx
  int v11; // ecx
  bool v12; // r8
  int v13; // edx
  signed __int32 v14; // ecx
  _QWORD CompareAddress[3]; // [rsp+20h] [rbp-30h] BYREF
  __int128 v16; // [rsp+38h] [rbp-18h]

  v8 = *Address;
  if ( !a2 )
  {
LABEL_17:
    while ( 2 )
    {
      v13 = v8 & 4;
      v14 = v8;
      switch ( v8 )
      {
        case 0:
LABEL_16:
          v12 = 0;
          v8 = _InterlockedCompareExchange(Address, v13 | 2, v14);
          if ( v14 != v8 )
            continue;
          goto LABEL_12;
        case 1:
LABEL_23:
          CompareAddress[0] = &off_44A180;
          CompareAddress[1] = 1LL;
          CompareAddress[2] = 8LL;
          v16 = 0LL;
          sub_405240((__int64)CompareAddress, a5);
        case 2:
          while ( 2 )
          {
            if ( v13 || (v14 |= 4u, v8 = _InterlockedCompareExchange(Address, v14, 2), v8 == 2) )
            {
              LODWORD(CompareAddress[0]) = v14;
              if ( !WaitOnAddress(Address, CompareAddress, 4uLL, 0xFFFFFFFF) )
                GetLastError();
              v14 = *Address;
              v13 = *Address & 4;
              switch ( *Address & 3 )
              {
                case 0:
                  goto LABEL_16;
                case 1:
                  goto LABEL_23;
                case 2:
                  continue;
                case 3:
                  return;
              }
            }
            goto LABEL_17;
          }
        case 3:
          return;
      }
    }
  }
  do
  {
    while ( 1 )
    {
      v10 = v8 & 3;
      if ( v10 < 2 )
        break;
      if ( v10 != 2 )
        return;
      v11 = v8;
      if ( (v8 & 4) == 0 )
      {
        v11 = v8 | 4;
        v8 = _InterlockedCompareExchange(Address, v8 | 4, 2);
        if ( v8 != 2 )
          continue;
      }
      LODWORD(CompareAddress[0]) = v11;
      if ( !WaitOnAddress(Address, CompareAddress, 4uLL, 0xFFFFFFFF) )
        GetLastError();
      v8 = *Address;
    }
    v9 = v8;
    v8 = _InterlockedCompareExchange(Address, v8 & 4 | 2, v8);
  }
  while ( v9 != v8 );
  v12 = v10 == 1;
LABEL_12:
  LODWORD(CompareAddress[0]) = 3;
  BYTE4(CompareAddress[0]) = v12;
  (*(void (__fastcall **)(__int64, _QWORD *))(a4 + 32))(a3, CompareAddress);
  if ( (_InterlockedExchange(Address, CompareAddress[0]) & 4) != 0 )
    WakeByAddressAll((PVOID)Address);
}
// 44A180: using guessed type char *off_44A180;

//----- (0000000000437720) ----------------------------------------------------
void __fastcall sub_437720(_QWORD *a1)
{
  _QWORD v1[6]; // [rsp+0h] [rbp-30h] BYREF

  v1[5] = *a1;
  sub_437750((_BYTE **)&v1[5]);
}

//----- (0000000000437750) ----------------------------------------------------
void __fastcall sub_437750(_BYTE **a1)
{
  bool v1; // zf
  LPVOID Value; // rax
  int v3; // eax
  DWORD v4; // eax
  char v5; // al
  __int128 v6; // [rsp+20h] [rbp-20h]
  __int128 v7; // [rsp+30h] [rbp-10h]
  _BYTE v8[9]; // [rsp+47h] [rbp+7h] BYREF

  v1 = **a1 == 0;
  **a1 = 0;
  if ( v1 )
    sub_407050((__int64)&off_449000);
  v8[0] = 0;
  if ( dword_450080 == 3 || (sub_437929((__int64)v8), !v8[0]) )
  {
    if ( dword_450100 )
    {
      Value = TlsGetValue(dword_450100 - 1);
      if ( Value )
        goto LABEL_5;
    }
    else
    {
      v4 = sub_412510((signed __int64)&unk_4500E8);
      Value = TlsGetValue(v4);
      if ( Value )
      {
LABEL_5:
        if ( Value == (LPVOID)qword_450048 )
        {
LABEL_6:
          if ( dword_450050 == -1 )
            return;
          v3 = dword_450050 + 1;
LABEL_14:
          dword_450050 = v3;
          *(_QWORD *)&v6 = 0LL;
          *((_QWORD *)&v6 + 1) = 1LL;
          *(_QWORD *)&v7 = 0LL;
          BYTE8(v7) = 0;
          BYTE13(v7) = 0;
          *(_DWORD *)((char *)&v7 + 9) = 0;
          if ( qword_450058 )
            sub_406750((__int64)&off_448C30);
          qword_450058 = -1LL;
          sub_4379C0((__int64)&xmmword_450060);
          xmmword_450070 = v7;
          xmmword_450060 = v6;
          ++qword_450058;
          if ( !--dword_450050 )
          {
            qword_450048 = 0LL;
            v5 = byte_450054;
            byte_450054 = 0;
            if ( v5 == 2 )
              WakeByAddressSingle(&byte_450054);
          }
          return;
        }
LABEL_12:
        if ( _InterlockedCompareExchange8(&byte_450054, 1, 0) )
          return;
        qword_450048 = (__int64)Value;
        v3 = 1;
        goto LABEL_14;
      }
    }
    Value = sub_437520();
    if ( Value == (LPVOID)qword_450048 )
      goto LABEL_6;
    goto LABEL_12;
  }
}
// 43777D: conditional instruction was optimized away because %var_9.1==0
// 43786C: variable 'v7' is possibly undefined
// 448C30: using guessed type char *off_448C30;
// 449000: using guessed type char *off_449000;
// 450048: using guessed type __int64 qword_450048;
// 450050: using guessed type int dword_450050;
// 450054: using guessed type char byte_450054;
// 450058: using guessed type __int64 qword_450058;
// 450060: using guessed type __int128 xmmword_450060;
// 450070: using guessed type __int128 xmmword_450070;
// 450080: using guessed type int dword_450080;
// 450100: using guessed type int dword_450100;

//----- (0000000000437929) ----------------------------------------------------
void __fastcall sub_437929(__int64 a1)
{
  _QWORD v1[3]; // [rsp+28h] [rbp-28h] BYREF
  _QWORD *v2; // [rsp+40h] [rbp-10h] BYREF
  char v3; // [rsp+4Fh] [rbp-1h] BYREF

  if ( dword_450080 != 3 )
  {
    v1[0] = a1;
    v1[1] = &qword_450048;
    v1[2] = &v3;
    v2 = v1;
    sub_437590(&dword_450080, 1, (__int64)&v2, (__int64)&unk_449018, (__int64)&off_449040);
  }
}
// 450048: using guessed type __int64 qword_450048;
// 450080: using guessed type int dword_450080;

//----- (0000000000437990) ----------------------------------------------------
void __fastcall sub_437990(__int64 a1)
{
  char v2; // al

  if ( (*(_DWORD *)(a1 + 8))-- == 1 )
  {
    *(_QWORD *)a1 = 0LL;
    v2 = *(_BYTE *)(a1 + 12);
    *(_BYTE *)(a1 + 12) = 0;
    if ( v2 == 2 )
      WakeByAddressSingle((PVOID)(a1 + 12));
  }
}

//----- (00000000004379C0) ----------------------------------------------------
void __fastcall sub_4379C0(__int64 a1)
{
  char **v2; // rax
  char *v3; // rdi
  _QWORD *v4; // r14
  __int64 v5; // r15
  HANDLE ProcessHeap; // rax
  HANDLE v7; // rax
  void *v8; // rsi
  HANDLE v9; // rax

  if ( !*(_BYTE *)(a1 + 24) )
  {
    v2 = sub_437AD0(a1);
    if ( ((unsigned __int8)v2 & 3) == 1 )
    {
      v3 = (char *)v2 - 1;
      v4 = *(char **)((char *)v2 - 1);
      v5 = *(__int64 *)((char *)v2 + 7);
      if ( *(_QWORD *)v5 )
        (*(void (__fastcall **)(_QWORD *))v5)(v4);
      if ( *(_QWORD *)(v5 + 8) )
      {
        if ( *(_QWORD *)(v5 + 16) >= 0x11uLL )
          v4 = (_QWORD *)*(v4 - 1);
        ProcessHeap = GetProcessHeap();
        HeapFree(ProcessHeap, 0, v4);
      }
      v7 = GetProcessHeap();
      HeapFree(v7, 0, v3);
    }
  }
  if ( *(_QWORD *)a1 )
  {
    v8 = *(void **)(a1 + 8);
    v9 = GetProcessHeap();
    HeapFree(v9, 0, v8);
  }
}

//----- (0000000000437AD0) ----------------------------------------------------
char **__fastcall sub_437AD0(__int64 a1)
{
  unsigned __int64 v1; // r15
  unsigned __int8 *v3; // r14
  unsigned __int64 v4; // rdi
  unsigned __int64 v5; // r15
  __int64 v6; // rax
  unsigned __int64 v7; // rdx
  __int64 v8; // rcx
  _QWORD *v9; // r13
  __int64 v10; // r15
  HANDLE ProcessHeap; // rax
  HANDLE v12; // rax
  char **result; // rax
  size_t v14; // r14
  unsigned __int64 v15; // r14
  bool v16; // cf
  char *v17; // rcx
  char *v18; // rdx
  char **v19; // rdi
  void *lpMem; // [rsp+20h] [rbp+0h]

  v1 = *(_QWORD *)(a1 + 16);
  if ( !v1 )
    return 0LL;
  v3 = (unsigned __int8 *)(a1 + 25);
  v4 = 0LL;
  while ( 1 )
  {
    *(_BYTE *)(a1 + 24) = 1;
    v5 = v1 - v4;
    v6 = sub_435C30(0xFFFFFFF5, (unsigned __int8 *)(v4 + *(_QWORD *)(a1 + 8)), v5, v3);
    if ( (v6 & 1) == 0 )
      v5 = v7;
    v8 = 0LL;
    if ( (v7 & 0xFFFFFFFF00000003uLL) != 0x600000002LL )
    {
      v8 = v6;
      v5 = v7;
    }
    *(_BYTE *)(a1 + 24) = 0;
    if ( (v6 & 1) != 0 && v8 )
    {
      switch ( v5 & 3 )
      {
        case 0uLL:
          if ( *(_BYTE *)(v5 + 16) == 35 )
            goto LABEL_4;
          goto LABEL_24;
        case 1uLL:
          if ( *(_BYTE *)(v5 + 15) != 35 )
            goto LABEL_24;
          if ( (v8 & 1) != 0 )
          {
            lpMem = (void *)(v5 - 1);
            v9 = *(_QWORD **)(v5 - 1);
            v10 = *(_QWORD *)(v5 + 7);
            if ( *(_QWORD *)v10 )
              (*(void (__fastcall **)(_QWORD *))v10)(v9);
            if ( *(_QWORD *)(v10 + 8) )
            {
              if ( *(_QWORD *)(v10 + 16) >= 0x11uLL )
                v9 = (_QWORD *)*(v9 - 1);
              ProcessHeap = GetProcessHeap();
              HeapFree(ProcessHeap, 0, v9);
            }
            v12 = GetProcessHeap();
            HeapFree(v12, 0, lpMem);
          }
          goto LABEL_4;
        case 2uLL:
          goto LABEL_24;
        case 3uLL:
          if ( (v5 & 0xFFFFFFFF00000000uLL) == 0x2300000000LL )
            goto LABEL_4;
LABEL_24:
          result = (char **)v5;
          if ( !v4 )
            return result;
          goto LABEL_31;
      }
    }
    if ( !v5 )
      break;
    v4 += v5;
LABEL_4:
    v1 = *(_QWORD *)(a1 + 16);
    if ( v4 >= v1 )
    {
      if ( !v4 )
        return 0LL;
      v14 = 0LL;
      result = 0LL;
      if ( v1 < v4 )
        sub_405B00(v4, *(_QWORD *)(a1 + 16), (__int64)&off_447D50);
      goto LABEL_34;
    }
  }
  result = &off_448850;
  if ( !v4 )
    return result;
LABEL_31:
  v15 = *(_QWORD *)(a1 + 16);
  v16 = v15 < v4;
  v14 = v15 - v4;
  if ( v16 )
    sub_405B00(v4, *(_QWORD *)(a1 + 16), (__int64)&off_447D50);
  *(_QWORD *)(a1 + 16) = 0LL;
  if ( v14 )
  {
    v17 = *(char **)(a1 + 8);
    v18 = &v17[v4];
    v19 = result;
    memmove(v17, v18, v14);
    result = v19;
LABEL_34:
    *(_QWORD *)(a1 + 16) = v14;
  }
  return result;
}
// 437B53: variable 'v7' is possibly undefined
// 447D50: using guessed type char *off_447D50;
// 448850: using guessed type char *off_448850;

//----- (0000000000437D10) ----------------------------------------------------
void __fastcall sub_437D10(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rsi
  bool v3; // cf
  size_t v4; // rsi

  if ( a2 )
  {
    v2 = *(_QWORD *)(a1 + 16);
    v3 = v2 < a2;
    v4 = v2 - a2;
    if ( v3 )
      sub_405B00(a2, *(_QWORD *)(a1 + 16), (__int64)&off_447D50);
    *(_QWORD *)(a1 + 16) = 0LL;
    if ( v4 )
    {
      memmove(*(void **)(a1 + 8), (const void *)(*(_QWORD *)(a1 + 8) + a2), v4);
      *(_QWORD *)(a1 + 16) = v4;
    }
  }
}
// 447D50: using guessed type char *off_447D50;

//----- (0000000000437D70) ----------------------------------------------------
__int64 __fastcall sub_437D70(_QWORD **a1)
{
  _QWORD *v1; // rdx
  _BYTE *v2; // rcx
  __int64 result; // rax
  _BYTE v4[19]; // [rsp+2Dh] [rbp-13h]

  v1 = *a1;
  v2 = (_BYTE *)**a1;
  result = v1[1];
  *v1 = 0LL;
  if ( !v2 )
    sub_407050((__int64)&off_449080);
  *v2 = 1;
  *(_OWORD *)&v4[3] = 0LL;
  *(_QWORD *)result = 0LL;
  *(_DWORD *)(result + 8) = 0;
  *(_BYTE *)(result + 12) = 0;
  *(_OWORD *)(result + 13) = *(_OWORD *)v4;
  *(_DWORD *)(result + 28) = 0;
  *(_QWORD *)(result + 32) = 1LL;
  *(_QWORD *)(result + 40) = 0LL;
  *(_BYTE *)(result + 48) = 0;
  *(_BYTE *)(result + 53) = 0;
  *(_DWORD *)(result + 49) = 0;
  return result;
}
// 437DB0: variable 'v4' is possibly undefined
// 449080: using guessed type char *off_449080;

//----- (0000000000437DF0) ----------------------------------------------------
__int64 __fastcall sub_437DF0(_QWORD **a1)
{
  _QWORD *v1; // rdx
  _BYTE *v2; // rcx
  __int64 result; // rax
  _BYTE v4[19]; // [rsp+2Dh] [rbp-13h]

  v1 = *a1;
  v2 = (_BYTE *)**a1;
  result = v1[1];
  *v1 = 0LL;
  if ( !v2 )
    sub_407050((__int64)&off_449080);
  *v2 = 1;
  *(_OWORD *)&v4[3] = 0LL;
  *(_QWORD *)result = 0LL;
  *(_DWORD *)(result + 8) = 0;
  *(_BYTE *)(result + 12) = 0;
  *(_OWORD *)(result + 13) = *(_OWORD *)v4;
  *(_DWORD *)(result + 28) = 0;
  *(_QWORD *)(result + 32) = 1LL;
  *(_QWORD *)(result + 40) = 0LL;
  *(_BYTE *)(result + 48) = 0;
  *(_BYTE *)(result + 53) = 0;
  *(_DWORD *)(result + 49) = 0;
  return result;
}
// 437E30: variable 'v4' is possibly undefined
// 449080: using guessed type char *off_449080;

//----- (0000000000437E70) ----------------------------------------------------
void __noreturn sub_437E70()
{
  _QWORD v0[7]; // [rsp+0h] [rbp-50h] BYREF
  __int128 v1; // [rsp+38h] [rbp-18h]

  v0[4] = &off_448790;
  v0[5] = 1LL;
  v0[6] = 8LL;
  v1 = 0LL;
  sub_405240((__int64)&v0[4], (__int64)&off_4487A0);
}
// 448790: using guessed type char *off_448790;
// 4487A0: using guessed type char *off_4487A0;

//----- (0000000000437EB0) ----------------------------------------------------
__int64 __fastcall sub_437EB0(__int64 a1, __int64 a2)
{
  HMODULE ModuleHandleA; // rax
  HRESULT (__stdcall *SetThreadDescription)(HANDLE, PCWSTR); // rax
  __int64 (__fastcall *v6)(); // r8

  ModuleHandleA = GetModuleHandleA("kernel32");
  if ( ModuleHandleA )
  {
    SetThreadDescription = (HRESULT (__stdcall *)(HANDLE, PCWSTR))GetProcAddress(ModuleHandleA, "SetThreadDescription");
    v6 = sub_437F10;
    if ( SetThreadDescription )
      v6 = (__int64 (__fastcall *)())SetThreadDescription;
  }
  else
  {
    v6 = sub_437F10;
  }
  off_43F020 = v6;
  return ((__int64 (__fastcall *)(__int64, __int64))v6)(a1, a2);
}
// 43F020: using guessed type __int64 (__fastcall *off_43F020)();

//----- (0000000000437F10) ----------------------------------------------------
__int64 sub_437F10()
{
  SetLastError(0x78u);
  return 2147500033LL;
}

//----- (0000000000437F30) ----------------------------------------------------
char **__fastcall sub_437F30(__int64 a1)
{
  DWORD v1; // ecx
  LPVOID Value; // rdi
  _QWORD *v3; // rax
  _QWORD *v4; // rsi
  DWORD v5; // ecx
  DWORD v7; // eax
  __int64 v8; // [rsp+28h] [rbp-48h] BYREF
  char **v9; // [rsp+30h] [rbp-40h] BYREF
  __int64 v10; // [rsp+38h] [rbp-38h]
  __int64 v11; // [rsp+40h] [rbp-30h]
  __int128 v12; // [rsp+48h] [rbp-28h]
  int v13; // [rsp+60h] [rbp-10h] BYREF
  char v14; // [rsp+64h] [rbp-Ch]
  char v15; // [rsp+68h] [rbp-8h] BYREF

  if ( a1 )
  {
    if ( a1 != 1 )
    {
      v9 = &off_448590;
      v10 = 1LL;
      v11 = 8LL;
      v12 = 0LL;
      sub_405240((__int64)&v9, (__int64)&off_4485C8);
    }
    v13 = 0;
    v14 = 0;
    v9 = &off_4486A0;
    v10 = 1LL;
    v11 = (__int64)&v15;
    v12 = 0LL;
    v8 = sub_412270((__int64)&v13, &v9);
    sub_4123A0(&v8);
    __fastfail(7u);
  }
  if ( dword_450120 )
    v1 = dword_450120 - 1;
  else
    v1 = sub_412510((signed __int64)&unk_450108);
  TlsSetValue(v1, (LPVOID)1);
  if ( dword_450100 )
  {
    Value = TlsGetValue(dword_450100 - 1);
    if ( Value )
      goto LABEL_6;
  }
  else
  {
    v7 = sub_412510((signed __int64)&unk_4500E8);
    Value = TlsGetValue(v7);
    if ( Value )
      goto LABEL_6;
  }
  Value = sub_437520();
LABEL_6:
  v3 = sub_43C4F0(0x30uLL);
  if ( !v3 )
    sub_4040E9(8LL, 48LL);
  v4 = v3;
  *v3 = 1LL;
  v3[1] = 1LL;
  v3[3] = 0LL;
  v3[2] = Value;
  *((_BYTE *)v3 + 40) = 0;
  v9 = (char **)1;
  v10 = (__int64)v3;
  if ( _InterlockedIncrement64(v3) <= 0 )
    BUG();
  if ( dword_450120 )
    v5 = dword_450120 - 1;
  else
    v5 = sub_412510((signed __int64)&unk_450108);
  TlsSetValue(v5, v4 + 2);
  return v9;
}
// 448590: using guessed type char *off_448590;
// 4485C8: using guessed type char *off_4485C8;
// 4486A0: using guessed type char *off_4486A0;
// 450100: using guessed type int dword_450100;
// 450120: using guessed type int dword_450120;
// 453040: using guessed type __int64 (__fastcall *TlsCallbacks[3])();

//----- (0000000000438120) ----------------------------------------------------
char __fastcall sub_438120(unsigned __int64 *a1, unsigned __int64 a2)
{
  unsigned __int64 v3; // rdi
  unsigned __int8 v4; // al
  char v5; // al
  char v6; // al
  char v7; // cl
  char v8; // al
  unsigned __int64 v9; // rdi
  bool v10; // zf
  unsigned __int8 v11; // al
  char v12; // cl
  __int64 v13; // r8
  char *v14; // rdx
  void *v15; // rsi
  char v16; // bl
  HANDLE ProcessHeap; // rax
  unsigned __int64 v19; // [rsp+30h] [rbp-30h] BYREF
  char v20; // [rsp+38h] [rbp-28h]
  char v21; // [rsp+39h] [rbp-27h]
  LPVOID lpMem[2]; // [rsp+40h] [rbp-20h] BYREF
  unsigned __int64 *v23; // [rsp+50h] [rbp-10h]
  int v24; // [rsp+60h] [rbp+0h] BYREF
  char v25[25]; // [rsp+67h] [rbp+7h] BYREF

  v3 = *a1;
  switch ( *a1 & 3 )
  {
    case 0uLL:
      v4 = (*(__int64 (__fastcall **)(_QWORD, const char *, __int64))(*(_QWORD *)(a2 + 56) + 24LL))(
             *(_QWORD *)(a2 + 48),
             aError_0,
             5LL);
      lpMem[0] = (LPVOID)a2;
      LOWORD(lpMem[1]) = v4;
      sub_406A60(lpMem, (__int64)aKind, 4uLL, v3 + 16, (unsigned __int8 (__fastcall *)(__int64, _OWORD *))sub_439040);
      sub_406A60(lpMem, (__int64)aMessage, 7uLL, v3, (unsigned __int8 (__fastcall *)(__int64, _OWORD *))sub_40E460);
      goto LABEL_13;
    case 1uLL:
      v19 = v3 - 1;
      v11 = (*(__int64 (__fastcall **)(_QWORD, const char *, __int64))(*(_QWORD *)(a2 + 56) + 24LL))(
              *(_QWORD *)(a2 + 48),
              aCustom,
              6LL);
      lpMem[0] = (LPVOID)a2;
      LOWORD(lpMem[1]) = v11;
      sub_406A60(lpMem, (__int64)aKind, 4uLL, v3 + 15, (unsigned __int8 (__fastcall *)(__int64, _OWORD *))sub_439040);
      sub_406A60(
        lpMem,
        (__int64)aError_1,
        5uLL,
        (__int64)&v19,
        (unsigned __int8 (__fastcall *)(__int64, _OWORD *))sub_438D90);
LABEL_13:
      if ( (__int64)lpMem[1] & 1 | ((BYTE1(lpMem[1]) & 1) == 0) )
      {
        v8 = LOBYTE(lpMem[1]) | BYTE1(lpMem[1]);
      }
      else if ( (*((_BYTE *)lpMem[0] + 36) & 4) != 0 )
      {
        v8 = (*(__int64 (__fastcall **)(_QWORD, char *, __int64))(*((_QWORD *)lpMem[0] + 7) + 24LL))(
               *((_QWORD *)lpMem[0] + 6),
               "}",
               1LL);
      }
      else
      {
        v8 = (*(__int64 (__fastcall **)(_QWORD, const char *, __int64))(*((_QWORD *)lpMem[0] + 7) + 24LL))(
               *((_QWORD *)lpMem[0] + 6),
               asc_447561,
               2LL);
      }
      return v8 & 1;
    case 2uLL:
      v24 = HIDWORD(*a1);
      v5 = (*(__int64 (__fastcall **)(_QWORD, const char *, __int64))(*(_QWORD *)(a2 + 56) + 24LL))(
             *(_QWORD *)(a2 + 48),
             aOs,
             2LL);
      v19 = a2;
      v20 = v5;
      v21 = 0;
      sub_406A60(
        &v19,
        (__int64)aCode,
        4uLL,
        (__int64)&v24,
        (unsigned __int8 (__fastcall *)(__int64, _OWORD *))sub_438E10);
      v6 = 1;
      if ( v24 > 1120 )
      {
        if ( v24 > 10012 )
        {
          switch ( v24 )
          {
            case 10013:
              goto LABEL_62;
            case 10014:
            case 10015:
            case 10016:
            case 10017:
            case 10018:
            case 10019:
            case 10020:
            case 10021:
            case 10023:
            case 10024:
            case 10025:
            case 10026:
            case 10027:
            case 10028:
            case 10029:
            case 10030:
            case 10031:
            case 10032:
            case 10033:
            case 10034:
            case 10036:
            case 10037:
            case 10038:
            case 10039:
            case 10040:
            case 10041:
            case 10042:
            case 10043:
            case 10044:
            case 10045:
            case 10046:
            case 10047:
            case 10052:
            case 10055:
            case 10056:
            case 10058:
            case 10059:
            case 10062:
            case 10063:
            case 10064:
            case 10066:
            case 10067:
            case 10068:
              goto LABEL_55;
            case 10022:
LABEL_20:
              v6 = 20;
              break;
            case 10035:
              v6 = 13;
              break;
            case 10048:
              v6 = 8;
              break;
            case 10049:
              v6 = 9;
              break;
            case 10050:
              v6 = 10;
              break;
            case 10051:
              goto LABEL_71;
            case 10053:
              v6 = 6;
              break;
            case 10054:
              v6 = 3;
              break;
            case 10057:
              v6 = 7;
              break;
            case 10060:
              goto LABEL_61;
            case 10061:
              v6 = 2;
              break;
            case 10065:
              goto LABEL_29;
            case 10069:
              goto LABEL_72;
            default:
              if ( (unsigned int)(v24 - 15402) >= 2 && v24 != 13805 )
                goto LABEL_55;
              goto LABEL_61;
          }
          goto LABEL_62;
        }
        if ( v24 > 1920 )
        {
          if ( v24 <= 7039 )
          {
            if ( v24 == 1921 )
            {
              v6 = 18;
              goto LABEL_62;
            }
            if ( v24 != 5910 && v24 != 7012 )
              goto LABEL_55;
          }
          else if ( v24 > 8225 )
          {
            if ( v24 != 8226 && v24 != 9705 )
              goto LABEL_55;
          }
          else if ( v24 != 7040 && v24 != 8014 )
          {
            goto LABEL_55;
          }
        }
        else if ( v24 <= 1230 )
        {
          if ( v24 != 1121 )
          {
            if ( v24 != 1131 )
            {
              if ( v24 == 1142 )
              {
                v6 = 32;
                goto LABEL_62;
              }
              goto LABEL_55;
            }
            v6 = 30;
            goto LABEL_62;
          }
        }
        else
        {
          if ( v24 <= 1294 )
          {
            if ( v24 != 1231 )
            {
              if ( v24 == 1232 )
              {
LABEL_29:
                v6 = 4;
                goto LABEL_62;
              }
              goto LABEL_55;
            }
LABEL_71:
            v6 = 5;
            goto LABEL_62;
          }
          if ( v24 == 1295 )
          {
LABEL_72:
            v6 = 26;
            goto LABEL_62;
          }
          if ( v24 != 1460 )
            goto LABEL_55;
        }
LABEL_61:
        v6 = 22;
        goto LABEL_62;
      }
      if ( v24 <= 335 )
      {
        switch ( v24 )
        {
          case 2:
          case 3:
          case 15:
          case 53:
          case 67:
            v6 = 0;
            break;
          case 5:
            goto LABEL_62;
          case 8:
          case 14:
            v6 = 38;
            break;
          case 17:
            v6 = 31;
            break;
          case 19:
            v6 = 17;
            break;
          case 39:
          case 112:
            v6 = 24;
            break;
          case 80:
          case 183:
            v6 = 12;
            break;
          case 87:
            goto LABEL_20;
          case 109:
          case 232:
            v6 = 11;
            break;
          case 120:
            v6 = 36;
            break;
          case 121:
          case 258:
            goto LABEL_61;
          case 123:
          case 161:
          case 206:
            v6 = 33;
            break;
          case 132:
            v6 = 25;
            break;
          case 145:
            v6 = 16;
            break;
          case 170:
            v6 = 28;
            break;
          case 223:
            v6 = 27;
            break;
          case 267:
            v6 = 14;
            break;
          default:
            goto LABEL_55;
        }
        goto LABEL_62;
      }
      if ( v24 > 994 )
      {
        if ( v24 != 995 && v24 != 1053 )
          goto LABEL_55;
        goto LABEL_61;
      }
      if ( v24 != 336 )
      {
        if ( v24 != 594 )
        {
LABEL_55:
          v6 = 41;
          goto LABEL_62;
        }
        goto LABEL_61;
      }
      v6 = 15;
LABEL_62:
      v25[0] = v6;
      sub_406A60(
        &v19,
        (__int64)aKind,
        4uLL,
        (__int64)v25,
        (unsigned __int8 (__fastcall *)(__int64, _OWORD *))sub_439040);
      sub_438770(lpMem, v24);
      sub_406A60(
        &v19,
        (__int64)aMessage,
        7uLL,
        (__int64)lpMem,
        (unsigned __int8 (__fastcall *)(__int64, _OWORD *))sub_438DF0);
      v8 = v20;
      if ( v21 == 1 )
      {
        v12 = 1;
        if ( (v20 & 1) == 0 )
        {
          v13 = 0LL;
          v14 = "}";
          if ( (*(_BYTE *)(v19 + 36) & 4) == 0 )
            v14 = asc_447561;
          LOBYTE(v13) = (*(_BYTE *)(v19 + 36) & 4) == 0;
          v12 = (*(__int64 (__fastcall **)(_QWORD, char *, __int64))(*(_QWORD *)(v19 + 56) + 24LL))(
                  *(_QWORD *)(v19 + 48),
                  v14,
                  v13 + 1);
        }
        v20 = v12;
        v8 = v12;
      }
      if ( lpMem[0] )
      {
        v15 = lpMem[1];
        v16 = v8;
        ProcessHeap = GetProcessHeap();
        HeapFree(ProcessHeap, 0, v15);
        v8 = v16;
      }
      return v8 & 1;
    case 3uLL:
      v7 = (*(__int64 (__fastcall **)(_QWORD, const char *, __int64))(*(_QWORD *)(a2 + 56) + 24LL))(
             *(_QWORD *)(a2 + 48),
             aKind_0,
             4LL);
      v8 = 1;
      if ( v7 )
        return v8 & 1;
      v9 = HIDWORD(v3);
      if ( (*(_BYTE *)(a2 + 36) & 4) != 0 )
      {
        if ( !(*(unsigned __int8 (__fastcall **)(_QWORD, const char *, __int64))(*(_QWORD *)(a2 + 56) + 24LL))(
                *(_QWORD *)(a2 + 48),
                asc_4428D9,
                2LL) )
        {
          LOBYTE(v19) = 1;
          *(_OWORD *)lpMem = *(_OWORD *)(a2 + 48);
          v23 = &v19;
          if ( !sub_406C00(
                  (__int64 *)lpMem,
                  (__int64)&unk_44A8E0 + *((int *)&unk_44A8E0 + (v9 & 0x3F)),
                  qword_44A790[(unsigned __int8)v9]) )
          {
            v10 = sub_406C00((__int64 *)lpMem, (__int64)asc_4428D7, 2uLL) == 0;
            v8 = 1;
            if ( !v10 )
              return v8 & 1;
LABEL_40:
            v8 = (*(__int64 (__fastcall **)(_QWORD, const char *, __int64))(*(_QWORD *)(a2 + 56) + 24LL))(
                   *(_QWORD *)(a2 + 48),
                   asc_448BDD,
                   1LL);
            return v8 & 1;
          }
        }
      }
      else if ( !(*(unsigned __int8 (__fastcall **)(_QWORD, char *, __int64))(*(_QWORD *)(a2 + 56) + 24LL))(
                   *(_QWORD *)(a2 + 48),
                   "(><&@",
                   1LL) )
      {
        v10 = (*(unsigned __int8 (__fastcall **)(_QWORD, char *, _QWORD))(*(_QWORD *)(a2 + 56) + 24LL))(
                *(_QWORD *)(a2 + 48),
                (char *)&unk_44A8E0 + *((int *)&unk_44A8E0 + (v9 & 0x3F)),
                qword_44A790[(unsigned __int8)v9]) == 0;
        v8 = 1;
        if ( !v10 )
          return v8 & 1;
        goto LABEL_40;
      }
      v8 = 1;
      return v8 & 1;
  }
}
// 448BDD: using guessed type char asc_448BDD;
// 44A790: using guessed type _QWORD qword_44A790[42];

//----- (0000000000438770) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
unsigned __int64 __fastcall sub_438770(_QWORD *a1, DWORD a2)
{
  DWORD v2; // edi
  HMODULE v4; // rbx
  _WORD *v5; // r13
  DWORD v6; // ecx
  HMODULE ModuleHandleW; // rax
  DWORD v8; // eax
  __int64 v9; // rdi
  char *v10; // rax
  char *v11; // r14
  _BYTE *v12; // r12
  unsigned __int64 v13; // rdi
  _WORD *v14; // rsi
  unsigned __int64 v15; // rbx
  unsigned int v16; // eax
  unsigned __int64 v17; // r15
  _BYTE *v18; // rax
  __int64 v19; // rcx
  HANDLE ProcessHeap; // rax
  unsigned __int64 result; // rax
  LPVOID v22; // rbx
  char *v23; // rdx
  char v24; // r8
  char *v25; // rax
  unsigned int v26; // r8d
  char v27; // r9
  char v28; // r10
  int v29; // r10d
  int v30; // r9d
  unsigned int v31; // r9d
  _QWORD *v32; // rcx
  _BYTE v33[64]; // [rsp+0h] [rbp-80h] BYREF
  _BYTE v34[4032]; // [rsp+80h] [rbp+0h] BYREF
  _QWORD *v35; // [rsp+1040h] [rbp+FC0h]
  DWORD LastError; // [rsp+104Ch] [rbp+FCCh] BYREF
  char **v37; // [rsp+1050h] [rbp+FD0h] BYREF
  LPVOID lpMem; // [rsp+1058h] [rbp+FD8h]
  _DWORD **p_Src; // [rsp+1060h] [rbp+FE0h]
  __int64 v40; // [rsp+1068h] [rbp+FE8h]
  __int64 v41; // [rsp+1070h] [rbp+FF0h]
  _DWORD *Src; // [rsp+1080h] [rbp+1000h] BYREF
  __int64 (__fastcall *v43)(int *, __int64); // [rsp+1088h] [rbp+1008h]
  DWORD *p_LastError; // [rsp+1090h] [rbp+1010h]
  __int64 (__fastcall *v45)(int *, __int64); // [rsp+1098h] [rbp+1018h]
  _DWORD v46[9]; // [rsp+10A4h] [rbp+1024h] BYREF

  v2 = a2;
  v46[0] = a2;
  v4 = 0LL;
  v5 = &v33[64];
  memset(v5, 0, 0x1000uLL);
  v6 = 4608;
  if ( (v2 & 0x10000000) != 0 )
  {
    ModuleHandleW = GetModuleHandleW(L"NTDLL.DLL");
    if ( ModuleHandleW )
    {
      v4 = ModuleHandleW;
      v2 &= ~0x10000000u;
      v46[0] = v2;
      v6 = 6656;
    }
    else
    {
      v4 = 0LL;
      v6 = 4608;
    }
  }
  v8 = FormatMessageW(v6, v4, v2, 0, (LPWSTR)&v33[64], 0x800u, 0LL);
  if ( !v8 )
  {
    LastError = GetLastError();
    Src = v46;
    v43 = sub_408AB0;
    p_LastError = &LastError;
    v45 = sub_408AB0;
    v37 = &off_449B18;
    lpMem = (LPVOID)3;
    v41 = 0LL;
    p_Src = &Src;
    v40 = 2LL;
    v19 = (__int64)a1;
    return sub_404400(v19, (__int64 *)&v37);
  }
  v9 = v8;
  if ( v8 >= 0x801 )
    sub_405B00(v8, 2048LL, (__int64)&off_449B70);
  v35 = a1;
  v10 = (char *)sub_43C4F0(v8);
  if ( !v10 )
    sub_4040E9(1LL, v9);
  v11 = v10;
  v37 = (char **)v9;
  lpMem = v10;
  p_Src = 0LL;
  v12 = &v34[2 * v9 - 64];
  v13 = 0LL;
  do
  {
    while ( 1 )
    {
      v14 = v5 + 1;
      LODWORD(v15) = (unsigned __int16)*v5;
      if ( (*v5 & 0xF800) != 0xD800 )
        break;
      if ( (unsigned int)v15 > 0xDBFF || v14 == (_WORD *)v12 || (unsigned __int16)(*v14 + 0x2000) < 0xFC00u )
      {
        if ( v37 )
        {
          ProcessHeap = GetProcessHeap();
          HeapFree(ProcessHeap, 0, v11);
        }
LABEL_29:
        Src = v46;
        v43 = sub_408AB0;
        v37 = &off_449BB8;
        lpMem = (LPVOID)2;
        v41 = 0LL;
        p_Src = &Src;
        v40 = 1LL;
        v19 = (__int64)v35;
        return sub_404400(v19, (__int64 *)&v37);
      }
      v15 = ((v15 & 0x3FF) << 26) + 0x100000000LL;
      v16 = v15 | ((*v14 & 0x3FF) << 16);
      LODWORD(Src) = (unsigned __int8)(v15 >> 34) | 0xF0;
      BYTE1(Src) = (v15 >> 28) & 0x3F | 0x80;
      BYTE2(Src) = (v16 >> 22) & 0x3F | 0x80;
      v17 = 4LL;
      v14 = v5 + 2;
      LOBYTE(v15) = BYTE2(v16);
      v18 = (char *)&Src + 3;
LABEL_21:
      *v18 = v15 & 0x3F | 0x80;
      if ( (unsigned __int64)v37 - v13 < v17 )
      {
        sub_404110((signed __int64 *)&v37, v13, v17);
        v11 = (char *)lpMem;
        v13 = (unsigned __int64)p_Src;
      }
      memcpy(&v11[v13], &Src, v17);
      v13 += v17;
      p_Src = (_DWORD **)v13;
      v5 = v14;
      if ( v14 == (_WORD *)v12 )
        goto LABEL_28;
    }
    if ( (unsigned int)v15 >= 0x80 )
    {
      LODWORD(Src) = 0;
      if ( (unsigned int)v15 >= 0x800 )
      {
        LOBYTE(Src) = ((unsigned int)v15 >> 12) | 0xE0;
        BYTE1(Src) = ((unsigned int)v15 >> 6) & 0x3F | 0x80;
        v17 = 3LL;
        v18 = (char *)&Src + 2;
      }
      else
      {
        LOBYTE(Src) = ((unsigned int)v15 >> 6) | 0xC0;
        v17 = 2LL;
        v18 = (char *)&Src + 1;
      }
      goto LABEL_21;
    }
    if ( (char **)v13 == v37 )
      sub_403F80((signed __int64 *)&v37, (__int64)&off_442648);
    v11 = (char *)lpMem;
    *((_BYTE *)lpMem + v13++) = v15;
    p_Src = (_DWORD **)v13;
    ++v5;
  }
  while ( v14 != (_WORD *)v12 );
LABEL_28:
  if ( __OFSUB__(-(__int64)v37, 1LL) )
    goto LABEL_29;
  v22 = lpMem;
  if ( !v13 )
    goto LABEL_62;
  v23 = (char *)lpMem + v13;
  while ( 1 )
  {
    v25 = v23;
    v26 = *(v23 - 1);
    if ( (v26 & 0x80000000) != 0 )
    {
      v27 = *(v23 - 2);
      if ( v27 >= -64 )
      {
        v23 -= 2;
        v30 = v27 & 0x1F;
      }
      else
      {
        v28 = *(v23 - 3);
        if ( v28 >= -64 )
        {
          v23 -= 3;
          v29 = v28 & 0xF;
        }
        else
        {
          v23 -= 4;
          v29 = ((*(v25 - 4) & 7) << 6) | v28 & 0x3F;
        }
        v30 = (v29 << 6) | v27 & 0x3F;
      }
      v26 = (v30 << 6) | v26 & 0x3F;
      if ( v26 - 9 < 5 )
        goto LABEL_35;
    }
    else
    {
      --v23;
      if ( v26 - 9 < 5 )
        goto LABEL_35;
    }
    if ( v26 == 32 )
      goto LABEL_35;
    if ( v26 < 0x80 )
      break;
    v31 = v26 >> 8;
    if ( v26 >> 8 <= 0x1F )
    {
      if ( v31 )
      {
        if ( v31 != 22 )
          break;
        v24 = v26 == 5760;
      }
      else
      {
        v24 = byte_447B00[(unsigned __int8)v26];
      }
      goto LABEL_34;
    }
    if ( v31 == 32 )
    {
      v24 = byte_447B00[(unsigned __int8)v26] >> 1;
      goto LABEL_34;
    }
    if ( v31 != 48 )
      break;
    v24 = v26 == 12288;
LABEL_34:
    if ( (v24 & 1) == 0 )
      break;
LABEL_35:
    if ( v23 == lpMem )
      goto LABEL_62;
  }
  result = v25 - (_BYTE *)lpMem;
  if ( v13 < result )
  {
    result = v13;
    goto LABEL_63;
  }
  if ( !result )
  {
LABEL_62:
    result = 0LL;
    goto LABEL_63;
  }
  if ( v13 > result && *((char *)lpMem + result) <= -65 )
    sub_405FC0((__int64)"assertion failed: self.is_char_boundary(new_len)", 48LL, (__int64)&off_447E18);
LABEL_63:
  v32 = v35;
  *v35 = v37;
  v32[1] = v22;
  v32[2] = result;
  return result;
}
// 438B90: positive sp value 10A8 has been found
// 442648: using guessed type char *off_442648;
// 447B00: using guessed type _BYTE byte_447B00[256];
// 447E18: using guessed type char *off_447E18;
// 449B18: using guessed type char *off_449B18;
// 449B70: using guessed type char *off_449B70;
// 449BB8: using guessed type char *off_449BB8;

//----- (0000000000438D90) ----------------------------------------------------
__int64 __fastcall sub_438D90(_QWORD **a1)
{
  return (*(__int64 (__fastcall **)(_QWORD))((*a1)[1] + 24LL))(**a1);
}

//----- (0000000000438DB0) ----------------------------------------------------
void __fastcall sub_438DB0(_QWORD *a1)
{
  void *v1; // rsi
  HANDLE ProcessHeap; // rax

  if ( *a1 )
  {
    v1 = (void *)a1[1];
    ProcessHeap = GetProcessHeap();
    HeapFree(ProcessHeap, 0, v1);
  }
}

//----- (0000000000438DF0) ----------------------------------------------------
__int64 __fastcall sub_438DF0(__int64 a1, __int64 a2)
{
  return sub_4072E0(*(_BYTE **)(a1 + 8), *(_QWORD *)(a1 + 16), *(_QWORD *)(a2 + 48), *(_QWORD *)(a2 + 56));
}

//----- (0000000000438E10) ----------------------------------------------------
__int64 __fastcall sub_438E10(unsigned int *a1, __int64 a2)
{
  int v3; // edx
  int v4; // ecx
  __int64 v5; // r9
  __int64 v6; // r8
  __int64 v7; // rsi
  unsigned int v8; // r11d
  bool v9; // cc
  __int64 v10; // r8
  unsigned int v11; // ecx
  __int64 v12; // r9
  unsigned int v13; // r8d
  __int64 v14; // rdx
  char v15; // r10
  unsigned int v16; // ecx
  unsigned int v17; // r8d
  char v18; // r10
  _WORD v20[78]; // [rsp+34h] [rbp-4Ch] BYREF

  v3 = *(_DWORD *)(a2 + 36);
  if ( (v3 & 0x10) != 0 )
  {
    v11 = *a1;
    v12 = 129LL;
    v13 = v11;
    do
    {
      v14 = v12;
      v13 >>= 4;
      v15 = (v11 & 0xF) + 87;
      if ( (v11 & 0xF) < 0xA )
        v15 = (v11 & 0xF) + 48;
      *((_BYTE *)&v20[1] + v12--) = v15;
      v9 = v11 <= 0xF;
      v11 = v13;
    }
    while ( !v9 );
    return sub_405270(a2, 1, (__int64)a0x, 2LL, (__int64)&v20[1] + v14, 129 - v12);
  }
  if ( (v3 & 0x20) != 0 )
  {
    v16 = *a1;
    v12 = 129LL;
    v17 = v16;
    do
    {
      v14 = v12;
      v17 >>= 4;
      v18 = (v16 & 0xF) + 55;
      if ( (v16 & 0xF) < 0xA )
        v18 = (v16 & 0xF) + 48;
      *((_BYTE *)&v20[1] + v12--) = v18;
      v9 = v16 <= 0xF;
      v16 = v17;
    }
    while ( !v9 );
    return sub_405270(a2, 1, (__int64)a0x, 2LL, (__int64)&v20[1] + v14, 129 - v12);
  }
  v4 = *a1;
  LODWORD(v5) = -v4;
  if ( v4 > 0 )
    LODWORD(v5) = v4;
  v6 = 10LL;
  if ( (unsigned int)v5 < 0x2710 )
  {
    v5 = (unsigned int)v5;
    if ( (unsigned int)v5 <= 0x63 )
      goto LABEL_10;
    goto LABEL_9;
  }
  v7 = 5LL;
  do
  {
    v8 = (unsigned int)v5 / 0x2710;
    v6 = v7 * 2 - 4;
    v20[v7] = a0001020304[(5243 * ((unsigned int)v5 % 0x2710)) >> 19];
    v20[v7 + 1] = a0001020304[(unsigned __int16)((unsigned int)v5 % 0x2710
                                               - 100
                                               * ((unsigned __int16)((5243 * ((unsigned int)v5 % 0x2710)) >> 16) >> 3))];
    v7 -= 2LL;
    v9 = (unsigned int)v5 <= 0x5F5E0FF;
    LODWORD(v5) = (unsigned int)v5 / 0x2710;
  }
  while ( !v9 );
  v5 = v8;
  if ( v8 > 0x63 )
  {
LABEL_9:
    *(_WORD *)((char *)&v20[1] + v6) = a0001020304[(unsigned __int16)v5 % 0x64u];
    v6 -= 2LL;
    v5 = (unsigned int)(5243 * ((unsigned __int16)v5 >> 2)) >> 17;
  }
LABEL_10:
  if ( (unsigned int)v5 >= 0xA )
  {
    *(_WORD *)((char *)&v20[1] + v6) = a0001020304[v5];
    v10 = v6 - 2;
  }
  else
  {
    *((_BYTE *)&v20[1] + v6 + 1) = v5 | 0x30;
    v10 = v6 - 1;
  }
  return sub_405270(a2, v4 >= 0, 1LL, 0LL, (__int64)&v20[2] + v10, 10 - v10);
}
// 4428DB: using guessed type _WORD a0001020304[100];

//----- (0000000000439040) ----------------------------------------------------
__int64 __fastcall sub_439040(unsigned __int8 *a1, __int64 a2)
{
  return (*(__int64 (__fastcall **)(_QWORD, char *, _QWORD))(*(_QWORD *)(a2 + 56) + 24LL))(
           *(_QWORD *)(a2 + 48),
           (char *)&unk_44A8E0 + *((int *)&unk_44A8E0 + *a1),
           qword_44A790[*a1]);
}
// 44A790: using guessed type _QWORD qword_44A790[42];

//----- (0000000000439080) ----------------------------------------------------
char __fastcall sub_439080(__int64 *a1, __int64 a2)
{
  __int64 v2; // rax
  char result; // al
  void *v5; // rsi
  char v6; // bl
  HANDLE ProcessHeap; // rax
  __int64 v8; // rax
  char (__fastcall *v9)(__int64, __int64); // rcx
  void *v10; // [rsp+28h] [rbp-58h] BYREF
  __int64 v11; // [rsp+30h] [rbp-50h]
  char **v12; // [rsp+38h] [rbp-48h]
  __int64 v13; // [rsp+40h] [rbp-40h]
  __int64 v14; // [rsp+48h] [rbp-38h]
  char *v15; // [rsp+58h] [rbp-28h] BYREF
  char (__fastcall *v16)(__int64, __int64); // [rsp+60h] [rbp-20h]
  int *v17; // [rsp+68h] [rbp-18h]
  __int64 (__fastcall *v18)(int *, __int64); // [rsp+70h] [rbp-10h]
  char **v19; // [rsp+78h] [rbp-8h] BYREF
  LPVOID lpMem; // [rsp+80h] [rbp+0h]
  int v21; // [rsp+94h] [rbp+14h] BYREF

  v2 = *a1;
  switch ( *a1 & 3 )
  {
    case 0LL:
      result = sub_405B80(a2, *(unsigned __int16 **)v2, *(_QWORD *)(v2 + 8));
      break;
    case 1LL:
      result = (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)(v2 + 7) + 32LL))(*(_QWORD *)(v2 - 1));
      break;
    case 2LL:
      v21 = HIDWORD(*a1);
      sub_438770(&v19, HIDWORD(v2));
      v15 = (char *)&v19;
      v16 = sub_439230;
      v17 = &v21;
      v18 = sub_408AB0;
      v10 = &unk_448BE0;
      v11 = 3LL;
      v14 = 0LL;
      v12 = &v15;
      v13 = 2LL;
      result = sub_406180(*(_QWORD *)(a2 + 48), *(_QWORD *)(a2 + 56), &v10);
      if ( v19 )
      {
        v5 = lpMem;
        v6 = result;
        ProcessHeap = GetProcessHeap();
        HeapFree(ProcessHeap, 0, v5);
        result = v6;
      }
      break;
    case 3LL:
      v8 = v2 >> 32;
      v9 = (char (__fastcall *)(__int64, __int64))qword_44A4F0[v8];
      v15 = (&off_44A640)[v8];
      v16 = v9;
      v19 = &v15;
      lpMem = sub_4123C0;
      v10 = &unk_448868;
      v11 = 1LL;
      v14 = 0LL;
      v12 = (char **)&v19;
      v13 = 1LL;
      result = sub_406180(*(_QWORD *)(a2 + 48), *(_QWORD *)(a2 + 56), &v10);
      break;
  }
  return result;
}
// 44A4F0: using guessed type _QWORD qword_44A4F0[42];
// 44A640: using guessed type char *off_44A640;

//----- (0000000000439230) ----------------------------------------------------
char __fastcall sub_439230(__int64 a1, __int64 a2)
{
  return sub_405B80(a2, *(unsigned __int16 **)(a1 + 8), *(_QWORD *)(a1 + 16));
}

//----- (0000000000439250) ----------------------------------------------------
__int64 __fastcall sub_439250(__int64 a1, __int64 a2)
{
  unsigned int v2; // ebx
  __int64 v3; // r14
  unsigned __int64 v4; // rdi
  __int64 v5; // rsi
  __int64 v6; // r15
  unsigned __int8 (__fastcall *v7)(__int64, const char *, __int64); // r12
  char *v8; // r13
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // r12
  char *v11; // rdx
  char *v12; // rdx
  char *v13; // rax
  __int64 v14; // r9
  char v15; // r10
  unsigned int v16; // eax
  char *v17; // rdx
  unsigned __int64 v18; // r12
  _QWORD v20[6]; // [rsp+28h] [rbp-48h] BYREF
  _QWORD v21[2]; // [rsp+58h] [rbp-18h] BYREF
  unsigned int (__fastcall *v22)(__int64, const char *, __int64); // [rsp+68h] [rbp-8h]
  __int16 v23; // [rsp+76h] [rbp+6h] BYREF

  v3 = *(_QWORD *)(a1 + 8);
  v4 = *(_QWORD *)(a1 + 16);
  v5 = *(_QWORD *)(a2 + 48);
  v6 = *(_QWORD *)(a2 + 56);
  v7 = *(unsigned __int8 (__fastcall **)(__int64, const char *, __int64))(v6 + 24);
  LOBYTE(v2) = 1;
  if ( v7(v5, asc_4487BC, 1LL) )
    return v2;
  v22 = (unsigned int (__fastcall *)(__int64, const char *, __int64))v7;
  v8 = (char *)(v3 + v4);
  v9 = 0LL;
LABEL_3:
  if ( v9 != v4 )
  {
    v10 = v9;
    v11 = (char *)(v3 + v9);
    while ( 1 )
    {
      v13 = v11 + 1;
      v15 = *v11;
      v14 = 1LL;
      if ( *v11 < 0 )
      {
        if ( (unsigned __int8)v15 < 0xE0u )
        {
          v12 = v11 + 2;
          if ( v13 != v8 )
            v13 = v12;
          v14 = 2LL;
        }
        else if ( v15 == -19 )
        {
          if ( v13 == v8 || v11 + 2 == v8 )
            goto LABEL_27;
          v16 = (unsigned __int8)v11[1];
          if ( v16 > 0x9F )
          {
            v23 = (v11[2] & 0x3F) + ((v16 & 0x1F) << 6) - 10240;
            if ( v10 < v9 )
              sub_406FD0(v9, v10, (__int64)&off_4492B8);
            if ( v10 > v4 )
              sub_405B00(v10, v4, (__int64)&off_4492B8);
            if ( sub_439490(v5, v6, (unsigned __int8 *)(v3 + v9), v10 - v9) )
              return v2;
            v21[0] = &v23;
            v21[1] = sub_4067B0;
            v20[0] = &off_4492D8;
            v20[1] = 2LL;
            v20[4] = 0LL;
            v20[2] = v21;
            v20[3] = 1LL;
            if ( sub_406180(v5, v6, v20) )
              return v2;
            v18 = v10 + 3;
            v9 = v18;
            if ( v18 > v4 )
              sub_4050A0(v18, v4, (__int64)&off_449360);
            goto LABEL_3;
          }
          v14 = 3LL;
          v13 = v11 + 3;
        }
        else
        {
          v17 = v11 + 2;
          if ( v13 == v8 )
            v17 = v13;
          v13 = &v17[v17 != v8];
          v14 = 3LL;
          if ( (unsigned __int8)v15 >= 0xF0u )
          {
            v13 += v13 != v8;
            v14 = 4LL;
          }
        }
      }
      v10 += v14;
      v11 = v13;
      if ( v13 == v8 )
        goto LABEL_27;
    }
  }
  v9 = v4;
LABEL_27:
  if ( !sub_439490(v5, v6, (unsigned __int8 *)(v9 + v3), v4 - v9) )
    return v22(v5, asc_4487BC, 1LL);
  return v2;
}
// 439456: variable 'v2' is possibly undefined
// 4487BC: using guessed type char asc_4487BC;
// 4492B8: using guessed type char *off_4492B8;
// 4492D8: using guessed type char *off_4492D8;
// 449360: using guessed type char *off_449360;

//----- (0000000000439490) ----------------------------------------------------
char __fastcall sub_439490(__int64 a1, __int64 a2, unsigned __int8 *a3, __int64 a4)
{
  unsigned __int8 v4; // bl
  unsigned __int64 v5; // r12
  unsigned __int8 v6; // r13
  char v7; // r15
  unsigned __int8 *v8; // rdi
  unsigned __int8 *v9; // rsi
  unsigned __int8 v10; // r14
  __m128i si128; // xmm6
  __m128i v12; // xmm7
  __m128i v13; // xmm8
  unsigned int v14; // r12d
  int v15; // eax
  int v16; // edx
  int v17; // ecx
  char v18; // al
  char *v19; // rcx
  char v20; // al
  __int64 v21; // rdx
  __int64 v22; // rax
  unsigned int v23; // eax
  __int64 v24; // rax
  char v26; // [rsp+3Ch] [rbp-44h] BYREF
  unsigned __int8 *v27; // [rsp+48h] [rbp-38h]
  unsigned __int8 *v28; // [rsp+50h] [rbp-30h]
  _WORD v29[6]; // [rsp+58h] [rbp-28h] BYREF
  char v30; // [rsp+64h] [rbp-1Ch]
  __int64 v31; // [rsp+70h] [rbp-10h]
  __int64 v32; // [rsp+78h] [rbp-8h]
  _BYTE v33[12]; // [rsp+84h] [rbp+4h] BYREF

  v8 = a3;
  v31 = a2;
  v32 = a1;
  v9 = &a3[a4];
  v27 = a3;
  v28 = &a3[a4];
  LOBYTE(v29[0]) = -127;
  v30 = -127;
  v10 = -127;
  si128 = _mm_load_si128((const __m128i *)&xmmword_441F10);
  v12 = _mm_load_si128((const __m128i *)&xmmword_441F20);
  v13 = _mm_load_si128((const __m128i *)&xmmword_441F30);
  while ( 1 )
  {
    while ( v10 != 0x81 )
    {
      if ( v10 == 128 )
      {
        v21 = (unsigned int)(v5 >> 16);
        memset(v29, 0, sizeof(v29));
        v5 = 0LL;
        v7 = 0;
        v4 = 0;
        v6 = 0;
        v10 = 0;
      }
      else
      {
        if ( v6 >= v4 )
          break;
        LOBYTE(v29[0]) = v10;
        HIBYTE(v29[0]) = v7;
        *(_QWORD *)&v29[1] = v5;
        v22 = v6++;
        v21 = *((unsigned __int8 *)v29 + v22);
      }
      if ( (*(unsigned __int8 (__fastcall **)(__int64, __int64))(v31 + 32))(v32, v21) )
        return 1;
    }
    if ( !v8 || v8 == v9 )
      return 0;
    v14 = *v8;
    if ( (v14 & 0x80u) != 0 )
    {
      v15 = v14 & 0x1F;
      v16 = v8[1] & 0x3F;
      if ( (unsigned __int8)v14 <= 0xDFu )
      {
        v8 += 2;
        v14 = v16 | (v15 << 6);
        if ( v14 <= 0x27 )
          goto LABEL_12;
      }
      else
      {
        v17 = (v16 << 6) | v8[2] & 0x3F;
        if ( (unsigned __int8)v14 < 0xF0u )
        {
          v8 += 3;
          v14 = (v15 << 12) | v17;
          if ( v14 <= 0x27 )
            goto LABEL_12;
        }
        else
        {
          v14 = ((v14 & 7) << 18) | (v17 << 6) | v8[3] & 0x3F;
          if ( v14 == 1114112 )
            return 0;
          v8 += 4;
          if ( v14 <= 0x27 )
            goto LABEL_12;
        }
      }
LABEL_20:
      if ( v14 == 92 )
      {
        v7 = 92;
        v14 = 0;
        v10 = 92;
        goto LABEL_4;
      }
LABEL_22:
      if ( v14 <= 0x2FF )
      {
        v19 = v33;
        if ( v14 < 0x20 )
          goto LABEL_46;
        v10 = 0x80;
        if ( v14 < 0x7F )
          goto LABEL_4;
LABEL_35:
        v20 = sub_408030(v14, byte_443096, 40LL, (__int64)&unk_4430E6, 0x122uLL, byte_443208, 297LL);
LABEL_36:
        v10 = 0x80;
        v19 = v33;
        if ( v20 )
          goto LABEL_4;
        goto LABEL_46;
      }
      v18 = sub_407EB0(v14);
      v19 = &v26;
      if ( v18 )
        goto LABEL_46;
      if ( v14 < 0x10000 )
        goto LABEL_35;
      if ( v14 < 0x20000 )
      {
        v20 = sub_408030(v14, byte_442D88, 44LL, (__int64)&unk_442DE0, 0xD0uLL, asc_442EB0, 486LL);
        goto LABEL_36;
      }
      v19 = v33;
      if ( _mm_movemask_ps((__m128)_mm_cmpgt_epi32(
                                     _mm_xor_si128(
                                       _mm_add_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(v14), 0), si128),
                                       v12),
                                     v13)) == 0
        && v14 - 917760 < 0xFFF522B0
        && v14 - 196608 < 0xFFFFFA1E
        && v14 - 201552 < 0xFFFFFFFB
        && (v14 & 0x1FFFE0) != 0x2A6E0
        && v14 <= 0xE01EF )
      {
        v10 = 0x80;
        if ( (v14 & 0x1FFFFE) != 0x2B81E )
          goto LABEL_4;
      }
LABEL_46:
      _BitScanReverse(&v23, v14 | 1);
      v24 = (v23 ^ 0x1C) >> 2;
      v6 = v24 - 2;
      v19[2] = 0;
      *(_WORD *)v19 = 0;
      v19[3] = a0123456789abcd[v14 >> 20];
      v19[4] = a0123456789abcd[HIWORD(v14) & 0xF];
      v19[5] = a0123456789abcd[(unsigned __int16)v14 >> 12];
      v19[6] = a0123456789abcd[(v14 >> 8) & 0xF];
      v19[7] = a0123456789abcd[(unsigned __int8)v14 >> 4];
      v19[8] = a0123456789abcd[v14 & 0xF];
      v19[9] = 125;
      *(_WORD *)&v19[v24 - 2] = 30044;
      v19[v24] = 123;
      v10 = *v19;
      v7 = v19[1];
      v5 = *(_QWORD *)(v19 + 2);
      v4 = 10;
      if ( *v19 == -127 )
        return 0;
    }
    else
    {
      ++v8;
LABEL_12:
      v10 = 92;
      switch ( v14 )
      {
        case 0u:
          v7 = 48;
          goto LABEL_4;
        case 1u:
        case 2u:
        case 3u:
        case 4u:
        case 5u:
        case 6u:
        case 7u:
        case 8u:
        case 0xBu:
        case 0xCu:
        case 0xEu:
        case 0xFu:
        case 0x10u:
        case 0x11u:
        case 0x12u:
        case 0x13u:
        case 0x14u:
        case 0x15u:
        case 0x16u:
        case 0x17u:
        case 0x18u:
        case 0x19u:
        case 0x1Au:
        case 0x1Bu:
        case 0x1Cu:
        case 0x1Du:
        case 0x1Eu:
        case 0x1Fu:
        case 0x20u:
        case 0x21u:
        case 0x23u:
        case 0x24u:
        case 0x25u:
        case 0x26u:
          goto LABEL_22;
        case 9u:
          v7 = 116;
          break;
        case 0xAu:
          v7 = 110;
          break;
        case 0xDu:
          v7 = 114;
          break;
        case 0x22u:
          v7 = 34;
          break;
        case 0x27u:
          v7 = 39;
          break;
        default:
          goto LABEL_20;
      }
      v14 = 0;
LABEL_4:
      v5 = (unsigned __int64)v14 << 16;
      v4 = 2;
      v6 = 0;
    }
  }
}
// 439537: variable 'v6' is possibly undefined
// 439537: variable 'v4' is possibly undefined
// 439727: variable 'v5' is possibly undefined
// 439754: variable 'v7' is possibly undefined
// 441F10: using guessed type __int128 xmmword_441F10;
// 441F20: using guessed type __int128 xmmword_441F20;
// 441F30: using guessed type __int128 xmmword_441F30;
// 442D88: using guessed type _BYTE byte_442D88[88];
// 443096: using guessed type _BYTE byte_443096[80];

//----- (00000000004398F0) ----------------------------------------------------
void *__fastcall sub_4398F0(__int64 a1, _BYTE *a2, size_t a3)
{
  unsigned __int64 v5; // rbx
  int v6; // r14d
  char v7; // al
  __int64 v8; // r8
  __int16 v9; // r15
  unsigned int v10; // r12d
  __int16 v11; // r15
  unsigned __int64 v12; // rax
  unsigned __int64 v13; // rcx
  __m128i v14; // xmm6
  __int64 v15; // rcx
  _BYTE *v16; // r14
  char *v17; // rax
  char *v18; // r8
  char *v19; // r8
  char *v20; // rcx
  char v21; // r9
  char *v22; // r8
  void *result; // rax
  _BYTE *v24; // r14
  _BYTE *v25; // r13
  _BYTE *v26; // r14

  v5 = *(_QWORD *)(a1 + 16);
  v6 = 0;
  v7 = 0;
  if ( v5 >= 3 )
  {
    v8 = *(_QWORD *)(a1 + 8);
    v6 = 0;
    if ( (*(_BYTE *)(v8 + v5 - 2) & 0xF0) == 0xA0 )
    {
      v6 = 0;
      if ( *(_BYTE *)(v8 + v5 - 3) == 0xED )
      {
        v6 = ((*(_BYTE *)(v8 + v5 - 2) & 0xF) << 16) | ((*(_BYTE *)(v8 + v5 - 1) & 0x3F) << 10);
        v7 = 1;
      }
    }
  }
  if ( a3 < 3 )
  {
    if ( !a3 )
      goto LABEL_33;
  }
  else if ( *a2 == 0xED )
  {
    v9 = (unsigned __int8)a2[1];
    if ( !(((a2[1] & 0xF0) != 0xB0) | (unsigned __int8)v7 ^ 1) )
    {
      if ( v5 >= 3 )
      {
        v5 -= 3LL;
        *(_QWORD *)(a1 + 16) = v5;
      }
      v10 = (unsigned __int8)a2[2];
      v11 = v9 << 6;
      v12 = *(_QWORD *)a1;
      v13 = *(_QWORD *)a1 - v5;
      if ( v13 < a3 + 1 )
      {
        v25 = a2;
        sub_413290((unsigned __int64 *)a1, v5, a3 + 1, 1LL, 1LL);
        a2 = v25;
        v12 = *(_QWORD *)a1;
        v5 = *(_QWORD *)(a1 + 16);
        v13 = *(_QWORD *)a1 - v5;
      }
      v14 = _mm_or_si128(
              _mm_and_si128(
                _mm_cvtsi32_si128((((v6 | v11 & 0x3C0 | v10) + 0x10000) >> 18) | (((v6 | v11 & 0x3C0 | v10) + 0x10000) >> 4) & 0xFF00 | ((v6 | v11 & 0x3C0) << 10) & 0xFF0000 | ((v6 | v11 & 0x3C0 | v10) << 24)),
                (__m128i)xmmword_441FE0),
              (__m128i)xmmword_441FF0);
      if ( v13 <= 3 )
      {
        v26 = a2;
        sub_413290((unsigned __int64 *)a1, v5, 4LL, 1LL, 1LL);
        a2 = v26;
        v12 = *(_QWORD *)a1;
        v5 = *(_QWORD *)(a1 + 16);
      }
      a2 += 3;
      v15 = *(_QWORD *)(a1 + 8);
      *(_DWORD *)(v15 + v5) = _mm_cvtsi128_si32(v14);
      v5 += 4LL;
      *(_QWORD *)(a1 + 16) = v5;
      a3 -= 3LL;
      if ( v12 - v5 < a3 )
      {
        v16 = a2;
        sub_413290((unsigned __int64 *)a1, v5, a3, 1LL, 1LL);
        a2 = v16;
        v15 = *(_QWORD *)(a1 + 8);
        v5 = *(_QWORD *)(a1 + 16);
      }
      goto LABEL_36;
    }
  }
  v17 = &a2[a3];
  v18 = a2;
  while ( 1 )
  {
    v20 = v18 + 1;
    v21 = *v18;
    if ( *v18 < 0 )
      break;
LABEL_20:
    v18 = v20;
    if ( v20 == v17 )
      goto LABEL_33;
  }
  if ( (unsigned __int8)v21 < 0xE0u )
  {
    v19 = v18 + 2;
    if ( v20 != v17 )
      v20 = v19;
    goto LABEL_20;
  }
  if ( v21 != -19 )
  {
    v22 = v18 + 2;
    if ( v20 == v17 )
      v22 = v20;
    v20 = &v22[v22 != v17];
    if ( (unsigned __int8)v21 >= 0xF0u )
      v20 += v20 != v17;
    goto LABEL_20;
  }
  if ( v20 == v17 || v18 + 2 == v17 )
    goto LABEL_33;
  if ( (unsigned __int8)v18[1] <= 0x9Fu )
  {
    v20 = v18 + 3;
    goto LABEL_20;
  }
  *(_BYTE *)(a1 + 24) = 0;
LABEL_33:
  if ( *(_QWORD *)a1 - v5 < a3 )
  {
    v24 = a2;
    sub_413290((unsigned __int64 *)a1, v5, a3, 1LL, 1LL);
    a2 = v24;
    v5 = *(_QWORD *)(a1 + 16);
  }
  v15 = *(_QWORD *)(a1 + 8);
LABEL_36:
  result = memcpy((void *)(v5 + v15), a2, a3);
  *(_QWORD *)(a1 + 16) = a3 + v5;
  return result;
}
// 441FE0: using guessed type __int128 xmmword_441FE0;
// 441FF0: using guessed type __int128 xmmword_441FF0;

//----- (0000000000439BD0) ----------------------------------------------------
unsigned int __fastcall sub_439BD0(__int64 a1, unsigned __int8 *a2, void *a3)
{
  unsigned __int8 *v4; // r15
  unsigned __int64 v5; // r14
  unsigned __int8 v6; // bl
  __int64 v7; // r13
  unsigned __int64 v8; // rdx
  unsigned __int8 *v9; // rcx
  unsigned __int64 v10; // rcx
  __int64 v11; // rcx
  __int64 v12; // rcx
  bool v13; // di
  __int64 v14; // rdx
  __int64 v15; // r12
  unsigned __int64 v16; // rcx
  __int64 v17; // rdx
  __int64 v18; // rcx
  unsigned int result; // eax
  unsigned __int8 *v20; // rdi
  _QWORD *v21; // rax
  _QWORD *v22; // r14
  __int128 v23; // xmm0
  __int128 v24; // xmm1
  __int128 v25; // xmm0
  __int128 v26; // xmm1
  unsigned __int8 *v27; // rdx
  unsigned __int64 v28; // rcx
  __int64 v29; // rdx
  __int64 v30; // rdx
  bool v31; // al
  __int64 v32; // rax
  __int64 v33; // rcx
  __int128 v34; // xmm1
  __int128 v35; // xmm2
  char v36; // r14
  __int64 v37; // rax
  __int64 v38; // rcx
  bool v39; // zf
  _BYTE *v40; // rcx
  __int64 v41; // r12
  __int64 v42; // r15
  __int64 v43; // r12
  __int64 v44; // rax
  __int64 v45; // rcx
  __int128 v46; // xmm1
  __int128 v47; // xmm2
  HANDLE ProcessHeap; // rax
  _OWORD *v49; // rsi
  void *v50; // rdi
  HANDLE v51; // rax
  __int128 v52; // xmm0
  _OWORD v53[3]; // [rsp+30h] [rbp-50h] BYREF
  __int64 v54; // [rsp+60h] [rbp-20h]
  __int64 v55; // [rsp+A0h] [rbp+20h]
  _BYTE v56[15]; // [rsp+A8h] [rbp+28h]
  __int128 v57; // [rsp+B8h] [rbp+38h]
  __int128 v58; // [rsp+C8h] [rbp+48h]
  _BYTE v59[64]; // [rsp+D8h] [rbp+58h] BYREF
  __int128 v60; // [rsp+118h] [rbp+98h] BYREF
  __int64 v61; // [rsp+128h] [rbp+A8h]
  __int128 v62; // [rsp+130h] [rbp+B0h] BYREF
  __int128 v63; // [rsp+140h] [rbp+C0h]
  __int128 v64; // [rsp+150h] [rbp+D0h]
  __int128 v65; // [rsp+160h] [rbp+E0h]
  __int128 v66; // [rsp+170h] [rbp+F0h] BYREF
  __int128 v67; // [rsp+180h] [rbp+100h]
  __int128 v68; // [rsp+190h] [rbp+110h]
  __int64 v69; // [rsp+1A0h] [rbp+120h]
  unsigned __int8 *v70; // [rsp+1B0h] [rbp+130h]
  _QWORD *v71; // [rsp+1B8h] [rbp+138h]
  LPVOID lpMem; // [rsp+1C0h] [rbp+140h]

  lpMem = a3;
  v4 = *(unsigned __int8 **)(a1 + 8);
  v71 = (_QWORD *)a1;
  v5 = *(_QWORD *)(a1 + 16);
  sub_434DE0((__int64)&v62, v4, v5);
  v6 = v62;
  v7 = v63;
  v8 = v5;
  v9 = v4;
  switch ( (char)v62 )
  {
    case 0:
    case 3:
      v10 = v63 + 4;
      goto LABEL_11;
    case 1:
      v11 = v64 + 1;
      if ( !(_QWORD)v64 )
        v11 = 0LL;
      v10 = v63 + v11 + 8;
      goto LABEL_11;
    case 2:
      v10 = 6LL;
      goto LABEL_11;
    case 4:
      v12 = v64 + 1;
      if ( !(_QWORD)v64 )
        v12 = 0LL;
      v10 = v63 + v12 + 2;
      goto LABEL_11;
    case 5:
      v10 = 2LL;
LABEL_11:
      v8 = v5 - v10;
      if ( v5 < v10 )
        sub_4050A0(v10, v5, (__int64)&off_448DF0);
      v9 = &v4[v10];
      break;
    case 6:
      break;
  }
  if ( v8 )
    v13 = *v9 == 47 || *v9 == 92;
  else
    v13 = 0;
  *(_QWORD *)&v56[7] = *((_QWORD *)&v62 + 1);
  *(_QWORD *)v56 = *(_QWORD *)((char *)&v62 + 1);
  v70 = v4;
  v55 = v64;
  if ( (_BYTE)v62 != 6 )
  {
    switch ( (char)v62 )
    {
      case 0:
      case 3:
        JUMPOUT(0x439D19LL);
      case 1:
        v14 = v64 + 1;
        if ( !(_QWORD)v64 )
          v14 = 0LL;
        if ( (_QWORD)v63 + v14 != -8 )
        {
          switch ( (char)v62 )
          {
            case 0:
            case 1:
            case 2:
            case 3:
              goto LABEL_23;
            case 4:
              JUMPOUT(0x439F5DLL);
          }
        }
        return result;
      case 2:
        break;
    }
  }
LABEL_23:
  v15 = *((_QWORD *)&v63 + 1);
  if ( !(unsigned __int8)sub_434CA0(a2, lpMem) )
  {
    sub_434DE0((__int64)&v62, a2, (unsigned __int64)lpMem);
    switch ( (char)v62 )
    {
      case 0:
      case 3:
        v16 = v63 + 4;
        goto LABEL_32;
      case 1:
        JUMPOUT(0x439E05LL);
      case 2:
        v16 = 6LL;
        goto LABEL_32;
      case 4:
        v17 = v64 + 1;
        if ( !(_QWORD)v64 )
          v17 = 0LL;
        v16 = v17 + v63 + 2;
        goto LABEL_32;
      case 5:
        v16 = 2LL;
LABEL_32:
        if ( v16 > (unsigned __int64)lpMem )
          sub_4050A0(v16, (__int64)lpMem, (__int64)&off_448DF0);
        break;
      case 6:
        if ( v6 == 6 || v6 >= 3u || lpMem == 0LL )
        {
          sub_434DE0((__int64)&v62, a2, (unsigned __int64)lpMem);
          JUMPOUT(0x439F14LL);
        }
        *(_QWORD *)v59 = v70;
        *(_QWORD *)&v59[8] = v5;
        v59[16] = v6;
        *(_QWORD *)&v59[17] = *(_QWORD *)v56;
        *(_QWORD *)&v59[24] = *(_QWORD *)&v56[7];
        *(_QWORD *)&v59[32] = v7;
        *(_QWORD *)&v59[40] = v15;
        *(_QWORD *)&v59[48] = v55;
        *(_WORD *)&v59[56] = 512;
        v59[58] = v13;
        sub_435280((__int64)v53, (__int64)v59);
        if ( LOBYTE(v53[0]) == 10 )
        {
          *(_QWORD *)&v66 = 0LL;
          *((_QWORD *)&v66 + 1) = 8LL;
          *(_QWORD *)&v67 = 0LL;
          v20 = a2;
        }
        else
        {
          v21 = sub_43C4F0(0xE0uLL);
          if ( !v21 )
            sub_4040E9(8LL, 224LL);
          v22 = v21;
          v21[6] = v54;
          v23 = v53[0];
          v24 = v53[1];
          *((_OWORD *)v21 + 2) = v53[2];
          *((_OWORD *)v21 + 1) = v24;
          *(_OWORD *)v21 = v23;
          *(_QWORD *)&v60 = 4LL;
          *((_QWORD *)&v60 + 1) = v21;
          v61 = 1LL;
          v65 = *(_OWORD *)&v59[48];
          v64 = *(_OWORD *)&v59[32];
          v63 = *(_OWORD *)&v59[16];
          v62 = *(_OWORD *)v59;
          sub_435280((__int64)&v66, (__int64)&v62);
          v20 = a2;
          if ( (_BYTE)v66 != 10 )
          {
            if ( (_QWORD)v60 == 1LL )
            {
              sub_413290((unsigned __int64 *)&v60, 1LL, 1LL, 8LL, 56LL);
              v22 = (_QWORD *)*((_QWORD *)&v60 + 1);
            }
            v22[13] = v69;
            v25 = v66;
            v26 = v67;
            *(_OWORD *)(v22 + 11) = v68;
            *(_OWORD *)(v22 + 9) = v26;
            *(_OWORD *)(v22 + 7) = v25;
            v61 = 2LL;
            JUMPOUT(0x43A0D4LL);
          }
          v66 = v60;
          *(_QWORD *)&v67 = v61;
        }
        sub_434DE0((__int64)v59, v20, (unsigned __int64)lpMem);
        v27 = v20;
        switch ( (unsigned __int64)v20 )
        {
          case 0uLL:
          case 3uLL:
            v28 = *(_QWORD *)&v59[16] + 4LL;
            goto LABEL_58;
          case 1uLL:
            v29 = *(_QWORD *)&v59[32] + 1LL;
            if ( !*(_QWORD *)&v59[32] )
              v29 = 0LL;
            v28 = v29 + *(_QWORD *)&v59[16] + 8;
            goto LABEL_58;
          case 2uLL:
            v28 = 6LL;
            goto LABEL_58;
          case 4uLL:
            v30 = *(_QWORD *)&v59[32] + 1LL;
            if ( !*(_QWORD *)&v59[32] )
              v30 = 0LL;
            v28 = v30 + *(_QWORD *)&v59[16] + 2;
            goto LABEL_58;
          case 5uLL:
            v28 = 2LL;
LABEL_58:
            if ( v28 > (unsigned __int64)lpMem )
              sub_4050A0(v28, (__int64)lpMem, (__int64)&off_448DF0);
            if ( (LPVOID)v28 == lpMem )
            {
              v31 = 0;
            }
            else
            {
              v27 = &v20[v28];
LABEL_62:
              v31 = *v27 == 47 || *v27 == 92;
            }
            *(_QWORD *)&v65 = *(_QWORD *)&v59[32];
            v64 = *(_OWORD *)&v59[16];
            v63 = *(_OWORD *)v59;
            *(_QWORD *)&v62 = v20;
            *((_QWORD *)&v62 + 1) = lpMem;
            WORD4(v65) = 512;
            BYTE10(v65) = v31;
            while ( 1 )
            {
              sub_435280((__int64)v59, (__int64)&v62);
              v36 = v59[0];
              if ( v59[0] == 10LL )
                break;
              v37 = v59[0] - 5LL;
              if ( (unsigned __int8)(v59[0] - 6) >= 4u )
                v37 = 0LL;
              if ( v37 == 1 )
              {
                v41 = v67;
                v42 = v67 != 0;
                *(_QWORD *)&v67 = v42;
                if ( (_QWORD)v66 == v42 )
                  sub_437220((unsigned __int64 *)&v66, (__int64)&off_448F80);
                v32 = *((_QWORD *)&v66 + 1);
                v33 = 56 * v42;
                *(_BYTE *)(*((_QWORD *)&v66 + 1) + v33) = v36;
                v34 = *(_OWORD *)&v59[17];
                v35 = *(_OWORD *)&v59[33];
                *(_OWORD *)(v32 + v33 + 1) = *(_OWORD *)&v59[1];
                *(_OWORD *)(v32 + v33 + 17) = v34;
                *(_OWORD *)(v32 + v33 + 33) = v35;
                *(_QWORD *)(v32 + v33 + 48) = *(_QWORD *)&v59[48];
                *(_QWORD *)&v67 = 1 - ((v41 == 0) - 1LL);
              }
              else if ( v37 != 2 )
              {
                if ( v37 == 3 )
                {
                  v38 = *((_QWORD *)&v66 + 1) + 56 * v67;
                  v39 = v38 == 56;
                  v40 = (_BYTE *)(v38 - 56);
                  if ( (_QWORD)v67 != 0LL && !v39 && *v40 == 9 )
                    *(_QWORD *)&v67 = v67 - 1;
                }
                else
                {
                  v43 = v67;
                  if ( (_QWORD)v67 == (_QWORD)v66 )
                    sub_437220((unsigned __int64 *)&v66, (__int64)&off_448F98);
                  v44 = *((_QWORD *)&v66 + 1);
                  v45 = 56 * v43;
                  *(_BYTE *)(*((_QWORD *)&v66 + 1) + v45) = v36;
                  v46 = *(_OWORD *)&v59[17];
                  v47 = *(_OWORD *)&v59[33];
                  *(_OWORD *)(v44 + v45 + 1) = *(_OWORD *)&v59[1];
                  *(_OWORD *)(v44 + v45 + 17) = v46;
                  *(_OWORD *)(v44 + v45 + 33) = v47;
                  *(_QWORD *)(v44 + v45 + 48) = *(_QWORD *)&v59[48];
                  *(_QWORD *)&v67 = v43 + 1;
                }
              }
            }
            *(_QWORD *)&v57 = 0LL;
            *((_QWORD *)&v57 + 1) = 1LL;
            *(_QWORD *)&v58 = 0LL;
            BYTE8(v58) = 1;
            lpMem = (LPVOID)*((_QWORD *)&v66 + 1);
            v70 = (unsigned __int8 *)v66;
            result = v67;
            if ( (_QWORD)v67 )
            {
              result = 0;
              if ( *(_BYTE *)lpMem != 10LL )
                JUMPOUT(0x43A5B4LL);
            }
            if ( v70 )
            {
              ProcessHeap = GetProcessHeap();
              result = HeapFree(ProcessHeap, 0, lpMem);
            }
            v49 = v71;
            if ( *v71 )
            {
              v50 = (void *)v71[1];
              v51 = GetProcessHeap();
              result = HeapFree(v51, 0, v50);
            }
            v52 = v57;
            v49[1] = v58;
            *v49 = v52;
            break;
          case 6uLL:
            goto LABEL_62;
        }
        return result;
    }
  }
  v18 = (__int64)v71;
  v71[2] = 0LL;
  return (unsigned int)sub_4398F0(v18, a2, (size_t)lpMem);
}
// 439D16: control flows out of bounds to 439D19
// 439E02: control flows out of bounds to 439E05
// 439F0F: control flows out of bounds to 439F14
// 439F59: control flows out of bounds to 439F5D
// 43A0D1: control flows out of bounds to 43A0D4
// 43A5AE: control flows out of bounds to 43A5B4
// 434CA0: using guessed type __int64 __fastcall sub_434CA0(_QWORD, _QWORD);
// 448DF0: using guessed type char *off_448DF0;
// 448F80: using guessed type char *off_448F80;
// 448F98: using guessed type char *off_448F98;

//----- (000000000043A830) ----------------------------------------------------
void __fastcall sub_43A830(__int64 a1, unsigned __int64 a2, unsigned __int64 a3)
{
  char v3; // al
  char **v4; // rax
  _QWORD v5[6]; // [rsp+28h] [rbp-48h] BYREF
  unsigned __int64 v6; // [rsp+58h] [rbp-18h] BYREF
  unsigned __int64 *v7; // [rsp+60h] [rbp-10h] BYREF
  __int64 (__fastcall *v8)(unsigned __int64 *, __int64); // [rsp+68h] [rbp-8h]

  v6 = a3;
  if ( !a3 )
    return;
  if ( a3 >= a2 )
  {
    if ( a3 == a2 )
      return;
    v7 = &v6;
    v8 = sub_405120;
    v4 = &off_449398;
    goto LABEL_15;
  }
  v3 = *(_BYTE *)(a1 + a3);
  if ( v3 != -19 )
  {
    if ( v3 > -65 )
      return;
    v7 = &v6;
    v8 = sub_405120;
    v4 = &off_449420;
LABEL_15:
    v5[0] = v4;
    v5[1] = 2LL;
    v5[4] = 0LL;
    v5[2] = &v7;
    v5[3] = 1LL;
    sub_405240((__int64)v5, (__int64)&off_448810);
  }
  if ( a3 + 1 >= a2 )
    sub_4050B0(a3 + 1, a2, (__int64)&off_448810);
  if ( a3 >= 3 && *(_BYTE *)(a1 + a3 + 1) > 0x9Fu && *(_BYTE *)(a1 + a3 - 3) == 0xED && *(_BYTE *)(a1 + a3 - 2) >= 0xA0u )
  {
    v7 = &v6;
    v8 = sub_405120;
    v4 = &off_4493E0;
    goto LABEL_15;
  }
}
// 448810: using guessed type char *off_448810;
// 449398: using guessed type char *off_449398;
// 4493E0: using guessed type char *off_4493E0;
// 449420: using guessed type char *off_449420;

//----- (000000000043A920) ----------------------------------------------------
int __fastcall sub_43A920(__int64 a1, unsigned __int8 *a2, __int64 a3, int a4)
{
  __int64 v8; // rax
  unsigned __int64 v9; // rdx
  void *v10; // rdi
  HANDLE FirstFile; // rax
  unsigned __int64 v12; // rdx
  WCHAR *v13; // r14
  __int64 v14; // r12
  __int128 v15; // xmm0
  __m128 v16; // xmm1
  unsigned int v17; // ecx
  unsigned __int64 v18; // rdx
  HANDLE ProcessHeap; // rax
  __int128 FindFileData[37]; // [rsp+38h] [rbp-48h] BYREF
  __int64 v22; // [rsp+288h] [rbp+208h] BYREF
  LPCWSTR lpFileName; // [rsp+290h] [rbp+210h]
  __int128 v24; // [rsp+2A0h] [rbp+220h] BYREF
  __int64 v25; // [rsp+2B0h] [rbp+230h]
  _QWORD v26[2]; // [rsp+2B8h] [rbp+238h] BYREF
  int v27; // [rsp+2C8h] [rbp+248h]
  __int64 v28; // [rsp+2CCh] [rbp+24Ch]
  __int64 v29; // [rsp+2D4h] [rbp+254h]
  __int16 v30; // [rsp+2DCh] [rbp+25Ch]

  v28 = 0x700000000LL;
  v30 = 0;
  v29 = 0LL;
  v26[1] = 0LL;
  v26[0] = 1LL;
  v27 = a4 | 0x2000000;
  v8 = sub_432610(a2, a3, (__int64)v26);
  v10 = (void *)v9;
  if ( v8 )
  {
    LODWORD(FirstFile) = v9 & 3;
    if ( (_DWORD)FirstFile == 2 && ((v12 = HIDWORD(v9), v12 == 5) || (_DWORD)v12 == 32) )
    {
      sub_4329C0((__int64)&v24, a2, a3);
      v13 = (WCHAR *)*((_QWORD *)&v24 + 1);
      LODWORD(FirstFile) = v24;
      if ( __OFSUB__(-(__int64)v24, 1LL)
        || (FindFileData[0] = v24,
            *(_QWORD *)&FindFileData[1] = v25,
            sub_432CE0(&v22, FindFileData),
            LODWORD(FirstFile) = 0,
            v14 = v22,
            v13 = (WCHAR *)lpFileName,
            v22 == 0x8000000000000000uLL) )
      {
        *(_QWORD *)(a1 + 8) = v13;
        *(_QWORD *)a1 = 2LL;
      }
      else
      {
        memset(FindFileData, 0, sizeof(FindFileData));
        FirstFile = FindFirstFileExW(lpFileName, FindExInfoBasic, FindFileData, FindExSearchNameMatch, 0LL, 0);
        if ( FirstFile == (HANDLE)-1LL
          || (FindClose(FirstFile),
              LODWORD(FirstFile) = FindFileData[0],
              v15 = *(__int128 *)((char *)FindFileData + 4),
              v16 = (__m128)*(unsigned __int64 *)((char *)&FindFileData[1] + 4),
              v17 = DWORD1(FindFileData[2]) & ((int)(LODWORD(FindFileData[0]) << 21) >> 31),
              !a4)
          && ((unsigned __int8)(LODWORD(FindFileData[0]) >> 10) & (v17 >> 29) & 1) != 0 )
        {
          *(_QWORD *)(a1 + 8) = v10;
          *(_QWORD *)a1 = 2LL;
        }
        else
        {
          v18 = LODWORD(FindFileData[2]) | ((unsigned __int64)HIDWORD(FindFileData[1]) << 32);
          *(_QWORD *)a1 = 0LL;
          *(_DWORD *)(a1 + 16) = 0;
          *(_DWORD *)(a1 + 24) = 0;
          *(_OWORD *)(a1 + 32) = v15;
          _mm_storel_ps((double *)(a1 + 48), v16);
          *(_QWORD *)(a1 + 56) = v18;
          *(_DWORD *)(a1 + 64) = 0;
          *(_DWORD *)(a1 + 76) = (_DWORD)FirstFile;
          *(_DWORD *)(a1 + 80) = v17;
        }
        if ( v14 )
        {
          ProcessHeap = GetProcessHeap();
          LODWORD(FirstFile) = HeapFree(ProcessHeap, 0, v13);
        }
      }
    }
    else
    {
      *(_QWORD *)(a1 + 8) = v10;
      *(_QWORD *)a1 = 2LL;
    }
  }
  else
  {
    sub_4328B0(a1, (void *)v9);
    LODWORD(FirstFile) = CloseHandle(v10);
  }
  return (int)FirstFile;
}
// 43A9A0: variable 'v9' is possibly undefined

//----- (000000000043AB70) ----------------------------------------------------
char **__fastcall sub_43AB70(__int64 a1, unsigned __int8 *a2, unsigned __int64 a3)
{
  unsigned __int64 v5; // rax
  unsigned __int8 *v6; // rbx
  char **result; // rax
  __int64 v8; // rbx
  char **v9; // rcx

  v5 = *(_QWORD *)a1;
  if ( *(_QWORD *)a1 - *(_QWORD *)(a1 + 16) < a3 )
  {
    v6 = a2;
    result = sub_437AD0(a1);
    if ( result )
      return result;
    v5 = *(_QWORD *)a1;
    a2 = v6;
  }
  if ( v5 <= a3 )
  {
    *(_BYTE *)(a1 + 24) = 1;
    v9 = sub_43AC10((unsigned __int8 *)(a1 + 25), a2, a3);
    result = 0LL;
    if ( ((unsigned __int64)v9 & 0xFFFFFFFF00000003uLL) != 0x600000002LL )
      result = v9;
    *(_BYTE *)(a1 + 24) = 0;
  }
  else
  {
    v8 = *(_QWORD *)(a1 + 16);
    memcpy((void *)(v8 + *(_QWORD *)(a1 + 8)), a2, a3);
    *(_QWORD *)(a1 + 16) = a3 + v8;
    return 0LL;
  }
  return result;
}

//----- (000000000043AC10) ----------------------------------------------------
char **__fastcall sub_43AC10(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // rsi
  __int64 v6; // rax
  unsigned __int64 v7; // rdx
  void *v8; // r14
  _QWORD *v9; // r15
  __int64 v10; // r12
  HANDLE ProcessHeap; // rax
  HANDLE v12; // rax

  if ( a3 )
  {
    v3 = a3;
    do
    {
      v6 = sub_435C30(0xFFFFFFF5, a2, v3, a1);
      if ( v6 )
      {
        switch ( v7 & 3 )
        {
          case 0uLL:
            if ( *(_BYTE *)(v7 + 16) == 35 )
              break;
            return (char **)v7;
          case 1uLL:
            if ( *(_BYTE *)(v7 + 15) != 35 )
              return (char **)v7;
            if ( (v6 & 1) != 0 )
            {
              v8 = (void *)(v7 - 1);
              v9 = *(_QWORD **)(v7 - 1);
              v10 = *(_QWORD *)(v7 + 7);
              if ( *(_QWORD *)v10 )
                (*(void (__fastcall **)(_QWORD))v10)(*(_QWORD *)(v7 - 1));
              if ( *(_QWORD *)(v10 + 8) )
              {
                if ( *(_QWORD *)(v10 + 16) >= 0x11uLL )
                  v9 = (_QWORD *)*(v9 - 1);
                ProcessHeap = GetProcessHeap();
                HeapFree(ProcessHeap, 0, v9);
              }
              v12 = GetProcessHeap();
              HeapFree(v12, 0, v8);
            }
            break;
          case 2uLL:
            return (char **)v7;
          case 3uLL:
            if ( HIDWORD(v7) != 35 )
              return (char **)v7;
            break;
        }
      }
      else
      {
        if ( !v7 )
          return &off_448D10;
        if ( v3 < v7 )
          sub_4050A0(v7, v3, (__int64)&off_448D28);
        a2 += v7;
        v3 -= v7;
      }
    }
    while ( v3 );
  }
  return 0LL;
}
// 43AC40: variable 'v7' is possibly undefined
// 448D10: using guessed type char *off_448D10;
// 448D28: using guessed type char *off_448D28;

//----- (000000000043AD86) ----------------------------------------------------
void sub_43AD86()
{
  _QWORD v0[2]; // [rsp+30h] [rbp-20h] BYREF
  _QWORD *v1; // [rsp+40h] [rbp-10h] BYREF
  char v2; // [rsp+4Fh] [rbp-1h] BYREF

  if ( dword_450080 != 3 )
  {
    v0[0] = &qword_450048;
    v0[1] = &v2;
    v1 = v0;
    sub_437590(&dword_450080, 1, (__int64)&v1, (__int64)&unk_449058, (__int64)&off_449040);
  }
}
// 450048: using guessed type __int64 qword_450048;
// 450080: using guessed type int dword_450080;

//----- (000000000043ADF0) ----------------------------------------------------
LPVOID __fastcall sub_43ADF0(__int64 **a1)
{
  __int64 v1; // rsi
  LPVOID result; // rax

  v1 = **a1;
  **a1 = 0LL;
  if ( !v1 )
    sub_407050((__int64)&off_449080);
  result = sub_43C4F0(0x400uLL);
  if ( !result )
    sub_4040E9(1LL, 1024LL);
  *(_QWORD *)v1 = 0LL;
  *(_DWORD *)(v1 + 8) = 0;
  *(_BYTE *)(v1 + 12) = 0;
  *(_QWORD *)(v1 + 16) = 0LL;
  *(_QWORD *)(v1 + 24) = 1024LL;
  *(_QWORD *)(v1 + 32) = result;
  *(_QWORD *)(v1 + 40) = 0LL;
  *(_BYTE *)(v1 + 48) = 0;
  *(_BYTE *)(v1 + 53) = 0;
  *(_DWORD *)(v1 + 49) = 0;
  return result;
}
// 449080: using guessed type char *off_449080;

//----- (000000000043AE90) ----------------------------------------------------
LPVOID __fastcall sub_43AE90(__int64 **a1)
{
  __int64 v1; // rsi
  LPVOID result; // rax

  v1 = **a1;
  **a1 = 0LL;
  if ( !v1 )
    sub_407050((__int64)&off_449080);
  result = sub_43C4F0(0x400uLL);
  if ( !result )
    sub_4040E9(1LL, 1024LL);
  *(_QWORD *)v1 = 0LL;
  *(_DWORD *)(v1 + 8) = 0;
  *(_BYTE *)(v1 + 12) = 0;
  *(_QWORD *)(v1 + 16) = 0LL;
  *(_QWORD *)(v1 + 24) = 1024LL;
  *(_QWORD *)(v1 + 32) = result;
  *(_QWORD *)(v1 + 40) = 0LL;
  *(_BYTE *)(v1 + 48) = 0;
  *(_BYTE *)(v1 + 53) = 0;
  *(_DWORD *)(v1 + 49) = 0;
  return result;
}
// 449080: using guessed type char *off_449080;

//----- (000000000043AF30) ----------------------------------------------------
char **__fastcall sub_43AF30(__int64 a1, unsigned __int8 *a2, size_t a3)
{
  size_t v3; // rdi
  unsigned __int8 *v4; // rbx
  size_t v6; // rdx
  __int64 v7; // rax
  __int64 v8; // r8
  bool v9; // cf
  unsigned __int64 v10; // rcx
  size_t *v11; // r14
  unsigned __int8 *v12; // rax
  unsigned __int64 v13; // r9
  __int64 v14; // r15
  bool v15; // zf
  unsigned __int64 v16; // r15
  __int64 v17; // r12
  char **result; // rax
  unsigned __int8 *v19; // r13
  __int64 v20; // r8
  unsigned __int64 v21; // rax
  unsigned __int8 *v22; // r9
  __int64 v23; // r12
  __int64 v24; // rax
  __int64 v25; // r15
  _QWORD v26[3]; // [rsp+20h] [rbp-30h] BYREF
  __int128 v27; // [rsp+38h] [rbp-18h]
  size_t *v28; // [rsp+50h] [rbp+0h]

  if ( *(_QWORD *)(a1 + 16) )
    sub_406750((__int64)&off_448C48);
  v3 = a3;
  v4 = a2;
  v6 = ((unsigned __int64)(a2 + 7) & 0xFFFFFFFFFFFFFFF8uLL) - (_QWORD)a2;
  v7 = ((_BYTE)a3 - (_BYTE)v6) & 0xF;
  v8 = 0LL;
  v9 = v3 < v6;
  *(_QWORD *)(a1 + 16) = -1LL;
  if ( v3 <= v6 )
    v6 = v3;
  if ( !v9 )
    v8 = v7;
  v10 = v3 - v8;
  if ( v3 < v8 )
    sub_4050A0(v10, v3, (__int64)&off_442A10);
  v11 = (size_t *)(a1 + 24);
  v12 = &v4[v3 - 1];
  v13 = v8;
  do
  {
    if ( !v13 )
    {
      v28 = (size_t *)(a1 + 24);
      v19 = &v4[~v8];
      v20 = -v8;
      do
      {
        v21 = v10;
        v22 = v19;
        v23 = v20;
        if ( v10 <= v6 )
          break;
        v10 -= 16LL;
        v19 -= 16;
        v20 -= 16LL;
      }
      while ( ((*(_QWORD *)&v4[v21 - 8] ^ 0xA0A0A0A0A0A0A0ALL | (0x101010101010100LL
                                                               - (*(_QWORD *)&v4[v21 - 8] ^ 0xA0A0A0A0A0A0A0ALL))) & (*(_QWORD *)&v4[v21 - 16] | (0x101010101010100LL - (*(_QWORD *)&v4[v21 - 16] ^ 0xA0A0A0A0A0A0A0ALL))) & 0x8080808080808080uLL) == 0x8080808080808080uLL );
      if ( v21 > v3 )
        sub_405B00(v21, v3, (__int64)&off_442A28);
      v11 = v28;
      while ( v23 + v3 )
      {
        v24 = v23;
        v15 = v22[v3] == 10;
        --v22;
        --v23;
        if ( v15 )
        {
          v16 = v3 + v24;
          v9 = v3 < v3 + v24;
          v3 = -v24;
          if ( v9 )
          {
LABEL_24:
            v26[0] = &off_4479E0;
            v26[1] = 1LL;
            v26[2] = 8LL;
            v27 = 0LL;
            sub_405240((__int64)v26, (__int64)&off_4488A8);
          }
          goto LABEL_11;
        }
      }
      v25 = *(_QWORD *)(a1 + 40);
      if ( v25 )
      {
        if ( *(_BYTE *)(*(_QWORD *)(a1 + 32) + v25 - 1) == 10 )
        {
          result = sub_437AD0((__int64)v28);
          if ( result )
            goto LABEL_28;
          v25 = *(_QWORD *)(a1 + 40);
        }
        if ( *v28 - v25 > v3 )
          goto LABEL_27;
      }
      else
      {
        v25 = 0LL;
        if ( *v28 > v3 )
          goto LABEL_27;
      }
      goto LABEL_34;
    }
    v14 = v13--;
    v15 = *v12-- == 10;
  }
  while ( !v15 );
  v16 = v10 + v14;
  v9 = v3 < v16;
  v3 -= v16;
  if ( v9 )
    goto LABEL_24;
LABEL_11:
  v17 = *(_QWORD *)(a1 + 40);
  if ( !v17 )
  {
    result = sub_43AC10((unsigned __int8 *)(a1 + 49), v4, v16);
    if ( ((unsigned __int64)result & 0xFFFFFFFF00000003uLL) != 0x600000002LL && result != 0LL )
      goto LABEL_28;
    goto LABEL_26;
  }
  if ( v16 < *v11 - v17 )
  {
    memcpy((void *)(v17 + *(_QWORD *)(a1 + 32)), v4, v16);
    *(_QWORD *)(a1 + 40) = v16 + v17;
LABEL_14:
    result = sub_437AD0((__int64)v11);
    if ( result )
      goto LABEL_28;
LABEL_26:
    v4 += v16;
    v25 = *(_QWORD *)(a1 + 40);
    if ( v3 < *(_QWORD *)(a1 + 24) - v25 )
    {
LABEL_27:
      memcpy((void *)(v25 + *(_QWORD *)(a1 + 32)), v4, v3);
      *(_QWORD *)(a1 + 40) = v3 + v25;
      result = 0LL;
      goto LABEL_28;
    }
LABEL_34:
    result = sub_43AB70((__int64)v11, v4, v3);
    goto LABEL_28;
  }
  result = sub_43AB70((__int64)v11, v4, v16);
  if ( !result )
    goto LABEL_14;
LABEL_28:
  ++*(_QWORD *)(a1 + 16);
  return result;
}
// 442A10: using guessed type char *off_442A10;
// 442A28: using guessed type char *off_442A28;
// 4479E0: using guessed type char *off_4479E0;
// 4488A8: using guessed type char *off_4488A8;
// 448C48: using guessed type char *off_448C48;

//----- (000000000043B230) ----------------------------------------------------
bool __fastcall sub_43B230(__int64 a1, unsigned __int8 *a2, size_t a3)
{
  char **v4; // rdi
  __int64 v5; // rcx

  v4 = sub_43AF30(**(_QWORD **)a1, a2, a3);
  if ( v4 )
  {
    v5 = *(_QWORD *)(a1 + 8);
    if ( v5 )
      sub_4131C0(v5);
    *(_QWORD *)(a1 + 8) = v4;
  }
  return v4 != 0LL;
}

//----- (000000000043B280) ----------------------------------------------------
bool __fastcall sub_43B280(__int64 a1, unsigned int a2)
{
  size_t v3; // r8
  char **v4; // rdi
  __int64 v5; // rcx
  unsigned __int8 v7[20]; // [rsp+2Ch] [rbp-4h] BYREF

  *(_DWORD *)v7 = 0;
  if ( a2 >= 0x80 )
  {
    if ( a2 >= 0x800 )
    {
      if ( a2 >= 0x10000 )
      {
        v7[0] = (a2 >> 18) | 0xF0;
        v7[1] = (a2 >> 12) & 0x3F | 0x80;
        v7[2] = (a2 >> 6) & 0x3F | 0x80;
        v7[3] = a2 & 0x3F | 0x80;
        v3 = 4LL;
      }
      else
      {
        v7[0] = (a2 >> 12) | 0xE0;
        v7[1] = (a2 >> 6) & 0x3F | 0x80;
        v7[2] = a2 & 0x3F | 0x80;
        v3 = 3LL;
      }
    }
    else
    {
      v7[0] = (a2 >> 6) | 0xC0;
      v7[1] = a2 & 0x3F | 0x80;
      v3 = 2LL;
    }
  }
  else
  {
    v7[0] = a2;
    v3 = 1LL;
  }
  v4 = sub_43AF30(**(_QWORD **)a1, v7, v3);
  if ( v4 )
  {
    v5 = *(_QWORD *)(a1 + 8);
    if ( v5 )
      sub_4131C0(v5);
    *(_QWORD *)(a1 + 8) = v4;
  }
  return v4 != 0LL;
}

//----- (000000000043B370) ----------------------------------------------------
char __fastcall sub_43B370(__int64 a1, _QWORD *a2)
{
  return sub_406180(a1, (__int64)&off_448178, a2);
}
// 448178: using guessed type __int64 (__fastcall *off_448178)();

//----- (000000000043B390) ----------------------------------------------------
__int64 __fastcall sub_43B390(__int64 **a1, _QWORD *a2)
{
  __int64 v3; // rbx
  LPVOID Value; // rdi
  int v5; // eax
  DWORD v6; // eax
  char v7; // cl
  __int64 result; // rax
  __int64 v9; // rcx
  bool v10; // zf
  void *v11; // rsi
  _QWORD *v12; // rbx
  __int64 v13; // r14
  HANDLE ProcessHeap; // rax
  HANDLE v15; // rax
  char v16; // dl
  __int64 v17; // rsi
  _QWORD v18[3]; // [rsp+28h] [rbp-48h] BYREF
  __int128 v19; // [rsp+40h] [rbp-30h]
  __int64 *v20; // [rsp+58h] [rbp-18h] BYREF
  __int64 v21; // [rsp+60h] [rbp-10h]
  __int64 v22; // [rsp+68h] [rbp-8h] BYREF

  v3 = **a1;
  if ( dword_450100 )
  {
    Value = TlsGetValue(dword_450100 - 1);
    if ( Value )
      goto LABEL_3;
LABEL_7:
    Value = sub_437520();
    if ( Value == *(LPVOID *)v3 )
      goto LABEL_4;
    goto LABEL_8;
  }
  v6 = sub_412510((signed __int64)&unk_4500E8);
  Value = TlsGetValue(v6);
  if ( !Value )
    goto LABEL_7;
LABEL_3:
  if ( Value == *(LPVOID *)v3 )
  {
LABEL_4:
    v5 = *(_DWORD *)(v3 + 8);
    if ( v5 == -1 )
      sub_407070();
    *(_DWORD *)(v3 + 8) = v5 + 1;
    goto LABEL_11;
  }
LABEL_8:
  if ( _InterlockedCompareExchange8((volatile signed __int8 *)(v3 + 12), 1, 0) )
    sub_413070((signed __int8 *)(v3 + 12));
  *(_QWORD *)v3 = Value;
  *(_DWORD *)(v3 + 8) = 1;
LABEL_11:
  v22 = v3;
  v20 = &v22;
  v21 = 0LL;
  v7 = sub_406180((__int64)&v20, (__int64)&off_448148, a2);
  result = v21;
  if ( v7 )
  {
    if ( !v21 )
    {
      v18[0] = &off_448D98;
      v18[1] = 1LL;
      v18[2] = 8LL;
      v19 = 0LL;
      sub_405240((__int64)v18, (__int64)&off_448DA8);
    }
    v9 = v22;
    v10 = (*(_DWORD *)(v22 + 8))-- == 1;
    if ( v10 )
    {
LABEL_24:
      *(_QWORD *)v9 = 0LL;
      v16 = *(_BYTE *)(v9 + 12);
      *(_BYTE *)(v9 + 12) = 0;
      if ( v16 == 2 )
      {
        v17 = result;
        WakeByAddressSingle((PVOID)(v9 + 12));
        return v17;
      }
    }
  }
  else
  {
    if ( (v21 & 3) == 1 )
    {
      v11 = (void *)(v21 - 1);
      v12 = *(_QWORD **)(v21 - 1);
      v13 = *(_QWORD *)(v21 + 7);
      if ( *(_QWORD *)v13 )
        (*(void (__fastcall **)(_QWORD *))v13)(v12);
      if ( *(_QWORD *)(v13 + 8) )
      {
        if ( *(_QWORD *)(v13 + 16) >= 0x11uLL )
          v12 = (_QWORD *)*(v12 - 1);
        ProcessHeap = GetProcessHeap();
        HeapFree(ProcessHeap, 0, v12);
      }
      v15 = GetProcessHeap();
      HeapFree(v15, 0, v11);
    }
    result = 0LL;
    v9 = v22;
    v10 = (*(_DWORD *)(v22 + 8))-- == 1;
    if ( v10 )
      goto LABEL_24;
  }
  return result;
}
// 448148: using guessed type __int64 (__fastcall *off_448148)();
// 448D98: using guessed type char *off_448D98;
// 448DA8: using guessed type char *off_448DA8;
// 450100: using guessed type int dword_450100;

//----- (000000000043B5A0) ----------------------------------------------------
bool __fastcall sub_43B5A0(__int64 **a1, unsigned __int8 *a2, unsigned __int64 a3)
{
  __int64 v3; // rdi
  char **v5; // rax
  char **v6; // rbx
  __int64 v7; // rcx

  v3 = **a1;
  if ( *(_QWORD *)(v3 + 16) )
    sub_406750((__int64)&off_448C60);
  *(_QWORD *)(v3 + 16) = -1LL;
  v5 = sub_412EF0((unsigned __int8 *)(v3 + 24), a2, a3);
  v6 = 0LL;
  if ( ((unsigned __int64)v5 & 0xFFFFFFFF00000003uLL) != 0x600000002LL )
    v6 = v5;
  ++*(_QWORD *)(v3 + 16);
  if ( v6 )
  {
    v7 = (__int64)a1[1];
    if ( v7 )
      sub_4131C0(v7);
    a1[1] = (__int64 *)v6;
  }
  return v6 != 0LL;
}
// 448C60: using guessed type char *off_448C60;

//----- (000000000043B640) ----------------------------------------------------
bool __fastcall sub_43B640(__int64 **a1, unsigned int a2)
{
  unsigned __int64 v3; // r8
  __int64 v4; // rdi
  char **v5; // rax
  char **v6; // rbx
  __int64 v7; // rcx
  unsigned __int8 v9[28]; // [rsp+24h] [rbp+4h] BYREF

  *(_DWORD *)v9 = 0;
  if ( a2 >= 0x80 )
  {
    if ( a2 >= 0x800 )
    {
      if ( a2 >= 0x10000 )
      {
        v9[0] = (a2 >> 18) | 0xF0;
        v9[1] = (a2 >> 12) & 0x3F | 0x80;
        v9[2] = (a2 >> 6) & 0x3F | 0x80;
        v9[3] = a2 & 0x3F | 0x80;
        v3 = 4LL;
      }
      else
      {
        v9[0] = (a2 >> 12) | 0xE0;
        v9[1] = (a2 >> 6) & 0x3F | 0x80;
        v9[2] = a2 & 0x3F | 0x80;
        v3 = 3LL;
      }
    }
    else
    {
      v9[0] = (a2 >> 6) | 0xC0;
      v9[1] = a2 & 0x3F | 0x80;
      v3 = 2LL;
    }
  }
  else
  {
    v9[0] = a2;
    v3 = 1LL;
  }
  v4 = **a1;
  if ( *(_QWORD *)(v4 + 16) )
    sub_406750((__int64)&off_448C60);
  *(_QWORD *)(v4 + 16) = -1LL;
  v5 = sub_412EF0((unsigned __int8 *)(v4 + 24), v9, v3);
  v6 = 0LL;
  if ( ((unsigned __int64)v5 & 0xFFFFFFFF00000003uLL) != 0x600000002LL )
    v6 = v5;
  ++*(_QWORD *)(v4 + 16);
  if ( v6 )
  {
    v7 = (__int64)a1[1];
    if ( v7 )
      sub_4131C0(v7);
    a1[1] = (__int64 *)v6;
  }
  return v6 != 0LL;
}
// 448C60: using guessed type char *off_448C60;

//----- (000000000043B780) ----------------------------------------------------
char __fastcall sub_43B780(__int64 a1, _QWORD *a2)
{
  return sub_406180(a1, (__int64)&off_448148, a2);
}
// 448148: using guessed type __int64 (__fastcall *off_448148)();

//----- (000000000043B7A0) ----------------------------------------------------
int __fastcall sub_43B7A0(_QWORD *a1)
{
  __int64 v1; // rsi
  int result; // eax
  __int64 v3; // rax
  void *v4; // rsi
  _QWORD *v5; // rdi
  __int64 v6; // r14
  HANDLE ProcessHeap; // rax
  HANDLE v8; // rax
  _QWORD v9[10]; // [rsp+0h] [rbp-30h] BYREF

  v9[5] = &unk_450088;
  v9[4] = &v9[5];
  v1 = sub_43B390((__int64 **)&v9[4], a1);
  result = v1 & 3;
  if ( result == 1 )
  {
    v3 = v1;
    v4 = (void *)(v1 - 1);
    v5 = *(_QWORD **)(v3 - 1);
    v6 = *(_QWORD *)(v3 + 7);
    if ( *(_QWORD *)v6 )
      (*(void (__fastcall **)(_QWORD *))v6)(v5);
    if ( *(_QWORD *)(v6 + 8) )
    {
      if ( *(_QWORD *)(v6 + 16) >= 0x11uLL )
        v5 = (_QWORD *)*(v5 - 1);
      ProcessHeap = GetProcessHeap();
      HeapFree(ProcessHeap, 0, v5);
    }
    v8 = GetProcessHeap();
    return HeapFree(v8, 0, v4);
  }
  return result;
}

//----- (000000000043B870) ----------------------------------------------------
void __fastcall sub_43B870(_QWORD *a1)
{
  int v2; // ecx
  LPVOID Value; // rsi
  int v4; // eax
  DWORD v5; // eax
  char v6; // al
  char (__fastcall *v7)(__int64, __int64); // r15
  char *v8; // rdi
  _QWORD *v9; // rbx
  __int64 v10; // r15
  HANDLE ProcessHeap; // rax
  HANDLE v12; // rax
  __int64 v13; // rcx
  bool v14; // zf
  char v15; // al
  _QWORD v16[2]; // [rsp+20h] [rbp-60h] BYREF
  char **v17; // [rsp+30h] [rbp-50h] BYREF
  __int64 v18; // [rsp+38h] [rbp-48h]
  __int64 v19; // [rsp+40h] [rbp-40h]
  __int128 v20; // [rsp+48h] [rbp-38h]
  _QWORD *v21; // [rsp+60h] [rbp-20h] BYREF
  char (__fastcall *v22)(__int64, __int64); // [rsp+68h] [rbp-18h]
  _QWORD *v23; // [rsp+70h] [rbp-10h]
  char (__fastcall *v24)(__int64 *, __int64); // [rsp+78h] [rbp-8h]
  _QWORD v25[6]; // [rsp+80h] [rbp+0h] BYREF

  v16[0] = aStdout;
  v16[1] = 6LL;
  if ( dword_450080 == 3 )
  {
    v2 = dword_450100;
    if ( dword_450100 )
      goto LABEL_3;
  }
  else
  {
    sub_43AD86();
    v2 = dword_450100;
    if ( dword_450100 )
    {
LABEL_3:
      Value = TlsGetValue(v2 - 1);
      if ( Value )
        goto LABEL_4;
LABEL_9:
      Value = sub_437520();
      if ( Value == (LPVOID)qword_450048 )
        goto LABEL_5;
      goto LABEL_10;
    }
  }
  v5 = sub_412510((signed __int64)&unk_4500E8);
  Value = TlsGetValue(v5);
  if ( !Value )
    goto LABEL_9;
LABEL_4:
  if ( Value == (LPVOID)qword_450048 )
  {
LABEL_5:
    if ( dword_450050 == -1 )
      sub_407070();
    v4 = dword_450050 + 1;
    goto LABEL_13;
  }
LABEL_10:
  if ( _InterlockedCompareExchange8(&byte_450054, 1, 0) )
    sub_413070(&byte_450054);
  qword_450048 = (__int64)Value;
  v4 = 1;
LABEL_13:
  dword_450050 = v4;
  v25[0] = &qword_450048;
  v21 = v25;
  v22 = 0LL;
  v6 = sub_406180((__int64)&v21, (__int64)&off_448178, a1);
  v7 = v22;
  if ( v6 )
  {
    if ( !v22 )
    {
      v17 = &off_448D98;
      v18 = 1LL;
      v19 = 8LL;
      v20 = 0LL;
      sub_405240((__int64)&v17, (__int64)&off_448DA8);
    }
    goto LABEL_24;
  }
  if ( ((unsigned __int8)v22 & 3) == 1 )
  {
    v8 = (char *)v22 - 1;
    v9 = *(_QWORD **)((char *)v22 - 1);
    v10 = *(_QWORD *)((char *)v22 + 7);
    if ( *(_QWORD *)v10 )
      (*(void (__fastcall **)(_QWORD *))v10)(v9);
    if ( *(_QWORD *)(v10 + 8) )
    {
      if ( *(_QWORD *)(v10 + 16) >= 0x11uLL )
        v9 = (_QWORD *)*(v9 - 1);
      ProcessHeap = GetProcessHeap();
      HeapFree(ProcessHeap, 0, v9);
    }
    v12 = GetProcessHeap();
    v7 = 0LL;
    HeapFree(v12, 0, v8);
LABEL_24:
    v13 = v25[0];
    v14 = (*(_DWORD *)(v25[0] + 8LL))-- == 1;
    if ( !v14 )
      goto LABEL_28;
    goto LABEL_27;
  }
  v7 = 0LL;
  v13 = v25[0];
  v14 = (*(_DWORD *)(v25[0] + 8LL))-- == 1;
  if ( !v14 )
    goto LABEL_28;
LABEL_27:
  *(_QWORD *)v13 = 0LL;
  v15 = *(_BYTE *)(v13 + 12);
  *(_BYTE *)(v13 + 12) = 0;
  if ( v15 != 2 )
  {
LABEL_28:
    if ( !v7 )
      return;
LABEL_32:
    v25[0] = v7;
    v21 = v16;
    v22 = sub_4123C0;
    v23 = v25;
    v24 = sub_439080;
    v17 = &off_448C90;
    v18 = 2LL;
    v19 = (__int64)&v21;
    v20 = 2uLL;
    sub_405240((__int64)&v17, (__int64)&off_448CB0);
  }
  WakeByAddressSingle((PVOID)(v13 + 12));
  if ( v7 )
    goto LABEL_32;
}
// 448178: using guessed type __int64 (__fastcall *off_448178)();
// 448C90: using guessed type char *off_448C90;
// 448CB0: using guessed type char *off_448CB0;
// 448D98: using guessed type char *off_448D98;
// 448DA8: using guessed type char *off_448DA8;
// 450048: using guessed type __int64 qword_450048;
// 450050: using guessed type int dword_450050;
// 450054: using guessed type char byte_450054;
// 450080: using guessed type int dword_450080;
// 450100: using guessed type int dword_450100;

//----- (000000000043BB40) ----------------------------------------------------
__int64 __fastcall sub_43BB40(unsigned __int8 *a1, unsigned __int64 a2)
{
  __int64 v2; // r12
  unsigned __int64 v3; // rsi
  unsigned __int8 *v4; // rdi
  int v5; // r10d
  unsigned __int64 v6; // rdx
  unsigned __int8 *v7; // r8
  unsigned __int64 v8; // rcx
  __int64 v9; // rdx
  __int64 v10; // rdx
  bool v11; // r13
  unsigned int v12; // r14d
  int v13; // r15d
  __int64 v14; // rcx
  int v15; // r14d
  __int128 *v16; // rcx
  unsigned __int8 *v17; // rax
  char v18; // dl
  __int64 v19; // r8
  unsigned __int64 v20; // r9
  __int64 v21; // rdx
  bool v22; // r11
  bool v23; // dl
  unsigned __int8 *v24; // r8
  unsigned __int8 v25; // dl
  unsigned __int8 *v26; // r15
  __int64 v27; // rdi
  int v28; // r12d
  __int128 *v29; // rbx
  char v30; // r9
  __int64 v31; // r8
  __int64 result; // rax
  char v33; // r11
  unsigned __int64 v34; // rcx
  unsigned __int64 v35; // r12
  __int64 v36; // r9
  __int64 v37; // rcx
  int v38; // ebx
  unsigned __int8 *v39; // rdx
  bool v40; // r9
  unsigned __int8 v41; // cl
  __int64 v42; // rdx
  int v43; // edx
  __int64 v44; // [rsp+0h] [rbp-80h] BYREF
  __int128 v45; // [rsp+20h] [rbp-60h] BYREF
  __int128 v46; // [rsp+30h] [rbp-50h]
  __int64 v47; // [rsp+40h] [rbp-40h]
  unsigned __int8 *v48; // [rsp+60h] [rbp-20h] BYREF
  unsigned __int64 v49; // [rsp+68h] [rbp-18h]
  __int128 v50; // [rsp+70h] [rbp-10h]
  __int128 v51; // [rsp+80h] [rbp+0h]
  __int64 v52; // [rsp+90h] [rbp+10h]
  __int16 v53; // [rsp+98h] [rbp+18h]
  bool v54; // [rsp+9Ah] [rbp+1Ah]
  __int64 v55; // [rsp+A0h] [rbp+20h]
  __int64 v56; // [rsp+A8h] [rbp+28h]
  __int64 v57; // [rsp+B0h] [rbp+30h]
  int v58; // [rsp+BCh] [rbp+3Ch]
  __int64 v59; // [rsp+C0h] [rbp+40h]

  v3 = a2;
  v4 = a1;
  sub_434DE0((__int64)(&v44 + 4), a1, a2);
  v6 = v3;
  v7 = v4;
  switch ( v3 )
  {
    case 0uLL:
    case 3uLL:
      v8 = v46 + 4;
      goto LABEL_11;
    case 1uLL:
      v9 = v47 + 1;
      if ( !v47 )
        v9 = 0LL;
      v8 = v9 + v46 + 8;
      goto LABEL_11;
    case 2uLL:
      v8 = 6LL;
      goto LABEL_11;
    case 4uLL:
      v10 = v47 + 1;
      if ( !v47 )
        v10 = 0LL;
      v8 = v10 + v46 + 2;
      goto LABEL_11;
    case 5uLL:
      v8 = 2LL;
LABEL_11:
      v6 = v3 - v8;
      if ( v3 < v8 )
        sub_4050A0(v8, v3, (__int64)&off_448DF0);
      v7 = &v4[v8];
      break;
    case 6uLL:
      break;
  }
  if ( v6 )
    v11 = *v7 == 47 || *v7 == 92;
  else
    v11 = 0;
  v48 = v4;
  v49 = v3;
  v50 = v45;
  v51 = v46;
  v52 = v47;
  v54 = v11;
  v53 = 512;
  v12 = (unsigned __int8)v45;
  LOBYTE(v5) = (unsigned __int8)v45 == 6;
  v13 = (unsigned __int8)v45 - 5;
  v14 = v47 + 1;
  if ( !v47 )
    v14 = 0LL;
  v56 = v46 + v14 + 2;
  v57 = v46 + v14 + 8;
  v59 = v46 + 4;
  v55 = (unsigned __int8)v45;
  if ( v11 )
  {
    v15 = HIBYTE(v53);
    v16 = &v45;
    while ( 2 )
    {
      v17 = &v4[v3];
      v18 = 2;
      LODWORD(v19) = v15;
      do
      {
        v15 = v19;
        if ( v18 != 2 )
        {
          HIBYTE(v53) = v19;
          if ( !v3 )
            sub_405B00(-1LL, 0LL, (__int64)&off_448F18);
          return 0LL;
        }
        if ( v11 || (unsigned __int8)v13 >= 2u )
          goto LABEL_26;
        if ( !((unsigned __int8)v5 | (v3 >= 2)) )
        {
          HIBYTE(v53) = v19;
          sub_4050A0(2LL, v3, (__int64)&off_448E10);
        }
        v21 = 2 * ((unsigned __int8)v5 ^ 1u);
        if ( v21 == v3 )
        {
LABEL_26:
          v22 = 0;
        }
        else
        {
          v24 = &v4[v21 + 1];
          v25 = v4[v21];
          if ( v24 == v17 || v25 != 46 )
            v22 = v25 == 46 && v24 == v17;
          else
            v22 = *v24 == 92 || *v24 == 47;
        }
        switch ( v55 )
        {
          case 0LL:
          case 3LL:
            v23 = v11;
            v19 = v59;
            break;
          case 1LL:
            v23 = v11;
            v19 = v57;
            break;
          case 2LL:
            v19 = 6LL;
            goto LABEL_37;
          case 4LL:
            v23 = v11;
            v19 = v56;
            break;
          case 5LL:
            v19 = 2LL;
LABEL_37:
            v23 = v11;
            break;
          case 6LL:
            v23 = v11;
            v19 = 0LL;
            break;
        }
        v20 = v19 + v22 + (unsigned __int64)v23;
        LOBYTE(v19) = 1;
        v18 = 1;
      }
      while ( v3 <= v20 );
      v58 = v13;
      v26 = v4;
      v27 = v2;
      v28 = v5;
      HIBYTE(v53) = v15;
      v29 = v16;
      sub_435740((__int64)v16, (__int64)&v48, v19, v20);
      if ( v3 < (unsigned __int64)v45 )
        sub_405B00(v3 - v45, v3, (__int64)&off_448F30);
      v30 = BYTE8(v45);
      v31 = v46;
      v49 = v3 - v45;
      v3 -= v45;
      v5 = v28;
      v16 = v29;
      v2 = v27;
      v4 = v26;
      v13 = v58;
      if ( BYTE8(v45) == 10 )
        continue;
      break;
    }
LABEL_40:
    result = 0LL;
    if ( v30 == 9 )
      return v31;
  }
  else
  {
    v33 = 2;
    result = 0LL;
    v34 = v3;
    do
    {
      while ( 1 )
      {
        do
        {
          do
          {
            do
            {
              while ( 1 )
              {
                v35 = v34;
                if ( v33 == 1 )
                  break;
                if ( v33 != 2 )
                  return result;
                v36 = 0LL;
                if ( (unsigned __int8)v13 >= 2u )
                  goto LABEL_60;
                if ( (_BYTE)v5 )
                {
                  v37 = 0LL;
                }
                else
                {
                  v37 = 2LL;
                  if ( v3 <= 1 )
                    sub_4050A0(2LL, v3, (__int64)&off_448E10);
                }
                if ( v37 == v3 )
                {
LABEL_60:
                  v36 = 0LL;
                }
                else
                {
                  v39 = &v4[v37 + 1];
                  v40 = v39 == &v4[v3];
                  v41 = v4[v37];
                  if ( v40 || v41 != 46 )
                    LOBYTE(v36) = v41 == 46 && v40;
                  else
                    LOBYTE(v36) = *v39 == 92 || *v39 == 47;
                }
                switch ( v12 )
                {
                  case 0u:
                    v42 = v59;
                    goto LABEL_61;
                  case 1u:
                    v42 = v57;
                    goto LABEL_61;
                  case 2u:
                    v42 = 6LL;
LABEL_61:
                    if ( v35 <= v42 + (unsigned __int64)(unsigned __int8)v36 )
                    {
                      HIBYTE(v53) = 1;
                      v33 = 1;
                      v34 = v35;
                    }
                    else
                    {
                      v38 = v5;
                      sub_435740((__int64)&v45, (__int64)&v48, (unsigned __int8)v36, v36);
                      v3 = v35 - v45;
                      if ( v35 < (unsigned __int64)v45 )
                        sub_405B00(v35 - v45, v35, (__int64)&off_448F30);
                      v30 = BYTE8(v45);
                      v31 = v46;
                      v49 = v35 - v45;
                      v33 = 2;
                      v34 = v35 - v45;
                      v5 = v38;
                      result = 0LL;
                      if ( BYTE8(v45) != 10 )
                        goto LABEL_40;
                    }
                    break;
                  default:
                    goto LABEL_49;
                }
              }
              HIBYTE(v53) = 0;
              v33 = 0;
            }
            while ( v12 < 3 );
LABEL_49:
            v34 = v35;
          }
          while ( v12 == 5 );
          if ( v12 != 6 )
            return 0LL;
          v33 = 0;
          v34 = 0LL;
        }
        while ( !v35 );
        if ( v35 != 1 && *v4 == 46 )
          break;
        v33 = 0;
        v34 = v35;
        if ( *v4 == 46 && v35 == 1 )
          goto LABEL_79;
      }
      v43 = v4[1];
      if ( v43 == 47 )
        break;
      v33 = 0;
      v34 = v35;
    }
    while ( v43 != 92 );
LABEL_79:
    if ( !v3 )
      sub_405B00(-1LL, 0LL, (__int64)&off_448F00);
    return 0LL;
  }
  return result;
}
// 43BD97: variable 'v2' is possibly undefined
// 43BD9A: variable 'v5' is possibly undefined
// 448DF0: using guessed type char *off_448DF0;
// 448E10: using guessed type char *off_448E10;
// 448F00: using guessed type char *off_448F00;
// 448F18: using guessed type char *off_448F18;
// 448F30: using guessed type char *off_448F30;

//----- (000000000043C0B0) ----------------------------------------------------
unsigned __int64 __fastcall sub_43C0B0(_QWORD *a1, char *a2, char *a3)
{
  char *v4; // rdi
  char *v5; // r12
  size_t v6; // rbx
  char *v7; // rdx
  char *v8; // rax
  __int64 v9; // r8
  char v10; // r9
  char *v11; // rdx
  unsigned __int64 result; // rax
  _BYTE *v13; // rax
  _BYTE *v14; // r15
  size_t v15; // r14
  __int64 v16; // r14
  unsigned __int64 v17; // rbx
  char *v18; // r9
  unsigned __int64 v19; // r13
  char *v20; // r9
  char *v21; // rax
  __int64 v22; // rdx
  char v23; // r8
  char *v24; // r9
  char *v25; // r8
  char *v26; // rbx
  __int64 v27; // r14
  unsigned __int64 v28; // r13
  char *v29; // rsi
  char *v30; // r14
  char *Src; // [rsp+38h] [rbp-28h]
  char **v33; // [rsp+40h] [rbp-20h]
  char *v34; // [rsp+48h] [rbp-18h]
  LPVOID lpMem[2]; // [rsp+50h] [rbp-10h] BYREF
  __int64 v36; // [rsp+60h] [rbp+0h]

  v4 = a2;
  if ( !a3 )
  {
LABEL_18:
    a1[1] = v4;
    a1[2] = a3;
    result = 0x8000000000000000uLL;
    *a1 = 0x8000000000000000uLL;
    return result;
  }
  v5 = &a3[(_QWORD)a2];
  v6 = 0LL;
  while ( 1 )
  {
    v8 = a2 + 1;
    v10 = *a2;
    v9 = 1LL;
    if ( *a2 < 0 )
      break;
LABEL_6:
    v6 += v9;
    a2 = v8;
    if ( v8 == v5 )
      goto LABEL_18;
  }
  if ( (unsigned __int8)v10 < 0xE0u )
  {
    v7 = a2 + 2;
    if ( v8 != v5 )
      v8 = v7;
    v9 = 2LL;
    goto LABEL_6;
  }
  if ( v10 != -19 )
  {
    v11 = a2 + 2;
    if ( v8 == v5 )
      v11 = v8;
    v8 = &v11[v11 != v5];
    v9 = 3LL;
    if ( (unsigned __int8)v10 >= 0xF0u )
    {
      v8 += v8 != v5;
      v9 = 4LL;
    }
    goto LABEL_6;
  }
  if ( v8 == v5 || a2 + 2 == v5 )
    goto LABEL_18;
  if ( (unsigned __int8)a2[1] <= 0x9Fu )
  {
    v9 = 3LL;
    v8 = a2 + 3;
    goto LABEL_6;
  }
  if ( (__int64)a3 < 0 )
    sub_4040B0((__int64)&off_449318);
  v13 = sub_43C4F0((SIZE_T)a3);
  if ( !v13 )
    sub_4040E9(1LL, (__int64)a3);
  v14 = v13;
  lpMem[0] = a3;
  lpMem[1] = v13;
  if ( (unsigned __int64)a3 < v6 )
  {
    v33 = &off_449330;
    goto LABEL_59;
  }
  memcpy(v13, v4, v6);
  v36 = v6;
  v15 = v6;
  if ( (unsigned __int64)&a3[-v6] <= 2 )
  {
    sub_413290((unsigned __int64 *)lpMem, v6, 3LL, 1LL, 1LL);
    v14 = lpMem[1];
    v15 = v36;
  }
  v14[v15 + 2] = -67;
  *(_WORD *)&v14[v15] = -16401;
  v16 = v15 + 3;
  v36 = v16;
  v17 = v6 + 3;
  if ( v17 > (unsigned __int64)a3 )
  {
    v28 = v17;
    goto LABEL_57;
  }
  v33 = &off_449348;
LABEL_26:
  if ( (char *)v17 != a3 )
  {
    v18 = &v4[v17];
    v19 = v17;
    Src = &v4[v17];
    while ( 1 )
    {
      v21 = v18 + 1;
      v23 = *v18;
      v22 = 1LL;
      if ( *v18 < 0 )
      {
        if ( (unsigned __int8)v23 < 0xE0u )
        {
          v20 = v18 + 2;
          if ( v21 != v5 )
            v21 = v20;
          v22 = 2LL;
        }
        else if ( v23 == -19 )
        {
          if ( v21 == v5 || v18 + 2 == v5 )
            goto LABEL_53;
          if ( (unsigned __int8)v18[1] > 0x9Fu )
          {
            v25 = (char *)(v19 - v17);
            if ( v19 < v17 )
              sub_406FD0(v17, v19, (__int64)&off_449348);
            if ( v19 <= (unsigned __int64)a3 )
            {
              if ( (char *)lpMem[0] - v16 < v25 )
              {
                sub_413290((unsigned __int64 *)lpMem, v16, (__int64)v25, 1LL, 1LL);
                v16 = v36;
                v34 = (char *)lpMem[0];
                v14 = lpMem[1];
                v25 = (char *)(v19 - v17);
              }
              else
              {
                v34 = (char *)lpMem[0];
              }
              v26 = v25;
              memcpy(&v14[v16], Src, (size_t)v25);
              v27 = (__int64)&v26[v16];
              v36 = v27;
              if ( (unsigned __int64)&v34[-v27] <= 2 )
              {
                sub_413290((unsigned __int64 *)lpMem, v27, 3LL, 1LL, 1LL);
                v14 = lpMem[1];
                v27 = v36;
              }
              v14[v27 + 2] = -67;
              *(_WORD *)&v14[v27] = -16401;
              v16 = v27 + 3;
              v36 = v16;
              v28 = v19 + 3;
              v17 = v28;
              if ( v28 > (unsigned __int64)a3 )
LABEL_57:
                sub_4050A0(v28, (__int64)a3, (__int64)&off_449360);
              goto LABEL_26;
            }
            v6 = v19;
LABEL_59:
            sub_405B00(v6, (__int64)a3, (__int64)v33);
          }
          v22 = 3LL;
          v21 = v18 + 3;
        }
        else
        {
          v24 = v18 + 2;
          if ( v21 == v5 )
            v24 = v21;
          v21 = &v24[v24 != v5];
          v22 = 3LL;
          if ( (unsigned __int8)v23 >= 0xF0u )
          {
            v21 += v21 != v5;
            v22 = 4LL;
          }
        }
      }
      v19 += v22;
      v18 = v21;
      if ( v21 == v5 )
        goto LABEL_53;
    }
  }
  v17 = (unsigned __int64)a3;
LABEL_53:
  v29 = &a3[-v17];
  if ( (char *)lpMem[0] - v16 < v29 )
  {
    sub_413290((unsigned __int64 *)lpMem, v16, (__int64)v29, 1LL, 1LL);
    v14 = lpMem[1];
    v16 = v36;
  }
  memcpy(&v14[v16], &v4[v17], (size_t)v29);
  v30 = &v29[v16];
  v36 = (__int64)v30;
  result = (unsigned __int64)a1;
  *(_OWORD *)a1 = *(_OWORD *)lpMem;
  a1[2] = v30;
  return result;
}
// 449318: using guessed type char *off_449318;
// 449330: using guessed type char *off_449330;
// 449348: using guessed type char *off_449348;
// 449360: using guessed type char *off_449360;

//----- (000000000043C4F0) ----------------------------------------------------
LPVOID __fastcall sub_43C4F0(SIZE_T dwBytes)
{
  HANDLE ProcessHeap; // rax

  ProcessHeap = GetProcessHeap();
  if ( ProcessHeap )
    return HeapAlloc(ProcessHeap, 0, dwBytes);
  else
    return 0LL;
}

//----- (000000000043C530) ----------------------------------------------------
void __fastcall __noreturn sub_43C530(__int64 *a1)
{
  sub_43C540(a1);
}

//----- (000000000043C540) ----------------------------------------------------
void __fastcall __noreturn sub_43C540(__int64 *a1)
{
  __int64 **v1; // rax
  __int64 v2; // r8
  __int64 v3; // rdx
  __int64 v4; // rax
  __int64 v5; // rdx
  __int64 *v6; // rdx
  _QWORD v7[6]; // [rsp+30h] [rbp-20h] BYREF

  v1 = (__int64 **)*a1;
  v2 = *(_QWORD *)(*a1 + 8);
  v3 = *(_QWORD *)(*a1 + 24);
  if ( v2 == 1 )
  {
    if ( !v3 )
    {
      v6 = *v1;
      v4 = **v1;
      v5 = v6[1];
LABEL_7:
      v7[0] = v4;
      v7[1] = v5;
      sub_411502((__int64)v7, (__int64)&unk_4495B0, a1[1], *(_BYTE *)(a1[2] + 16), *(_BYTE *)(a1[2] + 17));
    }
  }
  else if ( !v2 && !v3 )
  {
    v4 = 1LL;
    v5 = 0LL;
    goto LABEL_7;
  }
  v7[3] = a1;
  v7[0] = 0x8000000000000000uLL;
  sub_411502((__int64)v7, (__int64)&off_4495E8, a1[1], *(_BYTE *)(a1[2] + 16), *(_BYTE *)(a1[2] + 17));
}
// 4495E8: using guessed type __int64 (__fastcall *off_4495E8)();

//----- (000000000043C620) ----------------------------------------------------
__int64 __fastcall sub_43C620(_QWORD *a1, __int64 a2)
{
  return (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a2 + 56) + 24LL))(
           *(_QWORD *)(a2 + 48),
           *a1,
           a1[1]);
}

//----- (000000000043C640) ----------------------------------------------------
_QWORD *__fastcall sub_43C640(__int64 *a1)
{
  __int64 v1; // rsi
  __int64 v2; // rdi
  _QWORD *result; // rax

  v1 = *a1;
  v2 = a1[1];
  result = sub_43C4F0(0x10uLL);
  if ( !result )
    sub_4040E9(8LL, 16LL);
  *result = v1;
  result[1] = v2;
  return result;
}

//----- (000000000043C690) ----------------------------------------------------
__int64 __fastcall sub_43C690(__int64 a1)
{
  return a1;
}

//----- (000000000043C6A0) ----------------------------------------------------
__int64 __fastcall sub_43C6A0(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (000000000043C6B0) ----------------------------------------------------
int __fastcall sub_43C6B0(_QWORD *a1)
{
  __int64 v1; // rax
  void *v2; // rsi
  HANDLE ProcessHeap; // rax

  v1 = 2LL * *a1;
  if ( v1 )
  {
    v2 = (void *)a1[1];
    ProcessHeap = GetProcessHeap();
    LODWORD(v1) = HeapFree(ProcessHeap, 0, v2);
  }
  return v1;
}

//----- (000000000043C6F0) ----------------------------------------------------
char __fastcall sub_43C6F0(__int64 a1, __int64 a2)
{
  __int128 *v2; // rax
  __int128 v3; // xmm0
  __int128 v4; // xmm1
  _OWORD v6[3]; // [rsp+20h] [rbp-30h] BYREF

  if ( !__OFSUB__(0LL, *(_QWORD *)a1) )
    return (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a2 + 56) + 24LL))(
             *(_QWORD *)(a2 + 48),
             *(_QWORD *)(a1 + 8),
             *(_QWORD *)(a1 + 16));
  v2 = **(__int128 ***)(a1 + 24);
  v3 = *v2;
  v4 = v2[1];
  v6[2] = v2[2];
  v6[1] = v4;
  v6[0] = v3;
  return sub_406180(*(_QWORD *)(a2 + 48), *(_QWORD *)(a2 + 56), v6);
}

//----- (000000000043C760) ----------------------------------------------------
_QWORD *__fastcall sub_43C760(__int64 *a1)
{
  __int64 v2; // rbx
  __int128 **v3; // rax
  __int128 *v4; // rax
  __int128 v5; // xmm0
  __int128 v6; // xmm1
  __int128 v7; // xmm0
  __int64 v8; // rsi
  __int64 v9; // r14
  _QWORD *result; // rax
  __int128 v11; // [rsp+20h] [rbp-50h] BYREF
  __int128 v12; // [rsp+30h] [rbp-40h]
  __int128 v13; // [rsp+40h] [rbp-30h]
  LPVOID lpMem[2]; // [rsp+58h] [rbp-18h] BYREF
  __int64 v15; // [rsp+68h] [rbp-8h]

  v2 = *a1;
  if ( __OFSUB__(-*a1, 1LL) )
  {
    v3 = (__int128 **)a1[3];
    lpMem[0] = 0LL;
    lpMem[1] = (LPVOID)1;
    v15 = 0LL;
    v4 = *v3;
    v5 = *v4;
    v6 = v4[1];
    v13 = v4[2];
    v12 = v6;
    v11 = v5;
    sub_406180((__int64)lpMem, (__int64)&off_4481D8, &v11);
    v7 = *(_OWORD *)lpMem;
    v11 = *(_OWORD *)lpMem;
    *(_QWORD *)&v12 = v15;
    a1[2] = v15;
    *(_OWORD *)a1 = v7;
    v2 = *a1;
  }
  v8 = a1[1];
  v9 = a1[2];
  *a1 = 0LL;
  a1[1] = 1LL;
  a1[2] = 0LL;
  result = sub_43C4F0(0x18uLL);
  if ( !result )
    sub_4040E9(8LL, 24LL);
  *result = v2;
  result[1] = v8;
  result[2] = v9;
  return result;
}
// 4481D8: using guessed type __int64 (__fastcall *off_4481D8)();

//----- (000000000043C880) ----------------------------------------------------
_QWORD *__fastcall sub_43C880(_QWORD *a1)
{
  __int128 **v2; // rax
  __int128 *v3; // rax
  __int128 v4; // xmm0
  __int128 v5; // xmm1
  __int128 v6; // xmm0
  __int128 v8; // [rsp+20h] [rbp-50h] BYREF
  __int128 v9; // [rsp+30h] [rbp-40h]
  __int128 v10; // [rsp+40h] [rbp-30h]
  LPVOID lpMem[2]; // [rsp+58h] [rbp-18h] BYREF
  __int64 v12; // [rsp+68h] [rbp-8h]

  if ( __OFSUB__(0LL, *a1) )
  {
    v2 = (__int128 **)a1[3];
    lpMem[0] = 0LL;
    lpMem[1] = (LPVOID)1;
    v12 = 0LL;
    v3 = *v2;
    v4 = *v3;
    v5 = v3[1];
    v10 = v3[2];
    v9 = v5;
    v8 = v4;
    sub_406180((__int64)lpMem, (__int64)&off_4481D8, &v8);
    v6 = *(_OWORD *)lpMem;
    v8 = *(_OWORD *)lpMem;
    *(_QWORD *)&v9 = v12;
    a1[2] = v12;
    *(_OWORD *)a1 = v6;
  }
  return a1;
}
// 4481D8: using guessed type __int64 (__fastcall *off_4481D8)();

//----- (000000000043C940) ----------------------------------------------------
unsigned __int64 sub_43C940()
{
  return 0x855AD7BC9E1B7232uLL;
}

//----- (000000000043C960) ----------------------------------------------------
__int64 __fastcall sub_43C960(unsigned __int64 *a1, const void *a2, size_t a3)
{
  __int64 v5; // rbx
  const void *v7; // r14

  v5 = a1[2];
  if ( *a1 - v5 < a3 )
  {
    v7 = a2;
    sub_413290(a1, v5, a3, 1LL, 1LL);
    a2 = v7;
    v5 = a1[2];
  }
  memcpy((void *)(v5 + a1[1]), a2, a3);
  a1[2] = a3 + v5;
  return 0LL;
}

//----- (000000000043C9D0) ----------------------------------------------------
__int64 __fastcall sub_43C9D0(unsigned __int64 *a1, unsigned int a2)
{
  unsigned __int64 v3; // rdi
  char v4; // bl
  size_t v5; // rdi
  __int64 v6; // rbx
  int Src; // [rsp+34h] [rbp+4h] BYREF

  if ( a2 >= 0x80 )
  {
    Src = 0;
    if ( a2 >= 0x800 )
    {
      if ( a2 >= 0x10000 )
      {
        LOBYTE(Src) = (a2 >> 18) | 0xF0;
        BYTE1(Src) = (a2 >> 12) & 0x3F | 0x80;
        BYTE2(Src) = (a2 >> 6) & 0x3F | 0x80;
        HIBYTE(Src) = a2 & 0x3F | 0x80;
        v5 = 4LL;
      }
      else
      {
        LOBYTE(Src) = (a2 >> 12) | 0xE0;
        BYTE1(Src) = (a2 >> 6) & 0x3F | 0x80;
        BYTE2(Src) = a2 & 0x3F | 0x80;
        v5 = 3LL;
      }
    }
    else
    {
      LOBYTE(Src) = (a2 >> 6) | 0xC0;
      BYTE1(Src) = a2 & 0x3F | 0x80;
      v5 = 2LL;
    }
    v6 = a1[2];
    if ( *a1 - v6 < v5 )
    {
      sub_413290(a1, v6, v5, 1LL, 1LL);
      v6 = a1[2];
    }
    memcpy((void *)(v6 + a1[1]), &Src, v5);
    a1[2] = v5 + v6;
  }
  else
  {
    v3 = a1[2];
    if ( v3 == *a1 )
    {
      v4 = a2;
      sub_403F80((signed __int64 *)a1, (__int64)&off_447DD0);
      LOBYTE(a2) = v4;
    }
    *(_BYTE *)(a1[1] + v3) = a2;
    a1[2] = v3 + 1;
  }
  return 0LL;
}
// 447DD0: using guessed type char *off_447DD0;

//----- (000000000043CB00) ----------------------------------------------------
char __fastcall sub_43CB00(__int64 a1, _QWORD *a2)
{
  return sub_406180(a1, (__int64)&off_4481D8, a2);
}
// 4481D8: using guessed type __int64 (__fastcall *off_4481D8)();

//----- (000000000043CB20) ----------------------------------------------------
int __fastcall sub_43CB20(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  int result; // eax
  __int64 v4; // rax
  void *v5; // rsi
  _QWORD *v6; // rdi
  __int64 v7; // r14
  HANDLE ProcessHeap; // rax
  HANDLE v9; // rax
  _QWORD v10[13]; // [rsp+0h] [rbp-70h] BYREF
  int v11; // [rsp+68h] [rbp-8h]
  char v12; // [rsp+6Ch] [rbp-4h]

  v11 = 0;
  v12 = 0;
  v10[12] = a2;
  v10[10] = &v10[12];
  v10[11] = sub_405120;
  v10[4] = &off_449468;
  v10[5] = 2LL;
  v10[8] = 0LL;
  v10[6] = &v10[10];
  v10[7] = 1LL;
  v2 = sub_412270((__int64)&v10[13], &v10[4]);
  result = v2 & 3;
  if ( result == 1 )
  {
    v4 = v2;
    v5 = (void *)(v2 - 1);
    v6 = *(_QWORD **)(v4 - 1);
    v7 = *(_QWORD *)(v4 + 7);
    if ( *(_QWORD *)v7 )
      (*(void (__fastcall **)(_QWORD *))v7)(v6);
    if ( *(_QWORD *)(v7 + 8) )
    {
      if ( *(_QWORD *)(v7 + 16) >= 0x11uLL )
        v6 = (_QWORD *)*(v6 - 1);
      ProcessHeap = GetProcessHeap();
      HeapFree(ProcessHeap, 0, v6);
    }
    v9 = GetProcessHeap();
    return HeapFree(v9, 0, v5);
  }
  return result;
}
// 449468: using guessed type char *off_449468;

//----- (000000000043CC30) ----------------------------------------------------
void __fastcall __noreturn sub_43CC30(_OWORD *a1)
{
  _OWORD v1[3]; // [rsp+0h] [rbp-40h] BYREF
  _OWORD *v2; // [rsp+30h] [rbp-10h]

  v1[2] = *a1;
  v2 = a1;
  sub_43C530((__int64 *)&v1[2]);
}

//----- (000000000043CC50) ----------------------------------------------------
void __fastcall __noreturn sub_43CC50(__int64 a1, __int64 a2)
{
  sub_43CB20(a1, a2);
  __fastfail(7u);
}

//----- (000000000043CC70) ----------------------------------------------------
void __fastcall __noreturn sub_43CC70(__int64 a1, __int64 a2)
{
  sub_43CC50(a2, a1);
}

//----- (000000000043CE80) ----------------------------------------------------
__int64 __fastcall sub_43CE80(ULONG_PTR a1)
{
  ULONG_PTR Arguments; // [rsp+40h] [rbp+8h] BYREF

  Arguments = a1;
  RaiseException(0x22474343u, 0, 1u, &Arguments);
  (*(void (__fastcall **)(__int64, __int64, _QWORD))(Arguments + 16))(1LL, 26LL, *(_QWORD *)Arguments);
  return 16LL;
}

//----- (000000000043CEE0) ----------------------------------------------------
__int64 __fastcall sub_43CEE0(__int64 a1, unsigned int a2)
{
  if ( a2 > 1 )
    abort();
  return *(_QWORD *)(a1 + 8LL * (int)a2 + 16);
}

//----- (000000000043CF00) ----------------------------------------------------
void __fastcall sub_43CF00(__int64 a1, unsigned int a2, __int64 a3)
{
  if ( a2 > 1 )
    abort();
  *(_QWORD *)(a1 + 8LL * (int)a2 + 16) = a3;
}

//----- (000000000043CF20) ----------------------------------------------------
__int64 __fastcall sub_43CF20(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (000000000043CF30) ----------------------------------------------------
__int64 __fastcall sub_43CF30(__int64 a1)
{
  return *(_QWORD *)(a1 + 8);
}

//----- (000000000043CF40) ----------------------------------------------------
__int64 __fastcall sub_43CF40(__int64 a1, _DWORD *a2)
{
  __int64 result; // rax

  result = *(_QWORD *)(a1 + 8);
  *a2 = 0;
  return result;
}

//----- (000000000043CF50) ----------------------------------------------------
void __fastcall sub_43CF50(__int64 a1, __int64 a2)
{
  *(_QWORD *)(a1 + 8) = a2;
}

//----- (000000000043CF60) ----------------------------------------------------
__int64 __fastcall sub_43CF60(__int64 a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 32) + 56LL);
}

//----- (000000000043CF70) ----------------------------------------------------
__int64 __fastcall sub_43CF70(__int64 a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8LL) + **(unsigned int **)(*(_QWORD *)(a1 + 32) + 16LL);
}

//----- (000000000043CF80) ----------------------------------------------------
PRUNTIME_FUNCTION __fastcall sub_43CF80(ULONG64 a1)
{
  PRUNTIME_FUNCTION result; // rax
  unsigned __int64 ImageBase; // [rsp+28h] [rbp-10h] BYREF

  result = RtlLookupFunctionEntry(a1, &ImageBase, 0LL);
  if ( result )
    return (PRUNTIME_FUNCTION)(ImageBase + result->BeginAddress);
  return result;
}

//----- (000000000043CFB0) ----------------------------------------------------
__int64 sub_43CFB0()
{
  return 0LL;
}

//----- (000000000043CFC0) ----------------------------------------------------
__int64 __fastcall sub_43CFC0(__int64 a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8LL);
}

//----- (000000000043CFD0) ----------------------------------------------------
__int64 __fastcall sub_43CFD0(
        PEXCEPTION_RECORD ExceptionRecord,
        PVOID TargetFrame,
        PCONTEXT ContextRecord,
        __int64 a4,
        __int64 (__fastcall *a5)(__int64, __int64, __int64, __int64 *, __int64 *))
{
  DWORD ExceptionFlags; // eax
  DWORD ExceptionCode; // edx
  __int64 *v11; // rbp
  __int64 v12; // rcx
  __int64 v13; // r8
  __int64 v14; // rdx
  int v15; // eax
  PVOID v16; // rax
  int v18; // eax
  ULONG_PTR v19; // rax
  PVOID v20; // rdx
  PVOID v21; // r9
  struct _UNWIND_HISTORY_TABLE *HistoryTable; // rax
  __int64 v23; // [rsp+30h] [rbp-68h] BYREF
  PVOID TargetIp; // [rsp+38h] [rbp-60h]
  PVOID ReturnValue; // [rsp+40h] [rbp-58h]
  ULONG_PTR v26; // [rsp+48h] [rbp-50h]
  __int64 v27; // [rsp+50h] [rbp-48h]

  ExceptionFlags = ExceptionRecord->ExceptionFlags;
  if ( (ExceptionFlags & 0x20) != 0 )
  {
    *(_QWORD *)(*(_QWORD *)(a4 + 40) + 136LL) = ExceptionRecord->ExceptionInformation[3];
    return 1LL;
  }
  ExceptionCode = ExceptionRecord->ExceptionCode;
  v11 = (__int64 *)ExceptionRecord->ExceptionInformation[0];
  if ( ExceptionRecord->ExceptionCode == 558318403 )
  {
    if ( TargetFrame == (PVOID)ExceptionRecord->ExceptionInformation[1] )
    {
      RtlUnwindEx(
        TargetFrame,
        (PVOID)ExceptionRecord->ExceptionInformation[2],
        ExceptionRecord,
        (PVOID)ExceptionRecord->ExceptionInformation[0],
        ContextRecord,
        *(PUNWIND_HISTORY_TABLE *)(a4 + 64));
      abort();
    }
    return 1LL;
  }
  v12 = *(_QWORD *)(a4 + 40);
  v27 = a4;
  v23 = *(_QWORD *)(v12 + 152);
  TargetIp = *(PVOID *)a4;
  ReturnValue = (PVOID)3735928559LL;
  v26 = 3735928559LL;
  if ( ExceptionCode == 575095619 )
  {
    ((void (__fastcall *)(__int64, __int64, __int64, __int64 *, __int64 *, __int64))v11[2])(
      1LL,
      10LL,
      *v11,
      v11,
      &v23,
      v11[6]);
    v13 = *v11;
    v14 = 10LL;
LABEL_7:
    v15 = a5(1LL, v14, v13, v11, &v23);
    if ( v15 != 8 )
    {
      if ( v15 == 7 )
      {
        v16 = TargetIp;
        ExceptionRecord->ExceptionInformation[1] = (ULONG_PTR)TargetFrame;
        ExceptionRecord->ExceptionInformation[2] = (ULONG_PTR)v16;
        ExceptionRecord->ExceptionInformation[3] = v26;
        RaiseException(0x21474343u, 1u, 4u, ExceptionRecord->ExceptionInformation);
      }
      goto LABEL_10;
    }
    return 1LL;
  }
  if ( ExceptionCode != 541541187 )
    return 1LL;
  v13 = *v11;
  if ( (ExceptionFlags & 6) != 0 )
  {
    v14 = 2LL;
    goto LABEL_7;
  }
  v18 = a5(1LL, 1LL, v13, v11, &v23);
  if ( v18 != 8 )
  {
    if ( v18 == 6 && (unsigned int)a5(1LL, 6LL, *v11, v11, &v23) == 7 )
    {
      v19 = v26;
      v20 = TargetIp;
      v11[3] = (__int64)TargetFrame;
      v21 = ReturnValue;
      v11[5] = v19;
      v11[4] = (__int64)v20;
      ExceptionRecord->ExceptionInformation[3] = v19;
      HistoryTable = *(struct _UNWIND_HISTORY_TABLE **)(a4 + 64);
      ExceptionRecord->NumberParameters = 4;
      ExceptionRecord->ExceptionInformation[1] = (ULONG_PTR)TargetFrame;
      ExceptionRecord->ExceptionInformation[2] = (ULONG_PTR)v20;
      RtlUnwindEx(TargetFrame, v20, ExceptionRecord, v21, ContextRecord, HistoryTable);
    }
LABEL_10:
    abort();
  }
  return 1LL;
}

//----- (000000000043D1F0) ----------------------------------------------------
__int64 __fastcall sub_43D1F0(_QWORD *a1)
{
  ULONG_PTR Arguments; // [rsp+30h] [rbp+8h] BYREF

  Arguments = (ULONG_PTR)a1;
  a1[2] = 0LL;
  a1[3] = 0LL;
  a1[4] = 0LL;
  a1[5] = 0LL;
  a1[6] = 0LL;
  a1[7] = 0LL;
  RaiseException(0x20474343u, 0, 1u, &Arguments);
  return 5LL;
}

//----- (000000000043D250) ----------------------------------------------------
void __fastcall __noreturn sub_43D250(ULONG_PTR ReturnValue)
{
  _EXCEPTION_RECORD ExceptionRecord; // [rsp+30h] [rbp-678h] BYREF
  struct _UNWIND_HISTORY_TABLE HistoryTable; // [rsp+D0h] [rbp-5D8h] BYREF
  CONTEXT ContextRecord; // [rsp+1B0h] [rbp-4F8h] BYREF

  ContextRecord.ContextFlags = 1048607;
  memset(&ExceptionRecord.ExceptionRecord, 0, 0x90uLL);
  ExceptionRecord.ExceptionInformation[0] = ReturnValue;
  memset(&HistoryTable, 0, sizeof(HistoryTable));
  ExceptionRecord.NumberParameters = 4;
  *(_QWORD *)&ExceptionRecord.ExceptionCode = 0x120474343LL;
  ExceptionRecord.ExceptionInformation[1] = *(_QWORD *)(ReturnValue + 24);
  ExceptionRecord.ExceptionInformation[2] = *(_QWORD *)(ReturnValue + 32);
  ExceptionRecord.ExceptionInformation[3] = *(_QWORD *)(ReturnValue + 40);
  RtlCaptureContext(&ContextRecord);
  RtlUnwindEx(
    *(PVOID *)(ReturnValue + 24),
    *(PVOID *)(ReturnValue + 32),
    &ExceptionRecord,
    (PVOID)ReturnValue,
    &ContextRecord,
    &HistoryTable);
  abort();
}

//----- (000000000043D300) ----------------------------------------------------
void __fastcall __noreturn sub_43D300(_QWORD *a1)
{
  if ( a1[2] )
    sub_43CE80((ULONG_PTR)a1);
  else
    sub_43D1F0(a1);
  abort();
}

//----- (000000000043D320) ----------------------------------------------------
__int64 __fastcall sub_43D320(ULONG_PTR a1, __int64 a2, __int64 a3)
{
  *(_QWORD *)(a1 + 24) = 0LL;
  *(_QWORD *)(a1 + 32) = 0LL;
  *(_QWORD *)(a1 + 40) = 0LL;
  *(_QWORD *)(a1 + 56) = 0LL;
  *(_QWORD *)(a1 + 16) = a2;
  *(_QWORD *)(a1 + 48) = a3;
  return sub_43CE80(a1);
}

//----- (000000000043D350) ----------------------------------------------------
__int64 (__fastcall *__fastcall sub_43D350(__int64 a1))(__int64, __int64)
{
  __int64 (__fastcall *result)(__int64, __int64); // rax

  result = *(__int64 (__fastcall **)(__int64, __int64))(a1 + 8);
  if ( result )
    return (__int64 (__fastcall *)(__int64, __int64))result(1LL, a1);
  return result;
}

//----- (000000000043D370) ----------------------------------------------------
__int64 __fastcall sub_43D370(unsigned int (__fastcall *a1)(_QWORD *, __int64), __int64 a2)
{
  DWORD64 *v3; // rbx
  DWORD64 Rip; // rcx
  _QWORD *v6; // rbx
  struct _RUNTIME_FUNCTION *v7; // r9
  _QWORD v9[4]; // [rsp+40h] [rbp-678h] BYREF
  _QWORD *v10; // [rsp+60h] [rbp-658h]
  _QWORD v11[5]; // [rsp+70h] [rbp-648h] BYREF
  CONTEXT *p_ContextRecord; // [rsp+98h] [rbp-620h]
  __int64 v13; // [rsp+A0h] [rbp-618h]
  __int64 v14; // [rsp+A8h] [rbp-610h]
  struct _UNWIND_HISTORY_TABLE *p_HistoryTable; // [rsp+B0h] [rbp-608h]
  __int64 v16; // [rsp+B8h] [rbp-600h]
  struct _UNWIND_HISTORY_TABLE HistoryTable; // [rsp+C0h] [rbp-5F8h] BYREF
  CONTEXT ContextRecord; // [rsp+1A0h] [rbp-518h] BYREF

  v3 = v11;
  memset(v9, 0, sizeof(v9));
  memset(&HistoryTable, 0, sizeof(HistoryTable));
  memset(v11, 0, sizeof(v11));
  p_ContextRecord = 0LL;
  v13 = 0LL;
  v14 = 0LL;
  p_HistoryTable = 0LL;
  v16 = 0LL;
  ContextRecord.ContextFlags = 1048607;
  RtlCaptureContext(&ContextRecord);
  v10 = v11;
  Rip = ContextRecord.Rip;
  p_ContextRecord = &ContextRecord;
  p_HistoryTable = &HistoryTable;
  while ( 1 )
  {
    *v3 = Rip;
    v3[2] = (DWORD64)RtlLookupFunctionEntry(Rip, v3 + 1, &HistoryTable);
    v6 = v10;
    v7 = (struct _RUNTIME_FUNCTION *)v10[2];
    if ( !v7 )
      return 5LL;
    v6[6] = RtlVirtualUnwind(0, v10[1], ContextRecord.Rip, v7, &ContextRecord, (PVOID *)v10 + 7, v10 + 3, 0LL);
    if ( a1(v9, a2) )
      break;
    Rip = ContextRecord.Rip;
    if ( !ContextRecord.Rip )
      return 5LL;
    v3 = v10;
  }
  return 3LL;
}

//----- (000000000043D5A0) ----------------------------------------------------
__int64 sub_43D5A0()
{
  return qword_450130;
}
// 450130: using guessed type __int64 qword_450130;

//----- (000000000043D5B0) ----------------------------------------------------
__int64 __fastcall sub_43D5B0(__int64 a1)
{
  return _InterlockedExchange64(&qword_450130, a1);
}
// 450130: using guessed type __int64 qword_450130;

//----- (000000000043D5C0) ----------------------------------------------------
char *sub_43D5C0()
{
  return acmdln;
}

//----- (000000000043D5D0) ----------------------------------------------------
__int64 sub_43D5D0()
{
  return *(_QWORD *)&fmode;
}

//----- (000000000043D5E0) ----------------------------------------------------
void (*sub_43D5E0())(void)
{
  void (*result)(void); // rax

  result = (void (*)(void))(*off_43F090)[0];
  if ( (*off_43F090)[0] )
  {
    do
    {
      result();
      result = (void (*)(void))(*off_43F090)[1];
      off_43F090 = (__int64 (*)[4])((char *)off_43F090 + 8);
    }
    while ( result );
  }
  return result;
}
// 43F090: using guessed type __int64 (*off_43F090)[4];

//----- (000000000043D620) ----------------------------------------------------
__int64 sub_43D620()
{
  void (**v0)(void); // rbx
  __int64 *v1; // rsi
  unsigned int v3; // eax
  unsigned int v4; // ecx

  v3 = 0;
  do
    v4 = v3++;
  while ( qword_43EBC0[v3] );
  if ( v4 )
  {
    v0 = (void (**)(void))&qword_43EBC0[v4];
    v1 = &qword_43EBC0[v4 - (unsigned __int64)(v4 - 1) - 1];
    do
      (*v0--)();
    while ( v0 != (void (**)(void))v1 );
  }
  return sub_401520((int (__cdecl *)())sub_43D5E0);
}
// 43EBC0: using guessed type __int64 qword_43EBC0[];

//----- (000000000043D690) ----------------------------------------------------
__int64 sub_43D690()
{
  __int64 result; // rax

  result = (unsigned int)dword_450140;
  if ( !dword_450140 )
  {
    dword_450140 = 1;
    return sub_43D620();
  }
  return result;
}
// 450140: using guessed type int dword_450140;

//----- (000000000043D6C0) ----------------------------------------------------
__int64 sub_43D6C0()
{
  return 0LL;
}

//----- (000000000043D6D0) ----------------------------------------------------
LONGLONG sub_43D6D0()
{
  LONGLONG result; // rax
  struct _FILETIME v1; // rsi
  DWORD CurrentProcessId; // ebp
  DWORD CurrentThreadId; // edi
  DWORD TickCount; // r12d
  unsigned __int64 v5; // rdx
  struct _FILETIME SystemTimeAsFileTime; // [rsp+20h] [rbp-38h] BYREF
  LARGE_INTEGER PerformanceCount; // [rsp+28h] [rbp-30h] BYREF

  result = 0x2B992DDFA232LL;
  SystemTimeAsFileTime = 0LL;
  if ( qword_43F0B0 == 0x2B992DDFA232LL )
  {
    GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
    v1 = SystemTimeAsFileTime;
    CurrentProcessId = GetCurrentProcessId();
    CurrentThreadId = GetCurrentThreadId();
    TickCount = GetTickCount();
    QueryPerformanceCounter(&PerformanceCount);
    result = (PerformanceCount.QuadPart ^ *(_QWORD *)&v1 ^ CurrentProcessId ^ CurrentThreadId ^ TickCount) & 0xFFFFFFFFFFFFLL;
    if ( result == 0x2B992DDFA232LL )
    {
      v5 = 0xFFFFD466D2205DCCuLL;
      result = 0x2B992DDFA233LL;
    }
    else
    {
      v5 = ~result;
    }
    qword_43F0B0 = result;
    qword_43F0C0 = v5;
  }
  else
  {
    qword_43F0C0 = ~qword_43F0B0;
  }
  return result;
}
// 43F0B0: using guessed type __int64 qword_43F0B0;
// 43F0C0: using guessed type __int64 qword_43F0C0;

//----- (000000000043D7B0) ----------------------------------------------------
void __fastcall __noreturn sub_43D7B0(DWORD64 a1)
{
  DWORD64 Rip; // rsi
  struct _RUNTIME_FUNCTION *v3; // r9
  HANDLE CurrentProcess; // rax
  unsigned __int64 ImageBase; // [rsp+48h] [rbp-28h] BYREF
  unsigned __int64 EstablisherFrame; // [rsp+50h] [rbp-20h] BYREF
  PVOID HandlerData[4]; // [rsp+58h] [rbp-18h] BYREF
  char vars8; // [rsp+78h] [rbp+8h] BYREF
  DWORD64 retaddr; // [rsp+88h] [rbp+18h]

  RtlCaptureContext(&ContextRecord);
  Rip = ContextRecord.Rip;
  v3 = RtlLookupFunctionEntry(ContextRecord.Rip, &ImageBase, 0LL);
  if ( v3 )
  {
    RtlVirtualUnwind(0, ImageBase, Rip, v3, &ContextRecord, HandlerData, &EstablisherFrame, 0LL);
  }
  else
  {
    ContextRecord.Rip = retaddr;
    ContextRecord.Rsp = (DWORD64)&vars8;
  }
  ContextRecord.Rcx = a1;
  qword_450670 = ContextRecord.Rip;
  qword_450660 = 0x1C0000409LL;
  HandlerData[1] = (PVOID)qword_43F0B0;
  HandlerData[2] = (PVOID)qword_43F0C0;
  SetUnhandledExceptionFilter(0LL);
  UnhandledExceptionFilter((struct _EXCEPTION_POINTERS *)&ExceptionInfo);
  CurrentProcess = GetCurrentProcess();
  TerminateProcess(CurrentProcess, 0xC0000409);
  abort();
}
// 43F0B0: using guessed type __int64 qword_43F0B0;
// 43F0C0: using guessed type __int64 qword_43F0C0;
// 450660: using guessed type __int64 qword_450660;
// 450670: using guessed type __int64 qword_450670;

//----- (000000000043D8B0) ----------------------------------------------------
__int64 __fastcall TlsCallback_2(__int64 a1, unsigned int a2)
{
  if ( a2 != 3 && a2 )
    return 1LL;
  sub_43E650(a1, a2);
  return 1LL;
}

//----- (000000000043D8E0) ----------------------------------------------------
__int64 __fastcall TlsCallback_1(__int64 a1, int a2)
{
  if ( unk_43F0A0 != 2 )
    unk_43F0A0 = 2;
  if ( a2 == 1 )
    sub_43E650(a1, 1u);
  return 1LL;
}

//----- (000000000043D970) ----------------------------------------------------
__int64 sub_43D970()
{
  return 0LL;
}

//----- (000000000043D980) ----------------------------------------------------
__int64 __fastcall sub_43D980(__int64 a1)
{
  const char *v1; // rbx
  double v2; // xmm8_8
  double v3; // xmm7_8
  double v4; // xmm6_8
  const char *v5; // rsi
  FILE *v6; // rax

  switch ( *(_DWORD *)a1 )
  {
    case 1:
      v1 = "Argument domain error (DOMAIN)";
      break;
    case 2:
      v1 = "Argument singularity (SIGN)";
      break;
    case 3:
      v1 = "Overflow range error (OVERFLOW)";
      break;
    case 4:
      v1 = "The result is too small to be represented (UNDERFLOW)";
      break;
    case 5:
      v1 = "Total loss of significance (TLOSS)";
      break;
    case 6:
      v1 = "Partial loss of significance (PLOSS)";
      break;
    default:
      v1 = "Unknown error";
      break;
  }
  v2 = *(double *)(a1 + 32);
  v3 = *(double *)(a1 + 24);
  v4 = *(double *)(a1 + 16);
  v5 = *(const char **)(a1 + 8);
  v6 = sub_43EB50(2);
  fprintf(v6, "_matherr(): %s in %s(%g, %g)  (retval=%g)\n", v1, v5, v4, v3, v2);
  return 0LL;
}

//----- (000000000043DA80) ----------------------------------------------------
void sub_43DA80()
{
  __asm { fninit }
}

//----- (000000000043DA90) ----------------------------------------------------
void __noreturn sub_43DA90(char *Format, ...)
{
  FILE *v2; // rax
  FILE *v3; // rax
  va_list va; // [rsp+58h] [rbp+10h] BYREF

  va_start(va, Format);
  v2 = sub_43EB50(2);
  fwrite("Mingw-w64 runtime failure:\n", 1uLL, 0x1BuLL, v2);
  v3 = sub_43EB50(2);
  vfprintf(v3, Format, va);
  abort();
}

//----- (000000000043DB00) ----------------------------------------------------
int __fastcall sub_43DB00(_QWORD *a1, char *a2, unsigned int a3)
{
  __int64 v3; // rdi
  int v7; // ecx
  _QWORD *v8; // rax
  __int64 v9; // rbp
  __int64 v10; // rdi
  __int64 v11; // rax
  const void *v12; // rcx
  unsigned __int64 v13; // rcx
  char *v14; // r12
  char *v15; // rsi
  unsigned int v16; // ebx
  unsigned int v17; // ebx
  __int64 v18; // rdx
  PVOID BaseAddress; // rcx
  SIZE_T RegionSize; // rdx
  __int64 v21; // rdi
  DWORD LastError; // eax
  _MEMORY_BASIC_INFORMATION Buffer; // [rsp+20h] [rbp-58h] BYREF

  v3 = dword_450734;
  if ( dword_450734 <= 0 )
  {
    v3 = 0LL;
LABEL_6:
    v9 = sub_43E860();
    if ( !v9 )
      sub_43DA90("Address %p has no image-section", a1);
    v10 = 40 * v3;
    v11 = v10 + qword_450738;
    *(_QWORD *)(v11 + 32) = v9;
    *(_DWORD *)v11 = 0;
    v12 = (const void *)(sub_43E990() + *(unsigned int *)(v9 + 12));
    *(_QWORD *)(qword_450738 + v10 + 24) = v12;
    if ( !VirtualQuery(v12, &Buffer, 0x30uLL) )
      sub_43DA90(
        "  VirtualQuery failed for %d bytes at address %p",
        *(_DWORD *)(v9 + 8),
        *(const void **)(qword_450738 + v10 + 24));
    LODWORD(v8) = Buffer.Protect;
    if ( ((Buffer.Protect - 64) & 0xFFFFFFBF) != 0 )
    {
      LODWORD(v8) = (Buffer.Protect - 4) & 0xFFFFFFFB;
      if ( (_DWORD)v8 )
      {
        BaseAddress = Buffer.BaseAddress;
        RegionSize = Buffer.RegionSize;
        v21 = qword_450738 + v10;
        *(_QWORD *)(v21 + 8) = Buffer.BaseAddress;
        *(_QWORD *)(v21 + 16) = RegionSize;
        LODWORD(v8) = VirtualProtect(BaseAddress, RegionSize, 0x40u, (PDWORD)v21);
        if ( !(_DWORD)v8 )
        {
          LastError = GetLastError();
          sub_43DA90("  VirtualProtect failed with code 0x%x", LastError);
        }
      }
    }
    ++dword_450734;
  }
  else
  {
    v7 = 0;
    v8 = (_QWORD *)(qword_450738 + 24);
    while ( (unsigned __int64)a1 < *v8 || (unsigned __int64)a1 >= (unsigned __int64)*(unsigned int *)(v8[1] + 8LL) + *v8 )
    {
      ++v7;
      v8 += 5;
      if ( v7 == dword_450734 )
        goto LABEL_6;
    }
  }
  if ( a3 >= 8 )
  {
    v13 = (unsigned __int64)(a1 + 1) & 0xFFFFFFFFFFFFFFF8uLL;
    *a1 = *(_QWORD *)a2;
    LODWORD(v8) = a3;
    *(_QWORD *)((char *)a1 + a3 - 8) = *(_QWORD *)&a2[a3 - 8];
    v14 = (char *)a1 - v13;
    v15 = (char *)(a2 - v14);
    v16 = ((_DWORD)v14 + a3) & 0xFFFFFFF8;
    if ( v16 >= 8 )
    {
      v17 = v16 & 0xFFFFFFF8;
      LODWORD(v8) = 0;
      do
      {
        v18 = (unsigned int)v8;
        LODWORD(v8) = (_DWORD)v8 + 8;
        *(_QWORD *)(v13 + v18) = *(_QWORD *)&v15[v18];
      }
      while ( (unsigned int)v8 < v17 );
    }
  }
  else if ( (a3 & 4) != 0 )
  {
    *(_DWORD *)a1 = *(_DWORD *)a2;
    LODWORD(v8) = *(_DWORD *)&a2[a3 - 4];
    *(_DWORD *)((char *)a1 + a3 - 4) = (_DWORD)v8;
  }
  else if ( a3 )
  {
    LODWORD(v8) = (unsigned __int8)*a2;
    *(_BYTE *)a1 = (_BYTE)v8;
    if ( (a3 & 2) != 0 )
    {
      LODWORD(v8) = *(unsigned __int16 *)&a2[a3 - 2];
      *(_WORD *)((char *)a1 + a3 - 2) = (_WORD)v8;
    }
  }
  return (int)v8;
}
// 450734: using guessed type int dword_450734;
// 450738: using guessed type __int64 qword_450738;

//----- (000000000043DD10) ----------------------------------------------------
void sub_43DD10()
{
  unsigned __int64 v0; // rax
  void *v1; // rsp
  char v2; // [rsp+20h] [rbp-60h] BYREF

  if ( !dword_450730 )
  {
    dword_450730 = 1;
    sub_43E8F0();
    v0 = sub_43EB78();
    dword_450734 = 0;
    v1 = alloca(v0);
    qword_450738 = (__int64)&v2;
  }
}
// 44AD30: using guessed type _UNKNOWN *off_44AD30;
// 450730: using guessed type int dword_450730;
// 450734: using guessed type int dword_450734;
// 450738: using guessed type __int64 qword_450738;

//----- (000000000043E000) ----------------------------------------------------
__int64 (__fastcall *__fastcall sub_43E000(int a1, __int64 a2, double a3, double a4, __int64 a5))(_QWORD)
{
  __int64 (__fastcall *result)(_QWORD); // rax
  int v6; // [rsp+20h] [rbp-38h] BYREF
  __int64 v7; // [rsp+28h] [rbp-30h]
  double v8; // [rsp+30h] [rbp-28h]
  double v9; // [rsp+38h] [rbp-20h]
  __int64 v10; // [rsp+40h] [rbp-18h]

  result = qword_450740;
  if ( qword_450740 )
  {
    v6 = a1;
    v7 = a2;
    v8 = a3;
    v9 = a4;
    v10 = a5;
    return (__int64 (__fastcall *)(_QWORD))qword_450740(&v6);
  }
  return result;
}
// 450740: using guessed type __int64 (__fastcall *qword_450740)(_QWORD);

//----- (000000000043E050) ----------------------------------------------------
void __fastcall sub_43E050(_UserMathErrorFunctionPointer UserMathErrorFunction)
{
  qword_450740 = (__int64 (__fastcall *)(_QWORD))UserMathErrorFunction;
  _setusermatherr(UserMathErrorFunction);
}
// 450740: using guessed type __int64 (__fastcall *qword_450740)(_QWORD);

//----- (000000000043E060) ----------------------------------------------------
__int64 __fastcall sub_43E060(unsigned int *a1)
{
  unsigned int v1; // eax
  _crt_signal_t v2; // rax
  __int64 v3; // rdx
  unsigned int v4; // r8d
  _crt_signal_t v6; // rax
  _crt_signal_t v7; // rax

  v1 = *a1;
  if ( *a1 > 0xC0000096 )
    return 1;
  if ( v1 > 0xC000008B )
  {
    switch ( v1 )
    {
      case 0xC000008D:
      case 0xC000008E:
      case 0xC000008F:
      case 0xC0000090:
      case 0xC0000091:
      case 0xC0000093:
        v2 = signal(8, 0LL);
        if ( v2 != (_crt_signal_t)1 )
          goto LABEL_17;
        signal(8, (_crt_signal_t)1);
        sub_43DA80();
        goto LABEL_6;
      case 0xC0000094:
        v2 = signal(8, 0LL);
        if ( v2 == (_crt_signal_t)1 )
        {
          signal(8, (_crt_signal_t)1);
          return 0;
        }
        else
        {
LABEL_17:
          v4 = 1;
          if ( v2 )
          {
            ((void (__fastcall *)(__int64, __int64, __int64))v2)(8LL, v3, 1LL);
            return 0;
          }
        }
        return v4;
      case 0xC0000096:
        goto LABEL_12;
      default:
LABEL_6:
        v4 = 0;
        break;
    }
    return v4;
  }
  if ( v1 == -1073741819 )
  {
    v7 = signal(11, 0LL);
    if ( v7 == (_crt_signal_t)1 )
    {
      signal(11, (_crt_signal_t)1);
      return 0;
    }
    if ( !v7 )
      return 4;
    ((void (__fastcall *)(__int64))v7)(11LL);
    return 0;
  }
  if ( v1 > 0xC0000005 )
  {
    v4 = 0;
    if ( v1 != -1073741816 )
    {
      if ( v1 == -1073741795 )
      {
LABEL_12:
        v6 = signal(4, 0LL);
        if ( v6 == (_crt_signal_t)1 )
        {
          signal(4, (_crt_signal_t)1);
          return 0;
        }
        if ( v6 )
        {
          ((void (__fastcall *)(__int64))v6)(4LL);
          return 0LL;
        }
        return 4;
      }
      return 1;
    }
    return v4;
  }
  return v1 != -2147483646;
}
// 43E161: variable 'v3' is possibly undefined

//----- (000000000043E220) ----------------------------------------------------
__int64 sub_43E220()
{
  ULONG64 v0; // rsi
  __int64 result; // rax
  struct _RUNTIME_FUNCTION *v2; // rbx
  __int64 v3; // r12
  _DWORD *v4; // rdi
  DWORD v5; // edx
  DWORD v6; // edx
  int v7; // eax
  __int64 v8; // rax
  ULONG v9; // edx

  v0 = sub_43E990();
  result = (unsigned int)dword_450768;
  if ( !dword_450768 && v0 )
  {
    dword_450768 = 1;
    if ( !sub_43E7C0(".pdata") )
    {
      v2 = &FunctionTable;
      v3 = 0LL;
      memset(&FunctionTable, 0, 0x180uLL);
      memset(&unk_450780, 0, 0x100uLL);
      v4 = &unk_450780;
      while ( 1 )
      {
        v8 = sub_43E920();
        if ( !v8 )
          break;
        *(_BYTE *)v4 = 9;
        ++v3;
        ++v2;
        v4[1] = (unsigned int)sub_43E060 - v0;
        v5 = *(_DWORD *)(v8 + 12);
        v2[-1].BeginAddress = v5;
        v6 = *(_DWORD *)(v8 + 8) + v5;
        v7 = (int)v4;
        v4 += 2;
        v2[-1].EndAddress = v6;
        v2[-1].UnwindData = v7 - v0;
        if ( v3 == 32 )
        {
          v9 = 32;
          goto LABEL_12;
        }
      }
      if ( !v3 )
        return 1LL;
      v9 = v3;
LABEL_12:
      RtlAddFunctionTable(&FunctionTable, v9, v0);
    }
    return 1LL;
  }
  return result;
}
// 450768: using guessed type int dword_450768;

//----- (000000000043E4D0) ----------------------------------------------------
void sub_43E4D0()
{
  _QWORD *v0; // rbx
  LPVOID Value; // r12

  EnterCriticalSection(&CriticalSection);
  v0 = Block;
  if ( Block )
  {
    do
    {
      Value = TlsGetValue(*(_DWORD *)v0);
      if ( !GetLastError() && Value )
        ((void (__fastcall *)(LPVOID))v0[1])(Value);
      v0 = (_QWORD *)v0[2];
    }
    while ( v0 );
  }
  LeaveCriticalSection(&CriticalSection);
}

//----- (000000000043E540) ----------------------------------------------------
__int64 __fastcall sub_43E540(int a1, __int64 a2)
{
  __int64 result; // rax
  _QWORD *v5; // rax
  _QWORD *v6; // rbx
  void *v7; // rax

  result = (unsigned int)dword_450A08;
  if ( dword_450A08 )
  {
    v5 = calloc(1uLL, 0x18uLL);
    v6 = v5;
    if ( v5 )
    {
      *(_DWORD *)v5 = a1;
      v5[1] = a2;
      EnterCriticalSection(&CriticalSection);
      v7 = Block;
      Block = v6;
      v6[2] = v7;
      LeaveCriticalSection(&CriticalSection);
      return 0LL;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}
// 450A08: using guessed type int dword_450A08;

//----- (000000000043E5C0) ----------------------------------------------------
__int64 __fastcall sub_43E5C0(int a1)
{
  _QWORD *v3; // rcx
  _QWORD *v4; // rdx
  __int64 v5; // rax

  if ( !dword_450A08 )
    return 0LL;
  EnterCriticalSection(&CriticalSection);
  v3 = Block;
  if ( Block )
  {
    v4 = 0LL;
    while ( 1 )
    {
      v5 = v3[2];
      if ( *(_DWORD *)v3 == a1 )
        break;
      v4 = v3;
      if ( !v5 )
        goto LABEL_11;
      v3 = (_QWORD *)v3[2];
    }
    if ( v4 )
      v4[2] = v5;
    else
      Block = (void *)v3[2];
    free(v3);
  }
LABEL_11:
  LeaveCriticalSection(&CriticalSection);
  return 0LL;
}
// 450A08: using guessed type int dword_450A08;

//----- (000000000043E650) ----------------------------------------------------
__int64 __fastcall sub_43E650(__int64 a1, unsigned int a2)
{
  void *v3; // rbx
  void *v4; // rcx

  if ( a2 == 2 )
  {
    sub_43DA80();
    return 1LL;
  }
  else
  {
    if ( a2 > 2 )
    {
      if ( a2 == 3 && dword_450A08 )
        sub_43E4D0();
    }
    else if ( a2 )
    {
      if ( !dword_450A08 )
        InitializeCriticalSection(&CriticalSection);
      dword_450A08 = 1;
    }
    else
    {
      if ( dword_450A08 )
        sub_43E4D0();
      if ( dword_450A08 == 1 )
      {
        v3 = Block;
        while ( v3 )
        {
          v4 = v3;
          v3 = (void *)*((_QWORD *)v3 + 2);
          free(v4);
        }
        Block = 0LL;
        dword_450A08 = 0;
        DeleteCriticalSection(&CriticalSection);
      }
    }
    return 1LL;
  }
}
// 450A08: using guessed type int dword_450A08;

//----- (000000000043E730) ----------------------------------------------------
_BOOL8 __fastcall sub_43E730(__int64 a1)
{
  __int64 v1; // rdx
  _BOOL8 result; // rax

  v1 = *(int *)(a1 + 60) + a1;
  result = 0LL;
  if ( *(_DWORD *)v1 == 17744 )
    return *(_WORD *)(v1 + 24) == 523;
  return result;
}

//----- (000000000043E750) ----------------------------------------------------
_BOOL8 __fastcall sub_43E750(__int64 a1)
{
  return *(_WORD *)a1 == 23117 && sub_43E730(a1);
}

//----- (000000000043E770) ----------------------------------------------------
__int64 __fastcall sub_43E770(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rcx
  __int64 result; // rax
  int v4; // ecx
  __int64 v5; // r9
  unsigned __int64 v6; // r8

  v2 = *(int *)(a1 + 60) + a1;
  result = v2 + *(unsigned __int16 *)(v2 + 20) + 24;
  v4 = *(unsigned __int16 *)(v2 + 6);
  if ( !v4 )
    return 0LL;
  v5 = result + 40LL * (unsigned int)(v4 - 1) + 40;
  while ( 1 )
  {
    v6 = *(unsigned int *)(result + 12);
    if ( v6 <= a2 && (unsigned int)(*(_DWORD *)(result + 8) + v6) > a2 )
      break;
    result += 40LL;
    if ( result == v5 )
      return 0LL;
  }
  return result;
}

//----- (000000000043E7C0) ----------------------------------------------------
const char *__fastcall sub_43E7C0(char *Str2)
{
  const char *v2; // r12
  __int64 v3; // rcx
  __int64 v4; // rcx
  __int64 v5; // rsi

  if ( strlen(Str2) <= 8 )
  {
    v2 = 0LL;
    if ( *(_WORD *)off_44AD30 != 23117 || !sub_43E730((__int64)off_44AD30) )
      return v2;
    v4 = *(int *)(v3 + 60) + v3;
    v2 = (const char *)(v4 + *(unsigned __int16 *)(v4 + 20) + 24);
    if ( *(_WORD *)(v4 + 6) )
    {
      v5 = (__int64)&v2[40 * *(unsigned __int16 *)(v4 + 6)];
      while ( strncmp(v2, Str2, 8uLL) )
      {
        v2 += 40;
        if ( v2 == (const char *)v5 )
          return 0LL;
      }
      return v2;
    }
  }
  return 0LL;
}
// 43E7F0: variable 'v3' is possibly undefined
// 44AD30: using guessed type _UNKNOWN *off_44AD30;

//----- (000000000043E860) ----------------------------------------------------
__int64 sub_43E860()
{
  __int64 v0; // r8
  __int64 v1; // r9
  __int64 v2; // r10
  unsigned __int64 v3; // rcx
  __int64 v4; // r10
  __int64 v5; // r9
  unsigned __int64 v6; // rdx

  v0 = 0LL;
  if ( *(_WORD *)off_44AD30 == 23117 && sub_43E730((__int64)off_44AD30) )
  {
    v3 = v1 - v2;
    v4 = *(int *)(v2 + 60) + v2;
    v0 = v4 + *(unsigned __int16 *)(v4 + 20) + 24;
    if ( *(_WORD *)(v4 + 6) )
    {
      v5 = v0 + 40LL * ((unsigned int)*(unsigned __int16 *)(v4 + 6) - 1) + 40;
      while ( 1 )
      {
        v6 = *(unsigned int *)(v0 + 12);
        if ( v3 >= v6 && v3 < (unsigned int)(*(_DWORD *)(v0 + 8) + v6) )
          break;
        v0 += 40LL;
        if ( v0 == v5 )
          return 0LL;
      }
    }
    else
    {
      return 0LL;
    }
  }
  return v0;
}
// 43E88C: variable 'v1' is possibly undefined
// 43E88C: variable 'v2' is possibly undefined
// 43E8D9: variable 'v0' is possibly undefined
// 44AD30: using guessed type _UNKNOWN *off_44AD30;

//----- (000000000043E8F0) ----------------------------------------------------
__int64 sub_43E8F0()
{
  __int64 result; // rax
  __int64 v1; // rcx

  result = 0LL;
  if ( *(_WORD *)off_44AD30 == 23117 )
  {
    result = sub_43E730((__int64)off_44AD30);
    if ( (_DWORD)result )
      return *(unsigned __int16 *)(*(int *)(v1 + 60) + v1 + 6);
  }
  return result;
}
// 43E90D: variable 'v1' is possibly undefined
// 44AD30: using guessed type _UNKNOWN *off_44AD30;

//----- (000000000043E920) ----------------------------------------------------
__int64 sub_43E920()
{
  __int64 v0; // r8
  __int64 v1; // rcx
  __int64 v2; // r9
  __int64 v3; // rcx
  __int64 v4; // rax

  v0 = 0LL;
  if ( *(_WORD *)off_44AD30 == 23117 && sub_43E730((__int64)off_44AD30) )
  {
    v3 = *(int *)(v1 + 60) + v1;
    v0 = v3 + *(unsigned __int16 *)(v3 + 20) + 24;
    if ( *(_WORD *)(v3 + 6) )
    {
      v4 = v0 + 40LL * ((unsigned int)*(unsigned __int16 *)(v3 + 6) - 1) + 40;
      do
      {
        if ( (*(_BYTE *)(v0 + 39) & 0x20) != 0 )
        {
          if ( !v2 )
            return v0;
          --v2;
        }
        v0 += 40LL;
      }
      while ( v0 != v4 );
    }
    return 0LL;
  }
  return v0;
}
// 43E941: variable 'v1' is possibly undefined
// 43E972: variable 'v2' is possibly undefined
// 43E984: variable 'v0' is possibly undefined
// 44AD30: using guessed type _UNKNOWN *off_44AD30;

//----- (000000000043E990) ----------------------------------------------------
__int64 sub_43E990()
{
  __int64 v0; // r8
  __int64 v1; // rcx

  v0 = 0LL;
  if ( *(_WORD *)off_44AD30 == 23117 && sub_43E730((__int64)off_44AD30) )
    return v1;
  return v0;
}
// 43E9AC: variable 'v1' is possibly undefined
// 43E9B0: variable 'v0' is possibly undefined
// 44AD30: using guessed type _UNKNOWN *off_44AD30;

//----- (000000000043E9C0) ----------------------------------------------------
_BOOL8 sub_43E9C0()
{
  _BOOL8 result; // rax
  __int64 v1; // r8
  __int64 v2; // r9
  unsigned __int64 v3; // rcx
  __int64 v4; // r9
  _DWORD *v5; // rax
  __int64 v6; // r9
  unsigned __int64 v7; // r8

  result = 0LL;
  if ( *(_WORD *)off_44AD30 == 23117 )
  {
    result = sub_43E730((__int64)off_44AD30);
    if ( result )
    {
      v3 = v1 - v2;
      v4 = *(int *)(v2 + 60) + v2;
      v5 = (_DWORD *)(v4 + *(unsigned __int16 *)(v4 + 20) + 24);
      if ( *(_WORD *)(v4 + 6) )
      {
        v6 = (__int64)&v5[10 * *(unsigned __int16 *)(v4 + 6)];
        while ( 1 )
        {
          v7 = (unsigned int)v5[3];
          if ( v3 >= v7 && v3 < (unsigned int)(v5[2] + v7) )
            break;
          v5 += 10;
          if ( v5 == (_DWORD *)v6 )
            return 0LL;
        }
        return v5[9] >= 0;
      }
      else
      {
        return 0LL;
      }
    }
  }
  return result;
}
// 43E9EB: variable 'v1' is possibly undefined
// 43E9EB: variable 'v2' is possibly undefined
// 44AD30: using guessed type _UNKNOWN *off_44AD30;

//----- (000000000043EA50) ----------------------------------------------------
__int64 sub_43EA50()
{
  __int64 v0; // r9
  int v1; // r8d
  __int64 v2; // r11
  __int64 v3; // rcx
  unsigned __int64 v4; // rax
  __int64 v5; // rdx
  int v6; // ecx
  __int64 v7; // r10
  unsigned __int64 v8; // r9
  __int64 i; // rax

  v0 = 0LL;
  if ( *(_WORD *)off_44AD30 == 23117 && sub_43E730((__int64)off_44AD30) )
  {
    v3 = v2 + *(int *)(v2 + 60);
    v4 = *(unsigned int *)(v3 + 144);
    if ( (_DWORD)v4 )
    {
      v5 = v3 + *(unsigned __int16 *)(v3 + 20) + 24;
      v6 = *(unsigned __int16 *)(v3 + 6);
      if ( v6 )
      {
        v7 = v5 + 40LL * (unsigned int)(v6 - 1) + 40;
        while ( 1 )
        {
          v8 = *(unsigned int *)(v5 + 12);
          if ( v4 >= v8 && v4 < (unsigned int)(*(_DWORD *)(v5 + 8) + v8) )
            break;
          v5 += 40LL;
          if ( v5 == v7 )
            return 0LL;
        }
        for ( i = v2 + v4; *(_DWORD *)(i + 4) || *(_DWORD *)(i + 12); i += 20LL )
        {
          if ( v1 <= 0 )
            return v2 + *(unsigned int *)(i + 12);
          --v1;
        }
        return 0LL;
      }
    }
  }
  return v0;
}
// 43EA79: variable 'v2' is possibly undefined
// 43EAC8: variable 'v0' is possibly undefined
// 43EAD8: variable 'v1' is possibly undefined
// 44AD30: using guessed type _UNKNOWN *off_44AD30;

//----- (000000000043EB50) ----------------------------------------------------
FILE *__fastcall sub_43EB50(int a1)
{
  return &_iob_func()[a1];
}

//----- (000000000043EB78) ----------------------------------------------------
unsigned __int64 __fastcall sub_43EB78()
{
  unsigned __int64 v0; // rax
  char *v1; // rcx
  unsigned __int64 v3; // [rsp-8h] [rbp-10h]
  char v4; // [rsp+10h] [rbp+8h] BYREF

  v3 = v0;
  v1 = &v4;
  if ( v0 >= 0x1000 )
  {
    do
    {
      v1 -= 4096;
      v0 -= 4096LL;
    }
    while ( v0 > 0x1000 );
  }
  return v3;
}
// 43EB79: variable 'v0' is possibly undefined

// nfuncs=556 queued=468 decompiled=468 lumina nreq=0 worse=0 better=0
#error "There were 1 decompilation failure(s) on 468 function(s)"
