/* This file was generated by the Hex-Rays decompiler version 9.0.0.241217.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

int sub_1000101B();
int sub_10001036();
int sub_10001051();
int sub_1000105D();
int sub_10001069();
int sub_10001075();
int sub_1000166F();
int sub_100016CD();
_DWORD *__thiscall sub_100016F1(_DWORD *this, char a2);
BOOL __thiscall sub_10001724(void *this, int a2, _DWORD *a3);
const char *sub_10001770();
char *__stdcall sub_10001776(char *a1, int a2);
const char *sub_100017A4();
const char *sub_100017DB();
char *__stdcall sub_100017E1(char *a1, int a2);
_DWORD *__stdcall sub_1000180F(_DWORD *a1, int a2);
void __thiscall pugi::xml_writer_stream::~xml_writer_stream(pugi::xml_writer_stream *this); // idb
pugi::xml_writer *__thiscall pugi::xml_writer::xml_writer(pugi::xml_writer *this);
pugi::xml_writer *__thiscall pugi::xml_writer::xml_writer(pugi::xml_writer *this, const struct pugi::xml_writer *a2);
void *__thiscall pugi::xml_writer::operator=(void *this, int a2);
char *__thiscall sub_1000185C(char *this, char a2);
_DWORD *__thiscall pugi::xml_writer_file::operator=(_DWORD *this, int a2);
char *__thiscall sub_100018D3(char *this, char a2);
pugi::xml_writer_stream *__thiscall pugi::xml_writer_stream::xml_writer_stream(pugi::xml_writer_stream *this, const struct pugi::xml_writer_stream *a2);
_DWORD *__thiscall pugi::xml_writer_stream::operator=(_DWORD *this, int a2);
char *__thiscall sub_10001956(char *this, char a2);
_DWORD *__thiscall pugi::xml_text::operator=(_DWORD *this, _DWORD *a2);
char *__thiscall sub_100019E1(char *this, char a2);
void __thiscall pugi::xpath_exception::~xpath_exception(pugi::xpath_exception *__hidden this); // idb
pugi::xpath_exception *__thiscall pugi::xpath_exception::xpath_exception(pugi::xpath_exception *this, const struct pugi::xpath_exception *a2);
_DWORD *__thiscall pugi::xpath_exception::operator=(_DWORD *this, int a2);
char *__thiscall sub_10001A9A(char *this, char a2);
void __thiscall IToString::~IToString(IToString *this); // idb
IToString *__thiscall IToString::IToString(IToString *this); // idb
IToString *__thiscall IToString::IToString(IToString *this, const struct IToString *a2); // idb
char *__thiscall sub_10001B02(char *this, char a2);
void __thiscall IToCharArray::~IToCharArray(IToCharArray *this); // idb
IToCharArray *__thiscall IToCharArray::IToCharArray(IToCharArray *this); // idb
IToCharArray *__thiscall IToCharArray::IToCharArray(IToCharArray *this, const struct IToCharArray *a2); // idb
char *__thiscall sub_10001B6A(char *this, char a2);
_DWORD *__thiscall SValueBase<double>::SValueBase<double>(_DWORD *this);
char *__thiscall SValueBase<double>::SValueBase<double>(char *this, int a2);
int __thiscall SValueBase<double>::operator=(int this, int a2);
void __thiscall SString::~SString(void **this);
_DWORD *__thiscall SString::operator=(_DWORD *this, int a2);
Core::EnumStringContainer *__thiscall Core::EnumStringContainer::EnumStringContainer(Core::EnumStringContainer *this, const struct Core::EnumStringContainer *a2);
char *__thiscall sub_10001C7A(char *this, char a2);
void __thiscall Json::PathArgument::~PathArgument(void **this);
Titan::FunctionKey *__thiscall Titan::FunctionKey::FunctionKey(Titan::FunctionKey *this, const struct Titan::FunctionKey *a2);
int __thiscall Titan::FunctionKey::operator=(int this, int a2);
SaveFnKeys *__thiscall SaveFnKeys::SaveFnKeys(SaveFnKeys *this, const struct SaveFnKeys *a2); // idb
_BYTE *__thiscall SaveFnKeys::operator=(_BYTE *this, int a2);
UserSession *__thiscall UserSession::UserSession(UserSession *this); // idb
void __thiscall UserSession::Initialize(UserSession *this, const struct seh_usr_def *a2); // idb
void *__thiscall UserSession::operator=(void *this, const void *a2);
struct UserSession *__thiscall TitanSession::User(TitanSession *this); // idb
TitanSession *__thiscall TitanSession::TitanSession(TitanSession *this); // idb
void __thiscall TitanSession::~TitanSession(void **this);
TitanSession *__thiscall TitanSession::TitanSession(TitanSession *this, const struct TitanSession *a2); // idb
_DWORD *__thiscall TitanSession::operator=(_DWORD *this, _DWORD *a2);
void __thiscall TableItem::~TableItem(void **this);
TableItem *__thiscall TableItem::TableItem(TableItem *this, const struct TableItem *a2); // idb
char *__thiscall TableItem::operator=(char *this, int a2);
void __thiscall TableFile::SetAllowDup(TableFile *this, bool a2); // idb
void __thiscall TableFile::SetMixedCase(TableFile *this, bool a2); // idb
void *__thiscall TableFile::operator=(void *this, const void *a2);
TFDictionary *__thiscall TFDictionary::TFDictionary(TFDictionary *this); // idb
void __thiscall TFDictionary::Add(TFDictionary *this, const char *a2, const char *a3); // idb
int __thiscall SystemVariables::GetUserID(char *this, int a2);
int __thiscall SystemVariables::GetAccountingDate(char *this, int a2);
int __thiscall SystemVariables::GetPolicy(char *this, int a2);
int __thiscall SystemVariables::GetSystemNumber(SystemVariables *this); // idb
int __thiscall SystemVariables::GetRecordNumber(SystemVariables *this); // idb
int __thiscall SystemVariables::GetSecretCode(char *this, int a2);
int __thiscall SystemVariables::GetDiskUtils(char *this, int a2);
int __thiscall SystemVariables::GetDiskWork(char *this, int a2);
int __thiscall SystemVariables::GetDiskProgs(char *this, int a2);
int __thiscall SystemVariables::GetDiskDatas(char *this, int a2);
int __thiscall SystemVariables::GetDiskSystem(char *this, int a2);
void __thiscall SystemVariables::SetAccountingDate(int *this, int a2, int a3, int a4, int a5, int a6, int a7);
void __thiscall SystemVariables::SetPolicy(int *this, int a2, int a3, int a4, int a5, int a6, int a7);
void __thiscall SystemVariables::SetSystemNumber(SystemVariables *this, int a2); // idb
void __thiscall SystemVariables::SetRecordNumber(SystemVariables *this, int a2); // idb
void __thiscall SystemVariables::SetSecretCode(int *this, int a2, int a3, int a4, int a5, int a6, int a7);
SystemVariables *__thiscall SystemVariables::SystemVariables(SystemVariables *this, const struct SystemVariables *a2); // idb
_DWORD *__thiscall SystemVariables::operator=(_DWORD *this, _DWORD *a2);
char *__thiscall sub_100023DC(char *this, char a2);
void *__thiscall PowerList::operator=(void *this, const void *a2);
Json::Exception *__thiscall Json::Exception::Exception(Json::Exception *this, const struct Json::Exception *a2);
_DWORD *__thiscall Json::Exception::operator=(_DWORD *this, int a2);
char *__thiscall sub_100024AC(char *this, char a2);
void __thiscall Json::RuntimeError::~RuntimeError(Json::RuntimeError *__hidden this); // idb
Json::RuntimeError *__thiscall Json::RuntimeError::RuntimeError(Json::RuntimeError *this, const struct Json::RuntimeError *a2);
_DWORD *__thiscall Json::RuntimeError::operator=(_DWORD *this, int a2);
char *__thiscall sub_10002530(char *this, char a2);
Json::LogicError *__thiscall Json::LogicError::LogicError(Json::LogicError *this, const struct Json::LogicError *a2);
Json::StaticString *__thiscall Json::StaticString::StaticString(Json::StaticString *this, const char *a2);
const char *__thiscall Json::StaticString::c_str(Json::StaticString *this); // idb
void __thiscall Json::Value::`default constructor closure'(Json::Value *this); // idb
Json::PathArgument *__thiscall Json::PathArgument::PathArgument(Json::PathArgument *this, const struct Json::PathArgument *a2);
_DWORD *__thiscall Json::PathArgument::operator=(_DWORD *this, _DWORD *a2);
Json::Path *__thiscall Json::Path::Path(Json::Path *this, const struct Json::PathArgument **a2);
const struct Json::PathArgument **__thiscall Json::Path::operator=(const struct Json::PathArgument **this, const struct Json::PathArgument **a2);
bool __thiscall Json::ValueIteratorBase::operator==(Json::ValueIteratorBase *this, const struct Json::ValueIteratorBase *a2);
bool __thiscall Json::ValueIteratorBase::operator!=(Json::ValueIteratorBase *this, const struct Json::ValueIteratorBase *a2);
int __thiscall Json::ValueIteratorBase::operator-(const struct Json::ValueIteratorBase *this, Json::ValueIteratorBase *a2);
_DWORD *__thiscall Json::ValueConstIterator::operator++(Json::ValueIteratorBase *this, _DWORD *a2, int a3);
_DWORD *__thiscall Json::ValueConstIterator::operator--(Json::ValueIteratorBase *this, _DWORD *a2, int a3);
Json::ValueIteratorBase *__thiscall Json::ValueIterator::operator--(Json::ValueIteratorBase *this);
Json::ValueIteratorBase *__thiscall Json::ValueIterator::operator++(Json::ValueIteratorBase *this);
Json::ValueIterator *__thiscall Json::ValueIterator::operator++(const struct Json::ValueIterator *this, Json::ValueIterator *a2, int a3);
Json::ValueIterator *__thiscall Json::ValueIterator::operator--(const struct Json::ValueIterator *this, Json::ValueIterator *a2, int a3);
void __thiscall Json::Reader::~Reader(void **this);
Json::Reader *__thiscall Json::Reader::Reader(Json::Reader *this, const struct Json::Reader *a2);
int __thiscall Json::Reader::operator=(int this, int a2);
void __thiscall Json::CharReader::~CharReader(Json::CharReader *this); // idb
void __thiscall Json::CharReader::Factory::~Factory(Json::CharReader::Factory *this); // idb
Json::CharReader::Factory *__thiscall Json::CharReader::Factory::Factory(Json::CharReader::Factory *this);
Json::CharReader::Factory *__thiscall Json::CharReader::Factory::Factory(Json::CharReader::Factory *this, const struct Json::CharReader::Factory *a2);
char *__thiscall sub_1000290A(char *this, char a2);
Json::CharReader *__thiscall Json::CharReader::CharReader(Json::CharReader *this);
Json::CharReader *__thiscall Json::CharReader::CharReader(Json::CharReader *this, const struct Json::CharReader *a2);
char *__thiscall sub_1000296B(char *this, char a2);
char *__thiscall Json::StreamWriterBuilder::operator=(char *this, int a2);
char *__thiscall sub_10002A15(char *this, char a2);
Json::StreamWriter::Factory *__thiscall Json::StreamWriter::Factory::Factory(Json::StreamWriter::Factory *this);
Json::StreamWriter::Factory *__thiscall Json::StreamWriter::Factory::Factory(Json::StreamWriter::Factory *this, const struct Json::StreamWriter::Factory *a2);
char *__thiscall sub_10002A77(char *this, char a2);
char *__thiscall sub_10002ADD(char *this, char a2);
char *__thiscall sub_10002B60(char *this, char a2);
void __thiscall WinTitan::FeatureFlag::~FeatureFlag(void **this);
WinTitan::FeatureFlag *__thiscall WinTitan::FeatureFlag::FeatureFlag(WinTitan::FeatureFlag *this, const struct WinTitan::FeatureFlag *a2);
_DWORD *__thiscall WinTitan::FeatureFlag::operator=(_DWORD *this, _DWORD *a2);
const char *__thiscall MessageItem::ToString(MessageItem *this); // idb
const char *__thiscall MessageItem::GetMsgType(MessageItem *this); // idb
void *__thiscall MessageItem::operator=(void *this, void *Src);
int __thiscall AGENT_ACCESS::total_agents(AGENT_ACCESS *this); // idb
void *__thiscall XMLDocument::operator=(void *this, const void *a2);
const char *__thiscall XMLElement::GetName(XMLElement *this); // idb
int __thiscall XMLElement::GetType(XMLElement *this); // idb
void __thiscall XMLElement::SetType(XMLElement *this, int a2); // idb
struct XMLElement *__thiscall XMLElement::GetParent(XMLElement *this); // idb
void __thiscall XMLElement::CloseElement(XMLElement *this); // idb
const char *__thiscall XMLElement::GetValue(XMLElement *this); // idb
const char *__thiscall XMLElement::GetComment(XMLElement *this); // idb
bool __thiscall XMLElement::ElementIsOpen(XMLElement *this); // idb
void *__thiscall XMLElement::operator=(void *this, void *Src);
void __thiscall XMLWriter::RestoreAttrPerLine(XMLWriter *this); // idb
bool __thiscall XMLWriter::IsOpen(XMLWriter *this); // idb
XMLWriter *__thiscall XMLWriter::XMLWriter(XMLWriter *this, const struct XMLWriter *a2); // idb
char *__thiscall XMLWriter::operator=(char *this, int a2);
bool __thiscall XMLReader::IsGood(XMLReader *this); // idb
struct XMLDocument *__thiscall XMLReader::GetDocument(XMLReader *this); // idb
void *__thiscall XMLReader::operator=(void *this, const void *a2);
int __thiscall XMLIterator::GetAttrAsLong(XMLElement **this, const char *a2);
const char *__thiscall XMLIterator::GetAttrAsString(XMLElement **this, const char *a2);
char __thiscall XMLIterator::GetAttrAsChar(XMLElement **this, const char *a2);
__int16 __thiscall XMLIterator::GetAttrAsShort(XMLElement **this, const char *a2);
double __thiscall XMLIterator::GetAttrAsDouble(XMLElement **this, const char *a2);
const char *__thiscall XMLIterator::GetElementName(XMLIterator *this); // idb
_DWORD *__thiscall XMLAttributeIterator::operator=(_DWORD *this, _DWORD *a2);
_WORD *__thiscall FileAttributes::operator=(_WORD *this, int a2);
int __thiscall AGENT_ACCESS::has_all_access(AGENT_ACCESS *this); // idb
void *__thiscall AGENT_ACCESS::operator=(void *this, const void *a2);
AncillaryList *__thiscall AncillaryList::AncillaryList(AncillaryList *this, const struct AncillaryList *a2); // idb
_DWORD *__thiscall AncillaryList::operator=(_DWORD *this, int a2);
void *__thiscall CBANNER_SWAP::operator=(void *this, const void *a2);
// _DWORD __stdcall std::string::string(_DWORD); weak
char *__thiscall sub_10003074(char *this, char *Str);
_DWORD *__thiscall sub_100030A9(_DWORD *this, int a2, unsigned int a3);
int __thiscall sub_10003108(int this, const struct Json::PathArgument **a2);
const struct Json::PathArgument **__thiscall sub_1000316D(const struct Json::PathArgument **this, const struct Json::PathArgument **a2);
int *__thiscall sub_100032DC(int *this, int *a2);
_DWORD *__thiscall sub_100033FC(_DWORD *this, int a2);
_DWORD *__thiscall sub_10003425(_DWORD *this, _DWORD *a2, unsigned int a3, size_t Size);
char *__thiscall sub_100034C8(char *this, char *Src, size_t Size);
BOOL __thiscall sub_1000355C(const void **this, unsigned int a2, int a3);
void __thiscall sub_100035A2(void **this, char a2, size_t Size);
char __thiscall sub_100035E8(_DWORD *this, unsigned int a2);
void __thiscall Json::Path::~Path(void ***this);
int *__thiscall sub_10003678(int *this, int *a2);
void __thiscall sub_10003798(int this);
_DWORD *__thiscall sub_100037F8(int *this, _DWORD *a2);
_DWORD *__thiscall sub_10003810(int *this, _DWORD *a2);
_DWORD *__thiscall sub_1000382B(int *this, _DWORD *a2, char a3, int a4, int a5, char a6, int a7, int a8);
void __thiscall sub_10003946(int this);
_DWORD *__thiscall sub_10003990(void *this, _DWORD *a2, int a3);
void __thiscall sub_100039BA(const void **this, unsigned int a2, size_t Size);
_DWORD *__thiscall sub_10003AA7(int *this, _DWORD *a2, char a3, int a4, int a5, char a6, int a7, int a8);
_DWORD *__thiscall sub_10003BC3(_DWORD *this, _DWORD *a2, int a3, int a4, int a5);
void __thiscall sub_10003BE2(_DWORD *this);
void __thiscall sub_10003C0E(_DWORD *this);
void *__stdcall sub_10003C3B(unsigned int a1);
int __thiscall sub_10003C66(_DWORD *this, _DWORD *a2, int a3, int a4, int a5, int a6, int a7);
_DWORD *__cdecl sub_10003D11(char a1, int a2, int a3, char a4, int a5, int a6, char a7, int a8, int a9);
_DWORD *__thiscall sub_10003DB0(int *this, _DWORD *a2, int a3, int a4, int a5, int *a6, int a7, int a8, int a9, int a10, int a11);
int __thiscall sub_100040A4(_DWORD *this, int *a2, int a3, int a4, int a5, int a6, int a7);
_DWORD *__cdecl sub_100040F3(char a1, int a2, int a3, char a4, int a5, int a6, char a7, int a8, unsigned int a9);
_DWORD *__thiscall sub_100041C8(int *this, _DWORD *a2, int a3, int a4, int a5, int *a6, int a7, int a8, int a9, int a10, int a11);
int __cdecl sub_10004382(char a1, int a2, int a3, char a4, int a5, int a6, char a7);
int __cdecl sub_100043C7(char a1, int a2, int a3, char a4, int a5, int a6, char a7);
int __cdecl sub_1000440C(char a1, int a2, int a3, char a4, int a5, int a6, char a7);
int __cdecl sub_10004451(char a1, int a2, int a3, char a4, int a5, int a6, char a7);
int __thiscall sub_10004496(int this, int *a2);
int __thiscall sub_1000451F(_DWORD *this, int *a2);
int __thiscall sub_100045A8(int **this);
void __thiscall sub_100045D1(int this, int a2);
void __thiscall sub_1000472B(int this, int a2);
_DWORD *__cdecl sub_10004882(char a1, int a2, int a3, char a4, int a5, int a6, char a7, int a8, int a9);
unsigned int __cdecl sub_1000494D(char a1, int a2, int a3, char a4);
_DWORD *__cdecl sub_100049F0(char a1, int a2, int a3, char a4, int a5, int a6, char a7, int a8, int a9);
_DWORD *__cdecl sub_10004ABB(int a1, int a2, int a3, int *a4, int a5, int a6, _DWORD *a7, int a8, int a9);
_DWORD *__cdecl sub_10004B1A(int *a1, int a2, int a3, int a4, int a5, int a6, _DWORD *a7, int a8, int a9);
_DWORD *__cdecl sub_10004B85(int a1, int a2, int a3, int *a4, int a5, int a6, int *a7, int a8, int a9);
_DWORD *__cdecl sub_10004BCA(int *a1, int a2, int a3, int a4, int a5, int a6, int *a7, int a8, int a9);
int __stdcall sub_10004C0F(_DWORD *a1, _DWORD *a2);
_DWORD *__thiscall sub_10004C4D(_DWORD *this, _DWORD *a2);
Json::PathArgument *__fastcall sub_10004C92(const struct Json::PathArgument *a1, const struct Json::PathArgument *a2, Json::PathArgument *a3);
void __cdecl sub_10004CF6(int a1, int a2, int a3, int a4);
int __cdecl sub_10004D6F(int a1, unsigned int a2, int a3, int a4, int a5, unsigned int a6);
int __cdecl sub_10004E65(int a1, unsigned int a2, int a3, int a4, int a5, unsigned int a6);
char *__thiscall sub_10004FA3(char *this, char a2);
bool __cdecl compileMode(bool a1); // idb
char **__cdecl argParseForward(int *a1, const char *a2, const char *a3); // idb
int __thiscall CSEH_CONSOLE::get_width(CSEH_CONSOLE *this);
int __thiscall CSEH_CONSOLE::get_height(CSEH_CONSOLE *this);
int __thiscall CSEH_CONSOLE::get_restoration(CSEH_CONSOLE *this); // idb
CSEH_CONSOLE *__thiscall CSEH_CONSOLE::CSEH_CONSOLE(CSEH_CONSOLE *this, const struct CSEH_CONSOLE *a2); // idb
void *__thiscall CSEH_CONSOLE::operator=(void *this, const void *a2);
int __cdecl main(int argc, const char **argv, const char **envp);
int sub_100052F6();
int __thiscall sub_10005388(void *this);
int sub_100054F1();
void __fastcall sub_10005CD2(int a1, int a2);
int __fastcall sub_10005F15(void **a1, void *a2);
int __fastcall sub_10006048(void **a1, int a2);
void __fastcall sub_100063ED(int a1, int a2);
void __thiscall sub_100064B3(void *this);
int __fastcall sub_10006AF8(char a1);
int __thiscall sub_10006B22(char *this);
int __thiscall sub_10006C52(void *this);
int __thiscall sub_10006D82(void **this);
int __thiscall sub_10006E25(void **this);
void __fastcall sub_10006EBC(int a1, const char *a2);
char *sub_10006F21();
int __thiscall sub_10007037(void *this);
char *__thiscall sub_10007281(void *this);
void *sub_1000751E();
// void *__cdecl memcpy(void *, const void *Src, size_t Size);
// void __stdcall `eh vector destructor iterator'(void *, unsigned int, int, void (__thiscall *)(void *)); idb
// int __cdecl atexit(void (__cdecl *)());
// void *__cdecl memset(void *, int Val, size_t Size);
void sub_10007FAF();
void __cdecl sub_10007FCF(); // idb
void __cdecl sub_10007FFF(); // idb
// int __cdecl _clean_type_info_names_internal(_DWORD); weak
// void __stdcall __noreturn CxxThrowException(void *pExceptionObject, _ThrowInfo *pThrowInfo);
void sub_10008488();
void __cdecl sub_10008497(); // idb
void __cdecl sub_100084A6(); // idb
void __cdecl sub_100084B5(); // idb
void __cdecl sub_100084C0(); // idb
void __cdecl sub_100084CB(); // idb
void __cdecl sub_100084D6(); // idb
// const char *__cdecl std::_Winerror_map(_DWORD); weak
// void __cdecl std::_Xbad_alloc(); weak
// void __cdecl std::_Xout_of_range(const char *); weak
// void __cdecl __noreturn std::_Xlength_error(const char *); weak
// const char *__cdecl std::_Syserror_map(_DWORD); weak
// void *__cdecl operator new(unsigned int); weak
// void __cdecl operator delete(void *); weak
// void __cdecl operator delete[](void *); weak
// _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const struct std::exception *); weak
// int __stdcall std::exception::operator=(_DWORD); weak
// void __thiscall std::exception::~exception(std::exception *__hidden this); weak
// _DWORD __cdecl close_db(struct _POSBLOCK *, bool, bool); weak
// void __cdecl fn_keys(_DWORD); weak
// void __cdecl clear_keys(int *); weak
// void __cdecl set_std_keys(int *); weak
// void __cdecl do_status(const char *, _DWORD, _DWORD, _DWORD, _DWORD); weak
// _DWORD __cdecl scroll_list(char **const, const char *, int *, _DWORD, _DWORD); weak
// void __cdecl read_screen_text(_DWORD, _DWORD, _DWORD, char *); weak
// void __cdecl fn_do_keys(const char *, _DWORD, _DWORD); weak
// void __cdecl io_strx(struct io_field *, _DWORD); weak
// _DWORD __cdecl io_str(struct io_field *, int *); weak
// void __cdecl out_str(struct io_field *, _DWORD); weak
// void __cdecl update_time(); weak
// void __cdecl do_help(const char *, char *, char *); weak
// void __cdecl disptext2(_DWORD, _DWORD, const char *, _DWORD, _DWORD); weak
// void __cdecl box(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// void __cdecl disptext(_DWORD, _DWORD, const char *, _DWORD, _DWORD, _DWORD); weak
// void __cdecl trim_str(char *, _DWORD); weak
// int __cdecl get_exit_key(); weak
// void __cdecl disp_att(_DWORD, _DWORD, _DWORD, _DWORD); weak
// void __cdecl date_to_str(_DWORD, const char *, char *, _DWORD); weak
// void dispf(_DWORD, _DWORD, _DWORD, const char *, ...); weak
// _DWORD __cdecl do_dataset_io(_DWORD, struct _POSBLOCK *, char *, _DWORD, char *, _DWORD, _DWORD, const char *, _DWORD); weak
// void __cdecl disp_error2(_DWORD, const char *, const char *, _DWORD, _DWORD, _DWORD); weak
// void __cdecl scroll_window(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// void __cdecl disp_error(_DWORD, const char *, _DWORD, _DWORD, _DWORD); weak
// void __cdecl pad_str(char *, const char *, _DWORD, _DWORD); weak
// int __cdecl open_db(_DWORD, _DWORD, _DWORD, _DWORD); weak
// void __thiscall CSEH_CONSOLE::~CSEH_CONSOLE(CSEH_CONSOLE *__hidden this); weak
// _DWORD __cdecl put_system(const char *, const char *, const char *, const char *, _DWORD, _DWORD, const char *, const char *, const char *, const char *, const char *, const char *); weak
// void __cdecl seh_banner2(const char *, const char *, const char *, const char *, _DWORD, _DWORD); weak
// _DWORD __cdecl get_ctl_rec(_DWORD, _DWORD, const char *, char *, _DWORD, _DWORD); weak
// void __cdecl fill_security(struct security_def *, const char *); weak
// void __thiscall CBANNER_SWAP::~CBANNER_SWAP(CBANNER_SWAP *__hidden this); weak
// CBANNER_SWAP *__thiscall CBANNER_SWAP::CBANNER_SWAP(CBANNER_SWAP *__hidden this, char *, char *); weak
// _DWORD __cdecl get_system(char *, char *, char *, char *, char *, char *, char *, char *, char *, char *, char *, char *); weak
// CSEH_CONSOLE *__thiscall CSEH_CONSOLE::CSEH_CONSOLE(CSEH_CONSOLE *__hidden this, __int16, __int16); weak
// int __thiscall UI::Color::Color(_DWORD, _DWORD); weak
// _DWORD __thiscall UI::Rect::Rect(UI::Rect *__hidden this, const struct UI::Rect *); weak
// _DWORD __thiscall UI::PixelRect::PixelRect(UI::PixelRect *__hidden this, const struct UI::PixelRect *); weak
// _DWORD __thiscall UI::Rect::GetHeight(UI::Rect *__hidden this); weak
// _DWORD __thiscall UI::Rect::GetWidth(UI::Rect *__hidden this); weak
// char **__cdecl argParse(int *, const char *, const char *); weak
// ListBox2 *__thiscall ListBox2::ListBox2(ListBox2 *__hidden this, const struct ListBox2 *); weak
// int __stdcall ListBox2::operator=(_DWORD); weak
// TableFile *__thiscall TableFile::TableFile(TableFile *__hidden this); weak
// void __thiscall TableFile::Add(TableFile *__hidden this, const char *, const char *); weak
// _DWORD __thiscall Titan::SideBar::SideBar(Titan::SideBar *__hidden this, const struct Titan::SideBar *); weak
// int __stdcall Titan::SideBar::operator=(_DWORD); weak
// void __thiscall Json::ValueIteratorBase::increment(Json::ValueIteratorBase *__hidden this); weak
// void __thiscall Json::ValueIteratorBase::decrement(Json::ValueIteratorBase *__hidden this); weak
// _DWORD __thiscall Json::ValueIteratorBase::computeDistance(Json::ValueIteratorBase *__hidden this, const struct Json::ValueIteratorBase *); weak
// bool __thiscall Json::ValueIteratorBase::isEqual(Json::ValueIteratorBase *__hidden this, const struct Json::ValueIteratorBase *); weak
// _DWORD __thiscall Json::ValueIterator::ValueIterator(Json::ValueIterator *__hidden this, const struct Json::ValueIterator *); weak
// _DWORD __thiscall Json::Value::Value(Json::Value *__hidden this, const struct Json::Value *); weak
// int __thiscall Json::Value::Value(_DWORD, _DWORD); weak
// int __thiscall Json::Value::operator=(_DWORD); weak
// _DWORD __thiscall XMLElement::GetAttrAsLong(XMLElement *__hidden this, const char *); weak
// const char *__thiscall XMLElement::GetAttrAsString(XMLElement *__hidden this, const char *); weak
// char __thiscall XMLElement::GetAttrAsChar(XMLElement *__hidden this, const char *); weak
// __int16 __thiscall XMLElement::GetAttrAsShort(XMLElement *__hidden this, const char *); weak
// void __cdecl clx(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// double __thiscall XMLElement::GetAttrAsDouble(XMLElement *__hidden this, const char *); weak
// _DWORD __thiscall AGENT_ACCESS::has_inquire_access(AGENT_ACCESS *__hidden this, const struct py_mast_def *); weak
// _DWORD __cdecl is_reserved(struct py_mast_def *); weak
// void __cdecl build_street_address(char *, const char *, _DWORD, const char *, _DWORD, _DWORD, _DWORD, _DWORD); weak
// _DWORD __cdecl get_street_defaults(char *, char *, char *); weak
// _DWORD __thiscall AGENT_ACCESS::build_access_list(AGENT_ACCESS *__hidden this, const char *, const char *, struct security_def *); weak
// void __thiscall AGENT_ACCESS::~AGENT_ACCESS(AGENT_ACCESS *__hidden this); weak
// AGENT_ACCESS *__thiscall AGENT_ACCESS::AGENT_ACCESS(AGENT_ACCESS *__hidden this); weak

//-------------------------------------------------------------------------
// Data declarations

// extern int (__cdecl *strncmp)(const char *Str1, const char *Str2, size_t MaxCount);
// extern int (__cdecl *atol)(const char *String);
// extern char *(__cdecl *strncat)(char *Destination, const char *Source, size_t Count);
// extern char *(__cdecl *strstr)(const char *Str, const char *SubStr);
// extern int (*sprintf)(char *const Buffer, const char *const Format, ...);
// extern char *(__cdecl *strcpy)(char *Destination, const char *Source);
// extern void *(__cdecl *memset)(void *, int Val, size_t Size);
// extern size_t (__cdecl *strlen)(const char *Str);
// extern void *(__cdecl *memmove)(void *, const void *Src, size_t Size);
// extern void *(__cdecl *memcpy)(void *, const void *Src, size_t Size);
// extern char *(__cdecl *strncpy)(char *Destination, const char *Source, size_t Count);
// extern char *(__cdecl *strupr)(char *String);
// extern char *const py_1_name; idb
// extern char *const py_13_name; idb
// extern int sys_num; weak
// extern int rec_number; weak
// extern void (__thiscall *const pugi::xml_tree_walker::~xml_tree_walker)(void *); idb
// extern void (__thiscall *const SystemVariables::~SystemVariables)(void *); idb
// extern void (__thiscall *const Json::StreamWriter::~StreamWriter)(void *); idb
// extern void (__thiscall *const Json::StreamWriter::Factory::~Factory)(void *); idb
// extern void (__thiscall *const Json::Exception::~Exception)(void *); idb
// extern void (__thiscall *const Json::CharReaderBuilder::~CharReaderBuilder)(void *); idb
// extern void (__thiscall *const Json::StreamWriterBuilder::~StreamWriterBuilder)(void *); idb
void *SystemVariables::`vftable' = &sub_100023DC; // weak
void *IToCharArray::`vftable' = &sub_10001B6A; // weak
void *Json::LogicError::`vftable' = &sub_10002530; // weak
void *Json::CharReader::Factory::`vftable' = &sub_1000290A; // weak
void *Json::RuntimeError::`vftable' = &sub_10002530; // weak
void *Core::EnumStringContainer::`vftable'{for `IToString'} = &sub_10001C7A; // weak
void *IToString::`vftable' = &sub_10001B02; // weak
void *Json::StreamWriter::Factory::`vftable' = &sub_10002A77; // weak
void *SValueBase<double>::`vftable' = &purecall; // weak
void *pugi::xpath_exception::`vftable' = &sub_10001A9A; // weak
void *std::error_category::`vftable' = &sub_100016F1; // weak
void *pugi::xml_writer_stream::`vftable' = &sub_10001956; // weak
void *pugi::xml_writer::`vftable' = &sub_1000185C; // weak
void *Json::Exception::`vftable' = &sub_100024AC; // weak
void *Core::EnumStringContainer::`vftable'{for `IToCharArray'} = &sub_10004FA3; // weak
void *Json::CharReader::`vftable' = &sub_1000296B; // weak
char byte_100097BC[4] = { '\xC2', '\0', '\0', '\0' }; // weak
char byte_100097C0[4] = { '\xC3', '\0', '\0', '\0' }; // weak
char byte_100097C4[4] = { '\xC1', '\0', '\0', '\0' }; // weak
char byte_100097C8[4] = { '\xB4', '\0', '\0', '\0' }; // weak
__int128 xmmword_10009B90 = 1LL; // weak
__int128 xmmword_10009BA0 = 0x10000000000000000LL; // weak
__int128 xmmword_10009BB0 = 0x1000000000000000000000000LL; // weak
__int128 xmmword_10009BC0 = 0x5000000070000000200000002LL; // weak
__int128 xmmword_10009BD0 = 0x5000000080000000A00000007LL; // weak
__int128 xmmword_10009BE0 = 0x5000000190000000400000002LL; // weak
__int128 xmmword_10009BF0 = 0x60000001A0000000600000002LL; // weak
__int128 xmmword_10009C00 = 0x70000001A0000000800000002LL; // weak
__int128 xmmword_10009C10 = 0x40000000050000000F00000000LL; // weak
void (*dword_1000A428[2])(void) = { NULL, NULL }; // weak
void (*dword_1000A430[2])(void) = { NULL, NULL }; // weak
int dword_1000F020 = 8; // weak
int dword_1000F024 = 1; // weak
int dword_1000F028 = 2; // weak
char aXccccccccccccc_1[27] = "Xccccccccccccccccccccccccc"; // weak
char aXccccccccccccc[26] = "Xcccccccccccccccccccccccc"; // weak
char aXccccccccccccc_0[16] = "Xcccccccccccccc"; // weak
char aXxxxxxxxxx[11] = "XXXXXXXXXX"; // weak
char aA9a9a9[8] = "A9A 9A9"; // weak
char aZzzzzzz9[9] = "zzzzzzz9"; // weak
char aPy59b000[10] = "PY59b.000"; // weak
char aPy59b1F[10] = "PY59b.1-f"; // weak
char aPolicyLocation[35] = "Policy Location Search Information"; // weak
char (*off_1000F130)[70] = &byte_100102E0; // weak
int dword_1000F138 = 2; // weak
_UNKNOWN unk_1000F14C; // weak
_UNKNOWN unk_1000F150; // weak
int dword_1000F154 = 0; // weak
int dword_1000F158 = 0; // weak
int dword_1000F15C = 0; // weak
int dword_1000F160 = 0; // weak
_UNKNOWN unk_1000F164; // weak
_UNKNOWN unk_1000F168; // weak
int dword_1000F16C = 0; // weak
__int128 xmmword_1000F170 = 0LL; // weak
int dword_1000F180 = 0; // weak
int dword_1000F184 = 0; // weak
int dword_1000F188 = 0; // weak
int dword_1000F18C = 0; // weak
__int128 xmmword_1000F190 = 0LL; // weak
int dword_1000F1A0 = 0; // weak
_UNKNOWN unk_1000F1A4; // weak
_UNKNOWN unk_1000F1A8; // weak
int dword_1000F1AC = 0; // weak
int dword_1000F1B0 = 0; // weak
int dword_1000F1B4 = 0; // weak
int dword_1000F1B8 = 0; // weak
_UNKNOWN unk_1000F1BC; // weak
_UNKNOWN unk_1000F1C0; // weak
int dword_1000F1C4 = 0; // weak
int dword_1000F1C8 = 0; // weak
int dword_1000F1CC = 0; // weak
__int128 xmmword_1000F1D0 = 0LL; // weak
int dword_1000F1E0 = 0; // weak
int dword_1000F1E4 = 0; // weak
int dword_1000F1E8 = 0; // weak
int dword_1000F1EC = 0; // weak
int dword_1000F1F0 = 0; // weak
int dword_1000F1F4 = 0; // weak
int dword_1000F1F8 = 0; // weak
_UNKNOWN unk_1000F1FC; // weak
_UNKNOWN unk_1000F200; // weak
int dword_1000F204 = 0; // weak
int dword_1000F208 = 0; // weak
int dword_1000F20C = 0; // weak
int dword_1000F210 = 0; // weak
_UNKNOWN unk_1000F214; // weak
_UNKNOWN unk_1000F218; // weak
int dword_1000F21C = 0; // weak
__int128 xmmword_1000F220 = 0LL; // weak
int dword_1000F230 = 0; // weak
int dword_1000F234 = 0; // weak
int dword_1000F238 = 0; // weak
int dword_1000F23C = 0; // weak
__int128 xmmword_1000F240 = 0LL; // weak
int dword_1000F250 = 0; // weak
_UNKNOWN unk_1000F254; // weak
_UNKNOWN unk_1000F258; // weak
int dword_1000F25C = 0; // weak
int dword_1000F260 = 0; // weak
int dword_1000F264 = 0; // weak
int dword_1000F268 = 0; // weak
_UNKNOWN unk_1000F26C; // weak
_UNKNOWN unk_1000F270; // weak
int dword_1000F274 = 0; // weak
int dword_1000F278 = 0; // weak
int dword_1000F27C = 0; // weak
__int128 xmmword_1000F280 = 0LL; // weak
int dword_1000F290 = 0; // weak
int dword_1000F294 = 0; // weak
int dword_1000F298 = 0; // weak
int dword_1000F29C = 0; // weak
int dword_1000F2A0 = 0; // weak
int dword_1000F2A4 = 0; // weak
int dword_1000F2A8 = 0; // weak
_UNKNOWN unk_1000F2AC; // weak
_UNKNOWN unk_1000F2B0; // weak
int dword_1000F2B4 = 0; // weak
int dword_1000F2B8 = 0; // weak
int dword_1000F2BC = 0; // weak
int dword_1000F2C0 = 0; // weak
_UNKNOWN unk_1000F2C4; // weak
_UNKNOWN unk_1000F2C8; // weak
int dword_1000F2CC = 0; // weak
__int128 xmmword_1000F2D0 = 0LL; // weak
int dword_1000F2E0 = 0; // weak
int dword_1000F2E4 = 0; // weak
int dword_1000F2E8 = 0; // weak
int dword_1000F2EC = 0; // weak
__int128 xmmword_1000F2F0 = 0LL; // weak
int dword_1000F300 = 0; // weak
_UNKNOWN unk_1000F304; // weak
_UNKNOWN unk_1000F308; // weak
int dword_1000F30C = 0; // weak
int dword_1000F310 = 0; // weak
int dword_1000F314 = 0; // weak
int dword_1000F318 = 0; // weak
_UNKNOWN unk_1000F31C; // weak
_UNKNOWN unk_1000F320; // weak
int dword_1000F324 = 0; // weak
int dword_1000F328 = 0; // weak
int dword_1000F32C = 0; // weak
__int128 xmmword_1000F330 = 0LL; // weak
int dword_1000F340 = 0; // weak
int dword_1000F344 = 0; // weak
int dword_1000F348 = 0; // weak
int dword_1000F34C = 0; // weak
int dword_1000F350 = 0; // weak
int dword_1000F354 = 0; // weak
int dword_1000F358 = 0; // weak
_UNKNOWN unk_1000F35C; // weak
_UNKNOWN unk_1000F360; // weak
int dword_1000F364 = 0; // weak
int dword_1000F368 = 0; // weak
int dword_1000F36C = 0; // weak
int dword_1000F370 = 0; // weak
_UNKNOWN unk_1000F374; // weak
_UNKNOWN unk_1000F378; // weak
int dword_1000F37C = 0; // weak
__int128 xmmword_1000F380 = 0LL; // weak
int dword_1000F390 = 0; // weak
int dword_1000F394 = 0; // weak
int dword_1000F398 = 0; // weak
int dword_1000F39C = 0; // weak
__int128 xmmword_1000F3A0 = 0LL; // weak
int dword_1000F3B0 = 0; // weak
_UNKNOWN unk_1000F3B4; // weak
_UNKNOWN unk_1000F3B8; // weak
int dword_1000F3BC = 0; // weak
int dword_1000F3C0 = 0; // weak
int dword_1000F3C4 = 0; // weak
int dword_1000F3C8 = 0; // weak
_UNKNOWN unk_1000F3CC; // weak
_UNKNOWN unk_1000F3D0; // weak
int dword_1000F3D4 = 0; // weak
int dword_1000F3D8 = 0; // weak
int dword_1000F3DC = 0; // weak
__int128 xmmword_1000F3E0 = 0LL; // weak
int dword_1000F3F0 = 0; // weak
int dword_1000F3F4 = 0; // weak
int dword_1000F3F8 = 0; // weak
int dword_1000F3FC = 0; // weak
int dword_1000F400 = 0; // weak
int dword_1000F404 = 0; // weak
int dword_1000F408 = 0; // weak
_UNKNOWN unk_1000F40C; // weak
_UNKNOWN unk_1000F410; // weak
int dword_1000F414 = 0; // weak
int dword_1000F418 = 0; // weak
int dword_1000F41C = 0; // weak
int dword_1000F420 = 0; // weak
_UNKNOWN unk_1000F424; // weak
_UNKNOWN unk_1000F428; // weak
int dword_1000F42C = 0; // weak
__int128 xmmword_1000F430 = 0LL; // weak
int dword_1000F440 = 0; // weak
int dword_1000F444 = 0; // weak
int dword_1000F448 = 0; // weak
int dword_1000F44C = 0; // weak
__int128 xmmword_1000F450 = 0LL; // weak
int dword_1000F460 = 0; // weak
_UNKNOWN unk_1000F464; // weak
_UNKNOWN unk_1000F468; // weak
int dword_1000F46C = 0; // weak
int dword_1000F470 = 0; // weak
int dword_1000F474 = 0; // weak
int dword_1000F478 = 0; // weak
_UNKNOWN unk_1000F47C; // weak
_UNKNOWN unk_1000F480; // weak
int dword_1000F484 = 0; // weak
int dword_1000F488 = 0; // weak
int dword_1000F48C = 0; // weak
__int128 xmmword_1000F490 = 0LL; // weak
char (*off_1000F4A0)[16] = &byte_10010250; // weak
int dword_1000F4A8 = 2; // weak
_UNKNOWN unk_1000F4BC; // weak
_UNKNOWN unk_1000F4C0; // weak
__int128 xmmword_1000F4C4 = 0LL; // weak
_UNKNOWN unk_1000F4D4; // weak
_UNKNOWN unk_1000F4D8; // weak
__int128 xmmword_1000F4DC = 0LL; // weak
int dword_1000F4EC = 0; // weak
int dword_1000F4F0 = 0; // weak
int dword_1000F4F4 = 0; // weak
int (__stdcall **off_1000F4F8[3])(char) = { &off_1000942C, &off_100093A0, &off_10009448 }; // weak
int (__stdcall **off_1000F4FC[2])(char) = { &off_100093A0, &off_10009448 }; // weak
int (__stdcall **off_1000F500)(char) = &off_10009448; // weak
_UNKNOWN unk_1000FBA4; // weak
_UNKNOWN unk_1000FBB0; // weak
int dword_1000FBC4; // weak
_UNKNOWN unk_1000FBC8; // weak
int dword_1000FE18; // weak
int dword_1000FE1C; // weak
int dword_1000FE20; // weak
char Source; // idb
int dword_1000FE2E; // weak
int dword_1000FE34; // weak
int dword_1000FE38; // weak
char byte_1000FE3C; // weak
__int16 word_1000FE46; // weak
__int16 word_1000FE48; // weak
__int16 word_1000FE4A; // weak
char byte_1000FE4C[70]; // idb
char byte_1000FE92[70]; // weak
char byte_1000FED8[103]; // idb
char byte_1000FF3F[11]; // weak
char byte_1000FF4A[36]; // weak
char byte_1000FF6E[78]; // weak
char byte_1000FFBC[26]; // weak
char byte_1000FFD6[26]; // weak
char byte_1000FFF0[128]; // weak
char byte_10010070[4]; // weak
char byte_10010074[94]; // weak
char byte_100100D2; // weak
char byte_100100D8; // weak
char byte_100100D9; // weak
char byte_100100FE[140]; // weak
char byte_1001018A; // weak
int dword_100101E0; // weak
char byte_100101E4; // idb
char byte_10010214[10]; // weak
char byte_1001021E; // weak
char byte_10010220[26]; // idb
char byte_1001023A; // weak
char byte_10010240[15]; // idb
char byte_1001024F; // weak
char byte_10010250[16]; // weak
char String[12]; // idb
char byte_1001026C[8]; // idb
char byte_10010274[52]; // weak
char Str2[24]; // idb
char byte_100102C0[26]; // idb
char byte_100102DA; // weak
char byte_100102E0[70]; // idb
char byte_10010326; // weak
char Str[24]; // idb
char byte_10010340[26]; // idb
char byte_1001035A; // weak
char byte_10010360[26]; // idb
char byte_1001037A; // weak
char byte_10010380[25]; // idb
char byte_10010399; // weak
int dword_100103A0; // weak
int dword_100103AC; // weak
int dword_100103B0; // weak
char byte_100103C0[70]; // idb
char byte_10010406[10]; // idb
int dword_10010410; // weak
int dword_10010414; // weak
char byte_10010418[12]; // idb
_UNKNOWN unk_10010424; // weak
int dword_1001042E; // weak
int dword_10010432; // weak
char byte_10010436[26]; // idb
_UNKNOWN unk_10010450; // weak
int dword_1001045A; // weak
int dword_1001045E; // weak
char byte_10010462[26]; // idb
char byte_1001047C[46]; // idb
_UNKNOWN unk_100104AA; // weak
int dword_100104B4; // weak
int dword_100104B8; // weak
char byte_100104BC[26]; // idb
char byte_100104D6[26]; // idb
char byte_100104F0[26]; // idb
char byte_1001050A[36]; // idb
int dword_1001052E; // weak
int dword_10010532; // weak
int dword_10010588; // weak
int dword_1001058C[65]; // weak
int dword_10010690; // weak
int dword_10010694; // weak
int dword_100106A0; // weak
int dword_100106B0; // weak
int dword_100106B4; // weak
int dword_100106C0; // weak
int dword_100106C4; // weak
int dword_100106C8; // weak
int dword_100106D0; // weak
int dword_100106D4; // weak
int dword_10010738; // weak
int dword_1001073C; // weak
char byte_100107A0[264]; // weak
char byte_100108A8[264]; // weak
char byte_100109B0[264]; // weak
char byte_10010AB8[264]; // weak
char byte_10010BC0[260]; // weak
char byte_10010CC4[16]; // weak
char byte_10010CD4[16]; // weak
char byte_10010CE4[12]; // weak
char byte_10010CF0[16]; // weak
char Destination[16]; // idb
char byte_10010D10[36]; // weak
char byte_10010D34[24]; // weak
_UNKNOWN unk_10010D4C; // weak
char byte_10010D64[24]; // weak
char byte_10010D7C[28]; // weak
_UNKNOWN unk_10010D98; // weak


//----- (1000101B) --------------------------------------------------------
int sub_1000101B()
{
  sub_10003074(byte_10010D64, "Atlas");
  return atexit(sub_10008497);
}

//----- (10001036) --------------------------------------------------------
int sub_10001036()
{
  sub_10003074(byte_10010D7C, "Z0Z0Z0");
  return atexit(sub_100084A6);
}

//----- (10001051) --------------------------------------------------------
int sub_10001051()
{
  return atexit(sub_100084CB);
}

//----- (1000105D) --------------------------------------------------------
int sub_1000105D()
{
  return atexit(sub_100084C0);
}

//----- (10001069) --------------------------------------------------------
int sub_10001069()
{
  return atexit(sub_100084B5);
}

//----- (10001075) --------------------------------------------------------
int sub_10001075()
{
  int result; // eax

  UI::Color::Color(&unk_1000F14C, 5);
  UI::Color::Color(&unk_1000F150, 15);
  dword_1000F154 = 2;
  dword_1000F158 = 70;
  dword_1000F15C = 6;
  dword_1000F160 = 6;
  UI::Color::Color(&unk_1000F164, 7);
  UI::Color::Color(&unk_1000F168, 1);
  dword_1000F180 = 0;
  dword_1000F184 = 0;
  xmmword_1000F170 = (__int128)_mm_load_si128((const __m128i *)&xmmword_10009BA0);
  dword_1000F16C = 2;
  dword_1000F188 = (int)byte_1001026C;
  dword_1000F18C = (int)aA9a9a9;
  xmmword_1000F190 = (__int128)_mm_load_si128((const __m128i *)&xmmword_10009BC0);
  dword_1000F1A0 = 28;
  UI::Color::Color(&unk_1000F1A4, 5);
  UI::Color::Color(&unk_1000F1A8, 15);
  dword_1000F1AC = 3;
  dword_1000F1B0 = 7;
  dword_1000F1B4 = 5;
  dword_1000F1B8 = 28;
  UI::Color::Color(&unk_1000F1BC, 7);
  UI::Color::Color(&unk_1000F1C0, 1);
  dword_1000F1C8 = 0;
  dword_1000F1CC = 0;
  dword_1000F1C4 = 3;
  dword_1000F1EC = 3;
  xmmword_1000F1D0 = (__int128)_mm_load_si128((const __m128i *)&xmmword_10009B90);
  dword_1000F1E0 = (int)&unk_10010214;
  dword_1000F1E4 = (int)aXxxxxxxxxx;
  dword_1000F1E8 = 2;
  dword_1000F1F0 = 10;
  dword_1000F1F4 = 5;
  dword_1000F1F8 = 25;
  UI::Color::Color(&unk_1000F1FC, 5);
  UI::Color::Color(&unk_1000F200, 15);
  dword_1000F204 = 4;
  dword_1000F208 = 10;
  dword_1000F20C = 5;
  dword_1000F210 = 25;
  UI::Color::Color(&unk_1000F214, 7);
  UI::Color::Color(&unk_1000F218, 1);
  dword_1000F230 = 0;
  dword_1000F234 = 0;
  dword_1000F21C = 4;
  xmmword_1000F220 = (__int128)_mm_load_si128((const __m128i *)&xmmword_10009BA0);
  dword_1000F238 = (int)byte_10010380;
  dword_1000F23C = (int)aXccccccccccccc;
  xmmword_1000F240 = (__int128)_mm_load_si128((const __m128i *)&xmmword_10009BE0);
  dword_1000F250 = 21;
  UI::Color::Color(&unk_1000F254, 5);
  UI::Color::Color(&unk_1000F258, 15);
  dword_1000F25C = 5;
  dword_1000F260 = 25;
  dword_1000F264 = 5;
  dword_1000F268 = 21;
  UI::Color::Color(&unk_1000F26C, 7);
  UI::Color::Color(&unk_1000F270, 1);
  dword_1000F278 = 0;
  dword_1000F27C = 0;
  dword_1000F274 = 5;
  xmmword_1000F280 = (__int128)_mm_load_si128((const __m128i *)&xmmword_10009B90);
  dword_1000F290 = (int)byte_10010240;
  dword_1000F294 = (int)aXccccccccccccc_0;
  dword_1000F298 = 2;
  dword_1000F29C = 5;
  dword_1000F2A0 = 15;
  dword_1000F2A4 = 5;
  dword_1000F2A8 = 60;
  UI::Color::Color(&unk_1000F2AC, 5);
  UI::Color::Color(&unk_1000F2B0, 15);
  dword_1000F2B4 = 6;
  dword_1000F2B8 = 15;
  dword_1000F2BC = 5;
  dword_1000F2C0 = 60;
  UI::Color::Color(&unk_1000F2C4, 7);
  UI::Color::Color(&unk_1000F2C8, 1);
  dword_1000F2E0 = 0;
  dword_1000F2E4 = 0;
  dword_1000F2CC = 6;
  xmmword_1000F2D0 = (__int128)_mm_load_si128((const __m128i *)&xmmword_10009BA0);
  dword_1000F2E8 = (int)byte_10010340;
  dword_1000F2EC = (int)aXccccccccccccc_1;
  xmmword_1000F2F0 = (__int128)_mm_load_si128((const __m128i *)&xmmword_10009BF0);
  dword_1000F300 = 12;
  UI::Color::Color(&unk_1000F304, 5);
  UI::Color::Color(&unk_1000F308, 15);
  dword_1000F30C = 7;
  dword_1000F310 = 26;
  dword_1000F314 = 6;
  dword_1000F318 = 12;
  UI::Color::Color(&unk_1000F31C, 7);
  UI::Color::Color(&unk_1000F320, 1);
  dword_1000F328 = 0;
  dword_1000F32C = 0;
  dword_1000F344 = (int)aXccccccccccccc_1;
  dword_1000F324 = 7;
  xmmword_1000F330 = (__int128)_mm_load_si128((const __m128i *)&xmmword_10009B90);
  dword_1000F340 = (int)byte_10010220;
  dword_1000F348 = 2;
  dword_1000F34C = 7;
  dword_1000F350 = 26;
  dword_1000F354 = 6;
  dword_1000F358 = 52;
  UI::Color::Color(&unk_1000F35C, 5);
  UI::Color::Color(&unk_1000F360, 15);
  dword_1000F364 = 8;
  dword_1000F368 = 26;
  dword_1000F36C = 6;
  dword_1000F370 = 52;
  UI::Color::Color(&unk_1000F374, 7);
  UI::Color::Color(&unk_1000F378, 1);
  dword_1000F390 = 0;
  dword_1000F394 = 0;
  xmmword_1000F380 = (__int128)_mm_load_si128((const __m128i *)&xmmword_10009BA0);
  dword_1000F37C = 8;
  dword_1000F398 = (int)byte_10010360;
  dword_1000F39C = (int)aXccccccccccccc_1;
  xmmword_1000F3A0 = (__int128)_mm_load_si128((const __m128i *)&xmmword_10009C00);
  dword_1000F3B0 = 12;
  UI::Color::Color(&unk_1000F3B4, 5);
  UI::Color::Color(&unk_1000F3B8, 15);
  dword_1000F3BC = 9;
  dword_1000F3C0 = 26;
  dword_1000F3C4 = 7;
  dword_1000F3C8 = 12;
  UI::Color::Color(&unk_1000F3CC, 7);
  UI::Color::Color(&unk_1000F3D0, 1);
  dword_1000F3D8 = 0;
  dword_1000F3DC = 0;
  dword_1000F3D4 = 9;
  dword_1000F3FC = 9;
  xmmword_1000F3E0 = (__int128)_mm_load_si128((const __m128i *)&xmmword_10009B90);
  dword_1000F3F0 = (int)byte_100102C0;
  dword_1000F3F4 = (int)aXccccccccccccc_1;
  dword_1000F3F8 = 2;
  dword_1000F400 = 26;
  dword_1000F404 = 7;
  dword_1000F408 = 52;
  UI::Color::Color(&unk_1000F40C, 5);
  UI::Color::Color(&unk_1000F410, 15);
  dword_1000F414 = 10;
  dword_1000F418 = 26;
  dword_1000F41C = 7;
  dword_1000F420 = 52;
  UI::Color::Color(&unk_1000F424, 7);
  UI::Color::Color(&unk_1000F428, 1);
  xmmword_1000F430 = (__int128)_mm_load_si128((const __m128i *)&xmmword_10009BA0);
  dword_1000F42C = 10;
  dword_1000F440 = 0;
  dword_1000F444 = 0;
  dword_1000F448 = (int)String;
  dword_1000F44C = (int)aZzzzzzz9;
  xmmword_1000F450 = (__int128)_mm_load_si128((const __m128i *)&xmmword_10009BD0);
  dword_1000F460 = 30;
  UI::Color::Color(&unk_1000F464, 5);
  UI::Color::Color(&unk_1000F468, 15);
  dword_1000F46C = 0;
  dword_1000F470 = 8;
  dword_1000F474 = 5;
  dword_1000F478 = 30;
  UI::Color::Color(&unk_1000F47C, 7);
  result = UI::Color::Color(&unk_1000F480, 1);
  dword_1000F484 = 0;
  dword_1000F488 = 0;
  dword_1000F48C = 0;
  xmmword_1000F490 = (__int128)_mm_load_si128((const __m128i *)&xmmword_10009B90);
  return result;
}
// 10009180: using guessed type int __thiscall UI::Color::Color(_DWORD, _DWORD);
// 10009B90: using guessed type __int128 xmmword_10009B90;
// 10009BA0: using guessed type __int128 xmmword_10009BA0;
// 10009BC0: using guessed type __int128 xmmword_10009BC0;
// 10009BD0: using guessed type __int128 xmmword_10009BD0;
// 10009BE0: using guessed type __int128 xmmword_10009BE0;
// 10009BF0: using guessed type __int128 xmmword_10009BF0;
// 10009C00: using guessed type __int128 xmmword_10009C00;
// 1000F154: using guessed type int dword_1000F154;
// 1000F158: using guessed type int dword_1000F158;
// 1000F15C: using guessed type int dword_1000F15C;
// 1000F160: using guessed type int dword_1000F160;
// 1000F16C: using guessed type int dword_1000F16C;
// 1000F170: using guessed type __int128 xmmword_1000F170;
// 1000F180: using guessed type int dword_1000F180;
// 1000F184: using guessed type int dword_1000F184;
// 1000F188: using guessed type int dword_1000F188;
// 1000F18C: using guessed type int dword_1000F18C;
// 1000F190: using guessed type __int128 xmmword_1000F190;
// 1000F1A0: using guessed type int dword_1000F1A0;
// 1000F1AC: using guessed type int dword_1000F1AC;
// 1000F1B0: using guessed type int dword_1000F1B0;
// 1000F1B4: using guessed type int dword_1000F1B4;
// 1000F1B8: using guessed type int dword_1000F1B8;
// 1000F1C4: using guessed type int dword_1000F1C4;
// 1000F1C8: using guessed type int dword_1000F1C8;
// 1000F1CC: using guessed type int dword_1000F1CC;
// 1000F1D0: using guessed type __int128 xmmword_1000F1D0;
// 1000F1E0: using guessed type int dword_1000F1E0;
// 1000F1E4: using guessed type int dword_1000F1E4;
// 1000F1E8: using guessed type int dword_1000F1E8;
// 1000F1EC: using guessed type int dword_1000F1EC;
// 1000F1F0: using guessed type int dword_1000F1F0;
// 1000F1F4: using guessed type int dword_1000F1F4;
// 1000F1F8: using guessed type int dword_1000F1F8;
// 1000F204: using guessed type int dword_1000F204;
// 1000F208: using guessed type int dword_1000F208;
// 1000F20C: using guessed type int dword_1000F20C;
// 1000F210: using guessed type int dword_1000F210;
// 1000F21C: using guessed type int dword_1000F21C;
// 1000F220: using guessed type __int128 xmmword_1000F220;
// 1000F230: using guessed type int dword_1000F230;
// 1000F234: using guessed type int dword_1000F234;
// 1000F238: using guessed type int dword_1000F238;
// 1000F23C: using guessed type int dword_1000F23C;
// 1000F240: using guessed type __int128 xmmword_1000F240;
// 1000F250: using guessed type int dword_1000F250;
// 1000F25C: using guessed type int dword_1000F25C;
// 1000F260: using guessed type int dword_1000F260;
// 1000F264: using guessed type int dword_1000F264;
// 1000F268: using guessed type int dword_1000F268;
// 1000F274: using guessed type int dword_1000F274;
// 1000F278: using guessed type int dword_1000F278;
// 1000F27C: using guessed type int dword_1000F27C;
// 1000F280: using guessed type __int128 xmmword_1000F280;
// 1000F290: using guessed type int dword_1000F290;
// 1000F294: using guessed type int dword_1000F294;
// 1000F298: using guessed type int dword_1000F298;
// 1000F29C: using guessed type int dword_1000F29C;
// 1000F2A0: using guessed type int dword_1000F2A0;
// 1000F2A4: using guessed type int dword_1000F2A4;
// 1000F2A8: using guessed type int dword_1000F2A8;
// 1000F2B4: using guessed type int dword_1000F2B4;
// 1000F2B8: using guessed type int dword_1000F2B8;
// 1000F2BC: using guessed type int dword_1000F2BC;
// 1000F2C0: using guessed type int dword_1000F2C0;
// 1000F2CC: using guessed type int dword_1000F2CC;
// 1000F2D0: using guessed type __int128 xmmword_1000F2D0;
// 1000F2E0: using guessed type int dword_1000F2E0;
// 1000F2E4: using guessed type int dword_1000F2E4;
// 1000F2E8: using guessed type int dword_1000F2E8;
// 1000F2EC: using guessed type int dword_1000F2EC;
// 1000F2F0: using guessed type __int128 xmmword_1000F2F0;
// 1000F300: using guessed type int dword_1000F300;
// 1000F30C: using guessed type int dword_1000F30C;
// 1000F310: using guessed type int dword_1000F310;
// 1000F314: using guessed type int dword_1000F314;
// 1000F318: using guessed type int dword_1000F318;
// 1000F324: using guessed type int dword_1000F324;
// 1000F328: using guessed type int dword_1000F328;
// 1000F32C: using guessed type int dword_1000F32C;
// 1000F330: using guessed type __int128 xmmword_1000F330;
// 1000F340: using guessed type int dword_1000F340;
// 1000F344: using guessed type int dword_1000F344;
// 1000F348: using guessed type int dword_1000F348;
// 1000F34C: using guessed type int dword_1000F34C;
// 1000F350: using guessed type int dword_1000F350;
// 1000F354: using guessed type int dword_1000F354;
// 1000F358: using guessed type int dword_1000F358;
// 1000F364: using guessed type int dword_1000F364;
// 1000F368: using guessed type int dword_1000F368;
// 1000F36C: using guessed type int dword_1000F36C;
// 1000F370: using guessed type int dword_1000F370;
// 1000F37C: using guessed type int dword_1000F37C;
// 1000F380: using guessed type __int128 xmmword_1000F380;
// 1000F390: using guessed type int dword_1000F390;
// 1000F394: using guessed type int dword_1000F394;
// 1000F398: using guessed type int dword_1000F398;
// 1000F39C: using guessed type int dword_1000F39C;
// 1000F3A0: using guessed type __int128 xmmword_1000F3A0;
// 1000F3B0: using guessed type int dword_1000F3B0;
// 1000F3BC: using guessed type int dword_1000F3BC;
// 1000F3C0: using guessed type int dword_1000F3C0;
// 1000F3C4: using guessed type int dword_1000F3C4;
// 1000F3C8: using guessed type int dword_1000F3C8;
// 1000F3D4: using guessed type int dword_1000F3D4;
// 1000F3D8: using guessed type int dword_1000F3D8;
// 1000F3DC: using guessed type int dword_1000F3DC;
// 1000F3E0: using guessed type __int128 xmmword_1000F3E0;
// 1000F3F0: using guessed type int dword_1000F3F0;
// 1000F3F4: using guessed type int dword_1000F3F4;
// 1000F3F8: using guessed type int dword_1000F3F8;
// 1000F3FC: using guessed type int dword_1000F3FC;
// 1000F400: using guessed type int dword_1000F400;
// 1000F404: using guessed type int dword_1000F404;
// 1000F408: using guessed type int dword_1000F408;
// 1000F414: using guessed type int dword_1000F414;
// 1000F418: using guessed type int dword_1000F418;
// 1000F41C: using guessed type int dword_1000F41C;
// 1000F420: using guessed type int dword_1000F420;
// 1000F42C: using guessed type int dword_1000F42C;
// 1000F430: using guessed type __int128 xmmword_1000F430;
// 1000F440: using guessed type int dword_1000F440;
// 1000F444: using guessed type int dword_1000F444;
// 1000F448: using guessed type int dword_1000F448;
// 1000F44C: using guessed type int dword_1000F44C;
// 1000F450: using guessed type __int128 xmmword_1000F450;
// 1000F460: using guessed type int dword_1000F460;
// 1000F46C: using guessed type int dword_1000F46C;
// 1000F470: using guessed type int dword_1000F470;
// 1000F474: using guessed type int dword_1000F474;
// 1000F478: using guessed type int dword_1000F478;
// 1000F484: using guessed type int dword_1000F484;
// 1000F488: using guessed type int dword_1000F488;
// 1000F48C: using guessed type int dword_1000F48C;
// 1000F490: using guessed type __int128 xmmword_1000F490;

//----- (1000166F) --------------------------------------------------------
int sub_1000166F()
{
  int result; // eax

  UI::Color::Color(&unk_1000F4BC, 5);
  UI::Color::Color(&unk_1000F4C0, 15);
  xmmword_1000F4C4 = (__int128)_mm_load_si128((const __m128i *)&xmmword_10009C10);
  UI::Color::Color(&unk_1000F4D4, 7);
  UI::Color::Color(&unk_1000F4D8, 1);
  result = 0;
  xmmword_1000F4DC = (__int128)_mm_load_si128((const __m128i *)&xmmword_10009BB0);
  dword_1000F4EC = 0;
  dword_1000F4F0 = 0;
  dword_1000F4F4 = 0;
  return result;
}
// 10009180: using guessed type int __thiscall UI::Color::Color(_DWORD, _DWORD);
// 10009BB0: using guessed type __int128 xmmword_10009BB0;
// 10009C10: using guessed type __int128 xmmword_10009C10;
// 1000F4C4: using guessed type __int128 xmmword_1000F4C4;
// 1000F4DC: using guessed type __int128 xmmword_1000F4DC;
// 1000F4EC: using guessed type int dword_1000F4EC;
// 1000F4F0: using guessed type int dword_1000F4F0;
// 1000F4F4: using guessed type int dword_1000F4F4;

//----- (100016CD) --------------------------------------------------------
int sub_100016CD()
{
  AGENT_ACCESS::AGENT_ACCESS((AGENT_ACCESS *)&unk_10010D98);
  return atexit(sub_100084D6);
}
// 10009258: using guessed type AGENT_ACCESS *__thiscall AGENT_ACCESS::AGENT_ACCESS(AGENT_ACCESS *__hidden this);

//----- (100016F1) --------------------------------------------------------
_DWORD *__thiscall sub_100016F1(_DWORD *this, char a2)
{
  *this = &std::error_category::`vftable';
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 1000906C: using guessed type void __cdecl operator delete(void *);
// 10009464: using guessed type void *std::error_category::`vftable';

//----- (10001724) --------------------------------------------------------
BOOL __thiscall sub_10001724(void *this, int a2, _DWORD *a3)
{
  _DWORD *v3; // eax
  _BYTE v5[8]; // [esp+0h] [ebp-8h] BYREF

  v3 = (_DWORD *)(*(int (__thiscall **)(void *, _BYTE *, int))(*(_DWORD *)this + 12))(this, v5, a2);
  return v3[1] == a3[1] && *v3 == *a3;
}

//----- (10001770) --------------------------------------------------------
const char *sub_10001770()
{
  return "generic";
}

//----- (10001776) --------------------------------------------------------
char *__stdcall sub_10001776(char *a1, int a2)
{
  const char *v2; // eax
  char *v3; // ecx

  v2 = std::_Syserror_map(a2);
  v3 = "unknown error";
  if ( v2 )
    v3 = (char *)v2;
  sub_10003074(a1, v3);
  return a1;
}
// 10009038: using guessed type const char *__cdecl std::_Syserror_map(_DWORD);

//----- (100017A4) --------------------------------------------------------
const char *sub_100017A4()
{
  return "iostream";
}

//----- (100017DB) --------------------------------------------------------
const char *sub_100017DB()
{
  return "system";
}

//----- (100017E1) --------------------------------------------------------
char *__stdcall sub_100017E1(char *a1, int a2)
{
  const char *v2; // eax
  char *v3; // ecx

  v2 = std::_Winerror_map(a2);
  v3 = "unknown error";
  if ( v2 )
    v3 = (char *)v2;
  sub_10003074(a1, v3);
  return a1;
}
// 10009028: using guessed type const char *__cdecl std::_Winerror_map(_DWORD);

//----- (1000180F) --------------------------------------------------------
_DWORD *__stdcall sub_1000180F(_DWORD *a1, int a2)
{
  bool v2; // zf
  _DWORD *result; // eax

  v2 = std::_Syserror_map(a2) == 0;
  result = a1;
  *a1 = a2;
  if ( v2 )
    a1[1] = off_1000F4F8;
  else
    a1[1] = off_1000F4FC;
  return result;
}
// 10009038: using guessed type const char *__cdecl std::_Syserror_map(_DWORD);
// 1000F4F8: using guessed type int (__stdcall **off_1000F4F8[3])(char);
// 1000F4FC: using guessed type int (__stdcall **off_1000F4FC[2])(char);

//----- (1000183C) --------------------------------------------------------
void __thiscall pugi::xml_writer_stream::~xml_writer_stream(pugi::xml_writer_stream *this)
{
  *(_DWORD *)this = &pugi::xml_writer::`vftable';
}
// 1000948C: using guessed type void *pugi::xml_writer::`vftable';

//----- (10001843) --------------------------------------------------------
pugi::xml_writer *__thiscall pugi::xml_writer::xml_writer(pugi::xml_writer *this)
{
  *(_DWORD *)this = &pugi::xml_writer::`vftable';
  return this;
}
// 1000948C: using guessed type void *pugi::xml_writer::`vftable';

//----- (1000184C) --------------------------------------------------------
pugi::xml_writer *__thiscall pugi::xml_writer::xml_writer(pugi::xml_writer *this, const struct pugi::xml_writer *a2)
{
  *(_DWORD *)this = &pugi::xml_writer::`vftable';
  return this;
}
// 1000948C: using guessed type void *pugi::xml_writer::`vftable';

//----- (10001857) --------------------------------------------------------
void *__thiscall pugi::xml_writer::operator=(void *this, int a2)
{
  return this;
}

//----- (1000185C) --------------------------------------------------------
char *__thiscall sub_1000185C(char *this, char a2)
{
  if ( (a2 & 2) != 0 )
  {
    `eh vector destructor iterator'(
      this,
      4u,
      *((_DWORD *)this - 1),
      (void (__thiscall *)(void *))pugi::xml_writer_stream::~xml_writer_stream);
    if ( (a2 & 1) != 0 )
      operator delete[](this - 4);
    return this - 4;
  }
  else
  {
    *(_DWORD *)this = &pugi::xml_writer::`vftable';
    if ( (a2 & 1) != 0 )
      operator delete(this);
    return this;
  }
}
// 1000906C: using guessed type void __cdecl operator delete(void *);
// 10009074: using guessed type void __cdecl operator delete[](void *);
// 1000948C: using guessed type void *pugi::xml_writer::`vftable';

//----- (100018C1) --------------------------------------------------------
_DWORD *__thiscall pugi::xml_writer_file::operator=(_DWORD *this, int a2)
{
  this[1] = *(_DWORD *)(a2 + 4);
  return this;
}

//----- (100018D3) --------------------------------------------------------
char *__thiscall sub_100018D3(char *this, char a2)
{
  if ( (a2 & 2) != 0 )
  {
    `eh vector destructor iterator'(
      this,
      8u,
      *((_DWORD *)this - 1),
      (void (__thiscall *)(void *))pugi::xml_writer_stream::~xml_writer_stream);
    if ( (a2 & 1) != 0 )
      operator delete[](this - 4);
    return this - 4;
  }
  else
  {
    *(_DWORD *)this = &pugi::xml_writer::`vftable';
    if ( (a2 & 1) != 0 )
      operator delete(this);
    return this;
  }
}
// 1000906C: using guessed type void __cdecl operator delete(void *);
// 10009074: using guessed type void __cdecl operator delete[](void *);
// 1000948C: using guessed type void *pugi::xml_writer::`vftable';

//----- (10001920) --------------------------------------------------------
pugi::xml_writer_stream *__thiscall pugi::xml_writer_stream::xml_writer_stream(
        pugi::xml_writer_stream *this,
        const struct pugi::xml_writer_stream *a2)
{
  *(_DWORD *)this = &pugi::xml_writer_stream::`vftable';
  *((_DWORD *)this + 1) = *((_DWORD *)a2 + 1);
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  return this;
}
// 10009480: using guessed type void *pugi::xml_writer_stream::`vftable';

//----- (1000193E) --------------------------------------------------------
_DWORD *__thiscall pugi::xml_writer_stream::operator=(_DWORD *this, int a2)
{
  this[1] = *(_DWORD *)(a2 + 4);
  this[2] = *(_DWORD *)(a2 + 8);
  return this;
}

//----- (10001956) --------------------------------------------------------
char *__thiscall sub_10001956(char *this, char a2)
{
  if ( (a2 & 2) != 0 )
  {
    `eh vector destructor iterator'(
      this,
      0xCu,
      *((_DWORD *)this - 1),
      (void (__thiscall *)(void *))pugi::xml_writer_stream::~xml_writer_stream);
    if ( (a2 & 1) != 0 )
      operator delete[](this - 4);
    return this - 4;
  }
  else
  {
    *(_DWORD *)this = &pugi::xml_writer::`vftable';
    if ( (a2 & 1) != 0 )
      operator delete(this);
    return this;
  }
}
// 1000906C: using guessed type void __cdecl operator delete(void *);
// 10009074: using guessed type void __cdecl operator delete[](void *);
// 1000948C: using guessed type void *pugi::xml_writer::`vftable';

//----- (100019A3) --------------------------------------------------------
_DWORD *__thiscall pugi::xml_text::operator=(_DWORD *this, _DWORD *a2)
{
  *this = *a2;
  return this;
}

//----- (100019E1) --------------------------------------------------------
char *__thiscall sub_100019E1(char *this, char a2)
{
  if ( (a2 & 2) != 0 )
  {
    `eh vector destructor iterator'(this, 8u, *((_DWORD *)this - 1), pugi::xml_tree_walker::~xml_tree_walker);
    if ( (a2 & 1) != 0 )
      operator delete[](this - 4);
    return this - 4;
  }
  else
  {
    pugi::xml_tree_walker::~xml_tree_walker(this);
    if ( (a2 & 1) != 0 )
      operator delete(this);
    return this;
  }
}
// 1000906C: using guessed type void __cdecl operator delete(void *);
// 10009074: using guessed type void __cdecl operator delete[](void *);

//----- (10001A4A) --------------------------------------------------------
pugi::xpath_exception *__thiscall pugi::xpath_exception::xpath_exception(
        pugi::xpath_exception *this,
        const struct pugi::xpath_exception *a2)
{
  std::exception::exception(this, a2);
  *(_DWORD *)this = &pugi::xpath_exception::`vftable';
  *((_DWORD *)this + 3) = *((_DWORD *)a2 + 3);
  *((_DWORD *)this + 4) = *((_DWORD *)a2 + 4);
  return this;
}
// 10009084: using guessed type _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const struct std::exception *);
// 10009420: using guessed type void *pugi::xpath_exception::`vftable';

//----- (10001A75) --------------------------------------------------------
_DWORD *__thiscall pugi::xpath_exception::operator=(_DWORD *this, int a2)
{
  std::exception::operator=(a2);
  this[3] = *(_DWORD *)(a2 + 12);
  this[4] = *(_DWORD *)(a2 + 16);
  return this;
}
// 10009088: using guessed type int __stdcall std::exception::operator=(_DWORD);

//----- (10001A9A) --------------------------------------------------------
char *__thiscall sub_10001A9A(char *this, char a2)
{
  if ( (a2 & 2) != 0 )
  {
    `eh vector destructor iterator'(
      this,
      0x14u,
      *((_DWORD *)this - 1),
      (void (__thiscall *)(void *))pugi::xpath_exception::~xpath_exception);
    if ( (a2 & 1) != 0 )
      operator delete[](this - 4);
    return this - 4;
  }
  else
  {
    std::exception::~exception((std::exception *)this);
    if ( (a2 & 1) != 0 )
      operator delete(this);
    return this;
  }
}
// 1000906C: using guessed type void __cdecl operator delete(void *);
// 10009074: using guessed type void __cdecl operator delete[](void *);
// 1000908C: using guessed type void __thiscall std::exception::~exception(std::exception *__hidden this);

//----- (10001AE7) --------------------------------------------------------
void __thiscall IToString::~IToString(IToString *this)
{
  *(_DWORD *)this = &IToString::`vftable';
}
// 100093EC: using guessed type void *IToString::`vftable';

//----- (10001AEE) --------------------------------------------------------
IToString *__thiscall IToString::IToString(IToString *this)
{
  *(_DWORD *)this = &IToString::`vftable';
  return this;
}
// 100093EC: using guessed type void *IToString::`vftable';

//----- (10001AF7) --------------------------------------------------------
IToString *__thiscall IToString::IToString(IToString *this, const struct IToString *a2)
{
  *(_DWORD *)this = &IToString::`vftable';
  return this;
}
// 100093EC: using guessed type void *IToString::`vftable';

//----- (10001B02) --------------------------------------------------------
char *__thiscall sub_10001B02(char *this, char a2)
{
  if ( (a2 & 2) != 0 )
  {
    `eh vector destructor iterator'(this, 4u, *((_DWORD *)this - 1), (void (__thiscall *)(void *))IToString::~IToString);
    if ( (a2 & 1) != 0 )
      operator delete[](this - 4);
    return this - 4;
  }
  else
  {
    *(_DWORD *)this = &IToString::`vftable';
    if ( (a2 & 1) != 0 )
      operator delete(this);
    return this;
  }
}
// 1000906C: using guessed type void __cdecl operator delete(void *);
// 10009074: using guessed type void __cdecl operator delete[](void *);
// 100093EC: using guessed type void *IToString::`vftable';

//----- (10001B4F) --------------------------------------------------------
void __thiscall IToCharArray::~IToCharArray(IToCharArray *this)
{
  *(_DWORD *)this = &IToCharArray::`vftable';
}
// 1000932C: using guessed type void *IToCharArray::`vftable';

//----- (10001B56) --------------------------------------------------------
IToCharArray *__thiscall IToCharArray::IToCharArray(IToCharArray *this)
{
  *(_DWORD *)this = &IToCharArray::`vftable';
  return this;
}
// 1000932C: using guessed type void *IToCharArray::`vftable';

//----- (10001B5F) --------------------------------------------------------
IToCharArray *__thiscall IToCharArray::IToCharArray(IToCharArray *this, const struct IToCharArray *a2)
{
  *(_DWORD *)this = &IToCharArray::`vftable';
  return this;
}
// 1000932C: using guessed type void *IToCharArray::`vftable';

//----- (10001B6A) --------------------------------------------------------
char *__thiscall sub_10001B6A(char *this, char a2)
{
  if ( (a2 & 2) != 0 )
  {
    `eh vector destructor iterator'(
      this,
      4u,
      *((_DWORD *)this - 1),
      (void (__thiscall *)(void *))IToCharArray::~IToCharArray);
    if ( (a2 & 1) != 0 )
      operator delete[](this - 4);
    return this - 4;
  }
  else
  {
    *(_DWORD *)this = &IToCharArray::`vftable';
    if ( (a2 & 1) != 0 )
      operator delete(this);
    return this;
  }
}
// 1000906C: using guessed type void __cdecl operator delete(void *);
// 10009074: using guessed type void __cdecl operator delete[](void *);
// 1000932C: using guessed type void *IToCharArray::`vftable';

//----- (10001BB7) --------------------------------------------------------
_DWORD *__thiscall SValueBase<double>::SValueBase<double>(_DWORD *this)
{
  *this = &SValueBase<double>::`vftable';
  return this;
}
// 10009410: using guessed type void *SValueBase<double>::`vftable';

//----- (10001BC0) --------------------------------------------------------
char *__thiscall SValueBase<double>::SValueBase<double>(char *this, int a2)
{
  char *result; // eax

  *(_DWORD *)this = &SValueBase<double>::`vftable';
  result = this;
  *(_QWORD *)(this + 4) = *(_QWORD *)(a2 + 4);
  return result;
}
// 10009410: using guessed type void *SValueBase<double>::`vftable';

//----- (10001BDC) --------------------------------------------------------
int __thiscall SValueBase<double>::operator=(int this, int a2)
{
  int result; // eax

  result = this;
  *(_QWORD *)(this + 4) = *(_QWORD *)(a2 + 4);
  return result;
}

//----- (10001BF2) --------------------------------------------------------
void __thiscall SString::~SString(void **this)
{
  sub_100035A2(this + 2, 1, 0);
  this[1] = &IToCharArray::`vftable';
  *this = &IToString::`vftable';
}
// 1000932C: using guessed type void *IToCharArray::`vftable';
// 100093EC: using guessed type void *IToString::`vftable';

//----- (10001C10) --------------------------------------------------------
_DWORD *__thiscall SString::operator=(_DWORD *this, int a2)
{
  _DWORD *v3; // ecx

  v3 = this + 2;
  if ( v3 != (_DWORD *)(a2 + 8) )
    sub_10003425(v3, (_DWORD *)(a2 + 8), 0, 0xFFFFFFFF);
  return this;
}

//----- (10001C34) --------------------------------------------------------
Core::EnumStringContainer *__thiscall Core::EnumStringContainer::EnumStringContainer(
        Core::EnumStringContainer *this,
        const struct Core::EnumStringContainer *a2)
{
  *((_DWORD *)this + 1) = &IToCharArray::`vftable';
  *(_DWORD *)this = &Core::EnumStringContainer::`vftable'{for `IToString'};
  *((_DWORD *)this + 1) = &Core::EnumStringContainer::`vftable'{for `IToCharArray'};
  std::string::string((char *)a2 + 8);
  return this;
}
// 1000304E: using guessed type _DWORD __stdcall std::string::string(_DWORD);
// 1000932C: using guessed type void *IToCharArray::`vftable';
// 100093E0: using guessed type void *Core::EnumStringContainer::`vftable'{for `IToString'};
// 100094A4: using guessed type void *Core::EnumStringContainer::`vftable'{for `IToCharArray'};

//----- (10001C7A) --------------------------------------------------------
char *__thiscall sub_10001C7A(char *this, char a2)
{
  if ( (a2 & 2) != 0 )
  {
    `eh vector destructor iterator'(this, 0x20u, *((_DWORD *)this - 1), (void (__thiscall *)(void *))SString::~SString);
    if ( (a2 & 1) != 0 )
      operator delete[](this - 4);
    return this - 4;
  }
  else
  {
    SString::~SString((void **)this);
    if ( (a2 & 1) != 0 )
      operator delete(this);
    return this;
  }
}
// 1000906C: using guessed type void __cdecl operator delete(void *);
// 10009074: using guessed type void __cdecl operator delete[](void *);

//----- (10001CD7) --------------------------------------------------------
void __thiscall Json::PathArgument::~PathArgument(void **this)
{
  sub_100035A2(this, 1, 0);
}

//----- (10001CE1) --------------------------------------------------------
Titan::FunctionKey *__thiscall Titan::FunctionKey::FunctionKey(
        Titan::FunctionKey *this,
        const struct Titan::FunctionKey *a2)
{
  std::string::string(a2);
  *((_BYTE *)this + 24) = *((_BYTE *)a2 + 24);
  return this;
}
// 1000304E: using guessed type _DWORD __stdcall std::string::string(_DWORD);

//----- (10001CFF) --------------------------------------------------------
int __thiscall Titan::FunctionKey::operator=(int this, int a2)
{
  if ( this != a2 )
    sub_10003425((_DWORD *)this, (_DWORD *)a2, 0, 0xFFFFFFFF);
  *(_BYTE *)(this + 24) = *(_BYTE *)(a2 + 24);
  return this;
}

//----- (10001D25) --------------------------------------------------------
SaveFnKeys *__thiscall SaveFnKeys::SaveFnKeys(SaveFnKeys *this, const struct SaveFnKeys *a2)
{
  Titan::SideBar::SideBar(this, a2);
  *((_BYTE *)this + 16) = *((_BYTE *)a2 + 16);
  return this;
}
// 100091D8: using guessed type _DWORD __thiscall Titan::SideBar::SideBar(Titan::SideBar *__hidden this, const struct Titan::SideBar *);

//----- (10001D44) --------------------------------------------------------
_BYTE *__thiscall SaveFnKeys::operator=(_BYTE *this, int a2)
{
  Titan::SideBar::operator=(a2);
  this[16] = *(_BYTE *)(a2 + 16);
  return this;
}
// 100091DC: using guessed type int __stdcall Titan::SideBar::operator=(_DWORD);

//----- (10001D63) --------------------------------------------------------
UserSession *__thiscall UserSession::UserSession(UserSession *this)
{
  memset(this, 0, 0x18Cu);
  return this;
}

//----- (10001D7B) --------------------------------------------------------
void __thiscall UserSession::Initialize(UserSession *this, const struct seh_usr_def *a2)
{
  qmemcpy(this, a2, 0x18Cu);
}

//----- (10001D90) --------------------------------------------------------
void *__thiscall UserSession::operator=(void *this, const void *a2)
{
  void *result; // eax

  result = this;
  qmemcpy(this, a2, 0x18Cu);
  return result;
}

//----- (10001DA7) --------------------------------------------------------
struct UserSession *__thiscall TitanSession::User(TitanSession *this)
{
  return this;
}

//----- (10001DAA) --------------------------------------------------------
TitanSession *__thiscall TitanSession::TitanSession(TitanSession *this)
{
  TitanSession *result; // eax

  memset(this, 0, 0x18Cu);
  *((_DWORD *)this + 103) = 0;
  *((_DWORD *)this + 104) = 15;
  result = this;
  *((_BYTE *)this + 396) = 0;
  return result;
}

//----- (10001DDA) --------------------------------------------------------
void __thiscall TitanSession::~TitanSession(void **this)
{
  sub_100035A2(this + 99, 1, 0);
}

//----- (10001DEA) --------------------------------------------------------
TitanSession *__thiscall TitanSession::TitanSession(TitanSession *this, const struct TitanSession *a2)
{
  qmemcpy(this, a2, 0x18Cu);
  std::string::string((char *)a2 + 396);
  return this;
}
// 1000304E: using guessed type _DWORD __stdcall std::string::string(_DWORD);

//----- (10001E18) --------------------------------------------------------
_DWORD *__thiscall TitanSession::operator=(_DWORD *this, _DWORD *a2)
{
  _DWORD *v3; // ecx

  qmemcpy(this, a2, 0x18Cu);
  v3 = this + 99;
  if ( v3 != a2 + 99 )
    sub_10003425(v3, a2 + 99, 0, 0xFFFFFFFF);
  return this;
}

//----- (10001E4E) --------------------------------------------------------
void __thiscall TableItem::~TableItem(void **this)
{
  sub_100035A2(this + 65, 1, 0);
}

//----- (10001E5E) --------------------------------------------------------
TableItem *__thiscall TableItem::TableItem(TableItem *this, const struct TableItem *a2)
{
  *(_DWORD *)this = *(_DWORD *)a2;
  qmemcpy((char *)this + 4, (char *)a2 + 4, 0x100u);
  std::string::string((char *)a2 + 260);
  qmemcpy((char *)this + 284, (char *)a2 + 284, 0x20u);
  qmemcpy((char *)this + 316, (char *)a2 + 316, 0x100u);
  qmemcpy((char *)this + 572, (char *)a2 + 572, 0x22u);
  return this;
}
// 1000304E: using guessed type _DWORD __stdcall std::string::string(_DWORD);

//----- (10001EE7) --------------------------------------------------------
char *__thiscall TableItem::operator=(char *this, int a2)
{
  int v2; // edx
  int v4; // edi
  _BYTE *v5; // ecx
  _BYTE *v6; // ecx
  int v7; // ebx
  _BYTE *v8; // ecx
  int v9; // edx
  int v10; // edx
  _BYTE *v11; // ecx

  v2 = 256;
  v4 = a2 - (_DWORD)this;
  *(_DWORD *)this = *(_DWORD *)a2;
  v5 = this + 4;
  do
  {
    *v5 = v5[v4];
    ++v5;
    --v2;
  }
  while ( v2 );
  if ( this + 260 != (char *)(a2 + 260) )
    sub_10003425((_DWORD *)this + 65, (_DWORD *)(a2 + 260), 0, 0xFFFFFFFF);
  v6 = this + 284;
  v7 = 32;
  do
  {
    *v6 = v6[v4];
    ++v6;
    --v7;
  }
  while ( v7 );
  v8 = this + 316;
  v9 = 256;
  do
  {
    *v8 = v8[v4];
    ++v8;
    --v9;
  }
  while ( v9 );
  v10 = 32;
  v11 = this + 572;
  do
  {
    *v11 = v11[v4];
    ++v11;
    --v10;
  }
  while ( v10 );
  this[604] = *(_BYTE *)(a2 + 604);
  this[605] = *(_BYTE *)(a2 + 605);
  return this;
}

//----- (10001F88) --------------------------------------------------------
void __thiscall TableFile::SetAllowDup(TableFile *this, bool a2)
{
  *((_BYTE *)this + 1575) = a2;
}

//----- (10001F98) --------------------------------------------------------
void __thiscall TableFile::SetMixedCase(TableFile *this, bool a2)
{
  *((_BYTE *)this + 1570) = a2;
}

//----- (10001FA8) --------------------------------------------------------
void *__thiscall TableFile::operator=(void *this, const void *a2)
{
  void *result; // eax

  result = this;
  qmemcpy(this, a2, 0x668u);
  return result;
}

//----- (10001FC1) --------------------------------------------------------
TFDictionary *__thiscall TFDictionary::TFDictionary(TFDictionary *this)
{
  TFDictionary *result; // eax

  TableFile::TableFile(this);
  *((_BYTE *)this + 1575) = 1;
  result = this;
  *((_BYTE *)this + 1570) = 1;
  return result;
}
// 100091C8: using guessed type TableFile *__thiscall TableFile::TableFile(TableFile *__hidden this);

//----- (10001FDC) --------------------------------------------------------
void __thiscall TFDictionary::Add(TFDictionary *this, const char *a2, const char *a3)
{
  TableFile::Add(this, a2, a3);
}
// 100091D0: using guessed type void __thiscall TableFile::Add(TableFile *__hidden this, const char *, const char *);

//----- (10002009) --------------------------------------------------------
int __thiscall SystemVariables::GetUserID(char *this, int a2)
{
  std::string::string(this + 28);
  return a2;
}
// 1000304E: using guessed type _DWORD __stdcall std::string::string(_DWORD);

//----- (10002026) --------------------------------------------------------
int __thiscall SystemVariables::GetAccountingDate(char *this, int a2)
{
  std::string::string(this + 52);
  return a2;
}
// 1000304E: using guessed type _DWORD __stdcall std::string::string(_DWORD);

//----- (10002043) --------------------------------------------------------
int __thiscall SystemVariables::GetPolicy(char *this, int a2)
{
  std::string::string(this + 76);
  return a2;
}
// 1000304E: using guessed type _DWORD __stdcall std::string::string(_DWORD);

//----- (10002060) --------------------------------------------------------
int __thiscall SystemVariables::GetSystemNumber(SystemVariables *this)
{
  return *((_DWORD *)this + 25);
}

//----- (10002064) --------------------------------------------------------
int __thiscall SystemVariables::GetRecordNumber(SystemVariables *this)
{
  return *((_DWORD *)this + 26);
}

//----- (10002068) --------------------------------------------------------
int __thiscall SystemVariables::GetSecretCode(char *this, int a2)
{
  std::string::string(this + 108);
  return a2;
}
// 1000304E: using guessed type _DWORD __stdcall std::string::string(_DWORD);

//----- (10002085) --------------------------------------------------------
int __thiscall SystemVariables::GetDiskUtils(char *this, int a2)
{
  std::string::string(this + 132);
  return a2;
}
// 1000304E: using guessed type _DWORD __stdcall std::string::string(_DWORD);

//----- (100020A5) --------------------------------------------------------
int __thiscall SystemVariables::GetDiskWork(char *this, int a2)
{
  std::string::string(this + 156);
  return a2;
}
// 1000304E: using guessed type _DWORD __stdcall std::string::string(_DWORD);

//----- (100020C5) --------------------------------------------------------
int __thiscall SystemVariables::GetDiskProgs(char *this, int a2)
{
  std::string::string(this + 180);
  return a2;
}
// 1000304E: using guessed type _DWORD __stdcall std::string::string(_DWORD);

//----- (100020E5) --------------------------------------------------------
int __thiscall SystemVariables::GetDiskDatas(char *this, int a2)
{
  std::string::string(this + 204);
  return a2;
}
// 1000304E: using guessed type _DWORD __stdcall std::string::string(_DWORD);

//----- (10002105) --------------------------------------------------------
int __thiscall SystemVariables::GetDiskSystem(char *this, int a2)
{
  std::string::string(this + 228);
  return a2;
}
// 1000304E: using guessed type _DWORD __stdcall std::string::string(_DWORD);

//----- (10002125) --------------------------------------------------------
void __thiscall SystemVariables::SetAccountingDate(int *this, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int *v7; // ecx

  v7 = this + 13;
  if ( v7 != &a2 )
    sub_10003425(v7, &a2, 0, 0xFFFFFFFF);
  sub_100035A2((void **)&a2, 1, 0);
}

//----- (10002161) --------------------------------------------------------
void __thiscall SystemVariables::SetPolicy(int *this, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int *v7; // ecx

  v7 = this + 19;
  if ( v7 != &a2 )
    sub_10003425(v7, &a2, 0, 0xFFFFFFFF);
  sub_100035A2((void **)&a2, 1, 0);
}

//----- (1000219D) --------------------------------------------------------
void __thiscall SystemVariables::SetSystemNumber(SystemVariables *this, int a2)
{
  *((_DWORD *)this + 25) = a2;
}

//----- (100021AA) --------------------------------------------------------
void __thiscall SystemVariables::SetRecordNumber(SystemVariables *this, int a2)
{
  *((_DWORD *)this + 26) = a2;
}

//----- (100021B7) --------------------------------------------------------
void __thiscall SystemVariables::SetSecretCode(int *this, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int *v7; // ecx

  v7 = this + 27;
  if ( v7 != &a2 )
    sub_10003425(v7, &a2, 0, 0xFFFFFFFF);
  sub_100035A2((void **)&a2, 1, 0);
}

//----- (100021F3) --------------------------------------------------------
SystemVariables *__thiscall SystemVariables::SystemVariables(SystemVariables *this, const struct SystemVariables *a2)
{
  *(_DWORD *)this = &SystemVariables::`vftable';
  std::string::string((char *)a2 + 4);
  std::string::string((char *)a2 + 28);
  std::string::string((char *)a2 + 52);
  std::string::string((char *)a2 + 76);
  *((_DWORD *)this + 25) = *((_DWORD *)a2 + 25);
  *((_DWORD *)this + 26) = *((_DWORD *)a2 + 26);
  std::string::string((char *)a2 + 108);
  std::string::string((char *)a2 + 132);
  std::string::string((char *)a2 + 156);
  std::string::string((char *)a2 + 180);
  std::string::string((char *)a2 + 204);
  std::string::string((char *)a2 + 228);
  return this;
}
// 1000304E: using guessed type _DWORD __stdcall std::string::string(_DWORD);
// 10009324: using guessed type void *SystemVariables::`vftable';

//----- (100022DD) --------------------------------------------------------
_DWORD *__thiscall SystemVariables::operator=(_DWORD *this, _DWORD *a2)
{
  _DWORD *v3; // ecx

  v3 = this + 1;
  if ( v3 != a2 + 1 )
    sub_10003425(v3, a2 + 1, 0, 0xFFFFFFFF);
  if ( this + 7 != a2 + 7 )
    sub_10003425(this + 7, a2 + 7, 0, 0xFFFFFFFF);
  if ( this + 13 != a2 + 13 )
    sub_10003425(this + 13, a2 + 13, 0, 0xFFFFFFFF);
  if ( this + 19 != a2 + 19 )
    sub_10003425(this + 19, a2 + 19, 0, 0xFFFFFFFF);
  this[25] = a2[25];
  this[26] = a2[26];
  if ( this + 27 != a2 + 27 )
    sub_10003425(this + 27, a2 + 27, 0, 0xFFFFFFFF);
  if ( this + 33 != a2 + 33 )
    sub_10003425(this + 33, a2 + 33, 0, 0xFFFFFFFF);
  if ( this + 39 != a2 + 39 )
    sub_10003425(this + 39, a2 + 39, 0, 0xFFFFFFFF);
  if ( this + 45 != a2 + 45 )
    sub_10003425(this + 45, a2 + 45, 0, 0xFFFFFFFF);
  if ( this + 51 != a2 + 51 )
    sub_10003425(this + 51, a2 + 51, 0, 0xFFFFFFFF);
  if ( this + 57 != a2 + 57 )
    sub_10003425(this + 57, a2 + 57, 0, 0xFFFFFFFF);
  return this;
}

//----- (100023DC) --------------------------------------------------------
char *__thiscall sub_100023DC(char *this, char a2)
{
  if ( (a2 & 2) != 0 )
  {
    `eh vector destructor iterator'(this, 0xFCu, *((_DWORD *)this - 1), SystemVariables::~SystemVariables);
    if ( (a2 & 1) != 0 )
      operator delete[](this - 4);
    return this - 4;
  }
  else
  {
    SystemVariables::~SystemVariables(this);
    if ( (a2 & 1) != 0 )
      operator delete(this);
    return this;
  }
}
// 1000906C: using guessed type void __cdecl operator delete(void *);
// 10009074: using guessed type void __cdecl operator delete[](void *);

//----- (1000242D) --------------------------------------------------------
void *__thiscall PowerList::operator=(void *this, const void *a2)
{
  void *result; // eax

  result = this;
  qmemcpy(this, a2, 0x18u);
  return result;
}

//----- (10002444) --------------------------------------------------------
Json::Exception *__thiscall Json::Exception::Exception(Json::Exception *this, const struct Json::Exception *a2)
{
  std::exception::exception(this, a2);
  *(_DWORD *)this = &Json::Exception::`vftable';
  std::string::string((char *)a2 + 12);
  return this;
}
// 1000304E: using guessed type _DWORD __stdcall std::string::string(_DWORD);
// 10009084: using guessed type _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const struct std::exception *);
// 10009498: using guessed type void *Json::Exception::`vftable';

//----- (1000247F) --------------------------------------------------------
_DWORD *__thiscall Json::Exception::operator=(_DWORD *this, int a2)
{
  std::exception::operator=(a2);
  if ( this + 3 != (_DWORD *)(a2 + 12) )
    sub_10003425(this + 3, (_DWORD *)(a2 + 12), 0, 0xFFFFFFFF);
  return this;
}
// 10009088: using guessed type int __stdcall std::exception::operator=(_DWORD);

//----- (100024AC) --------------------------------------------------------
char *__thiscall sub_100024AC(char *this, char a2)
{
  if ( (a2 & 2) != 0 )
  {
    `eh vector destructor iterator'(this, 0x24u, *((_DWORD *)this - 1), Json::Exception::~Exception);
    if ( (a2 & 1) != 0 )
      operator delete[](this - 4);
    return this - 4;
  }
  else
  {
    Json::Exception::~Exception(this);
    if ( (a2 & 1) != 0 )
      operator delete(this);
    return this;
  }
}
// 1000906C: using guessed type void __cdecl operator delete(void *);
// 10009074: using guessed type void __cdecl operator delete[](void *);

//----- (10002500) --------------------------------------------------------
Json::RuntimeError *__thiscall Json::RuntimeError::RuntimeError(
        Json::RuntimeError *this,
        const struct Json::RuntimeError *a2)
{
  Json::Exception::Exception(this, a2);
  *(_DWORD *)this = &Json::RuntimeError::`vftable';
  return this;
}
// 100093D4: using guessed type void *Json::RuntimeError::`vftable';

//----- (1000251B) --------------------------------------------------------
_DWORD *__thiscall Json::RuntimeError::operator=(_DWORD *this, int a2)
{
  Json::Exception::operator=(this, a2);
  return this;
}

//----- (10002530) --------------------------------------------------------
char *__thiscall sub_10002530(char *this, char a2)
{
  if ( (a2 & 2) != 0 )
  {
    `eh vector destructor iterator'(
      this,
      0x24u,
      *((_DWORD *)this - 1),
      (void (__thiscall *)(void *))Json::RuntimeError::~RuntimeError);
    if ( (a2 & 1) != 0 )
      operator delete[](this - 4);
    return this - 4;
  }
  else
  {
    Json::Exception::~Exception(this);
    if ( (a2 & 1) != 0 )
      operator delete(this);
    return this;
  }
}
// 1000906C: using guessed type void __cdecl operator delete(void *);
// 10009074: using guessed type void __cdecl operator delete[](void *);

//----- (1000257D) --------------------------------------------------------
Json::LogicError *__thiscall Json::LogicError::LogicError(Json::LogicError *this, const struct Json::LogicError *a2)
{
  Json::Exception::Exception(this, a2);
  *(_DWORD *)this = &Json::LogicError::`vftable';
  return this;
}
// 10009338: using guessed type void *Json::LogicError::`vftable';

//----- (10002598) --------------------------------------------------------
Json::StaticString *__thiscall Json::StaticString::StaticString(Json::StaticString *this, const char *a2)
{
  *(_DWORD *)this = a2;
  return this;
}

//----- (100025A6) --------------------------------------------------------
const char *__thiscall Json::StaticString::c_str(Json::StaticString *this)
{
  return *(const char **)this;
}

//----- (100025A9) --------------------------------------------------------
void __thiscall Json::Value::`default constructor closure'(Json::Value *this)
{
  Json::Value::Value(this, 0);
}
// 1000920C: using guessed type int __thiscall Json::Value::Value(_DWORD, _DWORD);

//----- (100025B2) --------------------------------------------------------
Json::PathArgument *__thiscall Json::PathArgument::PathArgument(
        Json::PathArgument *this,
        const struct Json::PathArgument *a2)
{
  std::string::string(a2);
  *((_DWORD *)this + 6) = *((_DWORD *)a2 + 6);
  *((_DWORD *)this + 7) = *((_DWORD *)a2 + 7);
  return this;
}
// 1000304E: using guessed type _DWORD __stdcall std::string::string(_DWORD);

//----- (100025D6) --------------------------------------------------------
_DWORD *__thiscall Json::PathArgument::operator=(_DWORD *this, _DWORD *a2)
{
  if ( this != a2 )
    sub_10003425(this, a2, 0, 0xFFFFFFFF);
  this[6] = a2[6];
  this[7] = a2[7];
  return this;
}

//----- (10002607) --------------------------------------------------------
Json::Path *__thiscall Json::Path::Path(Json::Path *this, const struct Json::PathArgument **a2)
{
  sub_10003108((int)this, a2);
  return this;
}

//----- (1000261C) --------------------------------------------------------
const struct Json::PathArgument **__thiscall Json::Path::operator=(
        const struct Json::PathArgument **this,
        const struct Json::PathArgument **a2)
{
  sub_1000316D(this, a2);
  return this;
}

//----- (10002631) --------------------------------------------------------
bool __thiscall Json::ValueIteratorBase::operator==(
        Json::ValueIteratorBase *this,
        const struct Json::ValueIteratorBase *a2)
{
  return Json::ValueIteratorBase::isEqual(this, a2);
}
// 100091F0: using guessed type bool __thiscall Json::ValueIteratorBase::isEqual(Json::ValueIteratorBase *__hidden this, const struct Json::ValueIteratorBase *);

//----- (1000263B) --------------------------------------------------------
bool __thiscall Json::ValueIteratorBase::operator!=(
        Json::ValueIteratorBase *this,
        const struct Json::ValueIteratorBase *a2)
{
  return !Json::ValueIteratorBase::isEqual(this, a2);
}
// 100091F0: using guessed type bool __thiscall Json::ValueIteratorBase::isEqual(Json::ValueIteratorBase *__hidden this, const struct Json::ValueIteratorBase *);

//----- (10002654) --------------------------------------------------------
int __thiscall Json::ValueIteratorBase::operator-(
        const struct Json::ValueIteratorBase *this,
        Json::ValueIteratorBase *a2)
{
  return Json::ValueIteratorBase::computeDistance(a2, this);
}
// 100091EC: using guessed type _DWORD __thiscall Json::ValueIteratorBase::computeDistance(Json::ValueIteratorBase *__hidden this, const struct Json::ValueIteratorBase *);

//----- (10002665) --------------------------------------------------------
_DWORD *__thiscall Json::ValueConstIterator::operator++(Json::ValueIteratorBase *this, _DWORD *a2, int a3)
{
  *a2 = *(_DWORD *)this;
  a2[1] = *((_DWORD *)this + 1);
  Json::ValueIteratorBase::increment(this);
  return a2;
}
// 100091E4: using guessed type void __thiscall Json::ValueIteratorBase::increment(Json::ValueIteratorBase *__hidden this);

//----- (10002683) --------------------------------------------------------
_DWORD *__thiscall Json::ValueConstIterator::operator--(Json::ValueIteratorBase *this, _DWORD *a2, int a3)
{
  *a2 = *(_DWORD *)this;
  a2[1] = *((_DWORD *)this + 1);
  Json::ValueIteratorBase::decrement(this);
  return a2;
}
// 100091E8: using guessed type void __thiscall Json::ValueIteratorBase::decrement(Json::ValueIteratorBase *__hidden this);

//----- (100026A1) --------------------------------------------------------
Json::ValueIteratorBase *__thiscall Json::ValueIterator::operator--(Json::ValueIteratorBase *this)
{
  Json::ValueIteratorBase::decrement(this);
  return this;
}
// 100091E8: using guessed type void __thiscall Json::ValueIteratorBase::decrement(Json::ValueIteratorBase *__hidden this);

//----- (100026AE) --------------------------------------------------------
Json::ValueIteratorBase *__thiscall Json::ValueIterator::operator++(Json::ValueIteratorBase *this)
{
  Json::ValueIteratorBase::increment(this);
  return this;
}
// 100091E4: using guessed type void __thiscall Json::ValueIteratorBase::increment(Json::ValueIteratorBase *__hidden this);

//----- (100026C1) --------------------------------------------------------
Json::ValueIterator *__thiscall Json::ValueIterator::operator++(
        const struct Json::ValueIterator *this,
        Json::ValueIterator *a2,
        int a3)
{
  Json::ValueIterator::ValueIterator(a2, this);
  Json::ValueIteratorBase::increment(this);
  return a2;
}
// 100091E4: using guessed type void __thiscall Json::ValueIteratorBase::increment(Json::ValueIteratorBase *__hidden this);
// 100091F4: using guessed type _DWORD __thiscall Json::ValueIterator::ValueIterator(Json::ValueIterator *__hidden this, const struct Json::ValueIterator *);

//----- (100026E1) --------------------------------------------------------
Json::ValueIterator *__thiscall Json::ValueIterator::operator--(
        const struct Json::ValueIterator *this,
        Json::ValueIterator *a2,
        int a3)
{
  Json::ValueIterator::ValueIterator(a2, this);
  Json::ValueIteratorBase::decrement(this);
  return a2;
}
// 100091E8: using guessed type void __thiscall Json::ValueIteratorBase::decrement(Json::ValueIteratorBase *__hidden this);
// 100091F4: using guessed type _DWORD __thiscall Json::ValueIterator::ValueIterator(Json::ValueIterator *__hidden this, const struct Json::ValueIterator *);

//----- (10002701) --------------------------------------------------------
void __thiscall Json::Reader::~Reader(void **this)
{
  sub_100035A2(this + 21, 1, 0);
  sub_100035A2(this + 10, 1, 0);
  sub_10003946((int)(this + 5));
  operator delete(this[5]);
  this[5] = 0;
  sub_10003798((int)this);
  operator delete(*this);
  *this = 0;
}
// 1000906C: using guessed type void __cdecl operator delete(void *);

//----- (10002749) --------------------------------------------------------
Json::Reader *__thiscall Json::Reader::Reader(Json::Reader *this, const struct Json::Reader *a2)
{
  const struct Json::Reader *v3; // ebx
  const struct Json::Reader **v4; // eax
  _DWORD *v5; // edi
  _DWORD *v6; // eax
  int *v8; // [esp-18h] [ebp-40h] BYREF
  int v9; // [esp-14h] [ebp-3Ch]
  int v10; // [esp-10h] [ebp-38h]
  int v11; // [esp-Ch] [ebp-34h] BYREF
  int v12; // [esp-8h] [ebp-30h]
  unsigned int v13; // [esp-4h] [ebp-2Ch]
  Json::Reader *v14; // [esp+14h] [ebp-14h]
  Json::Reader *v15; // [esp+18h] [ebp-10h]
  int v16; // [esp+24h] [ebp-4h]

  v15 = this;
  v3 = 0;
  v14 = this;
  v13 = 8;
  *(_DWORD *)this = 0;
  *((_DWORD *)this + 1) = 0;
  *((_DWORD *)this + 2) = 0;
  *((_DWORD *)this + 3) = 0;
  *((_DWORD *)this + 4) = 0;
  v4 = (const struct Json::Reader **)operator new(v13);
  if ( v4 )
    goto LABEL_3;
  do
  {
    std::_Xbad_alloc();
LABEL_3:
    *(_DWORD *)this = v4;
    *v4 = v3;
    v4[1] = v3;
    **(_DWORD **)this = this;
    v16 = (int)v3;
    v3 = a2;
    sub_10003810((int *)a2, &v11);
    sub_100037F8((int *)a2, &v8);
    sub_100040A4(this, v8, v9, v10, v11, v12, v13);
    v16 = 1;
    v5 = (_DWORD *)((char *)this + 20);
    a2 = (Json::Reader *)((char *)this + 20);
    v13 = 8;
    *((_DWORD *)this + 5) = 0;
    *((_DWORD *)this + 6) = 0;
    *((_DWORD *)this + 7) = 0;
    *((_DWORD *)this + 8) = 0;
    *((_DWORD *)this + 9) = 0;
    v6 = operator new(v13);
  }
  while ( !v6 );
  *v5 = v6;
  *v6 = 0;
  v6[1] = 0;
  *(_DWORD *)*v5 = v5;
  LOBYTE(v16) = 2;
  sub_10003810((int *)v3 + 5, &v11);
  sub_100037F8((int *)v3 + 5, &v8);
  sub_10003C66((_DWORD *)this + 5, v8, v9, v10, v11, v12, v13);
  LOBYTE(v16) = 3;
  std::string::string((char *)v3 + 40);
  LOBYTE(v16) = 4;
  *((_DWORD *)this + 16) = *((_DWORD *)v3 + 16);
  *((_DWORD *)this + 17) = *((_DWORD *)v3 + 17);
  *((_DWORD *)this + 18) = *((_DWORD *)v3 + 18);
  *((_DWORD *)this + 19) = *((_DWORD *)v3 + 19);
  *((_DWORD *)this + 20) = *((_DWORD *)v3 + 20);
  std::string::string((char *)v3 + 84);
  *((_DWORD *)this + 27) = *((_DWORD *)v3 + 27);
  *((_BYTE *)this + 112) = *((_BYTE *)v3 + 112);
  return this;
}
// 10002780: variable 'v4' is possibly undefined
// 1000304E: using guessed type _DWORD __stdcall std::string::string(_DWORD);
// 1000902C: using guessed type void __cdecl std::_Xbad_alloc();
// 10009064: using guessed type void *__cdecl operator new(unsigned int);

//----- (1000285C) --------------------------------------------------------
int __thiscall Json::Reader::operator=(int this, int a2)
{
  sub_10003678((int *)this, (int *)a2);
  sub_100032DC((int *)(this + 20), (int *)(a2 + 20));
  if ( this + 40 != a2 + 40 )
    sub_10003425((_DWORD *)(this + 40), (_DWORD *)(a2 + 40), 0, 0xFFFFFFFF);
  *(_DWORD *)(this + 64) = *(_DWORD *)(a2 + 64);
  *(_DWORD *)(this + 68) = *(_DWORD *)(a2 + 68);
  *(_DWORD *)(this + 72) = *(_DWORD *)(a2 + 72);
  *(_DWORD *)(this + 76) = *(_DWORD *)(a2 + 76);
  *(_DWORD *)(this + 80) = *(_DWORD *)(a2 + 80);
  if ( this + 84 != a2 + 84 )
    sub_10003425((_DWORD *)(this + 84), (_DWORD *)(a2 + 84), 0, 0xFFFFFFFF);
  *(_DWORD *)(this + 108) = *(_DWORD *)(a2 + 108);
  *(_BYTE *)(this + 112) = *(_BYTE *)(a2 + 112);
  return this;
}

//----- (100028E8) --------------------------------------------------------
void __thiscall Json::CharReader::~CharReader(Json::CharReader *this)
{
  *(_DWORD *)this = &Json::CharReader::`vftable';
}
// 100094D0: using guessed type void *Json::CharReader::`vftable';

//----- (100028EF) --------------------------------------------------------
void __thiscall Json::CharReader::Factory::~Factory(Json::CharReader::Factory *this)
{
  *(_DWORD *)this = &Json::CharReader::Factory::`vftable';
}
// 100093BC: using guessed type void *Json::CharReader::Factory::`vftable';

//----- (100028F6) --------------------------------------------------------
Json::CharReader::Factory *__thiscall Json::CharReader::Factory::Factory(Json::CharReader::Factory *this)
{
  *(_DWORD *)this = &Json::CharReader::Factory::`vftable';
  return this;
}
// 100093BC: using guessed type void *Json::CharReader::Factory::`vftable';

//----- (100028FF) --------------------------------------------------------
Json::CharReader::Factory *__thiscall Json::CharReader::Factory::Factory(
        Json::CharReader::Factory *this,
        const struct Json::CharReader::Factory *a2)
{
  *(_DWORD *)this = &Json::CharReader::Factory::`vftable';
  return this;
}
// 100093BC: using guessed type void *Json::CharReader::Factory::`vftable';

//----- (1000290A) --------------------------------------------------------
char *__thiscall sub_1000290A(char *this, char a2)
{
  if ( (a2 & 2) != 0 )
  {
    `eh vector destructor iterator'(
      this,
      4u,
      *((_DWORD *)this - 1),
      (void (__thiscall *)(void *))Json::CharReader::Factory::~Factory);
    if ( (a2 & 1) != 0 )
      operator delete[](this - 4);
    return this - 4;
  }
  else
  {
    *(_DWORD *)this = &Json::CharReader::Factory::`vftable';
    if ( (a2 & 1) != 0 )
      operator delete(this);
    return this;
  }
}
// 1000906C: using guessed type void __cdecl operator delete(void *);
// 10009074: using guessed type void __cdecl operator delete[](void *);
// 100093BC: using guessed type void *Json::CharReader::Factory::`vftable';

//----- (10002957) --------------------------------------------------------
Json::CharReader *__thiscall Json::CharReader::CharReader(Json::CharReader *this)
{
  *(_DWORD *)this = &Json::CharReader::`vftable';
  return this;
}
// 100094D0: using guessed type void *Json::CharReader::`vftable';

//----- (10002960) --------------------------------------------------------
Json::CharReader *__thiscall Json::CharReader::CharReader(Json::CharReader *this, const struct Json::CharReader *a2)
{
  *(_DWORD *)this = &Json::CharReader::`vftable';
  return this;
}
// 100094D0: using guessed type void *Json::CharReader::`vftable';

//----- (1000296B) --------------------------------------------------------
char *__thiscall sub_1000296B(char *this, char a2)
{
  if ( (a2 & 2) != 0 )
  {
    `eh vector destructor iterator'(
      this,
      4u,
      *((_DWORD *)this - 1),
      (void (__thiscall *)(void *))Json::CharReader::~CharReader);
    if ( (a2 & 1) != 0 )
      operator delete[](this - 4);
    return this - 4;
  }
  else
  {
    *(_DWORD *)this = &Json::CharReader::`vftable';
    if ( (a2 & 1) != 0 )
      operator delete(this);
    return this;
  }
}
// 1000906C: using guessed type void __cdecl operator delete(void *);
// 10009074: using guessed type void __cdecl operator delete[](void *);
// 100094D0: using guessed type void *Json::CharReader::`vftable';

//----- (100029ED) --------------------------------------------------------
char *__thiscall Json::StreamWriterBuilder::operator=(char *this, int a2)
{
  int v4; // [esp-18h] [ebp-1Ch] BYREF

  Json::Value::Value((Json::Value *)&v4, (const struct Json::Value *)(a2 + 8));
  Json::Value::operator=(this + 8);
  return this;
}
// 10009208: using guessed type _DWORD __thiscall Json::Value::Value(Json::Value *__hidden this, const struct Json::Value *);
// 10009210: using guessed type int __thiscall Json::Value::operator=(_DWORD);

//----- (10002A15) --------------------------------------------------------
char *__thiscall sub_10002A15(char *this, char a2)
{
  if ( (a2 & 2) != 0 )
  {
    `eh vector destructor iterator'(this, 0x20u, *((_DWORD *)this - 1), Json::CharReaderBuilder::~CharReaderBuilder);
    if ( (a2 & 1) != 0 )
      operator delete[](this - 4);
    return this - 4;
  }
  else
  {
    Json::CharReaderBuilder::~CharReaderBuilder(this);
    if ( (a2 & 1) != 0 )
      operator delete(this);
    return this;
  }
}
// 1000906C: using guessed type void __cdecl operator delete(void *);
// 10009074: using guessed type void __cdecl operator delete[](void *);

//----- (10002A63) --------------------------------------------------------
Json::StreamWriter::Factory *__thiscall Json::StreamWriter::Factory::Factory(Json::StreamWriter::Factory *this)
{
  *(_DWORD *)this = &Json::StreamWriter::Factory::`vftable';
  return this;
}
// 100093F8: using guessed type void *Json::StreamWriter::Factory::`vftable';

//----- (10002A6C) --------------------------------------------------------
Json::StreamWriter::Factory *__thiscall Json::StreamWriter::Factory::Factory(
        Json::StreamWriter::Factory *this,
        const struct Json::StreamWriter::Factory *a2)
{
  *(_DWORD *)this = &Json::StreamWriter::Factory::`vftable';
  return this;
}
// 100093F8: using guessed type void *Json::StreamWriter::Factory::`vftable';

//----- (10002A77) --------------------------------------------------------
char *__thiscall sub_10002A77(char *this, char a2)
{
  if ( (a2 & 2) != 0 )
  {
    `eh vector destructor iterator'(this, 4u, *((_DWORD *)this - 1), Json::StreamWriter::Factory::~Factory);
    if ( (a2 & 1) != 0 )
      operator delete[](this - 4);
    return this - 4;
  }
  else
  {
    Json::StreamWriter::Factory::~Factory(this);
    if ( (a2 & 1) != 0 )
      operator delete(this);
    return this;
  }
}
// 1000906C: using guessed type void __cdecl operator delete(void *);
// 10009074: using guessed type void __cdecl operator delete[](void *);

//----- (10002ADD) --------------------------------------------------------
char *__thiscall sub_10002ADD(char *this, char a2)
{
  if ( (a2 & 2) != 0 )
  {
    `eh vector destructor iterator'(this, 8u, *((_DWORD *)this - 1), Json::StreamWriter::~StreamWriter);
    if ( (a2 & 1) != 0 )
      operator delete[](this - 4);
    return this - 4;
  }
  else
  {
    Json::StreamWriter::~StreamWriter(this);
    if ( (a2 & 1) != 0 )
      operator delete(this);
    return this;
  }
}
// 1000906C: using guessed type void __cdecl operator delete(void *);
// 10009074: using guessed type void __cdecl operator delete[](void *);

//----- (10002B60) --------------------------------------------------------
char *__thiscall sub_10002B60(char *this, char a2)
{
  if ( (a2 & 2) != 0 )
  {
    `eh vector destructor iterator'(this, 0x20u, *((_DWORD *)this - 1), Json::StreamWriterBuilder::~StreamWriterBuilder);
    if ( (a2 & 1) != 0 )
      operator delete[](this - 4);
    return this - 4;
  }
  else
  {
    Json::StreamWriterBuilder::~StreamWriterBuilder(this);
    if ( (a2 & 1) != 0 )
      operator delete(this);
    return this;
  }
}
// 1000906C: using guessed type void __cdecl operator delete(void *);
// 10009074: using guessed type void __cdecl operator delete[](void *);

//----- (10002BAE) --------------------------------------------------------
void __thiscall WinTitan::FeatureFlag::~FeatureFlag(void **this)
{
  sub_100035A2(this + 42, 1, 0);
  sub_100035A2(this + 36, 1, 0);
  sub_100035A2(this + 30, 1, 0);
  sub_100035A2(this + 24, 1, 0);
  sub_100035A2(this + 18, 1, 0);
  sub_100035A2(this + 12, 1, 0);
  sub_100035A2(this + 6, 1, 0);
  sub_100035A2(this, 1, 0);
}

//----- (10002C11) --------------------------------------------------------
WinTitan::FeatureFlag *__thiscall WinTitan::FeatureFlag::FeatureFlag(
        WinTitan::FeatureFlag *this,
        const struct WinTitan::FeatureFlag *a2)
{
  std::string::string(a2);
  std::string::string((char *)a2 + 24);
  std::string::string((char *)a2 + 48);
  std::string::string((char *)a2 + 72);
  std::string::string((char *)a2 + 96);
  std::string::string((char *)a2 + 120);
  std::string::string((char *)a2 + 144);
  std::string::string((char *)a2 + 168);
  return this;
}
// 1000304E: using guessed type _DWORD __stdcall std::string::string(_DWORD);

//----- (10002CB1) --------------------------------------------------------
_DWORD *__thiscall WinTitan::FeatureFlag::operator=(_DWORD *this, _DWORD *a2)
{
  if ( this != a2 )
    sub_10003425(this, a2, 0, 0xFFFFFFFF);
  if ( this + 6 != a2 + 6 )
    sub_10003425(this + 6, a2 + 6, 0, 0xFFFFFFFF);
  if ( this + 12 != a2 + 12 )
    sub_10003425(this + 12, a2 + 12, 0, 0xFFFFFFFF);
  if ( this + 18 != a2 + 18 )
    sub_10003425(this + 18, a2 + 18, 0, 0xFFFFFFFF);
  if ( this + 24 != a2 + 24 )
    sub_10003425(this + 24, a2 + 24, 0, 0xFFFFFFFF);
  if ( this + 30 != a2 + 30 )
    sub_10003425(this + 30, a2 + 30, 0, 0xFFFFFFFF);
  if ( this + 36 != a2 + 36 )
    sub_10003425(this + 36, a2 + 36, 0, 0xFFFFFFFF);
  if ( this + 42 != a2 + 42 )
    sub_10003425(this + 42, a2 + 42, 0, 0xFFFFFFFF);
  return this;
}

//----- (10002D66) --------------------------------------------------------
const char *__thiscall MessageItem::ToString(MessageItem *this)
{
  return (char *)this + 2096;
}

//----- (10002D6D) --------------------------------------------------------
const char *__thiscall MessageItem::GetMsgType(MessageItem *this)
{
  return (char *)this + 4404;
}

//----- (10002D74) --------------------------------------------------------
void *__thiscall MessageItem::operator=(void *this, void *Src)
{
  memcpy(this, Src, 0x1184u);
  return this;
}

//----- (10002D92) --------------------------------------------------------
int __thiscall AGENT_ACCESS::total_agents(AGENT_ACCESS *this)
{
  return *((_DWORD *)this + 1);
}

//----- (10002D96) --------------------------------------------------------
void *__thiscall XMLDocument::operator=(void *this, const void *a2)
{
  void *result; // eax

  result = this;
  qmemcpy(this, a2, 0x14u);
  return result;
}

//----- (10002DAD) --------------------------------------------------------
const char *__thiscall XMLElement::GetName(XMLElement *this)
{
  return (char *)this + 16;
}

//----- (10002DB1) --------------------------------------------------------
int __thiscall XMLElement::GetType(XMLElement *this)
{
  return *((_DWORD *)this + 1335);
}

//----- (10002DB8) --------------------------------------------------------
void __thiscall XMLElement::SetType(XMLElement *this, int a2)
{
  *((_DWORD *)this + 1335) = a2;
}

//----- (10002DC8) --------------------------------------------------------
struct XMLElement *__thiscall XMLElement::GetParent(XMLElement *this)
{
  return (struct XMLElement *)*((_DWORD *)this + 2);
}

//----- (10002DCC) --------------------------------------------------------
void __thiscall XMLElement::CloseElement(XMLElement *this)
{
  *((_BYTE *)this + 5348) = 0;
}

//----- (10002DD4) --------------------------------------------------------
const char *__thiscall XMLElement::GetValue(XMLElement *this)
{
  return (char *)this + 96;
}

//----- (10002DD8) --------------------------------------------------------
const char *__thiscall XMLElement::GetComment(XMLElement *this)
{
  return (char *)this + 224;
}

//----- (10002DDF) --------------------------------------------------------
bool __thiscall XMLElement::ElementIsOpen(XMLElement *this)
{
  return *((_BYTE *)this + 5348);
}

//----- (10002DE6) --------------------------------------------------------
void *__thiscall XMLElement::operator=(void *this, void *Src)
{
  memcpy(this, Src, 0x14ECu);
  return this;
}

//----- (10002E04) --------------------------------------------------------
void __thiscall XMLWriter::RestoreAttrPerLine(XMLWriter *this)
{
  *((_DWORD *)this + 5) = *((_DWORD *)this + 4);
}

//----- (10002E0B) --------------------------------------------------------
bool __thiscall XMLWriter::IsOpen(XMLWriter *this)
{
  return *((_BYTE *)this + 289);
}

//----- (10002E12) --------------------------------------------------------
XMLWriter *__thiscall XMLWriter::XMLWriter(XMLWriter *this, const struct XMLWriter *a2)
{
  *(_DWORD *)this = *(_DWORD *)a2;
  *((_DWORD *)this + 1) = *((_DWORD *)a2 + 1);
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  *((_DWORD *)this + 3) = *((_DWORD *)a2 + 3);
  *((_DWORD *)this + 4) = *((_DWORD *)a2 + 4);
  *((_DWORD *)this + 5) = *((_DWORD *)a2 + 5);
  *((_DWORD *)this + 6) = *((_DWORD *)a2 + 6);
  qmemcpy((char *)this + 28, (char *)a2 + 28, 0x107u);
  *((_DWORD *)this + 73) = *((_DWORD *)a2 + 73);
  std::string::string((char *)a2 + 296);
  return this;
}
// 1000304E: using guessed type _DWORD __stdcall std::string::string(_DWORD);

//----- (10002E9B) --------------------------------------------------------
char *__thiscall XMLWriter::operator=(char *this, int a2)
{
  int v3; // edi
  _BYTE *v4; // edx

  v3 = 260;
  v4 = this + 28;
  *(_DWORD *)this = *(_DWORD *)a2;
  *((_DWORD *)this + 1) = *(_DWORD *)(a2 + 4);
  *((_DWORD *)this + 2) = *(_DWORD *)(a2 + 8);
  *((_DWORD *)this + 3) = *(_DWORD *)(a2 + 12);
  *((_DWORD *)this + 4) = *(_DWORD *)(a2 + 16);
  *((_DWORD *)this + 5) = *(_DWORD *)(a2 + 20);
  *((_DWORD *)this + 6) = *(_DWORD *)(a2 + 24);
  do
  {
    *v4 = v4[a2 - (_DWORD)this];
    ++v4;
    --v3;
  }
  while ( v3 );
  this[288] = *(_BYTE *)(a2 + 288);
  this[289] = *(_BYTE *)(a2 + 289);
  this[290] = *(_BYTE *)(a2 + 290);
  *((_DWORD *)this + 73) = *(_DWORD *)(a2 + 292);
  if ( this + 296 != (char *)(a2 + 296) )
    sub_10003425((_DWORD *)this + 74, (_DWORD *)(a2 + 296), 0, 0xFFFFFFFF);
  return this;
}

//----- (10002F37) --------------------------------------------------------
bool __thiscall XMLReader::IsGood(XMLReader *this)
{
  return *((_BYTE *)this + 261);
}

//----- (10002F3E) --------------------------------------------------------
struct XMLDocument *__thiscall XMLReader::GetDocument(XMLReader *this)
{
  return (XMLReader *)((char *)this + 284);
}

//----- (10002F45) --------------------------------------------------------
void *__thiscall XMLReader::operator=(void *this, const void *a2)
{
  void *result; // eax

  result = this;
  qmemcpy(this, a2, 0x130u);
  return result;
}

//----- (10002F5C) --------------------------------------------------------
int __thiscall XMLIterator::GetAttrAsLong(XMLElement **this, const char *a2)
{
  return XMLElement::GetAttrAsLong(*this, a2);
}
// 10009224: using guessed type _DWORD __thiscall XMLElement::GetAttrAsLong(XMLElement *__hidden this, const char *);

//----- (10002F68) --------------------------------------------------------
const char *__thiscall XMLIterator::GetAttrAsString(XMLElement **this, const char *a2)
{
  return XMLElement::GetAttrAsString(*this, a2);
}
// 10009228: using guessed type const char *__thiscall XMLElement::GetAttrAsString(XMLElement *__hidden this, const char *);

//----- (10002F74) --------------------------------------------------------
char __thiscall XMLIterator::GetAttrAsChar(XMLElement **this, const char *a2)
{
  return XMLElement::GetAttrAsChar(*this, a2);
}
// 1000922C: using guessed type char __thiscall XMLElement::GetAttrAsChar(XMLElement *__hidden this, const char *);

//----- (10002F80) --------------------------------------------------------
__int16 __thiscall XMLIterator::GetAttrAsShort(XMLElement **this, const char *a2)
{
  return XMLElement::GetAttrAsShort(*this, a2);
}
// 10009230: using guessed type __int16 __thiscall XMLElement::GetAttrAsShort(XMLElement *__hidden this, const char *);

//----- (10002F8C) --------------------------------------------------------
double __thiscall XMLIterator::GetAttrAsDouble(XMLElement **this, const char *a2)
{
  return XMLElement::GetAttrAsDouble(*this, a2);
}
// 10009238: using guessed type double __thiscall XMLElement::GetAttrAsDouble(XMLElement *__hidden this, const char *);

//----- (10002F98) --------------------------------------------------------
const char *__thiscall XMLIterator::GetElementName(XMLIterator *this)
{
  return (const char *)(*(_DWORD *)this + 16);
}

//----- (10002F9E) --------------------------------------------------------
_DWORD *__thiscall XMLAttributeIterator::operator=(_DWORD *this, _DWORD *a2)
{
  _DWORD *result; // eax

  result = this;
  *this = *a2;
  this[1] = a2[1];
  this[2] = a2[2];
  this[3] = a2[3];
  return result;
}

//----- (10002FB4) --------------------------------------------------------
_WORD *__thiscall FileAttributes::operator=(_WORD *this, int a2)
{
  *(_DWORD *)this = *(_DWORD *)a2;
  this[2] = *(_WORD *)(a2 + 4);
  return this;
}

//----- (10002FCC) --------------------------------------------------------
int __thiscall AGENT_ACCESS::has_all_access(AGENT_ACCESS *this)
{
  return *((_DWORD *)this + 19);
}

//----- (10002FD0) --------------------------------------------------------
void *__thiscall AGENT_ACCESS::operator=(void *this, const void *a2)
{
  void *result; // eax

  result = this;
  qmemcpy(this, a2, 0x50u);
  return result;
}

//----- (10002FED) --------------------------------------------------------
AncillaryList *__thiscall AncillaryList::AncillaryList(AncillaryList *this, const struct AncillaryList *a2)
{
  ListBox2::ListBox2(this, a2);
  *((_DWORD *)this + 76) = *((_DWORD *)a2 + 76);
  return this;
}
// 1000919C: using guessed type ListBox2 *__thiscall ListBox2::ListBox2(ListBox2 *__hidden this, const struct ListBox2 *);

//----- (10003012) --------------------------------------------------------
_DWORD *__thiscall AncillaryList::operator=(_DWORD *this, int a2)
{
  ListBox2::operator=(a2);
  this[76] = *(_DWORD *)(a2 + 304);
  return this;
}
// 100091A0: using guessed type int __stdcall ListBox2::operator=(_DWORD);

//----- (10003037) --------------------------------------------------------
void *__thiscall CBANNER_SWAP::operator=(void *this, const void *a2)
{
  void *result; // eax

  result = this;
  qmemcpy(this, a2, 0x54u);
  return result;
}

//----- (10003074) --------------------------------------------------------
char *__thiscall sub_10003074(char *this, char *Str)
{
  size_t v3; // eax

  v3 = 0;
  *((_DWORD *)this + 5) = 15;
  *((_DWORD *)this + 4) = 0;
  *this = 0;
  if ( *Str )
    v3 = strlen(Str);
  sub_100034C8(this, Str, v3);
  return this;
}

//----- (100030A9) --------------------------------------------------------
_DWORD *__thiscall sub_100030A9(_DWORD *this, int a2, unsigned int a3)
{
  _DWORD *v3; // esi
  unsigned int v4; // edi
  _BYTE *v5; // eax
  size_t v6; // edi
  bool v7; // cf
  _DWORD *v8; // eax

  v3 = this;
  v4 = this[4];
  if ( v4 > a3 )
  {
    if ( a3 )
    {
      if ( this[5] >= 0x10u )
        this = (_DWORD *)*this;
      v6 = v4 - a3;
      if ( v6 )
        memmove(this, (char *)this + a3, v6);
      v7 = v3[5] < 0x10u;
      v3[4] = v6;
      if ( v7 )
        v8 = v3;
      else
        v8 = (_DWORD *)*v3;
      *((_BYTE *)v8 + v6) = 0;
    }
  }
  else
  {
    this[4] = 0;
    if ( this[5] < 0x10u )
      v5 = this;
    else
      v5 = (_BYTE *)*this;
    *v5 = 0;
  }
  return v3;
}

//----- (10003108) --------------------------------------------------------
int __thiscall sub_10003108(int this, const struct Json::PathArgument **a2)
{
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
  if ( sub_100035E8((_DWORD *)this, (a2[1] - *a2) >> 5) )
    *(_DWORD *)(this + 4) = sub_10004C92(*a2, a2[1], *(Json::PathArgument **)this);
  return this;
}

//----- (1000316D) --------------------------------------------------------
const struct Json::PathArgument **__thiscall sub_1000316D(
        const struct Json::PathArgument **this,
        const struct Json::PathArgument **a2)
{
  const struct Json::PathArgument **v2; // esi
  const struct Json::PathArgument **v3; // ecx
  const struct Json::PathArgument *v4; // ebx
  const struct Json::PathArgument *v5; // eax
  void **v6; // edi
  void **v7; // ebx
  Json::PathArgument *v8; // eax
  unsigned int v9; // edx
  const struct Json::PathArgument *v10; // esi
  void **v11; // ebx
  const struct Json::PathArgument *v12; // edx
  const struct Json::PathArgument *v13; // esi
  void **v15; // [esp+10h] [ebp-20h]
  unsigned int v16; // [esp+18h] [ebp-18h]
  const struct Json::PathArgument *v17; // [esp+18h] [ebp-18h]

  v2 = this;
  v3 = a2;
  if ( this != a2 )
  {
    v4 = *a2;
    v5 = a2[1];
    v6 = (void **)*v2;
    if ( *a2 == v5 )
    {
      v7 = (void **)v2[1];
      while ( v6 != v7 )
      {
        sub_100035A2(v6, 1, 0);
        v6 += 8;
      }
      v8 = *v2;
      goto LABEL_29;
    }
    v16 = (v5 - v4) >> 5;
    v15 = (void **)v2[1];
    v9 = ((char *)v15 - (char *)v6) >> 5;
    if ( v16 <= v9 )
    {
      if ( v4 != v5 )
      {
        v10 = a2[1];
        do
        {
          Json::PathArgument::operator=(v6, v4);
          v4 = (const struct Json::PathArgument *)((char *)v4 + 32);
          v6 += 8;
        }
        while ( v4 != v10 );
        v2 = this;
      }
      v11 = (void **)v2[1];
      while ( v6 != v11 )
      {
        sub_100035A2(v6, 1, 0);
        v6 += 8;
      }
      v8 = (const struct Json::PathArgument *)((char *)*v2 + ((a2[1] - *a2) & 0xFFFFFFE0));
      goto LABEL_29;
    }
    if ( v16 <= (v2[2] - (const struct Json::PathArgument *)v6) >> 5 )
    {
      v12 = (const struct Json::PathArgument *)((char *)v4 + 32 * v9);
      v17 = v12;
      if ( v4 != v12 )
      {
        v13 = v12;
        do
        {
          Json::PathArgument::operator=(v6, v4);
          v4 = (const struct Json::PathArgument *)((char *)v4 + 32);
          v6 += 8;
        }
        while ( v4 != v13 );
        v2 = this;
        v3 = a2;
      }
      v8 = sub_10004C92(v17, v3[1], v2[1]);
      goto LABEL_29;
    }
    if ( v6 )
    {
      while ( v6 != v15 )
      {
        sub_100035A2(v6, 1, 0);
        v6 += 8;
      }
      operator delete(*v2);
      v3 = a2;
    }
    if ( sub_100035E8(v2, (v3[1] - *v3) >> 5) )
    {
      v8 = sub_10004C92(*a2, a2[1], *v2);
LABEL_29:
      v2[1] = v8;
    }
  }
  return v2;
}
// 1000906C: using guessed type void __cdecl operator delete(void *);

//----- (100032DC) --------------------------------------------------------
int *__thiscall sub_100032DC(int *this, int *a2)
{
  _DWORD *v3; // eax
  _DWORD *v4; // eax
  _DWORD *v5; // eax
  int v7; // [esp-24h] [ebp-54h] BYREF
  int v8; // [esp-20h] [ebp-50h]
  int v9; // [esp-1Ch] [ebp-4Ch]
  int *v10; // [esp-18h] [ebp-48h] BYREF
  int v11; // [esp-14h] [ebp-44h]
  int v12; // [esp-10h] [ebp-40h]
  int v13; // [esp-Ch] [ebp-3Ch] BYREF
  int v14; // [esp-8h] [ebp-38h]
  int v15; // [esp-4h] [ebp-34h]
  _DWORD v16[3]; // [esp+Ch] [ebp-24h] BYREF
  _DWORD v17[3]; // [esp+18h] [ebp-18h] BYREF
  _DWORD v18[3]; // [esp+24h] [ebp-Ch] BYREF

  if ( this != a2 )
  {
    if ( a2[4] )
    {
      if ( a2[4] > (unsigned int)this[4] )
      {
        v15 = this[4];
        v4 = sub_100037F8(a2, v18);
        sub_10003990(v4, v16, v15);
        sub_100037F8(this, &v13);
        sub_100033FC(&v10, (int)v16);
        sub_100037F8(a2, &v7);
        sub_10003D11(v7, v8, v9, (char)v10, v11, v12, v13, v14, v15);
        sub_10003810(a2, &v13);
        sub_100033FC(&v10, (int)v16);
        v5 = sub_10003810(this, v18);
        sub_100033FC(&v7, (int)v5);
        sub_10003DB0(this, v17, v7, v8, v9, v10, v11, v12, v13, v14, v15);
      }
      else
      {
        sub_100037F8(this, &v13);
        sub_10003810(a2, &v10);
        sub_100037F8(a2, &v7);
        sub_10003D11(v7, v8, v9, (char)v10, v11, v12, v13, v14, v15);
        v3 = sub_10003810(this, v17);
        sub_100033FC(&v13, (int)v3);
        sub_100033FC(&v10, (int)v16);
        sub_1000382B(this, v18, (char)v10, v11, v12, v13, v14, v15);
      }
    }
    else
    {
      sub_10003946((int)this);
    }
  }
  return this;
}

//----- (100033FC) --------------------------------------------------------
_DWORD *__thiscall sub_100033FC(_DWORD *this, int a2)
{
  _DWORD *v2; // eax

  *this = 0;
  this[1] = 0;
  if ( *(_DWORD *)a2 )
  {
    v2 = **(_DWORD ***)a2;
    if ( v2 )
      *this = *v2;
  }
  this[2] = *(_DWORD *)(a2 + 8);
  return this;
}

//----- (10003425) --------------------------------------------------------
_DWORD *__thiscall sub_10003425(_DWORD *this, _DWORD *a2, unsigned int a3, size_t Size)
{
  unsigned int v4; // eax
  _DWORD *v5; // ebx
  size_t v7; // edi
  size_t v8; // ecx
  bool v9; // cf
  _DWORD *v10; // edx
  void *v11; // ecx
  _DWORD *v12; // eax

  v4 = a3;
  v5 = a2;
  v7 = a2[4];
  if ( v7 >= a3 )
    goto LABEL_3;
  while ( 1 )
  {
    std::_Xout_of_range("invalid string position");
LABEL_3:
    v7 -= v4;
    if ( Size < v7 )
      v7 = Size;
    if ( this != a2 )
      break;
    v8 = v7 + v4;
    if ( this[4] >= v7 + v4 )
    {
      v9 = this[5] < 0x10u;
      this[4] = v8;
      if ( v9 )
        v10 = this;
      else
        v10 = (_DWORD *)*this;
      *((_BYTE *)v10 + v8) = 0;
      sub_100030A9(this, v7 + v4, v4);
      return this;
    }
  }
  if ( sub_1000355C((const void **)this, v7, (int)this) )
  {
    if ( a2[5] >= 0x10u )
      v5 = (_DWORD *)*a2;
    if ( this[5] < 0x10u )
      v11 = this;
    else
      v11 = (void *)*this;
    if ( v7 )
      memcpy(v11, (char *)v5 + a3, v7);
    v9 = this[5] < 0x10u;
    this[4] = v7;
    if ( v9 )
      v12 = this;
    else
      v12 = (_DWORD *)*this;
    *((_BYTE *)v12 + v7) = 0;
  }
  return this;
}
// 10003445: variable 'v4' is possibly undefined
// 1000347A: variable 'this' is possibly undefined
// 10009030: using guessed type void __cdecl std::_Xout_of_range(const char *);

//----- (100034C8) --------------------------------------------------------
char *__thiscall sub_100034C8(char *this, char *Src, size_t Size)
{
  char *v3; // esi
  char *v4; // eax
  char *v5; // eax
  char *v7; // eax
  bool v8; // cf
  char *v9; // eax

  v3 = this;
  if ( !Src )
    goto LABEL_26;
  v4 = *((_DWORD *)this + 5) < 0x10u ? this : *(char **)this;
  if ( Src < v4 )
    goto LABEL_26;
  if ( *((_DWORD *)this + 5) >= 0x10u )
    this = *(char **)this;
  if ( &this[*((_DWORD *)v3 + 4)] > Src )
  {
    if ( *((_DWORD *)v3 + 5) < 0x10u )
      v5 = v3;
    else
      v5 = *(char **)v3;
    return (char *)sub_10003425(v3, v3, Src - v5, Size);
  }
  else
  {
LABEL_26:
    if ( sub_1000355C((const void **)v3, Size, (int)this) )
    {
      if ( *((_DWORD *)v3 + 5) < 0x10u )
        v7 = v3;
      else
        v7 = *(char **)v3;
      if ( Size )
        memcpy(v7, Src, Size);
      v8 = *((_DWORD *)v3 + 5) < 0x10u;
      *((_DWORD *)v3 + 4) = Size;
      if ( v8 )
        v9 = v3;
      else
        v9 = *(char **)v3;
      v9[Size] = 0;
    }
    return v3;
  }
}

//----- (1000355C) --------------------------------------------------------
BOOL __thiscall sub_1000355C(const void **this, unsigned int a2, int a3)
{
  if ( a2 == -1 )
    std::_Xlength_error("string too long");
  if ( (unsigned int)this[5] >= a2 )
  {
    if ( !a2 )
    {
      this[4] = 0;
      if ( (unsigned int)this[5] >= 0x10 )
        this = (const void **)*this;
      *(_BYTE *)this = 0;
    }
  }
  else
  {
    sub_100039BA(this, a2, (size_t)this[4]);
  }
  return a2 != 0;
}
// 10009034: using guessed type void __cdecl __noreturn std::_Xlength_error(const char *);

//----- (100035A2) --------------------------------------------------------
void __thiscall sub_100035A2(void **this, char a2, size_t Size)
{
  void *v4; // ebx

  if ( a2 && (unsigned int)this[5] >= 0x10 )
  {
    v4 = *this;
    if ( Size )
      memcpy(this, v4, Size);
    operator delete(v4);
  }
  this[4] = (void *)Size;
  this[5] = (void *)15;
  *((_BYTE *)this + Size) = 0;
}
// 1000906C: using guessed type void __cdecl operator delete(void *);

//----- (100035E8) --------------------------------------------------------
char __thiscall sub_100035E8(_DWORD *this, unsigned int a2)
{
  char *v4; // eax

  *this = 0;
  this[1] = 0;
  this[2] = 0;
  if ( !a2 )
    return 0;
  if ( a2 > 0x7FFFFFF )
    std::_Xlength_error("vector<T> too long");
  v4 = (char *)operator new(32 * a2);
  if ( !v4 )
  {
    std::_Xbad_alloc();
    JUMPOUT(0x1000363E);
  }
  *this = v4;
  this[1] = v4;
  this[2] = &v4[32 * a2];
  return 1;
}
// 10003638: control flows out of bounds to 1000363E
// 1000902C: using guessed type void __cdecl std::_Xbad_alloc();
// 10009034: using guessed type void __cdecl __noreturn std::_Xlength_error(const char *);
// 10009064: using guessed type void *__cdecl operator new(unsigned int);

//----- (1000363F) --------------------------------------------------------
void __thiscall Json::Path::~Path(void ***this)
{
  void **v2; // edi
  void **v3; // ebx

  v2 = *this;
  if ( *this )
  {
    v3 = this[1];
    while ( v2 != v3 )
    {
      sub_100035A2(v2, 1, 0);
      v2 += 8;
    }
    operator delete(*this);
    *this = 0;
    this[1] = 0;
    this[2] = 0;
  }
}
// 1000906C: using guessed type void __cdecl operator delete(void *);

//----- (10003678) --------------------------------------------------------
int *__thiscall sub_10003678(int *this, int *a2)
{
  _DWORD *v3; // eax
  _DWORD *v4; // eax
  _DWORD *v5; // eax
  int v7; // [esp-24h] [ebp-54h] BYREF
  int v8; // [esp-20h] [ebp-50h]
  int v9; // [esp-1Ch] [ebp-4Ch]
  int *v10; // [esp-18h] [ebp-48h] BYREF
  int v11; // [esp-14h] [ebp-44h]
  int v12; // [esp-10h] [ebp-40h]
  int v13; // [esp-Ch] [ebp-3Ch] BYREF
  int v14; // [esp-8h] [ebp-38h]
  unsigned int v15; // [esp-4h] [ebp-34h]
  _DWORD v16[3]; // [esp+Ch] [ebp-24h] BYREF
  _DWORD v17[3]; // [esp+18h] [ebp-18h] BYREF
  _DWORD v18[3]; // [esp+24h] [ebp-Ch] BYREF

  if ( this != a2 )
  {
    if ( a2[4] )
    {
      if ( a2[4] > (unsigned int)this[4] )
      {
        v15 = this[4];
        v4 = sub_100037F8(a2, v18);
        sub_10003990(v4, v16, v15);
        sub_100037F8(this, &v13);
        sub_100033FC(&v10, (int)v16);
        sub_100037F8(a2, &v7);
        sub_100040F3(v7, v8, v9, (char)v10, v11, v12, v13, v14, v15);
        sub_10003810(a2, &v13);
        sub_100033FC(&v10, (int)v16);
        v5 = sub_10003810(this, v18);
        sub_100033FC(&v7, (int)v5);
        sub_100041C8(this, v17, v7, v8, v9, v10, v11, v12, v13, v14, v15);
      }
      else
      {
        sub_100037F8(this, &v13);
        sub_10003810(a2, &v10);
        sub_100037F8(a2, &v7);
        sub_100040F3(v7, v8, v9, (char)v10, v11, v12, v13, v14, v15);
        v3 = sub_10003810(this, v17);
        sub_100033FC(&v13, (int)v3);
        sub_100033FC(&v10, (int)v16);
        sub_10003AA7(this, v18, (char)v10, v11, v12, v13, v14, v15);
      }
    }
    else
    {
      sub_10003798((int)this);
    }
  }
  return this;
}

//----- (10003798) --------------------------------------------------------
void __thiscall sub_10003798(int this)
{
  int v2; // eax
  int v3; // edi
  int v4; // eax

  v2 = *(_DWORD *)(this + 16);
  if ( v2 )
  {
    do
      --v2;
    while ( v2 );
    *(_DWORD *)(this + 12) = 0;
    *(_DWORD *)(this + 16) = 0;
  }
  v3 = *(_DWORD *)(this + 8);
  while ( v3 )
  {
    v4 = *(_DWORD *)(this + 4);
    --v3;
    if ( *(_DWORD *)(v4 + 4 * v3) )
      operator delete(*(void **)(v4 + 4 * v3));
  }
  if ( *(_DWORD *)(this + 4) )
    operator delete(*(void **)(this + 4));
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 4) = 0;
}
// 1000906C: using guessed type void __cdecl operator delete(void *);

//----- (100037F8) --------------------------------------------------------
_DWORD *__thiscall sub_100037F8(int *this, _DWORD *a2)
{
  _DWORD *result; // eax
  int v3; // edx
  int v4; // ecx

  result = a2;
  v3 = this[3];
  v4 = *this;
  a2[1] = 0;
  *a2 = v4;
  a2[2] = v3;
  return result;
}

//----- (10003810) --------------------------------------------------------
_DWORD *__thiscall sub_10003810(int *this, _DWORD *a2)
{
  _DWORD *result; // eax
  int v3; // edx
  int v4; // ecx

  result = a2;
  v3 = this[3] + this[4];
  v4 = *this;
  a2[1] = 0;
  *a2 = v4;
  a2[2] = v3;
  return result;
}

//----- (1000382B) --------------------------------------------------------
_DWORD *__thiscall sub_1000382B(int *this, _DWORD *a2, char a3, int a4, int a5, char a6, int a7, int a8)
{
  _DWORD *v9; // eax
  int v10; // ebx
  int v11; // esi
  unsigned int v12; // edi
  int *v13; // ebx
  _DWORD *v14; // eax
  int v16; // [esp-24h] [ebp-5Ch] BYREF
  int v17; // [esp-20h] [ebp-58h]
  int v18; // [esp-1Ch] [ebp-54h]
  int v19; // [esp-18h] [ebp-50h] BYREF
  int v20; // [esp-14h] [ebp-4Ch]
  int v21; // [esp-10h] [ebp-48h]
  int v22; // [esp-Ch] [ebp-44h] BYREF
  _DWORD *v23; // [esp-8h] [ebp-40h]
  unsigned int v24; // [esp-4h] [ebp-3Ch]
  _DWORD v25[3]; // [esp+Ch] [ebp-2Ch] BYREF
  _DWORD v26[2]; // [esp+18h] [ebp-20h] BYREF
  int v27; // [esp+20h] [ebp-18h]
  _DWORD v28[2]; // [esp+24h] [ebp-14h] BYREF
  int v29; // [esp+2Ch] [ebp-Ch]
  int *v30; // [esp+34h] [ebp-4h]

  v30 = this;
  sub_100033FC(&v22, (int)&a3);
  sub_10003BC3(this, v28, v22, (int)v23, v24);
  sub_100033FC(&v22, (int)&a6);
  sub_10003BC3(this, v26, v22, (int)v23, v24);
  v9 = sub_100037F8(this, v25);
  v10 = v27;
  v11 = v27 - v29;
  v12 = v29 - v9[2];
  if ( v12 >= sub_10003810(v30, v25)[2] - v10 )
  {
    sub_100033FC(&v22, (int)v28);
    v13 = v30;
    sub_10003810(v30, &v19);
    sub_100033FC(&v16, (int)v26);
    sub_100043C7(v16, v17, v18, v19, v20, v21, v22);
    for ( ; v11; --v11 )
      sub_10003C0E(v13);
  }
  else
  {
    sub_100033FC(&v22, (int)v26);
    sub_100033FC(&v19, (int)v28);
    v13 = v30;
    sub_100037F8(v30, &v16);
    sub_10004382(v16, v17, v18, v19, v20, v21, v22);
    for ( ; v11; --v11 )
      sub_10003BE2(v13);
  }
  v24 = v12;
  v23 = a2;
  v14 = sub_100037F8(v13, v25);
  sub_10003990(v14, v23, v24);
  return a2;
}

//----- (10003946) --------------------------------------------------------
void __thiscall sub_10003946(int this)
{
  int v2; // edi
  int v3; // eax

  while ( *(_DWORD *)(this + 16) )
    sub_10003C0E((_DWORD *)this);
  v2 = *(_DWORD *)(this + 8);
  while ( v2 )
  {
    v3 = *(_DWORD *)(this + 4);
    --v2;
    if ( *(_DWORD *)(v3 + 4 * v2) )
      operator delete(*(void **)(v3 + 4 * v2));
  }
  if ( *(_DWORD *)(this + 4) )
    operator delete(*(void **)(this + 4));
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 4) = 0;
}
// 1000906C: using guessed type void __cdecl operator delete(void *);

//----- (10003990) --------------------------------------------------------
_DWORD *__thiscall sub_10003990(void *this, _DWORD *a2, int a3)
{
  _DWORD v4[2]; // [esp+0h] [ebp-Ch] BYREF
  int v5; // [esp+8h] [ebp-4h]

  sub_100033FC(v4, (int)this);
  v5 += a3;
  sub_100033FC(a2, (int)v4);
  return a2;
}

//----- (100039BA) --------------------------------------------------------
void __thiscall sub_100039BA(const void **this, unsigned int a2, size_t Size)
{
  const void **v3; // esi
  unsigned int v4; // edi
  unsigned int v5; // ebx
  unsigned int v6; // ecx
  void *v7; // eax
  const void **v8; // ecx
  void *v9; // [esp+14h] [ebp-14h]

  v3 = this;
  v4 = a2 | 0xF;
  if ( (a2 | 0xF) == 0xFFFFFFFF )
  {
    v4 = a2;
  }
  else
  {
    v5 = (unsigned int)this[5];
    v6 = v5 >> 1;
    if ( v5 >> 1 > v4 / 3 )
    {
      if ( v5 > -2 - v6 )
        v4 = -2;
      else
        v4 = v6 + v5;
    }
  }
  v7 = sub_10003C3B(v4 + 1);
  v9 = v7;
  if ( Size )
  {
    if ( (unsigned int)v3[5] < 0x10 )
      v8 = v3;
    else
      v8 = (const void **)*v3;
    memcpy(v7, v8, Size);
  }
  sub_100035A2((void **)v3, 1, 0);
  if ( v3 )
    *v3 = v9;
  v3[5] = (const void *)v4;
  v3[4] = (const void *)Size;
  if ( v4 >= 0x10 )
    v3 = (const void **)*v3;
  *((_BYTE *)v3 + Size) = 0;
}
// 10003A56: conditional instruction was optimized away because %Size.4!=0

//----- (10003AA7) --------------------------------------------------------
_DWORD *__thiscall sub_10003AA7(int *this, _DWORD *a2, char a3, int a4, int a5, char a6, int a7, int a8)
{
  _DWORD *v9; // eax
  int v10; // edi
  unsigned int v11; // ebx
  _DWORD *v12; // eax
  int v13; // eax
  _DWORD *v14; // eax
  int v16; // [esp-24h] [ebp-58h] BYREF
  int v17; // [esp-20h] [ebp-54h]
  int v18; // [esp-1Ch] [ebp-50h]
  int v19; // [esp-18h] [ebp-4Ch] BYREF
  int v20; // [esp-14h] [ebp-48h]
  int v21; // [esp-10h] [ebp-44h]
  int v22; // [esp-Ch] [ebp-40h] BYREF
  _DWORD *v23; // [esp-8h] [ebp-3Ch]
  unsigned int v24; // [esp-4h] [ebp-38h]
  _DWORD v25[3]; // [esp+Ch] [ebp-28h] BYREF
  _DWORD v26[2]; // [esp+18h] [ebp-1Ch] BYREF
  int v27; // [esp+20h] [ebp-14h]
  _DWORD v28[2]; // [esp+24h] [ebp-10h] BYREF
  int v29; // [esp+2Ch] [ebp-8h]

  sub_100033FC(&v22, (int)&a3);
  sub_10003BC3(this, v26, v22, (int)v23, v24);
  sub_100033FC(&v22, (int)&a6);
  sub_10003BC3(this, v28, v22, (int)v23, v24);
  v9 = sub_100037F8(this, v25);
  v10 = v29 - v27;
  v11 = v27 - v9[2];
  v12 = sub_10003810(this, v25);
  if ( v11 >= v12[2] - v29 )
  {
    sub_100033FC(&v22, (int)v26);
    sub_10003810(this, &v19);
    sub_100033FC(&v16, (int)v28);
    sub_10004451(v16, v17, v18, v19, v20, v21, v22);
    if ( v10 )
    {
      v13 = this[4];
      do
      {
        if ( !--v13 )
          this[3] = 0;
        --v10;
      }
      while ( v10 );
      goto LABEL_14;
    }
  }
  else
  {
    sub_100033FC(&v22, (int)v28);
    sub_100033FC(&v19, (int)v26);
    sub_100037F8(this, &v16);
    sub_1000440C(v16, v17, v18, v19, v20, v21, v22);
    if ( v10 )
    {
      v13 = this[4];
      do
      {
        if ( --v13 )
          ++this[3];
        else
          this[3] = 0;
        --v10;
      }
      while ( v10 );
LABEL_14:
      this[4] = v13;
    }
  }
  v24 = v11;
  v23 = a2;
  v14 = sub_100037F8(this, v25);
  sub_10003990(v14, v23, v24);
  return a2;
}

//----- (10003BC3) --------------------------------------------------------
_DWORD *__thiscall sub_10003BC3(_DWORD *this, _DWORD *a2, int a3, int a4, int a5)
{
  _DWORD *result; // eax

  result = a2;
  *a2 = 0;
  a2[1] = 0;
  if ( this )
    *a2 = *this;
  a2[2] = a5;
  return result;
}

//----- (10003BE2) --------------------------------------------------------
void __thiscall sub_10003BE2(_DWORD *this)
{
  sub_100035A2((void **)(*(_DWORD *)(this[1] + 4 * (this[3] & (this[2] - 1))) + 12), 1, 0);
  if ( this[4]-- == 1 )
    this[3] = 0;
  else
    ++this[3];
}

//----- (10003C0E) --------------------------------------------------------
void __thiscall sub_10003C0E(_DWORD *this)
{
  sub_100035A2((void **)(*(_DWORD *)(this[1] + 4 * ((this[2] - 1) & (this[3] + this[4] - 1))) + 12), 1, 0);
  if ( this[4]-- == 1 )
    this[3] = 0;
}

//----- (10003C3B) --------------------------------------------------------
void *__stdcall sub_10003C3B(unsigned int a1)
{
  void *v1; // ecx

  v1 = 0;
  if ( a1 )
  {
    v1 = operator new(a1);
    if ( !v1 )
      std::_Xbad_alloc();
  }
  return v1;
}
// 10003C60: variable 'v1' is possibly undefined
// 1000902C: using guessed type void __cdecl std::_Xbad_alloc();
// 10009064: using guessed type void *__cdecl operator new(unsigned int);

//----- (10003C66) --------------------------------------------------------
int __thiscall sub_10003C66(_DWORD *this, _DWORD *a2, int a3, int a4, int a5, int a6, int a7)
{
  int result; // eax
  _DWORD *v9; // edx
  int v10; // ecx
  _DWORD *v11; // ebx
  int v12; // eax
  int v13; // edi
  int v14; // edi
  void *v15; // ecx

  for ( result = a4; result != a7; result = ++a4 )
  {
    v9 = a2;
    if ( a2 )
      v9 = (_DWORD *)*a2;
    v10 = result & (v9[2] - 1);
    v11 = *(_DWORD **)(v9[1] + 4 * v10);
    if ( this[2] <= (unsigned int)(this[4] + 1) )
      sub_1000472B((int)this, v10);
    v12 = this[4];
    v13 = this[2] - 1;
    this[3] &= v13;
    v14 = (this[3] + v12) & v13;
    if ( !*(_DWORD *)(this[1] + 4 * v14) )
    {
      v15 = operator new(0x28u);
      if ( !v15 )
        std::_Xbad_alloc();
      *(_DWORD *)(this[1] + 4 * v14) = v15;
    }
    sub_10004C0F(*(_DWORD **)(this[1] + 4 * v14), v11);
    ++this[4];
  }
  return result;
}
// 10003CDD: variable 'v15' is possibly undefined
// 1000902C: using guessed type void __cdecl std::_Xbad_alloc();
// 10009064: using guessed type void *__cdecl operator new(unsigned int);

//----- (10003D11) --------------------------------------------------------
_DWORD *__cdecl sub_10003D11(char a1, int a2, int a3, char a4, int a5, int a6, char a7, int a8, int a9)
{
  _DWORD *v9; // ecx
  int v10; // esi
  int v11; // edi
  int v12; // ebx
  int v13; // eax
  _DWORD v15[4]; // [esp+Ch] [ebp-40h] BYREF
  _DWORD v16[4]; // [esp+1Ch] [ebp-30h] BYREF
  _DWORD v17[5]; // [esp+2Ch] [ebp-20h] BYREF
  _DWORD *v18; // [esp+40h] [ebp-Ch]
  int v19; // [esp+44h] [ebp-8h]
  int v20; // [esp+48h] [ebp-4h]

  v18 = v9;
  sub_100033FC(v17, (int)&a7);
  v10 = 0;
  if ( v17[0] )
    v11 = *(_DWORD *)v17[0];
  else
    v11 = 0;
  v12 = v17[2];
  sub_100033FC(v15, (int)&a4);
  v19 = v15[2];
  sub_100033FC(v16, (int)&a1);
  if ( v16[0] )
    v10 = *(_DWORD *)v16[0];
  v13 = v16[2];
  v17[0] = v10;
  while ( 1 )
  {
    v20 = v13;
    if ( v13 == v19 )
      break;
    sub_10004C4D(
      *(_DWORD **)(*(_DWORD *)(v11 + 4) + 4 * (v12++ & (*(_DWORD *)(v11 + 8) - 1))),
      *(_DWORD **)(*(_DWORD *)(v10 + 4) + 4 * (v13 & (*(_DWORD *)(v10 + 8) - 1))));
    v13 = v20 + 1;
  }
  a9 = v12;
  sub_100033FC(v18, (int)&a7);
  return v18;
}
// 10003D1D: variable 'v9' is possibly undefined

//----- (10003DB0) --------------------------------------------------------
_DWORD *__thiscall sub_10003DB0(
        int *this,
        _DWORD *a2,
        int a3,
        int a4,
        int a5,
        int *a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11)
{
  int *v11; // esi
  _DWORD *v12; // eax
  int v13; // edx
  int v14; // ecx
  unsigned int v15; // ebx
  unsigned int v16; // eax
  int v17; // edi
  int v18; // eax
  int v19; // ecx
  int v20; // ecx
  int v21; // eax
  bool v22; // zf
  int v23; // ecx
  int v24; // eax
  void *v25; // edx
  _DWORD *v26; // eax
  int v27; // esi
  int v28; // ebx
  int v29; // edi
  _DWORD *v30; // eax
  _DWORD *v31; // eax
  _DWORD *v32; // eax
  int v33; // eax
  int v34; // ecx
  int v35; // ecx
  int v36; // eax
  int v37; // ecx
  int v38; // eax
  void *v39; // edx
  _DWORD *v40; // eax
  _DWORD *v41; // eax
  _DWORD *v42; // eax
  _DWORD v44[2]; // [esp-24h] [ebp-ACh] BYREF
  unsigned int v45; // [esp-1Ch] [ebp-A4h]
  int v46[3]; // [esp-18h] [ebp-A0h] BYREF
  int v47; // [esp-Ch] [ebp-94h] BYREF
  _DWORD *v48; // [esp-8h] [ebp-90h]
  unsigned int v49; // [esp-4h] [ebp-8Ch]
  _DWORD v50[3]; // [esp+14h] [ebp-74h] BYREF
  _DWORD v51[4]; // [esp+20h] [ebp-68h] BYREF
  _DWORD v52[4]; // [esp+30h] [ebp-58h] BYREF
  int *v53; // [esp+40h] [ebp-48h] BYREF
  int v54; // [esp+48h] [ebp-40h]
  _DWORD v55[2]; // [esp+50h] [ebp-38h] BYREF
  int v56; // [esp+58h] [ebp-30h]
  int v57; // [esp+60h] [ebp-28h]
  _DWORD *v58; // [esp+64h] [ebp-24h]
  int v59; // [esp+68h] [ebp-20h]
  unsigned int v60; // [esp+6Ch] [ebp-1Ch]
  int *v61; // [esp+70h] [ebp-18h]
  unsigned int v62; // [esp+74h] [ebp-14h]
  int v63; // [esp+84h] [ebp-4h]

  v11 = this;
  v61 = this;
  v12 = sub_100037F8(this, v51);
  v13 = a8;
  v14 = a11;
  v15 = a5 - v12[2];
  v16 = v11[4];
  v60 = v15;
  v62 = v16;
  if ( a8 != a11 )
  {
    v17 = 0;
    if ( v15 > v16 >> 1 )
    {
      v63 = 2;
      while ( v13 != v14 )
      {
        if ( a6 )
          v33 = *a6;
        else
          v33 = 0;
        v34 = v13 & (*(_DWORD *)(v33 + 8) - 1);
        v58 = *(_DWORD **)(*(_DWORD *)(v33 + 4) + 4 * v34);
        if ( v11[2] <= (unsigned int)(v11[4] + 1) )
          sub_1000472B((int)v11, v34);
        v35 = v11[4];
        v36 = v11[2] - 1;
        v11[3] &= v36;
        v37 = v36 & (v11[3] + v35);
        v38 = v11[1];
        v57 = v37;
        if ( !*(_DWORD *)(v38 + 4 * v37) )
        {
          v39 = operator new(0x28u);
          if ( !v39 )
            goto LABEL_14;
          v37 = v57;
          *(_DWORD *)(v11[1] + 4 * v57) = v39;
        }
        sub_10004C0F(*(_DWORD **)(v11[1] + 4 * v37), v58);
        ++v11[4];
        v13 = a8 + 1;
        v14 = a11;
        ++a8;
      }
      v63 = -1;
      sub_10003810(v11, &v47);
      v45 = v62;
      v40 = sub_100037F8(v11, v50);
      sub_10003990(v40, v46, v45);
      v41 = sub_100037F8(v11, v51);
      sub_10003990(v41, v44, v15);
    }
    else
    {
      v63 = 0;
      while ( v13 != v14 )
      {
        if ( a6 )
          v18 = *a6;
        else
          v18 = 0;
        v19 = v13 & (*(_DWORD *)(v18 + 8) - 1);
        v58 = *(_DWORD **)(*(_DWORD *)(v18 + 4) + 4 * v19);
        if ( v11[2] <= (unsigned int)(v11[4] + 1) )
          sub_1000472B((int)v11, v19);
        v20 = v11[2];
        v21 = v20 - 1;
        v22 = ((v20 - 1) & v11[3]) == 0;
        v11[3] &= v20 - 1;
        if ( !v22 )
          v20 = v11[3];
        v57 = v20 - 1;
        v23 = v21 & (v20 - 1);
        v24 = v11[1];
        v59 = v23;
        if ( !*(_DWORD *)(v24 + 4 * v23) )
        {
          v25 = operator new(0x28u);
          if ( !v25 )
LABEL_14:
            std::_Xbad_alloc();
          v23 = v59;
          *(_DWORD *)(v11[1] + 4 * v59) = v25;
        }
        sub_10004C0F(*(_DWORD **)(v11[1] + 4 * v23), v58);
        ++v11[4];
        v13 = a8 + 1;
        v14 = a11;
        v11[3] = v57;
        ++a8;
      }
      v63 = -1;
      v49 = v11[4] - v62;
      v57 = v49;
      v26 = sub_100037F8(v11, v50);
      sub_10003990(v26, v52, v49);
      sub_100037F8(v11, v51);
      sub_100033FC(v55, (int)v52);
      if ( v55[0] )
        v62 = *(_DWORD *)v55[0];
      else
        v62 = 0;
      sub_100033FC(&v53, (int)v51);
      if ( v53 )
        v17 = *v53;
      if ( v54 != v56 )
      {
        v27 = v56;
        v28 = v54;
        do
        {
          if ( v28 == --v27 )
            break;
          sub_10004CF6(v17, v28++, v62, v27);
        }
        while ( v28 != v27 );
        v11 = v61;
        v15 = v60;
      }
      v29 = v57;
      v46[0] = v57;
      v30 = sub_100037F8(v11, v51);
      v31 = sub_10003990(v30, v50, v46[0]);
      sub_10003990(v31, &v47, v15);
      v32 = sub_100037F8(v11, v52);
      sub_10003990(v32, v46, v29);
      sub_100037F8(v11, v44);
    }
    sub_10004882(v44[0], v44[1], v45, v46[0], v46[1], v46[2], v47, (int)v48, v49);
  }
  v49 = v15;
  v48 = a2;
  v42 = sub_100037F8(v11, v55);
  sub_10003990(v42, v48, v49);
  return a2;
}
// 10003E64: variable 'v25' is possibly undefined
// 1000902C: using guessed type void __cdecl std::_Xbad_alloc();
// 10009064: using guessed type void *__cdecl operator new(unsigned int);

//----- (100040A4) --------------------------------------------------------
int __thiscall sub_100040A4(_DWORD *this, int *a2, int a3, int a4, int a5, int a6, int a7)
{
  int result; // eax
  int *v9; // eax

  for ( result = a4; result != a7; result = ++a4 )
  {
    v9 = (int *)sub_100045A8(&a2);
    sub_1000451F(this, v9);
  }
  return result;
}

//----- (100040F3) --------------------------------------------------------
_DWORD *__cdecl sub_100040F3(char a1, int a2, int a3, char a4, int a5, int a6, char a7, int a8, unsigned int a9)
{
  _DWORD *v9; // ecx
  _DWORD *v10; // edi
  int v11; // ebx
  int v12; // esi
  unsigned int v13; // eax
  unsigned int v14; // edx
  int v15; // edi
  _DWORD v17[4]; // [esp+Ch] [ebp-50h] BYREF
  int *v18; // [esp+1Ch] [ebp-40h] BYREF
  unsigned int v19; // [esp+24h] [ebp-38h]
  int *v20; // [esp+2Ch] [ebp-30h] BYREF
  unsigned int v21; // [esp+34h] [ebp-28h]
  int v22; // [esp+3Ch] [ebp-20h]
  _DWORD *v23; // [esp+44h] [ebp-18h]
  int v24; // [esp+48h] [ebp-14h]
  int v25; // [esp+4Ch] [ebp-10h]
  unsigned int v26; // [esp+50h] [ebp-Ch]
  int v27; // [esp+54h] [ebp-8h]
  unsigned int v28; // [esp+58h] [ebp-4h]

  v10 = v9;
  v23 = v9;
  sub_100033FC(&v20, (int)&a7);
  v11 = 0;
  v24 = 0;
  v12 = 0;
  if ( v20 )
    v12 = *v20;
  v26 = v21;
  v27 = v12;
  sub_100033FC(v17, (int)&a4);
  v25 = v17[2];
  sub_100033FC(&v18, (int)&a1);
  if ( v18 )
  {
    v11 = *v18;
    v24 = *v18;
  }
  v13 = v19;
  v14 = v21;
  v28 = v19;
  v22 = v11;
  if ( v19 != v25 )
  {
    do
    {
      v15 = *(_DWORD *)(*(_DWORD *)(v11 + 4) + 4 * ((*(_DWORD *)(v11 + 8) - 1) & (v13 >> 2)));
      v11 = v24;
      *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v27 + 4) + 4 * ((*(_DWORD *)(v27 + 8) - 1) & (v14 >> 2))) + 4 * (v14 & 3)) = *(_DWORD *)(v15 + 4 * (v28 & 3));
      v14 = v26 + 1;
      v13 = v28 + 1;
      ++v26;
      v28 = v13;
    }
    while ( v13 != v25 );
    v10 = v23;
  }
  a9 = v14;
  sub_100033FC(v10, (int)&a7);
  return v10;
}
// 100040FC: variable 'v9' is possibly undefined

//----- (100041C8) --------------------------------------------------------
_DWORD *__thiscall sub_100041C8(
        int *this,
        _DWORD *a2,
        int a3,
        int a4,
        int a5,
        int *a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11)
{
  _DWORD *v12; // eax
  int v13; // ecx
  int v14; // edx
  unsigned int v15; // edi
  unsigned int v16; // esi
  int *v17; // eax
  int v18; // esi
  _DWORD *v19; // eax
  _DWORD *v20; // eax
  _DWORD *v21; // eax
  _DWORD *v22; // eax
  int *v23; // eax
  _DWORD *v24; // eax
  _DWORD *v25; // eax
  _DWORD *v26; // eax
  _DWORD v28[3]; // [esp-24h] [ebp-7Ch] BYREF
  int v29; // [esp-18h] [ebp-70h] BYREF
  int *v30; // [esp-14h] [ebp-6Ch]
  unsigned int v31; // [esp-10h] [ebp-68h]
  int v32; // [esp-Ch] [ebp-64h] BYREF
  _DWORD *v33; // [esp-8h] [ebp-60h]
  unsigned int v34; // [esp-4h] [ebp-5Ch]
  _DWORD v35[3]; // [esp+10h] [ebp-48h] BYREF
  _DWORD v36[3]; // [esp+1Ch] [ebp-3Ch] BYREF
  _DWORD v37[3]; // [esp+28h] [ebp-30h] BYREF
  _DWORD v38[4]; // [esp+34h] [ebp-24h] BYREF
  unsigned int v39; // [esp+44h] [ebp-14h]
  int v40; // [esp+54h] [ebp-4h]

  v38[3] = this;
  v12 = sub_100037F8(this, v38);
  v13 = a8;
  v14 = a11;
  v15 = a5 - v12[2];
  v16 = this[4];
  v39 = v16;
  if ( a8 != a11 )
  {
    if ( v15 > v16 >> 1 )
    {
      v40 = 2;
      while ( v13 != v14 )
      {
        v23 = (int *)sub_100045A8(&a6);
        sub_1000451F(this, v23);
        v14 = a11;
        v13 = ++a8;
      }
      sub_10003810(this, &v32);
      v24 = sub_100037F8(this, v35);
      sub_10003990(v24, &v29, v16);
      v25 = sub_100037F8(this, v36);
      sub_10003990(v25, v28, v15);
    }
    else
    {
      v40 = 0;
      while ( v13 != v14 )
      {
        v17 = (int *)sub_100045A8(&a6);
        sub_10004496((int)this, v17);
        v14 = a11;
        v13 = ++a8;
      }
      v18 = this[4] - v39;
      v19 = sub_100037F8(this, v38);
      sub_10003990(v19, &v32, v18);
      sub_100037F8(this, &v29);
      sub_1000494D(v29, (int)v30, v31, v32);
      v31 = v15;
      v30 = &v32;
      v29 = v18;
      v20 = sub_100037F8(this, v37);
      v21 = sub_10003990(v20, v38, v29);
      sub_10003990(v21, v30, v31);
      v22 = sub_100037F8(this, v36);
      sub_10003990(v22, &v29, v18);
      sub_100037F8(this, v28);
    }
    sub_100049F0(v28[0], v28[1], v28[2], v29, (int)v30, v31, v32, (int)v33, v34);
  }
  v34 = v15;
  v33 = a2;
  v26 = sub_100037F8(this, v35);
  sub_10003990(v26, v33, v34);
  return a2;
}

//----- (10004382) --------------------------------------------------------
int __cdecl sub_10004382(char a1, int a2, int a3, char a4, int a5, int a6, char a7)
{
  int v7; // ecx
  int v8; // esi
  int v10[3]; // [esp-28h] [ebp-30h] BYREF
  int *v11[3]; // [esp-1Ch] [ebp-24h] BYREF
  _DWORD *v12[6]; // [esp-10h] [ebp-18h] BYREF

  v12[3] = v12[5];
  v8 = v7;
  sub_100033FC(v12, (int)&a7);
  sub_100033FC(v11, (int)&a4);
  sub_100033FC(v10, (int)&a1);
  sub_10004ABB(v10[0], v10[1], v10[2], v11[0], (int)v11[1], (int)v11[2], v12[0], (int)v12[1], (int)v12[2]);
  return v8;
}
// 1000438A: variable 'v7' is possibly undefined

//----- (100043C7) --------------------------------------------------------
int __cdecl sub_100043C7(char a1, int a2, int a3, char a4, int a5, int a6, char a7)
{
  int v7; // ecx
  int v8; // esi
  int *v10[3]; // [esp-28h] [ebp-30h] BYREF
  int v11[3]; // [esp-1Ch] [ebp-24h] BYREF
  _DWORD *v12[6]; // [esp-10h] [ebp-18h] BYREF

  v12[3] = v12[5];
  v8 = v7;
  sub_100033FC(v12, (int)&a7);
  sub_100033FC(v11, (int)&a4);
  sub_100033FC(v10, (int)&a1);
  sub_10004B1A(v10[0], (int)v10[1], (int)v10[2], v11[0], v11[1], v11[2], v12[0], (int)v12[1], (int)v12[2]);
  return v8;
}
// 100043CF: variable 'v7' is possibly undefined

//----- (1000440C) --------------------------------------------------------
int __cdecl sub_1000440C(char a1, int a2, int a3, char a4, int a5, int a6, char a7)
{
  int v7; // ecx
  int v8; // esi
  int v10[3]; // [esp-28h] [ebp-30h] BYREF
  int *v11[3]; // [esp-1Ch] [ebp-24h] BYREF
  int *v12[6]; // [esp-10h] [ebp-18h] BYREF

  v12[3] = v12[5];
  v8 = v7;
  sub_100033FC(v12, (int)&a7);
  sub_100033FC(v11, (int)&a4);
  sub_100033FC(v10, (int)&a1);
  sub_10004B85(v10[0], v10[1], v10[2], v11[0], (int)v11[1], (int)v11[2], v12[0], (int)v12[1], (int)v12[2]);
  return v8;
}
// 10004414: variable 'v7' is possibly undefined

//----- (10004451) --------------------------------------------------------
int __cdecl sub_10004451(char a1, int a2, int a3, char a4, int a5, int a6, char a7)
{
  int v7; // ecx
  int v8; // esi
  int *v10[3]; // [esp-28h] [ebp-30h] BYREF
  int v11[3]; // [esp-1Ch] [ebp-24h] BYREF
  int *v12[6]; // [esp-10h] [ebp-18h] BYREF

  v12[3] = v12[5];
  v8 = v7;
  sub_100033FC(v12, (int)&a7);
  sub_100033FC(v11, (int)&a4);
  sub_100033FC(v10, (int)&a1);
  sub_10004BCA(v10[0], (int)v10[1], (int)v10[2], v11[0], v11[1], v11[2], v12[0], (int)v12[1], (int)v12[2]);
  return v8;
}
// 10004459: variable 'v7' is possibly undefined

//----- (10004496) --------------------------------------------------------
int __thiscall sub_10004496(int this, int *a2)
{
  int v3; // ecx
  int v4; // edi
  bool v5; // zf
  unsigned int v6; // edi
  int v7; // ebx
  void *v8; // ecx
  int result; // eax
  int *v10; // ecx

  if ( (*(_BYTE *)(this + 12) & 3) == 0 && *(_DWORD *)(this + 8) <= (unsigned int)(*(_DWORD *)(this + 16) + 4) >> 2 )
    sub_100045D1(this, this);
  v3 = *(_DWORD *)(this + 8);
  v4 = 4 * v3;
  v5 = ((4 * v3 - 1) & *(_DWORD *)(this + 12)) == 0;
  *(_DWORD *)(this + 12) &= 4 * v3 - 1;
  if ( !v5 )
    v4 = *(_DWORD *)(this + 12);
  v6 = v4 - 1;
  v7 = (v6 >> 2) & (v3 - 1);
  if ( !*(_DWORD *)(*(_DWORD *)(this + 4) + 4 * v7) )
  {
    v8 = operator new(0x10u);
    if ( !v8 )
      std::_Xbad_alloc();
    *(_DWORD *)(*(_DWORD *)(this + 4) + 4 * v7) = v8;
  }
  result = *(_DWORD *)(*(_DWORD *)(this + 4) + 4 * v7);
  v10 = (int *)(result + 4 * (v6 & 3));
  if ( v10 )
  {
    result = *a2;
    *v10 = *a2;
  }
  ++*(_DWORD *)(this + 16);
  *(_DWORD *)(this + 12) = v6;
  return result;
}
// 100044F6: variable 'v8' is possibly undefined
// 1000902C: using guessed type void __cdecl std::_Xbad_alloc();
// 10009064: using guessed type void *__cdecl operator new(unsigned int);

//----- (1000451F) --------------------------------------------------------
int __thiscall sub_1000451F(_DWORD *this, int *a2)
{
  int v3; // eax
  int v4; // ecx
  int v5; // ecx
  int v6; // edi
  unsigned int v7; // edi
  int v8; // ebx
  void *v9; // ecx
  int result; // eax
  int *v11; // ecx

  v3 = this[3];
  v4 = this[4];
  if ( (((_BYTE)v4 + (_BYTE)v3) & 3) == 0 && this[2] <= (unsigned int)(v4 + 4) >> 2 )
    sub_100045D1((int)this, v4);
  v5 = this[2];
  v6 = this[4];
  this[3] &= 4 * v5 - 1;
  v7 = this[3] + v6;
  v8 = (v7 >> 2) & (v5 - 1);
  if ( !*(_DWORD *)(this[1] + 4 * v8) )
  {
    v9 = operator new(0x10u);
    if ( !v9 )
      std::_Xbad_alloc();
    *(_DWORD *)(this[1] + 4 * v8) = v9;
  }
  result = *(_DWORD *)(this[1] + 4 * v8);
  v11 = (int *)(result + 4 * (v7 & 3));
  if ( v11 )
  {
    result = *a2;
    *v11 = *a2;
  }
  ++this[4];
  return result;
}
// 10004584: variable 'v9' is possibly undefined
// 1000902C: using guessed type void __cdecl std::_Xbad_alloc();
// 10009064: using guessed type void *__cdecl operator new(unsigned int);

//----- (100045A8) --------------------------------------------------------
int __thiscall sub_100045A8(int **this)
{
  int v1; // esi

  if ( *this )
    v1 = **this;
  else
    v1 = 0;
  return *(_DWORD *)(*(_DWORD *)(v1 + 4) + 4 * ((*(_DWORD *)(v1 + 8) - 1) & ((unsigned int)this[2] >> 2)))
       + 4 * ((unsigned int)this[2] & 3);
}

//----- (100045D1) --------------------------------------------------------
void __thiscall sub_100045D1(int this, int a2)
{
  unsigned int v3; // ebx
  unsigned int v4; // ecx
  unsigned int v5; // ebx
  unsigned int v6; // esi
  unsigned int v7; // eax
  size_t v8; // esi
  char *v9; // edx
  char *v10; // eax
  char *v11; // edi
  unsigned int v12; // ecx
  size_t v13; // esi
  char *v14; // eax
  int v16; // [esp+10h] [ebp-Ch]
  unsigned int v17; // [esp+14h] [ebp-8h]
  char *v18; // [esp+18h] [ebp-4h]

  v3 = 1;
  v4 = *(_DWORD *)(this + 8);
  if ( v4 )
    v3 = v4;
  while ( v3 == v4 || v3 < 8 )
  {
    if ( 0xFFFFFFF - v3 < v3 )
      std::_Xlength_error("deque<T> too long");
    v3 *= 2;
  }
  v5 = v3 - v4;
  v18 = 0;
  v6 = *(_DWORD *)(this + 12) >> 2;
  v17 = v6;
  v7 = v4 + v5;
  if ( v4 + v5 )
  {
    if ( v7 > 0x3FFFFFFF || (v18 = (char *)operator new(4 * v7)) == 0 )
      std::_Xbad_alloc();
  }
  v16 = 4 * v6;
  v8 = (4 * *(_DWORD *)(this + 8) - 4 * v6) & 0xFFFFFFFC;
  v9 = (char *)memmove(&v18[v16], (const void *)(*(_DWORD *)(this + 4) + v16), v8) + v8;
  if ( v17 > v5 )
  {
    memmove(v9, *(const void **)(this + 4), 4 * v5);
    v11 = v18;
    v13 = (v16 - 4 * v5) & 0xFFFFFFFC;
    v14 = (char *)memmove(v18, (const void *)(4 * v5 + *(_DWORD *)(this + 4)), v13);
    if ( !v5 )
      goto LABEL_19;
    v12 = v5;
    v11 = &v14[v13];
    goto LABEL_18;
  }
  v10 = (char *)memmove(v9, *(const void **)(this + 4), 4 * v17);
  if ( v5 != v17 )
    memset(&v10[4 * v17], 0, 4 * (v5 - v17));
  v11 = v18;
  if ( v17 )
  {
    v12 = v17;
LABEL_18:
    memset(v11, 0, 4 * v12);
    v11 = v18;
  }
LABEL_19:
  if ( *(_DWORD *)(this + 4) )
    operator delete(*(void **)(this + 4));
  *(_DWORD *)(this + 8) += v5;
  *(_DWORD *)(this + 4) = v11;
}
// 1000902C: using guessed type void __cdecl std::_Xbad_alloc();
// 10009034: using guessed type void __cdecl __noreturn std::_Xlength_error(const char *);
// 10009064: using guessed type void *__cdecl operator new(unsigned int);
// 1000906C: using guessed type void __cdecl operator delete(void *);

//----- (1000472B) --------------------------------------------------------
void __thiscall sub_1000472B(int this, int a2)
{
  unsigned int v3; // ebx
  unsigned int v4; // ecx
  unsigned int v5; // ebx
  unsigned int v6; // esi
  unsigned int v7; // eax
  size_t v8; // esi
  char *v9; // edx
  char *v10; // eax
  char *v11; // edi
  unsigned int v12; // ecx
  size_t v13; // esi
  char *v14; // eax
  int v16; // [esp+10h] [ebp-Ch]
  unsigned int v17; // [esp+14h] [ebp-8h]
  char *v18; // [esp+18h] [ebp-4h]

  v3 = 1;
  v4 = *(_DWORD *)(this + 8);
  if ( v4 )
    v3 = v4;
  while ( v3 == v4 || v3 < 8 )
  {
    if ( 107374182 - v3 < v3 )
      std::_Xlength_error("deque<T> too long");
    v3 *= 2;
  }
  v18 = 0;
  v5 = v3 - v4;
  v6 = *(_DWORD *)(this + 12);
  v17 = v6;
  v7 = v4 + v5;
  if ( v4 + v5 )
  {
    if ( v7 > 0x3FFFFFFF || (v18 = (char *)operator new(4 * v7)) == 0 )
      std::_Xbad_alloc();
  }
  v16 = 4 * v6;
  v8 = (4 * *(_DWORD *)(this + 8) - 4 * v6) & 0xFFFFFFFC;
  v9 = (char *)memmove(&v18[v16], (const void *)(*(_DWORD *)(this + 4) + v16), v8) + v8;
  if ( v17 > v5 )
  {
    memmove(v9, *(const void **)(this + 4), 4 * v5);
    v11 = v18;
    v13 = (v16 - 4 * v5) & 0xFFFFFFFC;
    v14 = (char *)memmove(v18, (const void *)(4 * v5 + *(_DWORD *)(this + 4)), v13);
    if ( !v5 )
      goto LABEL_19;
    v12 = v5;
    v11 = &v14[v13];
    goto LABEL_18;
  }
  v10 = (char *)memmove(v9, *(const void **)(this + 4), 4 * v17);
  if ( v5 != v17 )
    memset(&v10[4 * v17], 0, 4 * (v5 - v17));
  v11 = v18;
  if ( v17 )
  {
    v12 = v17;
LABEL_18:
    memset(v11, 0, 4 * v12);
    v11 = v18;
  }
LABEL_19:
  if ( *(_DWORD *)(this + 4) )
    operator delete(*(void **)(this + 4));
  *(_DWORD *)(this + 8) += v5;
  *(_DWORD *)(this + 4) = v11;
}
// 1000902C: using guessed type void __cdecl std::_Xbad_alloc();
// 10009034: using guessed type void __cdecl __noreturn std::_Xlength_error(const char *);
// 10009064: using guessed type void *__cdecl operator new(unsigned int);
// 1000906C: using guessed type void __cdecl operator delete(void *);

//----- (10004882) --------------------------------------------------------
_DWORD *__cdecl sub_10004882(char a1, int a2, int a3, char a4, int a5, int a6, char a7, int a8, int a9)
{
  _DWORD *v9; // ecx
  int v10; // esi
  _DWORD *v11; // ebx
  int v12; // esi
  int v13; // edi
  int v14; // ebx
  _DWORD v16[4]; // [esp+Ch] [ebp-48h] BYREF
  _DWORD v17[4]; // [esp+1Ch] [ebp-38h] BYREF
  _DWORD v18[4]; // [esp+2Ch] [ebp-28h] BYREF
  _DWORD v19[2]; // [esp+3Ch] [ebp-18h] BYREF
  unsigned int v20; // [esp+44h] [ebp-10h]
  _DWORD *v21; // [esp+50h] [ebp-4h]

  v10 = a3;
  v11 = v9;
  v21 = v9;
  if ( a3 != a6 && a6 != a9 )
  {
    sub_100033FC(v19, (int)&a7);
    v12 = 0;
    v13 = 0;
    if ( v19[0] )
      v13 = *(_DWORD *)v19[0];
    sub_100033FC(v18, (int)&a4);
    v14 = 0;
    if ( v18[0] )
      v14 = *(_DWORD *)v18[0];
    sub_100033FC(v17, (int)&a1);
    if ( v17[0] )
      v12 = *(_DWORD *)v17[0];
    sub_10004D6F(v12, v17[2], v14, v18[2], v13, v20);
    v10 = a3;
    v11 = v21;
  }
  sub_100033FC(v17, (int)&a7);
  sub_100033FC(v18, (int)&a4);
  sub_100033FC(v16, (int)v17);
  sub_100033FC(v19, (int)v18);
  a3 = v16[2] - v20 + v10;
  sub_100033FC(v11, (int)&a1);
  return v11;
}
// 10004890: variable 'v9' is possibly undefined

//----- (1000494D) --------------------------------------------------------
unsigned int __cdecl sub_1000494D(char a1, int a2, int a3, char a4)
{
  int v4; // esi
  int v5; // edi
  unsigned int v6; // ebx
  unsigned int result; // eax
  unsigned int v8; // ebx
  unsigned int v9; // eax
  int v10; // ebx
  int v11; // edi
  int v12; // edx
  int v13; // eax
  int v14; // esi
  int v15; // edx
  int v16; // ecx
  _DWORD v17[2]; // [esp+10h] [ebp-20h] BYREF
  unsigned int v18; // [esp+18h] [ebp-18h]
  unsigned int v19; // [esp+20h] [ebp-10h]
  int v20; // [esp+24h] [ebp-Ch]
  int v21; // [esp+28h] [ebp-8h]
  unsigned int v22; // [esp+2Ch] [ebp-4h]

  sub_100033FC(v17, (int)&a4);
  v4 = 0;
  v21 = 0;
  v5 = 0;
  if ( v17[0] )
    v5 = *(_DWORD *)v17[0];
  v6 = v18;
  v20 = v5;
  sub_100033FC(v17, (int)&a1);
  if ( v17[0] )
  {
    v4 = *(_DWORD *)v17[0];
    v21 = *(_DWORD *)v17[0];
  }
  result = v18;
  while ( 1 )
  {
    v22 = result;
    if ( result == v6 )
      break;
    v8 = v6 - 1;
    v19 = v8;
    if ( result == v8 )
      break;
    v9 = v8 >> 2;
    v10 = v8 & 3;
    v11 = *(_DWORD *)(*(_DWORD *)(v5 + 4) + 4 * (v9 & (*(_DWORD *)(v5 + 8) - 1)));
    v12 = (v22 >> 2) & (*(_DWORD *)(v4 + 8) - 1);
    v13 = *(_DWORD *)(v4 + 4);
    v14 = v22 & 3;
    v15 = *(_DWORD *)(v13 + 4 * v12);
    v16 = *(_DWORD *)(v15 + 4 * v14);
    *(_DWORD *)(v15 + 4 * v14) = *(_DWORD *)(v11 + 4 * v10);
    v4 = v21;
    result = v22 + 1;
    *(_DWORD *)(v11 + 4 * v10) = v16;
    v6 = v19;
    v5 = v20;
  }
  return result;
}

//----- (100049F0) --------------------------------------------------------
_DWORD *__cdecl sub_100049F0(char a1, int a2, int a3, char a4, int a5, int a6, char a7, int a8, int a9)
{
  _DWORD *v9; // ecx
  int v10; // esi
  _DWORD *v11; // ebx
  int v12; // esi
  int v13; // edi
  int v14; // ebx
  _DWORD v16[4]; // [esp+Ch] [ebp-48h] BYREF
  _DWORD v17[4]; // [esp+1Ch] [ebp-38h] BYREF
  _DWORD v18[4]; // [esp+2Ch] [ebp-28h] BYREF
  _DWORD v19[2]; // [esp+3Ch] [ebp-18h] BYREF
  unsigned int v20; // [esp+44h] [ebp-10h]
  _DWORD *v21; // [esp+50h] [ebp-4h]

  v10 = a3;
  v11 = v9;
  v21 = v9;
  if ( a3 != a6 && a6 != a9 )
  {
    sub_100033FC(v19, (int)&a7);
    v12 = 0;
    v13 = 0;
    if ( v19[0] )
      v13 = *(_DWORD *)v19[0];
    sub_100033FC(v18, (int)&a4);
    v14 = 0;
    if ( v18[0] )
      v14 = *(_DWORD *)v18[0];
    sub_100033FC(v17, (int)&a1);
    if ( v17[0] )
      v12 = *(_DWORD *)v17[0];
    sub_10004E65(v12, v17[2], v14, v18[2], v13, v20);
    v10 = a3;
    v11 = v21;
  }
  sub_100033FC(v17, (int)&a7);
  sub_100033FC(v18, (int)&a4);
  sub_100033FC(v16, (int)v17);
  sub_100033FC(v19, (int)v18);
  a3 = v16[2] - v20 + v10;
  sub_100033FC(v11, (int)&a1);
  return v11;
}
// 100049FE: variable 'v9' is possibly undefined

//----- (10004ABB) --------------------------------------------------------
_DWORD *__cdecl sub_10004ABB(int a1, int a2, int a3, int *a4, int a5, int a6, _DWORD *a7, int a8, int a9)
{
  _DWORD *v9; // ecx
  _DWORD *v10; // esi
  int v11; // eax
  int v12; // edx
  int v13; // ecx
  int v14; // eax
  int v15; // edx
  _DWORD *v16; // eax
  _DWORD *v17; // ecx

  v10 = v9;
  while ( a3 != a6 )
  {
    v11 = --a6;
    if ( a4 )
      v12 = *a4;
    else
      v12 = 0;
    v13 = v11 & (*(_DWORD *)(v12 + 8) - 1);
    v14 = *(_DWORD *)(v12 + 4);
    v15 = a9 - 1;
    v16 = *(_DWORD **)(v14 + 4 * v13);
    v17 = a7;
    --a9;
    if ( a7 )
      v17 = (_DWORD *)*a7;
    sub_10004C4D(*(_DWORD **)(v17[1] + 4 * (v15 & (v17[2] - 1))), v16);
  }
  sub_100033FC(v10, (int)&a7);
  return v10;
}
// 10004ABF: variable 'v9' is possibly undefined

//----- (10004B1A) --------------------------------------------------------
_DWORD *__cdecl sub_10004B1A(int *a1, int a2, int a3, int a4, int a5, int a6, _DWORD *a7, int a8, int a9)
{
  _DWORD *v9; // ecx
  int v10; // eax
  _DWORD *v11; // esi
  int v12; // ebx
  int v13; // edx
  _DWORD *v14; // edi

  v10 = a3;
  v11 = v9;
  if ( a3 != a6 )
  {
    v12 = a9;
    do
    {
      if ( a1 )
        v13 = *a1;
      else
        v13 = 0;
      v14 = a7;
      if ( a7 )
        v14 = (_DWORD *)*a7;
      sub_10004C4D(
        *(_DWORD **)(v14[1] + 4 * (v12 & (v14[2] - 1))),
        *(_DWORD **)(*(_DWORD *)(v13 + 4) + 4 * (v10 & (*(_DWORD *)(v13 + 8) - 1))));
      v12 = a9 + 1;
      v10 = a3 + 1;
      ++a9;
      a3 = v10;
    }
    while ( v10 != a6 );
  }
  sub_100033FC(v11, (int)&a7);
  return v11;
}
// 10004B21: variable 'v9' is possibly undefined

//----- (10004B85) --------------------------------------------------------
_DWORD *__cdecl sub_10004B85(int a1, int a2, int a3, int *a4, int a5, int a6, int *a7, int a8, int a9)
{
  _DWORD *v9; // ecx
  int v10; // eax
  _DWORD *i; // edi
  _DWORD *v12; // eax

  v10 = a6;
  for ( i = v9; a3 != a6; v10 = a6 )
  {
    a6 = v10 - 1;
    v12 = (_DWORD *)sub_100045A8(&a4);
    --a9;
    *(_DWORD *)sub_100045A8(&a7) = *v12;
  }
  sub_100033FC(i, (int)&a7);
  return i;
}
// 10004B8C: variable 'v9' is possibly undefined

//----- (10004BCA) --------------------------------------------------------
_DWORD *__cdecl sub_10004BCA(int *a1, int a2, int a3, int a4, int a5, int a6, int *a7, int a8, int a9)
{
  _DWORD *v9; // ecx
  _DWORD *i; // edi
  _DWORD *v11; // esi

  for ( i = v9; a3 != a6; ++a3 )
  {
    v11 = (_DWORD *)sub_100045A8(&a1);
    *(_DWORD *)sub_100045A8(&a7) = *v11;
    ++a9;
  }
  sub_100033FC(i, (int)&a7);
  return i;
}
// 10004BD1: variable 'v9' is possibly undefined

//----- (10004C0F) --------------------------------------------------------
int __stdcall sub_10004C0F(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  if ( a1 )
  {
    *a1 = *a2;
    a1[1] = a2[1];
    a1[2] = a2[2];
    std::string::string(a2 + 3);
    result = a2[9];
    a1[9] = result;
  }
  return result;
}
// 1000304E: using guessed type _DWORD __stdcall std::string::string(_DWORD);

//----- (10004C4D) --------------------------------------------------------
_DWORD *__thiscall sub_10004C4D(_DWORD *this, _DWORD *a2)
{
  _DWORD *v2; // eax
  _DWORD *v4; // edi
  _DWORD *v5; // ecx

  v2 = a2;
  v4 = this;
  v5 = this + 3;
  *v4++ = *a2;
  *v4 = a2[1];
  v4[1] = a2[2];
  if ( v5 != a2 + 3 )
  {
    sub_10003425(v5, a2 + 3, 0, 0xFFFFFFFF);
    v2 = a2;
  }
  this[9] = v2[9];
  return this;
}

//----- (10004C92) --------------------------------------------------------
Json::PathArgument *__fastcall sub_10004C92(
        const struct Json::PathArgument *a1,
        const struct Json::PathArgument *a2,
        Json::PathArgument *a3)
{
  while ( a1 != a2 )
  {
    if ( a3 )
      Json::PathArgument::PathArgument(a3, a1);
    a3 = (Json::PathArgument *)((char *)a3 + 32);
    a1 = (const struct Json::PathArgument *)((char *)a1 + 32);
  }
  return a3;
}

//----- (10004CF6) --------------------------------------------------------
void __cdecl sub_10004CF6(int a1, int a2, int a3, int a4)
{
  int v4; // ebx
  _DWORD *v5; // [esp+10h] [ebp-40h]
  _DWORD v6[3]; // [esp+14h] [ebp-3Ch] BYREF
  void *v7[11]; // [esp+20h] [ebp-30h] BYREF
  int v8; // [esp+4Ch] [ebp-4h]

  v5 = *(_DWORD **)(*(_DWORD *)(a3 + 4) + 4 * (a4 & (*(_DWORD *)(a3 + 8) - 1)));
  v4 = *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4 * (a2 & (*(_DWORD *)(a1 + 8) - 1)));
  v6[0] = *(_DWORD *)v4;
  v6[1] = *(_DWORD *)(v4 + 4);
  v6[2] = *(_DWORD *)(v4 + 8);
  std::string::string(v4 + 12);
  v7[6] = *(void **)(v4 + 36);
  v8 = 0;
  sub_10004C4D((_DWORD *)v4, v5);
  sub_10004C4D(v5, v6);
  v8 = -1;
  sub_100035A2(v7, 1, 0);
}
// 1000304E: using guessed type _DWORD __stdcall std::string::string(_DWORD);

//----- (10004D6F) --------------------------------------------------------
int __cdecl sub_10004D6F(int a1, unsigned int a2, int a3, int a4, int a5, unsigned int a6)
{
  int result; // eax
  unsigned int v7; // ecx
  signed int v8; // esi
  int v9; // ebx
  int v10; // ecx
  int v11; // eax
  int v12; // et2
  int v13; // edx
  int *v14; // edi
  int v15; // ebx
  int v16; // edi
  unsigned int v17; // ebx
  int *v18; // edi
  _DWORD v19[2]; // [esp+14h] [ebp-3Ch] BYREF
  _DWORD v20[2]; // [esp+1Ch] [ebp-34h] BYREF
  _DWORD v21[2]; // [esp+24h] [ebp-2Ch] BYREF
  _DWORD v22[3]; // [esp+2Ch] [ebp-24h] BYREF
  unsigned int v23; // [esp+38h] [ebp-18h]
  int v24; // [esp+40h] [ebp-10h]
  unsigned int v25; // [esp+44h] [ebp-Ch]
  int v26; // [esp+48h] [ebp-8h]
  int v27; // [esp+4Ch] [ebp-4h]

  result = a6;
  v7 = a2;
  v8 = a4 - a2;
  v9 = a6 - a2;
  v27 = a6 - a2;
  if ( a2 > a6 )
    v27 = a6 - a2;
  if ( v8 )
  {
    v10 = a4 - a2;
    do
    {
      v11 = v9;
      v9 = v10;
      v12 = v11 % v10;
      result = v11 / v10;
      v10 = v12;
    }
    while ( v12 );
    v7 = a2;
    v27 = v9;
  }
  if ( v9 < (int)(a6 - a2) && v9 > 0 )
  {
    v13 = a1;
    do
    {
      v23 = v7 + v9;
      v26 = v13;
      v25 = v7 + v9;
      if ( v7 + v9 + v8 == a6 )
      {
        v22[0] = v13;
        v14 = v22;
        v22[1] = v7;
      }
      else
      {
        v21[1] = v7 + v9 + v8;
        v14 = v21;
        v24 = v7 + v9;
        v21[0] = v13;
      }
      v15 = *v14;
      v16 = v14[1];
      v24 = v15;
      do
      {
        sub_10004CF6(v26, v25, v15, v16);
        v7 = a2;
        v13 = a1;
        v26 = v15;
        v17 = a6 - v16;
        v25 = v16;
        if ( v8 >= (int)(a6 - v16) )
        {
          v19[0] = a1;
          result = a4 - v17;
          v18 = v19;
          v19[1] = a4 - v17;
        }
        else
        {
          result = v16 + v8;
          v20[0] = v24;
          v18 = v20;
          v20[1] = result;
        }
        v15 = *v18;
        v16 = v18[1];
        v24 = v15;
      }
      while ( v16 != v23 );
      v9 = v27 - 1;
      v27 = v9;
    }
    while ( v9 > 0 );
  }
  return result;
}

//----- (10004E65) --------------------------------------------------------
int __cdecl sub_10004E65(int a1, unsigned int a2, int a3, int a4, int a5, unsigned int a6)
{
  unsigned int v6; // ecx
  unsigned int v7; // edi
  int v8; // ebx
  int result; // eax
  int v10; // edi
  int v11; // edx
  int v12; // esi
  unsigned int v13; // eax
  int *v14; // edx
  int v15; // eax
  unsigned int v16; // edx
  int v17; // edi
  int v18; // esi
  int v19; // edx
  int v20; // edx
  int v21; // ecx
  int v22; // eax
  unsigned int v23; // edx
  int *v24; // edx
  int v25; // eax
  _DWORD v26[2]; // [esp+Ch] [ebp-44h] BYREF
  _DWORD v27[2]; // [esp+14h] [ebp-3Ch] BYREF
  _DWORD v28[2]; // [esp+1Ch] [ebp-34h] BYREF
  _DWORD v29[3]; // [esp+24h] [ebp-2Ch] BYREF
  unsigned int v30; // [esp+30h] [ebp-20h]
  unsigned int v31; // [esp+38h] [ebp-18h]
  int v32; // [esp+3Ch] [ebp-14h]
  int v33; // [esp+40h] [ebp-10h]
  int v34; // [esp+44h] [ebp-Ch]
  int v35; // [esp+48h] [ebp-8h]
  unsigned int v36; // [esp+4Ch] [ebp-4h]

  v6 = a2;
  v7 = a6;
  v8 = a4 - a2;
  v32 = a4 - a2;
  result = a6 - a2;
  v34 = a6 - a2;
  if ( a2 > a6 )
    v34 = a6 - a2;
  if ( v8 )
  {
    v10 = a4 - a2;
    do
    {
      v11 = result % v10;
      result = v10;
      v10 = v11;
    }
    while ( v11 );
    v7 = a6;
    v34 = result;
  }
  if ( result < (int)(a6 - a2) && result > 0 )
  {
    v12 = a1;
    do
    {
      v13 = v6 + result;
      v30 = v13;
      v33 = v12;
      v36 = v13;
      if ( v13 + v8 == v7 )
      {
        v29[0] = v12;
        v14 = v29;
        v29[1] = v6;
      }
      else
      {
        v28[1] = v13 + v8;
        v14 = v28;
        v31 = v13;
        v28[0] = v12;
      }
      v15 = *v14;
      v16 = v14[1];
      v35 = v15;
      v31 = v16;
      do
      {
        v17 = v16 & 3;
        v18 = *(_DWORD *)(*(_DWORD *)(v35 + 4) + 4 * ((v16 >> 2) & (*(_DWORD *)(v15 + 8) - 1)));
        v19 = (v36 >> 2) & (*(_DWORD *)(v33 + 8) - 1);
        v36 &= 3u;
        v20 = *(_DWORD *)(*(_DWORD *)(v33 + 4) + 4 * v19);
        v21 = *(_DWORD *)(v20 + 4 * v36);
        *(_DWORD *)(v20 + 4 * v36) = *(_DWORD *)(v18 + 4 * v17);
        v22 = v35;
        v8 = v32;
        *(_DWORD *)(v18 + 4 * v17) = v21;
        v7 = a6;
        v12 = a1;
        v33 = v22;
        v23 = a6 - v31;
        v36 = v31;
        v6 = a2;
        if ( v8 >= (int)(a6 - v31) )
        {
          v31 = a2;
          v26[0] = a1;
          v25 = v8 + a2 - v23;
          v24 = v26;
          v26[1] = v25;
        }
        else
        {
          v27[0] = v35;
          v24 = v27;
          v27[1] = v8 + v31;
        }
        v15 = *v24;
        v16 = v24[1];
        v35 = v15;
        v31 = v16;
      }
      while ( v16 != v30 );
      result = v34 - 1;
      v34 = result;
    }
    while ( result > 0 );
  }
  return result;
}

//----- (10004FA3) --------------------------------------------------------
char *__thiscall sub_10004FA3(char *this, char a2)
{
  return sub_10001C7A(this - 4, a2);
}

//----- (10004FAB) --------------------------------------------------------
bool __cdecl compileMode(bool a1)
{
  return a1;
}

//----- (10004FB3) --------------------------------------------------------
char **__cdecl argParseForward(int *a1, const char *a2, const char *a3)
{
  return argParse(a1, a2, a3);
}
// 10009198: using guessed type char **__cdecl argParse(int *, const char *, const char *);

//----- (10004FC3) --------------------------------------------------------
int __thiscall CSEH_CONSOLE::get_width(CSEH_CONSOLE *this)
{
  return UI::Rect::GetWidth((CSEH_CONSOLE *)((char *)this + 32));
}
// 10009190: using guessed type _DWORD __thiscall UI::Rect::GetWidth(UI::Rect *__hidden this);

//----- (10004FCC) --------------------------------------------------------
int __thiscall CSEH_CONSOLE::get_height(CSEH_CONSOLE *this)
{
  return UI::Rect::GetHeight((CSEH_CONSOLE *)((char *)this + 32));
}
// 1000918C: using guessed type _DWORD __thiscall UI::Rect::GetHeight(UI::Rect *__hidden this);

//----- (10004FD5) --------------------------------------------------------
int __thiscall CSEH_CONSOLE::get_restoration(CSEH_CONSOLE *this)
{
  return *((_DWORD *)this + 12);
}

//----- (10004FD9) --------------------------------------------------------
CSEH_CONSOLE *__thiscall CSEH_CONSOLE::CSEH_CONSOLE(CSEH_CONSOLE *this, const struct CSEH_CONSOLE *a2)
{
  UI::PixelRect::PixelRect(this, a2);
  UI::Rect::Rect((CSEH_CONSOLE *)((char *)this + 16), (const struct CSEH_CONSOLE *)((char *)a2 + 16));
  UI::Rect::Rect((CSEH_CONSOLE *)((char *)this + 32), (const struct CSEH_CONSOLE *)((char *)a2 + 32));
  *((_DWORD *)this + 12) = *((_DWORD *)a2 + 12);
  *((_WORD *)this + 26) = *((_WORD *)a2 + 26);
  *((_WORD *)this + 27) = *((_WORD *)a2 + 27);
  *((_DWORD *)this + 14) = *((_DWORD *)a2 + 14);
  *((_DWORD *)this + 15) = *((_DWORD *)a2 + 15);
  *((_DWORD *)this + 16) = *((_DWORD *)a2 + 16);
  *((_DWORD *)this + 17) = *((_DWORD *)a2 + 17);
  return this;
}
// 10009184: using guessed type _DWORD __thiscall UI::Rect::Rect(UI::Rect *__hidden this, const struct UI::Rect *);
// 10009188: using guessed type _DWORD __thiscall UI::PixelRect::PixelRect(UI::PixelRect *__hidden this, const struct UI::PixelRect *);

//----- (1000503A) --------------------------------------------------------
void *__thiscall CSEH_CONSOLE::operator=(void *this, const void *a2)
{
  void *result; // eax

  result = this;
  qmemcpy(this, a2, 0x48u);
  return result;
}

//----- (10005051) --------------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
int __cdecl main(int argc, const char **argv, const char **envp)
{
  CSEH_CONSOLE *v3; // ebx
  int v4; // edi
  CSEH_CONSOLE *v5; // eax
  int system; // esi
  _DWORD *v7; // ecx
  BOOL v8; // ebx
  _BYTE v10[84]; // [esp+14h] [ebp-B4h] BYREF
  char v11[92]; // [esp+68h] [ebp-60h] BYREF
  int v12; // [esp+C4h] [ebp-4h]

  v3 = 0;
  memset(v11, 0, 80);
  v4 = 1;
  v5 = (CSEH_CONSOLE *)operator new(0x48u);
  v12 = 0;
  if ( v5 )
    v3 = CSEH_CONSOLE::CSEH_CONSOLE(v5, 101, -1);
  v12 = -1;
  dword_1000FE1C = (__int16)UI::Rect::GetHeight((CSEH_CONSOLE *)((char *)v3 + 32));
  dword_100101E0 = dword_1000FE1C - 8;
  system = get_system(
             byte_10010D10,
             byte_10010CD4,
             byte_10010D34,
             Destination,
             byte_10010CE4,
             byte_10010CF0,
             byte_10010CC4,
             byte_10010BC0,
             byte_10010AB8,
             byte_100109B0,
             byte_100108A8,
             byte_100107A0);
  CBANNER_SWAP::CBANNER_SWAP((CBANNER_SWAP *)v10, aPolicyLocation, aPy59b1F);
  v12 = 1;
  if ( !system )
  {
    fill_security((struct security_def *)&unk_1000FBB0, byte_10010CC4);
    AGENT_ACCESS::build_access_list(
      (AGENT_ACCESS *)&unk_10010D98,
      byte_10010D10,
      byte_100108A8,
      (struct security_def *)&unk_1000FBB0);
    if ( !sub_100052F6()
      && !get_ctl_rec(3001, 0, byte_100108A8, byte_10010274, 50, 0)
      && !get_ctl_rec(99310, 2, byte_100108A8, v11, 1, 0) )
    {
      if ( v11[0] == 77 )
      {
        dword_1000F138 = 1;
        LODWORD(xmmword_1000F240) = 1;
        dword_1000F298 = 1;
        LODWORD(xmmword_1000F2F0) = 1;
        dword_1000F348 = 1;
        LODWORD(xmmword_1000F3A0) = 1;
        dword_1000F3F8 = 1;
        dword_1000F4A8 = 1;
      }
      if ( !get_street_defaults(Str2, Str, byte_100108A8) )
      {
        seh_banner2(byte_10010274, aPolicyLocation, aPy59b1F, byte_10010CD4, 2, 99);
        if ( !sub_10006C52((void *)0xC) )
          v4 = 0;
        sub_10005388((void *)v4);
      }
    }
    close_db((struct _POSBLOCK *)dword_10010588, 0, 0);
    close_db((struct _POSBLOCK *)dword_100103A0, 0, 0);
  }
  if ( dword_1000F024 )
  {
    v7 = (_DWORD *)rec_number;
  }
  else
  {
    memset(Destination, 0, 0xFu);
    strncpy(Destination, &Source, 0xAu);
    v7 = (_DWORD *)rec_number;
    rec_number = dword_1000FE20;
  }
  put_system(
    byte_10010D10,
    byte_10010CD4,
    byte_10010D34,
    Destination,
    sys_num,
    *v7,
    byte_10010CC4,
    byte_10010BC0,
    byte_10010AB8,
    byte_100109B0,
    byte_100108A8,
    byte_100107A0);
  if ( v3 )
  {
    CSEH_CONSOLE::~CSEH_CONSOLE(v3);
    operator delete(v3);
  }
  v8 = dword_1000F024 != 0;
  v12 = -1;
  CBANNER_SWAP::~CBANNER_SWAP((CBANNER_SWAP *)v10);
  return v8;
}
// 10005275: write access to const memory at 10009160 has been detected
// 10009064: using guessed type void *__cdecl operator new(unsigned int);
// 1000906C: using guessed type void __cdecl operator delete(void *);
// 100090E0: using guessed type _DWORD __cdecl close_db(struct _POSBLOCK *, bool, bool);
// 10009154: using guessed type void __thiscall CSEH_CONSOLE::~CSEH_CONSOLE(CSEH_CONSOLE *__hidden this);
// 10009158: using guessed type int sys_num;
// 1000915C: using guessed type _DWORD __cdecl put_system(const char *, const char *, const char *, const char *, _DWORD, _DWORD, const char *, const char *, const char *, const char *, const char *, const char *);
// 10009160: using guessed type int rec_number;
// 10009164: using guessed type void __cdecl seh_banner2(const char *, const char *, const char *, const char *, _DWORD, _DWORD);
// 10009168: using guessed type _DWORD __cdecl get_ctl_rec(_DWORD, _DWORD, const char *, char *, _DWORD, _DWORD);
// 1000916C: using guessed type void __cdecl fill_security(struct security_def *, const char *);
// 10009170: using guessed type void __thiscall CBANNER_SWAP::~CBANNER_SWAP(CBANNER_SWAP *__hidden this);
// 10009174: using guessed type CBANNER_SWAP *__thiscall CBANNER_SWAP::CBANNER_SWAP(CBANNER_SWAP *__hidden this, char *, char *);
// 10009178: using guessed type _DWORD __cdecl get_system(char *, char *, char *, char *, char *, char *, char *, char *, char *, char *, char *, char *);
// 1000917C: using guessed type CSEH_CONSOLE *__thiscall CSEH_CONSOLE::CSEH_CONSOLE(CSEH_CONSOLE *__hidden this, __int16, __int16);
// 1000918C: using guessed type _DWORD __thiscall UI::Rect::GetHeight(UI::Rect *__hidden this);
// 1000924C: using guessed type _DWORD __cdecl get_street_defaults(char *, char *, char *);
// 10009250: using guessed type _DWORD __thiscall AGENT_ACCESS::build_access_list(AGENT_ACCESS *__hidden this, const char *, const char *, struct security_def *);
// 1000F024: using guessed type int dword_1000F024;
// 1000F138: using guessed type int dword_1000F138;
// 1000F240: using guessed type __int128 xmmword_1000F240;
// 1000F298: using guessed type int dword_1000F298;
// 1000F2F0: using guessed type __int128 xmmword_1000F2F0;
// 1000F348: using guessed type int dword_1000F348;
// 1000F3A0: using guessed type __int128 xmmword_1000F3A0;
// 1000F3F8: using guessed type int dword_1000F3F8;
// 1000F4A8: using guessed type int dword_1000F4A8;
// 1000FE1C: using guessed type int dword_1000FE1C;
// 1000FE20: using guessed type int dword_1000FE20;
// 100101E0: using guessed type int dword_100101E0;
// 100103A0: using guessed type int dword_100103A0;
// 10010588: using guessed type int dword_10010588;

//----- (100052F6) --------------------------------------------------------
int sub_100052F6()
{
  int v0; // eax
  int v1; // esi
  int v2; // eax
  void *v4[6]; // [esp+10h] [ebp-40h] BYREF
  void *v5[9]; // [esp+28h] [ebp-28h] BYREF
  int v6; // [esp+4Ch] [ebp-4h]

  sub_10003074((char *)v5, py_13_name);
  v6 = 0;
  v0 = open_db(&dword_100103A0, v5, &unk_100108A8, 0);
  v6 = -1;
  v1 = v0;
  sub_100035A2(v5, 1, 0);
  if ( !v1 )
  {
    sub_10003074((char *)v4, py_1_name);
    v6 = 1;
    v2 = open_db(&dword_10010588, v4, &unk_100108A8, 0);
    v6 = -1;
    v1 = v2;
    sub_100035A2(v4, 1, 0);
  }
  return v1;
}
// 10009150: using guessed type int __cdecl open_db(_DWORD, _DWORD, _DWORD, _DWORD);
// 100103A0: using guessed type int dword_100103A0;
// 10010588: using guessed type int dword_10010588;

//----- (10005388) --------------------------------------------------------
int __thiscall sub_10005388(void *this)
{
  int result; // eax
  int v3; // edx
  char *v4[8]; // [esp+10h] [ebp-24h] BYREF

  v4[0] = " 0 - location display";
  v4[1] = " 1 - postal code";
  v4[2] = " 2 - zip code";
  v4[3] = " 3 - city";
  v4[4] = " 4 - city & street";
  v4[5] = " 5 - county & township & concession & lot";
  v4[6] = " 6 - record number";
  v4[7] = 0;
  do
  {
    fn_keys(14);
    clear_keys(&dword_10010690);
    set_std_keys(&dword_10010690);
    do_status("Change Inquiry", 0, 0, 0, 0);
    result = scroll_list(v4, "Inquiry Key Options", &dword_1000FBC4, 0, 0);
    if ( result )
      break;
    if ( dword_1000FBC4 )
    {
      v3 = 10;
      if ( dword_1000FBC4 != 5 )
        v3 = 8;
    }
    else
    {
      v3 = 9;
    }
    dword_1000F020 = v3;
    dword_1000FE18 = dword_100101E0 - v3 + 1;
    if ( dword_1000FBC4 <= 0 )
    {
LABEL_19:
      dword_1000F028 = 2;
      goto LABEL_20;
    }
    if ( dword_1000FBC4 <= 2 )
    {
      dword_1000F028 = 4;
    }
    else
    {
      switch ( dword_1000FBC4 )
      {
        case 3:
          dword_1000F028 = 5;
          break;
        case 4:
          dword_1000F028 = 6;
          break;
        case 5:
          dword_1000F028 = 7;
          break;
        case 6:
          dword_1000F028 = 1;
          break;
        default:
          goto LABEL_19;
      }
    }
LABEL_20:
    sub_1000751E();
    if ( !this )
      sub_10006F21();
    result = sub_100054F1();
    if ( result == 444 )
    {
      result = 0;
      if ( Source )
        this = 0;
    }
  }
  while ( !result );
  return result;
}
// 100090E4: using guessed type void __cdecl fn_keys(_DWORD);
// 100090E8: using guessed type void __cdecl clear_keys(int *);
// 100090EC: using guessed type void __cdecl set_std_keys(int *);
// 100090F0: using guessed type void __cdecl do_status(const char *, _DWORD, _DWORD, _DWORD, _DWORD);
// 100090F4: using guessed type _DWORD __cdecl scroll_list(char **const, const char *, int *, _DWORD, _DWORD);
// 1000F020: using guessed type int dword_1000F020;
// 1000F028: using guessed type int dword_1000F028;
// 1000FBC4: using guessed type int dword_1000FBC4;
// 1000FE18: using guessed type int dword_1000FE18;
// 100101E0: using guessed type int dword_100101E0;
// 10010690: using guessed type int dword_10010690;

//----- (100054F1) --------------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
int sub_100054F1()
{
  int v0; // ecx
  int v1; // esi
  int v2; // esi
  int v3; // edi
  int v4; // ebx
  int v5; // eax
  struct io_field *v6; // esi
  int v7; // eax
  int v8; // eax
  int v9; // ecx
  int v10; // eax
  int v11; // edi
  int j; // esi
  int v13; // edi
  int i; // esi
  const char *v16; // [esp-10h] [ebp-94h]
  char *v17; // [esp+8h] [ebp-7Ch]
  char *v18; // [esp+Ch] [ebp-78h]
  int v19; // [esp+10h] [ebp-74h]
  int v20; // [esp+14h] [ebp-70h]
  int v21; // [esp+18h] [ebp-6Ch]
  int v22; // [esp+1Ch] [ebp-68h]
  int v23; // [esp+20h] [ebp-64h]
  int v24; // [esp+24h] [ebp-60h]
  int v25; // [esp+28h] [ebp-5Ch]
  char *v26; // [esp+2Ch] [ebp-58h] BYREF
  _WORD v27[40]; // [esp+30h] [ebp-54h] BYREF

  memset(v27, 0, sizeof(v27));
  v24 = 0;
  v0 = 0;
  v19 = 0;
  v18 = (char *)dword_1000F020;
  v26 = (char *)dword_1000F020;
  v21 = 0;
  v17 = (char *)dword_100101E0;
  v22 = 1;
  v23 = 0;
  v20 = 1;
  if ( dword_1000FBC4 )
  {
    switch ( dword_1000FBC4 )
    {
      case 1:
        v0 = 1;
        v24 = 1;
        break;
      case 2:
        v0 = 2;
        v24 = 2;
        break;
      case 3:
        v0 = 3;
        v24 = 3;
        break;
      case 4:
        v0 = 3;
        v24 = 4;
        break;
      case 5:
        v0 = 5;
        v24 = 8;
        break;
      case 6:
        v0 = 9;
        v24 = 9;
        break;
      default:
        goto LABEL_16;
    }
  }
  else
  {
    v0 = 0;
    v24 = 0;
  }
  v23 = v0;
LABEL_16:
  v25 = v0;
  v1 = sub_10006C52((void *)9);
  if ( v1 )
    v1 = sub_10006C52((void *)0xA);
  sub_10005CD2(dword_1000FBC4, 0);
  if ( !v1 )
  {
LABEL_19:
    v2 = v21;
    while ( 1 )
    {
      while ( 1 )
      {
        do_status("Search mode", 0, 0, 0, 0);
        fn_keys(14);
        clear_keys(&dword_10010690);
        set_std_keys(&dword_10010690);
        dword_10010694 = 1;
        dword_100106A0 = 1;
        v3 = 1;
        dword_10010738 = 1;
        v4 = 1;
        dword_1001073C = 1;
        if ( v26 == v18 )
        {
          if ( sub_10006C52((void *)7) )
            v4 = 0;
          else
            sub_10006C52((void *)6);
        }
        if ( v26 == v17 )
        {
          if ( sub_10006C52((void *)6) )
            v3 = 0;
          else
            sub_10006C52((void *)7);
        }
        else
        {
          read_screen_text(v26 + 1, 3, 1, (char *)v27);
          if ( LOBYTE(v27[0]) == 32 )
            v3 = 0;
        }
        fn_do_keys("Select policy", 1, v22 == 0);
        dword_100106B4 = 1;
        if ( v20 == 1 )
        {
          fn_do_keys("Change Inquiry", 4, 1);
          dword_100106C0 = 1;
          if ( dword_1000FBC4 )
            fn_do_keys("text search", 5, 0);
          else
            fn_do_keys("text search", 5, 1);
          v16 = "Exit";
        }
        else
        {
          if ( v4 == 1 )
            fn_do_keys("search backwards", 5, 1);
          else
            fn_do_keys("search backwards", 5, 0);
          fn_do_keys("search forward ", 6, v3 == 1);
          dword_100106C8 = 1;
          v16 = "Exit text search";
        }
        dword_100106C4 = 1;
        fn_do_keys(v16, 8, 1);
        v5 = v20;
        dword_100106B0 = 1;
        dword_100106D0 = 1;
        if ( !v20 )
        {
          fn_do_keys("F9 - Help", 9, 1);
          dword_100106D4 = 1;
          io_strx((struct io_field *)&off_1000F4A0, 0);
          v2 = io_str((struct io_field *)&off_1000F4A0, &dword_10010690);
          v21 = v2;
          io_strx((struct io_field *)&off_1000F4A0, 1);
          out_str((struct io_field *)&off_1000F4A0, 1);
          v5 = 0;
        }
        if ( v5 == 1 )
        {
          v6 = (struct io_field *)(&off_1000F130 + 22 * v25);
          io_strx(v6, 0);
          if ( v19 )
          {
            v21 = io_str(v6, &dword_10010690);
          }
          else
          {
            if ( sub_10005F15((void **)&v26, 0) > 0 )
            {
              v22 = 0;
              sub_100063ED((int)v26, 0);
            }
            v19 = 1;
          }
          io_strx(v6, 1);
          out_str(v6, 1);
          v2 = v21;
        }
        fn_keys(14);
        if ( v2 > 1066 )
          break;
        if ( v2 == 1066 )
          goto LABEL_122;
        if ( v2 > 1059 )
        {
          switch ( v2 )
          {
            case 1062:
              return 444;
            case 1063:
              if ( v20 == 1 )
              {
                if ( dword_1000FBC4 )
                {
                  v9 = 2;
LABEL_73:
                  sub_10006EBC(v9, " ");
                }
                else
                {
                  sub_10005CD2(99, 1);
                  v20 = 0;
                }
              }
              else
              {
                if ( v4 )
                {
                  v10 = sub_10006048((void **)&v26, 2);
                  goto LABEL_142;
                }
LABEL_80:
                disp_error(0, "Top of File reached!", 0, 16, 0);
              }
              break;
            case 1064:
              if ( !v3 )
                goto LABEL_72;
              v10 = sub_10006048((void **)&v26, 3);
LABEL_142:
              if ( v10 > 0 )
              {
                v22 = 0;
                sub_100063ED((int)v26, 0);
              }
              break;
          }
        }
        else
        {
          switch ( v2 )
          {
            case 1059:
              if ( !v22 )
              {
                dword_1000F024 = 0;
                v1 = 111;
                sys_num = 20;
                return v1;
              }
              break;
            case 9:
LABEL_64:
              if ( ++v25 > v24 )
              {
                v7 = v23;
LABEL_58:
                v25 = v7;
              }
              break;
            case 13:
              if ( v20 == 1 )
                v8 = sub_10005F15((void **)&v26, (void *)v19);
              else
                v8 = sub_10006048((void **)&v26, 4);
              if ( v8 > 0 )
              {
                v22 = 0;
                sub_100063ED((int)v26, 0);
              }
              goto LABEL_64;
            case 27:
              goto LABEL_122;
            default:
              if ( v2 == 1015 && --v25 < v23 )
              {
                v7 = v24;
                goto LABEL_58;
              }
              break;
          }
        }
      }
      if ( v2 > 1081 )
      {
        switch ( v2 )
        {
          case 1118:
            if ( !v3 )
            {
LABEL_72:
              v9 = 1;
              goto LABEL_73;
            }
            v26 = v18;
            if ( dword_1000FBC4 )
            {
              switch ( dword_1000FBC4 )
              {
                case 1:
                  strcpy(byte_1001026C, "Z9Z 9Z9");
                  break;
                case 2:
                  memset(byte_10010214, 255, sizeof(byte_10010214));
                  byte_1001021E = 0;
                  break;
                case 3:
                  memset(byte_10010380, 255, sizeof(byte_10010380));
                  byte_10010399 = 0;
                  break;
                case 4:
                  memset(byte_10010380, 255, sizeof(byte_10010380));
                  byte_10010399 = 0;
                  memset(byte_10010240, 255, sizeof(byte_10010240));
                  byte_1001024F = 0;
                  break;
                case 5:
                  memset(byte_10010340, 255, sizeof(byte_10010340));
                  byte_1001035A = 0;
                  memset(byte_10010220, 255, sizeof(byte_10010220));
                  byte_1001023A = 0;
                  memset(byte_10010360, 255, sizeof(byte_10010360));
                  byte_1001037A = 0;
                  memset(byte_100102C0, 255, sizeof(byte_100102C0));
                  byte_100102DA = 0;
                  break;
                case 6:
                  strcpy(String, "99999999");
                  break;
              }
            }
            else
            {
              memset(byte_100102E0, 255, sizeof(byte_100102E0));
              byte_10010326 = 0;
            }
            goto LABEL_141;
          case 1132:
            if ( v4 )
            {
              v26 = v18;
              *(_BYTE *)*(&off_1000F130 + 22 * v25) = 0;
LABEL_141:
              v10 = sub_10005F15((void **)&v26, (void *)v19);
              goto LABEL_142;
            }
            goto LABEL_80;
          case 9999:
LABEL_122:
            if ( v20 )
              return 999;
            sub_10005CD2(dword_1000FBC4, 1);
            v20 = 1;
            break;
        }
      }
      else
      {
        switch ( v2 )
        {
          case 1081:
            if ( !v3 )
              goto LABEL_72;
            v13 = 0;
            while ( (int)v26 > (int)v18 )
            {
              ++v13;
              sub_10006D82((void **)&v26);
            }
            for ( i = 1; i <= 2 * dword_1000FE18 - 2; ++i )
            {
              update_time();
              if ( sub_10006E25((void **)&v26) )
                break;
            }
            while ( (int)v26 > (int)v18 )
              sub_10006D82((void **)&v26);
            v2 = v21;
            if ( v13 > 0 )
            {
              do
              {
                --v13;
                sub_10006E25((void **)&v26);
              }
              while ( v13 > 0 );
              goto LABEL_19;
            }
            break;
          case 1067:
            do_help(aPy59b000, byte_100109B0, byte_100109B0);
            break;
          case 1072:
            if ( !v4 )
              goto LABEL_80;
            sub_10006D82((void **)&v26);
            break;
          case 1073:
            if ( !v4 )
              goto LABEL_80;
            v11 = 0;
            while ( (int)v26 > (int)v18 )
            {
              ++v11;
              sub_10006D82((void **)&v26);
            }
            for ( j = 1; j <= dword_1000FE18 - 1; ++j )
            {
              update_time();
              if ( sub_10006D82((void **)&v26) )
                break;
            }
            while ( (int)v26 > (int)v18 )
              sub_10006D82((void **)&v26);
            v2 = v21;
            if ( v11 > 0 )
            {
              do
              {
                --v11;
                sub_10006E25((void **)&v26);
              }
              while ( v11 > 0 );
              goto LABEL_19;
            }
            break;
          case 1080:
            if ( !v3 )
              goto LABEL_72;
            sub_10006E25((void **)&v26);
            break;
        }
      }
    }
  }
  return v1;
}
// 100058FA: write access to const memory at 10009158 has been detected
// 100090E4: using guessed type void __cdecl fn_keys(_DWORD);
// 100090E8: using guessed type void __cdecl clear_keys(int *);
// 100090EC: using guessed type void __cdecl set_std_keys(int *);
// 100090F0: using guessed type void __cdecl do_status(const char *, _DWORD, _DWORD, _DWORD, _DWORD);
// 100090F8: using guessed type void __cdecl read_screen_text(_DWORD, _DWORD, _DWORD, char *);
// 100090FC: using guessed type void __cdecl fn_do_keys(const char *, _DWORD, _DWORD);
// 10009100: using guessed type void __cdecl io_strx(struct io_field *, _DWORD);
// 10009104: using guessed type _DWORD __cdecl io_str(struct io_field *, int *);
// 10009108: using guessed type void __cdecl out_str(struct io_field *, _DWORD);
// 1000910C: using guessed type void __cdecl update_time();
// 10009110: using guessed type void __cdecl do_help(const char *, char *, char *);
// 10009144: using guessed type void __cdecl disp_error(_DWORD, const char *, _DWORD, _DWORD, _DWORD);
// 10009158: using guessed type int sys_num;
// 1000F020: using guessed type int dword_1000F020;
// 1000F024: using guessed type int dword_1000F024;
// 1000F130: using guessed type char (*off_1000F130)[70];
// 1000F4A0: using guessed type char (*off_1000F4A0)[16];
// 1000FBC4: using guessed type int dword_1000FBC4;
// 1000FE18: using guessed type int dword_1000FE18;
// 100101E0: using guessed type int dword_100101E0;
// 1001021E: using guessed type char byte_1001021E;
// 1001023A: using guessed type char byte_1001023A;
// 1001024F: using guessed type char byte_1001024F;
// 100102DA: using guessed type char byte_100102DA;
// 10010326: using guessed type char byte_10010326;
// 1001035A: using guessed type char byte_1001035A;
// 1001037A: using guessed type char byte_1001037A;
// 10010399: using guessed type char byte_10010399;
// 10010690: using guessed type int dword_10010690;
// 10010694: using guessed type int dword_10010694;
// 100106A0: using guessed type int dword_100106A0;
// 100106B0: using guessed type int dword_100106B0;
// 100106B4: using guessed type int dword_100106B4;
// 100106C0: using guessed type int dword_100106C0;
// 100106C4: using guessed type int dword_100106C4;
// 100106C8: using guessed type int dword_100106C8;
// 100106D0: using guessed type int dword_100106D0;
// 100106D4: using guessed type int dword_100106D4;
// 10010738: using guessed type int dword_10010738;
// 1001073C: using guessed type int dword_1001073C;

//----- (10005CD2) --------------------------------------------------------
void __fastcall sub_10005CD2(int a1, int a2)
{
  int v3; // esi
  int v4; // esi
  int v5; // esi
  int v6; // esi

  fn_keys(14);
  clx(1, 5, 80, dword_1000F020 - 3, 0);
  if ( a1 > 4 )
  {
    v5 = a1 - 5;
    if ( v5 )
    {
      v6 = v5 - 1;
      if ( v6 )
      {
        if ( v6 == 93 )
        {
          clx(2, 5, 79, 6, 7);
          disptext2(5, 2, " Search key: location display           enter search string:", 7, 112);
        }
      }
      else
      {
        clx(2, 5, 79, 5, 7);
        disptext2(5, 2, " Search key: record number", 7, 112);
      }
    }
    else
    {
      clx(2, 5, 79, 7, 7);
      disptext2(5, 2, " Search key: county & township & concession & lot", 7, 112);
      disptext2(6, 2, " county:                               township:", 7, 112);
      disptext2(7, 2, "   conc:                                    lot:", 7, 112);
    }
  }
  else if ( a1 == 4 )
  {
    clx(2, 5, 79, 5, 7);
    disptext2(5, 2, " Search key: city                                 street", 7, 112);
  }
  else if ( a1 )
  {
    v3 = a1 - 1;
    if ( v3 )
    {
      v4 = v3 - 1;
      if ( v4 )
      {
        if ( v4 == 1 )
        {
          clx(2, 5, 79, 5, 7);
          disptext2(5, 2, " Search key: city", 7, 112);
        }
      }
      else
      {
        clx(2, 5, 79, 5, 7);
        disptext2(5, 2, " Search key: zip code", 7, 112);
      }
    }
    else
    {
      clx(2, 5, 79, 5, 7);
      disptext2(5, 2, " Search key: postal code", 7, 112);
    }
  }
  else
  {
    clx(2, 5, 79, 6, 7);
    disptext2(5, 2, " Search key: location display", 7, 112);
  }
  if ( !a2 )
  {
    box(0, dword_1000F020 - 2, 1, dword_100101E0 + 1, 62, 7, 11, 0);
    box(0, dword_1000F020 - 2, 62, dword_100101E0 + 1, 80, 7, 11, 48);
    box(0, dword_100101E0 + 1, 1, dword_1000FE1C, 80, 7, 11, 0);
    disptext(dword_1000F020 - 2, 62, byte_100097BC, 1, 7, 11);
    disptext(dword_100101E0 + 1, 1, byte_100097C0, 1, 7, 11);
    disptext(dword_100101E0 + 1, 62, byte_100097C4, 1, 7, 11);
    disptext(dword_100101E0 + 1, 80, byte_100097C8, 1, 7, 11);
    disptext2(dword_1000F020 - 1, 2, " policy   st effective    no.     display name              ", 7, 30);
    disptext2(dword_1000F020 - 1, 63, "    search key   ", 7, 30);
  }
}
// 100090E4: using guessed type void __cdecl fn_keys(_DWORD);
// 10009118: using guessed type void __cdecl disptext2(_DWORD, _DWORD, const char *, _DWORD, _DWORD);
// 1000911C: using guessed type void __cdecl box(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10009120: using guessed type void __cdecl disptext(_DWORD, _DWORD, const char *, _DWORD, _DWORD, _DWORD);
// 10009234: using guessed type void __cdecl clx(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1000F020: using guessed type int dword_1000F020;
// 1000FE1C: using guessed type int dword_1000FE1C;
// 100101E0: using guessed type int dword_100101E0;

//----- (10005F15) --------------------------------------------------------
int __fastcall sub_10005F15(void **a1, void *a2)
{
  int v2; // ebx
  void *v4; // ecx
  void *v5; // esi
  int v6; // eax
  int v7; // esi
  int v9; // [esp+Ch] [ebp-64h]
  int v11; // [esp+14h] [ebp-5Ch]
  int v12; // [esp+18h] [ebp-58h]
  _WORD v13[40]; // [esp+1Ch] [ebp-54h] BYREF

  memset(v13, 0, sizeof(v13));
  v2 = 0;
  v9 = dword_100101E0;
  v11 = 1;
  v12 = dword_1000F020;
  do_status("Display Locations", 1, 0, 0, 0);
  update_time();
  clx(2, dword_1000F020, 61, dword_100101E0, 0);
  clx(63, dword_1000F020, 79, dword_100101E0, 3);
  *a1 = (void *)dword_1000F020;
  memset(v13, 0, sizeof(v13));
  sub_10007037(a2);
  update_time();
  if ( sub_10006C52((void *)0xA) )
  {
    sub_10007037(a2);
    update_time();
    if ( sub_10006C52((void *)9) )
      goto LABEL_9;
  }
  else
  {
    v11 = 0;
  }
  sub_100064B3(*a1);
  v4 = *a1;
  v5 = (void *)v9;
  do
  {
    if ( (int)v4 > (int)v5 )
      break;
    ++v2;
    update_time();
    v6 = sub_10006E25(a1);
    v4 = *a1;
    if ( *a1 == v5 )
      v5 = 0;
  }
  while ( !v6 );
LABEL_9:
  update_time();
  v7 = v12;
  if ( !v11 )
    v7 = v12 + 1;
  while ( (int)*a1 > v7 )
    sub_10006D82(a1);
  return v2;
}
// 100090F0: using guessed type void __cdecl do_status(const char *, _DWORD, _DWORD, _DWORD, _DWORD);
// 1000910C: using guessed type void __cdecl update_time();
// 10009234: using guessed type void __cdecl clx(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1000F020: using guessed type int dword_1000F020;
// 100101E0: using guessed type int dword_100101E0;

//----- (10006048) --------------------------------------------------------
int __fastcall sub_10006048(void **a1, int a2)
{
  int v3; // edi
  int v4; // esi
  int v5; // eax
  void *v6; // ecx
  void *v7; // esi
  int v8; // eax
  int v10; // [esp+10h] [ebp-C0h]
  int v11; // [esp+14h] [ebp-BCh]
  int v12; // [esp+18h] [ebp-B8h]
  int v13; // [esp+1Ch] [ebp-B4h]
  int v15; // [esp+24h] [ebp-ACh]
  int v16; // [esp+28h] [ebp-A8h]
  char Buffer[2]; // [esp+2Ch] [ebp-A4h] BYREF
  char v18[78]; // [esp+2Eh] [ebp-A2h] BYREF
  char String[2]; // [esp+7Ch] [ebp-54h] BYREF
  _BYTE v20[78]; // [esp+7Eh] [ebp-52h] BYREF

  *(_WORD *)Buffer = 0;
  memset(v18, 0, sizeof(v18));
  *(_WORD *)String = 0;
  memset(v20, 0, sizeof(v20));
  v10 = dword_100101E0;
  v15 = 0;
  v16 = 1;
  v11 = dword_1000F020;
  v12 = 0;
  do_status("Searching", 11, 0, 0, 0);
  update_time();
  qmemcpy(&unk_1000FBC8, &dword_1000FE20, 0x250u);
  v3 = 0;
  clx(2, dword_1000F020, 61, dword_100101E0, 0);
  clx(63, dword_1000F020, 79, dword_100101E0, 3);
  *a1 = (void *)dword_1000F020;
  v13 = (a2 != 3) + 6;
  sprintf(Buffer, "%.15s", byte_10010250);
  strupr(Buffer);
  update_time();
  if ( a2 != 4 )
  {
    v4 = 0;
LABEL_9:
    fn_do_keys("abandon search", 8, 1);
    disptext2(11, 15, "records searched:", 7, 10);
    do
    {
      if ( v4 )
        break;
      update_time();
      v4 = sub_10006C52((void *)v13);
      sprintf(String, "%.70s", byte_1000FE4C);
      trim_str(String, 3);
      strupr(String);
      if ( strstr(String, Buffer) )
      {
        v16 = 0;
        sub_100064B3(*a1);
      }
      v5 = v15++;
      if ( v5 == 3 && !v4 )
      {
        update_time();
        v15 = 0;
        if ( !get_exit_key() )
          v4 = 999;
      }
      sprintf(String, "%ld", ++v12);
      disptext2(11, 34, String, 7, 14);
    }
    while ( v16 == 1 );
    goto LABEL_18;
  }
  v4 = sub_10006C52((void *)0xC);
  if ( !v4 )
  {
    sprintf(String, "%.70s", byte_1000FE4C);
    trim_str(String, 3);
    strupr(String);
  }
  if ( strstr(String, Buffer) )
  {
    v16 = 0;
    sub_100064B3(*a1);
    goto LABEL_18;
  }
  v13 = 6;
  if ( !v4 )
    goto LABEL_9;
LABEL_18:
  disptext2(11, 15, "                                   ", 7, 10);
  fn_keys(14);
  if ( v16 == 1 )
  {
    qmemcpy(&dword_1000FE20, &unk_1000FBC8, 0x250u);
    sub_100064B3(*a1);
    strncpy(byte_100103C0, byte_1000FE4C, 0x46u);
    strncpy(byte_10010406, &Source, 0xAu);
    dword_10010410 = dword_1000FE2E;
    dword_10010414 = dword_1000FE38;
    v4 = sub_10006C52((void *)5);
    if ( a2 == 2 )
      sub_10006EBC(3, Buffer);
    else
      sub_10006EBC(4, Buffer);
    v3 = 0;
  }
  if ( !v4 )
  {
    v6 = *a1;
    v7 = (void *)v10;
    do
    {
      if ( (int)v6 > (int)v7 )
        break;
      ++v3;
      update_time();
      v8 = sub_10006E25(a1);
      v6 = *a1;
      if ( *a1 == v7 )
        v7 = 0;
    }
    while ( !v8 );
  }
  update_time();
  while ( (int)*a1 > v11 )
    sub_10006D82(a1);
  return v3;
}
// 100090E4: using guessed type void __cdecl fn_keys(_DWORD);
// 100090F0: using guessed type void __cdecl do_status(const char *, _DWORD, _DWORD, _DWORD, _DWORD);
// 100090FC: using guessed type void __cdecl fn_do_keys(const char *, _DWORD, _DWORD);
// 1000910C: using guessed type void __cdecl update_time();
// 10009118: using guessed type void __cdecl disptext2(_DWORD, _DWORD, const char *, _DWORD, _DWORD);
// 10009124: using guessed type void __cdecl trim_str(char *, _DWORD);
// 10009128: using guessed type int __cdecl get_exit_key();
// 10009234: using guessed type void __cdecl clx(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1000F020: using guessed type int dword_1000F020;
// 1000FE20: using guessed type int dword_1000FE20;
// 1000FE2E: using guessed type int dword_1000FE2E;
// 1000FE38: using guessed type int dword_1000FE38;
// 100101E0: using guessed type int dword_100101E0;
// 10010410: using guessed type int dword_10010410;
// 10010414: using guessed type int dword_10010414;

//----- (100063ED) --------------------------------------------------------
void __fastcall sub_100063ED(int a1, int a2)
{
  int v3; // eax
  _WORD v4[40]; // [esp+Ch] [ebp-54h] BYREF

  memset(v4, 0, sizeof(v4));
  if ( a2 )
  {
    read_screen_text(a1, 1, 12, (char *)v4);
    v3 = sub_10006AF8(SHIBYTE(v4[3]));
    disp_att(a1, 2, 10, v3);
    if ( HIBYTE(v4[5]) == 67 )
      disp_att(a1, 12, 3, 12);
    else
      disp_att(a1, 12, 3, 3);
    disp_att(a1, 15, 11, 3);
    disp_att(a1, 26, 7, 15);
    disp_att(a1, 33, 29, 7);
    disp_att(a1, 63, 17, 48);
  }
  else
  {
    disp_att(a1, 2, 60, 224);
    disp_att(a1, 63, 17, 224);
  }
}
// 100090F8: using guessed type void __cdecl read_screen_text(_DWORD, _DWORD, _DWORD, char *);
// 1000912C: using guessed type void __cdecl disp_att(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (100064B3) --------------------------------------------------------
void __thiscall sub_100064B3(void *this)
{
  int v1; // eax
  int v2; // esi
  int v3; // [esp+Ch] [ebp-84h]
  char Destination[38]; // [esp+14h] [ebp-7Ch] BYREF
  __int16 v6; // [esp+3Ah] [ebp-56h]
  char Buffer[2]; // [esp+3Ch] [ebp-54h] BYREF
  _BYTE v8[78]; // [esp+3Eh] [ebp-52h] BYREF

  memset(Destination, 0, sizeof(Destination));
  v6 = 0;
  *(_WORD *)Buffer = 0;
  memset(v8, 0, sizeof(v8));
  clx(2, this, 61, this, 0);
  clx(63, this, 79, this, 3);
  v3 = sub_10006AF8(byte_100100D2);
  disptext(this, 3, &Source, 8, 7, 15);
  if ( byte_100100D8 == 67 )
    disptext(this, 12, &byte_100100D8, 1, 7, 12);
  else
    disptext(this, 12, &byte_100100D8, 1, 7, 3);
  date_to_str(dword_1000FE34, 0, Buffer, 4);
  disptext(this, 15, Buffer, 11, 7, 3);
  sprintf(Buffer, "%3d.%-3d", word_1000FE38, word_1000FE3A);
  disptext(this, 26, Buffer, 7, 7, 15);
  disptext(this, 33, byte_1000FE4C, 29, 7, 7);
  clx(2, dword_100101E0 + 2, 79, dword_1000FE1C - 1, 0);
  clx(5, dword_100101E0 + 4, 76, dword_100101E0 + 5, 7);
  disptext2(dword_100101E0 + 2, 6, "policy", 7, v3);
  sprintf(Buffer, "%.10s", byte_10010074);
  disptext2(dword_100101E0 + 2, 13, Buffer, 7, 15);
  sprintf(Buffer, "%.36s", byte_100100FE);
  disptext2(dword_100101E0 + 2, 24, Buffer, 7, 15);
  v1 = sub_10006B22(Buffer);
  disptext2(dword_100101E0 + 2, 62, Buffer, 7, v1);
  disptext2(dword_100101E0 + 3, 6, "location", 7, v3);
  sprintf(Buffer, "%3d.%-3d", word_1000FE38, word_1000FE3A);
  disptext2(dword_100101E0 + 3, 15, Buffer, 7, 15);
  sprintf(Buffer, "%-70.70s", byte_1000FE4C);
  disptext2(dword_100101E0 + 4, 6, Buffer, 7, 113);
  sprintf(Buffer, "%-70.70s", byte_1000FE92);
  disptext2(dword_100101E0 + 5, 6, Buffer, 7, 113);
  disptext2(dword_100101E0 + 6, 6, "effective", 7, v3);
  date_to_str(dword_1000FE34, 0, Buffer, 4);
  disptext2(dword_100101E0 + 6, 17, Buffer, 7, 15);
  v2 = 15;
  if ( byte_1000FE3C == 67 )
    v2 = 12;
  sprintf(Buffer, "%10.10s", &byte_1000FE3C);
  disptext2(dword_100101E0 + 6, 66, Buffer, 7, v2);
  sprintf(Buffer, "%-8ld", dword_1000FE20);
  disptext2(dword_1000FE1C, 67, Buffer, 7, 15);
  if ( dword_1000FBC4 )
  {
    switch ( dword_1000FBC4 )
    {
      case 1:
        disptext(this, 64, byte_1000FF3F, 7, 7, 48);
        sprintf(byte_1001026C, "%.7s", byte_1000FF3F);
        break;
      case 2:
        disptext(this, 64, byte_1000FF3F, 10, 7, 48);
        sprintf(byte_10010214, "%.10s", byte_1000FF3F);
        break;
      case 3:
        disptext(this, 64, byte_1000FF4A, 15, 7, 48);
        sprintf(byte_10010380, "%.25s", byte_1000FF4A);
        break;
      case 4:
        disptext(this, 64, byte_1000FF4A, 15, 7, 48);
        sprintf(byte_10010380, "%.25s", byte_1000FF4A);
        memset(Buffer, 0, 0x50u);
        memset(Destination, 0, 0x28u);
        if ( word_1000FE46 > 0
          && (word_1000FE46 <= 3 || word_1000FE46 > 4 && (word_1000FE46 <= 6 || word_1000FE46 == 10)) )
        {
          build_street_address(Buffer, byte_1000FED8, 37, byte_100108A8, 1, word_1000FE46, word_1000FE48, word_1000FE4A);
          if ( word_1000FE46 == 6 )
          {
            strcpy(Destination, "CIVIC ");
            strncat(Destination, Buffer, 0xFu);
          }
          else
          {
            strncpy(Destination, Buffer, 0xFu);
          }
        }
        else
        {
          strncpy(Buffer, byte_1000FED8, 0xFu);
          strncpy(Destination, Buffer, 0xFu);
        }
        sprintf(byte_10010240, "%.15s", Destination);
        break;
      case 5:
        disptext(this, 64, byte_1000FFF0, 15, 7, 48);
        sprintf(byte_10010340, "%.26s", byte_1000FFF0);
        sprintf(byte_10010220, "%.26s", byte_1000FFD6);
        sprintf(byte_10010360, "%.26s", byte_1000FFBC);
        sprintf(byte_100102C0, "%.26s", byte_1000FF6E);
        break;
      case 6:
        dispf(this, 64, 48, "%8ld", dword_1000FE20);
        sprintf(String, "%ld", dword_1000FE20);
        break;
    }
  }
  else
  {
    disptext(this, 64, byte_1000FE4C, 15, 7, 48);
    sprintf(byte_100102E0, "%.70s", byte_1000FE4C);
  }
  if ( dword_1000FBC4 )
  {
    switch ( dword_1000FBC4 )
    {
      case 1:
        out_str((struct io_field *)&dword_1000F188, 1);
        break;
      case 2:
        out_str((struct io_field *)&dword_1000F1E0, 1);
        break;
      case 3:
        out_str((struct io_field *)&dword_1000F238, 1);
        break;
      case 4:
        out_str((struct io_field *)&dword_1000F238, 1);
        out_str((struct io_field *)&dword_1000F290, 1);
        break;
      case 5:
        out_str((struct io_field *)&dword_1000F2E8, 1);
        out_str((struct io_field *)&dword_1000F340, 1);
        out_str((struct io_field *)&dword_1000F398, 1);
        out_str((struct io_field *)&dword_1000F3F0, 1);
        break;
      case 6:
        out_str((struct io_field *)&dword_1000F448, 1);
        break;
    }
  }
  else
  {
    out_str((struct io_field *)&off_1000F130, 1);
  }
}
// 10009108: using guessed type void __cdecl out_str(struct io_field *, _DWORD);
// 10009118: using guessed type void __cdecl disptext2(_DWORD, _DWORD, const char *, _DWORD, _DWORD);
// 10009120: using guessed type void __cdecl disptext(_DWORD, _DWORD, const char *, _DWORD, _DWORD, _DWORD);
// 10009130: using guessed type void __cdecl date_to_str(_DWORD, const char *, char *, _DWORD);
// 10009134: using guessed type void dispf(_DWORD, _DWORD, _DWORD, const char *, ...);
// 10009234: using guessed type void __cdecl clx(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10009248: using guessed type void __cdecl build_street_address(char *, const char *, _DWORD, const char *, _DWORD, _DWORD, _DWORD, _DWORD);
// 1000F130: using guessed type char (*off_1000F130)[70];
// 1000F188: using guessed type int dword_1000F188;
// 1000F1E0: using guessed type int dword_1000F1E0;
// 1000F238: using guessed type int dword_1000F238;
// 1000F290: using guessed type int dword_1000F290;
// 1000F2E8: using guessed type int dword_1000F2E8;
// 1000F340: using guessed type int dword_1000F340;
// 1000F398: using guessed type int dword_1000F398;
// 1000F3F0: using guessed type int dword_1000F3F0;
// 1000F448: using guessed type int dword_1000F448;
// 1000FBC4: using guessed type int dword_1000FBC4;
// 1000FE1C: using guessed type int dword_1000FE1C;
// 1000FE20: using guessed type int dword_1000FE20;
// 1000FE34: using guessed type int dword_1000FE34;
// 1000FE38: using guessed type __int16 word_1000FE38;
// 1000FE3A: using guessed type __int16 word_1000FE3A;
// 1000FE3C: using guessed type char byte_1000FE3C;
// 1000FE46: using guessed type __int16 word_1000FE46;
// 1000FE48: using guessed type __int16 word_1000FE48;
// 1000FE4A: using guessed type __int16 word_1000FE4A;
// 100100D2: using guessed type char byte_100100D2;
// 100100D8: using guessed type char byte_100100D8;
// 100101E0: using guessed type int dword_100101E0;

//----- (10006AF8) --------------------------------------------------------
int __fastcall sub_10006AF8(char a1)
{
  switch ( a1 )
  {
    case 'A':
      return 14;
    case 'C':
      return 7;
    case 'F':
      return 10;
    case 'M':
      return 15;
  }
  return 11;
}

//----- (10006B22) --------------------------------------------------------
int __thiscall sub_10006B22(char *this)
{
  int v1; // ebx
  void (__cdecl *v2)(char *, const char *); // esi
  const char *v4; // [esp-4h] [ebp-28h]
  const char *v5; // [esp-4h] [ebp-28h]
  char Destination[16]; // [esp+10h] [ebp-14h] BYREF

  memset(Destination, 0, 15);
  v1 = 15;
  switch ( byte_100100D8 )
  {
    case 'C':
      goto LABEL_20;
    case 'E':
      v4 = "Expired";
      goto LABEL_7;
    case 'I':
      v2 = (void (__cdecl *)(char *, const char *))strcpy;
      if ( byte_100100D9 == 78 )
      {
        strcpy(Destination, "InforceNew");
        goto LABEL_24;
      }
      v5 = "Inforce";
LABEL_18:
      v2(Destination, v5);
      goto LABEL_24;
  }
  if ( byte_100100D8 != 80 )
  {
    if ( byte_100100D8 != 86 )
    {
      v4 = "Other";
LABEL_7:
      v2 = (void (__cdecl *)(char *, const char *))strcpy;
      strcpy(Destination, v4);
      goto LABEL_24;
    }
LABEL_20:
    v2 = (void (__cdecl *)(char *, const char *))strcpy;
    if ( byte_100100D8 == 67 )
      strcpy(Destination, "Cancelled");
    else
      strcpy(Destination, "Void");
    v1 = 12;
    goto LABEL_24;
  }
  v2 = (void (__cdecl *)(char *, const char *))strcpy;
  switch ( byte_100100D9 )
  {
    case 'E':
      v5 = "P-Edit";
      goto LABEL_18;
    case 'R':
      v5 = "P-Renew";
      goto LABEL_18;
    case 'X':
      strcpy(Destination, "P-Reserved");
      break;
    default:
      strcpy(Destination, "Other");
      break;
  }
LABEL_24:
  if ( byte_1001018A == 89 && !is_reserved((struct py_mast_def *)&unk_10010070) )
    v2(Destination, "PendingHold");
  sprintf(this, "%14s", Destination);
  return v1;
}
// 10009244: using guessed type _DWORD __cdecl is_reserved(struct py_mast_def *);
// 100100D8: using guessed type char byte_100100D8;
// 100100D9: using guessed type char byte_100100D9;
// 1001018A: using guessed type char byte_1001018A;

//----- (10006C52) --------------------------------------------------------
int __thiscall sub_10006C52(void *this)
{
  _DWORD (__cdecl *v2)(int, struct _POSBLOCK *, char *, int, char *, _DWORD, int, const char *, _DWORD); // ecx
  int v3; // esi
  int v4; // eax
  int v5; // edi
  int v6; // eax
  int v8; // [esp-4h] [ebp-10h]

  v2 = do_dataset_io;
  v3 = 0;
  switch ( dword_1000F028 )
  {
    case 1:
      v4 = do_dataset_io(
             this,
             (struct _POSBLOCK *)dword_100103A0,
             (char *)&dword_1000FE20,
             592,
             (char *)&dword_100103AC,
             1,
             1,
             0,
             0);
      break;
    case 2:
      v4 = do_dataset_io(
             this,
             (struct _POSBLOCK *)dword_100103A0,
             (char *)&dword_1000FE20,
             592,
             byte_100103C0,
             3,
             1,
             0,
             0);
      break;
    case 4:
      v4 = do_dataset_io(
             this,
             (struct _POSBLOCK *)dword_100103A0,
             (char *)&dword_1000FE20,
             592,
             byte_10010418,
             4,
             1,
             0,
             0);
      break;
    case 5:
      v4 = do_dataset_io(
             this,
             (struct _POSBLOCK *)dword_100103A0,
             (char *)&dword_1000FE20,
             592,
             byte_10010436,
             5,
             1,
             0,
             0);
      break;
    case 6:
      v4 = do_dataset_io(
             this,
             (struct _POSBLOCK *)dword_100103A0,
             (char *)&dword_1000FE20,
             592,
             byte_10010462,
             6,
             1,
             0,
             0);
      break;
    case 7:
      v4 = do_dataset_io(
             this,
             (struct _POSBLOCK *)dword_100103A0,
             (char *)&dword_1000FE20,
             592,
             byte_100104BC,
             7,
             1,
             0,
             0);
      break;
    default:
      goto LABEL_15;
  }
  v5 = v4;
  if ( v4 )
    return v5;
  v2 = do_dataset_io;
LABEL_15:
  dword_1001058C[0] = dword_1000FE20;
  v6 = v2(5, (struct _POSBLOCK *)dword_10010588, byte_10010070, 366, (char *)dword_1001058C, 0, 1, 0, 0);
  v5 = v6;
  if ( v6 )
  {
    disp_error2(
      v6,
      "ERROR *** Could not get Policy Master for Location!",
      "Should not get here ... PRINT SCREEN and call for help!",
      0,
      0,
      0);
  }
  else if ( !AGENT_ACCESS::has_inquire_access((AGENT_ACCESS *)&unk_10010D98, (const struct py_mast_def *)byte_10010070) )
  {
    switch ( (unsigned int)this )
    {
      case 5u:
      case 6u:
      case 8u:
      case 9u:
      case 0xCu:
        v8 = 6;
        goto LABEL_21;
      case 7u:
      case 0xAu:
      case 0xBu:
        v8 = 7;
LABEL_21:
        v3 = v8;
        break;
      default:
        return sub_10006C52(v3);
    }
    return sub_10006C52(v3);
  }
  return v5;
}
// 10009138: using guessed type _DWORD __cdecl do_dataset_io(_DWORD, struct _POSBLOCK *, char *, _DWORD, char *, _DWORD, _DWORD, const char *, _DWORD);
// 1000913C: using guessed type void __cdecl disp_error2(_DWORD, const char *, const char *, _DWORD, _DWORD, _DWORD);
// 10009240: using guessed type _DWORD __thiscall AGENT_ACCESS::has_inquire_access(AGENT_ACCESS *__hidden this, const struct py_mast_def *);
// 1000F028: using guessed type int dword_1000F028;
// 1000FE20: using guessed type int dword_1000FE20;
// 100103A0: using guessed type int dword_100103A0;
// 100103AC: using guessed type int dword_100103AC;
// 10010588: using guessed type int dword_10010588;
// 1001058C: using guessed type int dword_1001058C[65];

//----- (10006D82) --------------------------------------------------------
int __thiscall sub_10006D82(void **this)
{
  void *v2; // ecx
  int v3; // eax
  int v5; // [esp+Ch] [ebp-4h]

  v5 = 0;
  v2 = *this;
  if ( (int)v2 <= dword_1000F020 )
  {
    sub_100063ED((int)v2, 1);
    v3 = sub_10006C52((void *)7);
    if ( !v3 )
    {
      scroll_window(2, dword_1000F020, 61, dword_100101E0, 1, 1, 0);
      scroll_window(63, dword_1000F020, 79, dword_100101E0, 1, 1, 0);
      goto LABEL_6;
    }
  }
  else
  {
    sub_100063ED((int)v2, 1);
    v3 = sub_10006C52((void *)7);
    if ( !v3 )
    {
      *this = (char *)*this - 1;
LABEL_6:
      sub_100064B3(*this);
      goto LABEL_10;
    }
  }
  if ( v3 != 9 )
    sub_10006C52((void *)6);
  v5 = 1;
LABEL_10:
  sub_100063ED((int)*this, 0);
  return v5;
}
// 10009140: using guessed type void __cdecl scroll_window(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1000F020: using guessed type int dword_1000F020;
// 100101E0: using guessed type int dword_100101E0;

//----- (10006E25) --------------------------------------------------------
int __thiscall sub_10006E25(void **this)
{
  int v2; // ebx
  void *v3; // ecx
  int v4; // eax

  v2 = 0;
  v3 = *this;
  if ( (int)v3 >= dword_100101E0 )
  {
    sub_100063ED((int)v3, 1);
    v4 = sub_10006C52((void *)6);
    if ( !v4 )
    {
      scroll_window(2, dword_1000F020, 61, dword_100101E0, 1, 0, 0);
      scroll_window(63, dword_1000F020, 79, dword_100101E0, 1, 0, 0);
      goto LABEL_6;
    }
  }
  else
  {
    sub_100063ED((int)v3, 1);
    v4 = sub_10006C52((void *)6);
    if ( !v4 )
    {
      *this = (char *)*this + 1;
LABEL_6:
      sub_100064B3(*this);
      goto LABEL_10;
    }
  }
  if ( v4 != 9 )
    sub_10006C52((void *)7);
  v2 = 1;
LABEL_10:
  sub_100063ED((int)*this, 0);
  return v2;
}
// 10009140: using guessed type void __cdecl scroll_window(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1000F020: using guessed type int dword_1000F020;
// 100101E0: using guessed type int dword_100101E0;

//----- (10006EBC) --------------------------------------------------------
void __fastcall sub_10006EBC(int a1, const char *a2)
{
  int v2; // ecx
  int v3; // ecx
  int v4; // ecx

  if ( a1 )
  {
    v2 = a1 - 1;
    if ( v2 )
    {
      v3 = v2 - 1;
      if ( v3 )
      {
        v4 = v3 - 1;
        if ( v4 )
        {
          if ( v4 == 1 )
            disp_error2(0, "The following text string could not be found searching FORWARD in the file", a2, 0, 16, 0);
        }
        else
        {
          disp_error2(0, "The following text string could not be found searching BACKWARD in the file", a2, 0, 16, 0);
        }
      }
      else
      {
        disp_error2(
          0,
          "There is no text search available for this Inquiry display.",
          "Text search is available ONLY for LOCATION",
          0,
          16,
          0);
      }
    }
    else
    {
      disp_error(0, "End of File reached!", 0, 16, 0);
    }
  }
  else
  {
    disp_error(0, "Top of File reached!", 0, 16, 0);
  }
}
// 1000913C: using guessed type void __cdecl disp_error2(_DWORD, const char *, const char *, _DWORD, _DWORD, _DWORD);
// 10009144: using guessed type void __cdecl disp_error(_DWORD, const char *, _DWORD, _DWORD, _DWORD);

//----- (10006F21) --------------------------------------------------------
char *sub_10006F21()
{
  char *result; // eax

  switch ( dword_1000FBC4 )
  {
    case 0:
      return (char *)sprintf(byte_100102E0, "%.70s", byte_1000FE4C);
    case 1:
      return (char *)sprintf(byte_1001026C, "%.7s", &unk_1000FF3F);
    case 2:
      return (char *)sprintf(byte_10010214, "%.10s", &unk_1000FF3F);
    case 3:
      return (char *)sprintf(byte_10010380, "%.25s", byte_1000FF4A);
    case 4:
      sprintf(byte_10010380, "%.25s", byte_1000FF4A);
      sprintf(byte_10010240, "%.15s", byte_1000FED8);
      return strcpy(&byte_100101E4, byte_10010240);
    case 5:
      sprintf(byte_10010340, "%.26s", byte_1000FFF0);
      sprintf(byte_10010220, "%.26s", byte_1000FFD6);
      sprintf(byte_10010360, "%.26s", byte_1000FFBC);
      return (char *)sprintf(byte_100102C0, "%.26s", byte_1000FF6E);
    default:
      result = (char *)(dword_1000FBC4 - 6);
      if ( dword_1000FBC4 == 6 )
        return (char *)sprintf(String, "%ld", dword_1000FE20);
      break;
  }
  return result;
}
// 1000FBC4: using guessed type int dword_1000FBC4;
// 1000FE20: using guessed type int dword_1000FE20;

//----- (10007037) --------------------------------------------------------
int __thiscall sub_10007037(void *this)
{
  int result; // eax
  char Buffer[2]; // [esp+Ch] [ebp-54h] BYREF
  _BYTE v4[78]; // [esp+Eh] [ebp-52h] BYREF

  *(_WORD *)Buffer = 0;
  memset(v4, 0, sizeof(v4));
  switch ( dword_1000FBC4 )
  {
    case 0:
      trim_str(byte_100102E0, 3);
      strncpy(byte_100103C0, byte_100102E0, 0x46u);
      memset(byte_10010406, 0, sizeof(byte_10010406));
      dword_10010410 = 0;
      result = 0;
      dword_10010414 = 0;
      return result;
    case 1:
      trim_str(byte_1001026C, 3);
      sprintf(Buffer, "0%s", byte_1001026C);
      goto LABEL_14;
    case 2:
      trim_str(byte_10010214, 3);
      sprintf(Buffer, "1%s", byte_10010214);
LABEL_14:
      strncpy(byte_10010418, Buffer, 0xCu);
      memset(&unk_10010424, 0, 0xAu);
      dword_1001042E = 0;
      result = 0;
      dword_10010432 = 0;
      return result;
    case 3:
      trim_str(byte_10010380, 3);
      strncpy(byte_10010436, byte_10010380, 0x1Au);
      memset(&unk_10010450, 0, 0xAu);
      dword_1001045A = 0;
      result = 0;
      dword_1001045E = 0;
      break;
    case 4:
      trim_str(byte_10010380, 3);
      trim_str(byte_10010240, 3);
      strncpy(byte_10010462, byte_10010380, 0x1Au);
      memset(byte_1001047C, 0, sizeof(byte_1001047C));
      sub_10007281(this);
      memset(&unk_100104AA, 0, 0xAu);
      dword_100104B4 = 0;
      result = 0;
      dword_100104B8 = 0;
      break;
    case 5:
      trim_str(byte_10010340, 3);
      trim_str(byte_10010220, 3);
      trim_str(byte_10010360, 3);
      trim_str(byte_100102C0, 3);
      strncpy(byte_100104BC, byte_10010340, 0x1Au);
      strncpy(byte_100104D6, byte_10010220, 0x1Au);
      strncpy(byte_100104F0, byte_10010360, 0x1Au);
      strncpy(byte_1001050A, byte_100102C0, 0x1Au);
      dword_1001052E = 0;
      result = 0;
      dword_10010532 = 0;
      break;
    default:
      result = dword_1000FBC4 - 6;
      if ( dword_1000FBC4 == 6 )
      {
        dword_100103AC = atol(String);
        result = 0;
        dword_100103B0 = 0;
      }
      break;
  }
  return result;
}
// 10009124: using guessed type void __cdecl trim_str(char *, _DWORD);
// 1000FBC4: using guessed type int dword_1000FBC4;
// 100103AC: using guessed type int dword_100103AC;
// 100103B0: using guessed type int dword_100103B0;
// 10010410: using guessed type int dword_10010410;
// 10010414: using guessed type int dword_10010414;
// 1001042E: using guessed type int dword_1001042E;
// 10010432: using guessed type int dword_10010432;
// 1001045A: using guessed type int dword_1001045A;
// 1001045E: using guessed type int dword_1001045E;
// 100104B4: using guessed type int dword_100104B4;
// 100104B8: using guessed type int dword_100104B8;
// 1001052E: using guessed type int dword_1001052E;
// 10010532: using guessed type int dword_10010532;

//----- (10007281) --------------------------------------------------------
char *__thiscall sub_10007281(void *this)
{
  char *result; // eax
  size_t v3; // esi
  int v4; // ecx
  char v5; // al
  char v6; // al
  int v7; // eax
  char *i; // edx
  char v9; // cl
  int v10; // edx
  _BYTE *v11; // esi
  size_t v12; // [esp+Ch] [ebp-70h]
  char Destination[2]; // [esp+10h] [ebp-6Ch] BYREF
  _BYTE v14[78]; // [esp+12h] [ebp-6Ah] BYREF
  __int16 v15; // [esp+60h] [ebp-1Ch] BYREF
  int v16; // [esp+62h] [ebp-1Ah]
  int v17; // [esp+66h] [ebp-16h]
  char v18; // [esp+6Ah] [ebp-12h]
  char v19[2]; // [esp+6Ch] [ebp-10h] BYREF
  int v20; // [esp+6Eh] [ebp-Eh]
  int v21; // [esp+72h] [ebp-Ah]
  char v22; // [esp+76h] [ebp-6h]

  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  *(_WORD *)v19 = 0;
  v20 = 0;
  v21 = 0;
  v22 = 0;
  *(_WORD *)Destination = 0;
  memset(v14, 0, sizeof(v14));
  memset(v19, 0, 0xBu);
  memset(Destination, 0, 0x32u);
  strncpy(Destination, byte_10010240, 0xFu);
  if ( !this && byte_100101E4 )
  {
    result = strncpy(byte_1001047C, &byte_100101E4, 0x2Eu);
    byte_100101E4 = 0;
    return result;
  }
  v12 = strlen(Str2);
  if ( !strncmp(Destination, Str2, v12) )
  {
    strncpy(v19, &Destination[v12], 0xAu);
    trim_str(v19, 3);
    pad_str(v19, "0", 10, 0);
    sprintf(Destination, "%-34.34s%s", "R. R. #", v19);
    return strncpy(byte_1001047C, Destination, 0x2Eu);
  }
  v3 = strlen(Str);
  if ( !strncmp(Destination, Str, v3) )
  {
    trim_str(Destination, 3);
    v4 = 0;
    while ( 1 )
    {
      v5 = Destination[v3];
      if ( v5 == 32 || !v5 )
        break;
      if ( v4 < 10 && v5 != 44 )
        v19[v4++] = v5;
      ++v3;
    }
    trim_str(v19, 3);
    pad_str(v19, "0", 10, 0);
    do
      v6 = Destination[++v3];
    while ( v6 != 32 && v6 );
    v7 = 0;
    for ( i = &Destination[v3]; *i; ++i )
    {
      if ( v7 < 10 )
        *((_BYTE *)&v15 + v7++) = *i;
    }
    trim_str((char *)&v15, 3);
    if ( (_BYTE)v15 )
    {
      pad_str((char *)&v15, "0", 10, 0);
      sprintf(Destination, "P.O. BOX %s, SITE %s", v19, (const char *)&v15);
    }
    else
    {
      sprintf(Destination, "P.O. BOX %s", v19);
    }
    return strncpy(byte_1001047C, Destination, 0x2Eu);
  }
  if ( strncmp(Destination, "CIVIC", 5u) )
    return strncpy(byte_1001047C, Destination, 0x2Eu);
  v9 = v14[4];
  v10 = 0;
  if ( v14[4] != 32 )
  {
    v11 = &v14[4];
    do
    {
      if ( !v9 )
        break;
      if ( v10 < 9 )
        v19[v10++] = v9;
      v9 = *++v11;
    }
    while ( *v11 != 32 );
  }
  trim_str(v19, 3);
  pad_str(v19, "0", 10, 0);
  sprintf(Destination, "CIVIC %-9.9s", v19);
  return strncpy(byte_1001047C, Destination, 0x2Eu);
}
// 10009124: using guessed type void __cdecl trim_str(char *, _DWORD);
// 10009148: using guessed type void __cdecl pad_str(char *, const char *, _DWORD, _DWORD);

//----- (1000751E) --------------------------------------------------------
void *sub_1000751E()
{
  memset(byte_10010380, 0, 0x1Au);
  memset(byte_10010360, 0, 0x1Bu);
  memset(byte_10010340, 0, 0x1Bu);
  memset(byte_100102E0, 0, 0x47u);
  memset(byte_100102C0, 0, 0x1Bu);
  memset(byte_1001026C, 0, sizeof(byte_1001026C));
  memset(String, 0, 9u);
  memset(&unk_10010250, 0, 0x10u);
  memset(byte_10010240, 0, 0x10u);
  memset(byte_10010220, 0, 0x1Bu);
  return memset(byte_10010214, 0, 0xBu);
}

//----- (10007FAF) --------------------------------------------------------
void sub_10007FAF()
{
  void (**i)(void); // esi

  for ( i = dword_1000A428; i < dword_1000A428; ++i )
  {
    if ( *i )
      (*i)();
  }
}
// 1000A428: using guessed type void (*dword_1000A428[2])(void);

//----- (10007FCF) --------------------------------------------------------
void __cdecl sub_10007FCF()
{
  void (**i)(void); // esi

  for ( i = dword_1000A430; i < dword_1000A430; ++i )
  {
    if ( *i )
      (*i)();
  }
}
// 1000A430: using guessed type void (*dword_1000A430[2])(void);

//----- (10007FFF) --------------------------------------------------------
void __cdecl sub_10007FFF()
{
  _clean_type_info_names_internal(&unk_1000FBA4);
}
// 10008012: using guessed type int __cdecl _clean_type_info_names_internal(_DWORD);

//----- (10008488) --------------------------------------------------------
void sub_10008488()
{
  sub_100035A2((void **)&unk_10010D4C, 1, 0);
}

//----- (10008497) --------------------------------------------------------
void __cdecl sub_10008497()
{
  sub_100035A2((void **)&unk_10010D64, 1, 0);
}

//----- (100084A6) --------------------------------------------------------
void __cdecl sub_100084A6()
{
  sub_100035A2((void **)&unk_10010D7C, 1, 0);
}

//----- (100084B5) --------------------------------------------------------
void __cdecl sub_100084B5()
{
  off_1000F4F8[0] = (int (__stdcall **)(char))&std::error_category::`vftable';
}
// 10009464: using guessed type void *std::error_category::`vftable';
// 1000F4F8: using guessed type int (__stdcall **off_1000F4F8[3])(char);

//----- (100084C0) --------------------------------------------------------
void __cdecl sub_100084C0()
{
  off_1000F500 = (int (__stdcall **)(char))&std::error_category::`vftable';
}
// 10009464: using guessed type void *std::error_category::`vftable';
// 1000F500: using guessed type int (__stdcall **off_1000F500)(char);

//----- (100084CB) --------------------------------------------------------
void __cdecl sub_100084CB()
{
  off_1000F4FC[0] = (int (__stdcall **)(char))&std::error_category::`vftable';
}
// 10009464: using guessed type void *std::error_category::`vftable';
// 1000F4FC: using guessed type int (__stdcall **off_1000F4FC[2])(char);

//----- (100084D6) --------------------------------------------------------
void __cdecl sub_100084D6()
{
  AGENT_ACCESS::~AGENT_ACCESS((AGENT_ACCESS *)&unk_10010D98);
}
// 10009254: using guessed type void __thiscall AGENT_ACCESS::~AGENT_ACCESS(AGENT_ACCESS *__hidden this);

// nfuncs=333 queued=255 decompiled=255 lumina nreq=0 worse=0 better=0
// ALL OK, 255 function(s) have been successfully decompiled
